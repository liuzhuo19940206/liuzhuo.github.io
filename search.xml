<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>北京欢乐谷</title>
      <link href="/2020/05/30/bei-jing-huan-le-gu/"/>
      <url>/2020/05/30/bei-jing-huan-le-gu/</url>
      
        <content type="html"><![CDATA[<h3 id="感慨"><a href="#感慨" class="headerlink" title="感慨"></a>感慨</h3><p>发现自己一直以来都是一个很果断的人，做什么决定，追求什么，放弃什么，都是自己做主，很少去参考别人的意见，其实也不是不去参考别人的意见，是身边的人无法给予一定意见，很多时候都必须靠自己，自己去摸索，去探索，估计是这样的习惯生活久了，导致现在做什么事，都不会去想到别人，都是一个人走走停停，无所畏惧，无所牵挂。爱上了在旅途中去认识新的朋友，今天的欢乐谷旅行也认识了很多朋友，哈哈，各个年龄段的都有，和他们对话笑死我了，好久没和别人聊天这么开心了~~~</p><hr><p>昨天，和leader拿着自己的项目去给一级部门老大演讲，又体验了一把被支配的恐惧；又回忆起了在校期间被导师支配的恐惧；哈哈，还好我的心态已经打造的乐观了，没事，接下来继续努力就行；越往上走，遇到的人都会太优秀，必须给自己施加压力，加油，你是最棒的。</p><hr><p>工作是工作，生活是生活，周末，还是需要给自己放松放松的。北京欢乐谷，我来了，其实，去年圣诞节的时候，就想去的，当时因为自己发烧了，在家躺了一天。。。</p><p>昨天，计划周末的旅途时，就想把欢乐谷补起来，看到有年卡办，就办了，价格还好，以后，压力大了，就去咆哮，呐喊吧，也是一个减压的措施。</p><hr><h3 id="北京欢乐谷"><a href="#北京欢乐谷" class="headerlink" title="北京欢乐谷"></a>北京欢乐谷</h3><p>今天，一身黄。。。</p><p>只是，为了，体现自己的年轻，哈哈。快30岁的人了，必须打扮年轻点去年轻人的场合。</p><p><img src="https://pic.downk.cc/item/5ed26eb3c2a9a83be5e326c0.jpg" alt></p><hr><h3 id="过山车"><a href="#过山车" class="headerlink" title="过山车"></a>过山车</h3><p>拿着我的年卡，排队一个小时入园了，入园第一眼就是北京欢乐谷的过山车，高，长，跨度大。</p><p><a href="https://pic.downk.cc/item/5ed26996c2a9a83be5da6373.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5ed26996c2a9a83be5da6373" alt></a></p><p><img src="https://pic.downk.cc/item/5ed270b0c2a9a83be5e6b24b.jpg" alt></p><p>不是排队嘛，到我时就掐断了，然后，我就是第一排，当时我整个人就害怕的不行，但是不能表现出来嘛，硬着头皮上的。。。</p><p>当时，旁边那个小姐姐快开始的时候，一直问我害不害怕，她说她好害怕，她后悔了。。。</p><p>弄得我好紧张，我也很害怕。。。</p><p>特别是过上车到达最高点的时候，突然下滑，失重的感觉，咔擦。</p><p>我第一次玩，结束后，旁边的小姐姐，边哭边笑，哈哈哈哈，说实话，我也有点想吐。</p><div id="dplayer7" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer7"),"theme":"#FADFA3","video":{"url":"http://upos-sz-mirrorkodo.bilivideo.com/upgcxcode/97/15/197071597/197071597-1-192.mp4?e=ig8euxZM2rNcNbRB7wdVhwdlhWUMhwdVhoNvNC8BqJIzNbfq9rVEuxTEnE8L5F6VnEsSTx0vkX8fqJeYTj_lta53NCM=&uipk=5&nbs=1&deadline=1590907179&gen=playurl&os=kodobv&oi=837395164&trid=4c4aaa57a962485ba86268b053972280T&platform=html5&upsig=00e617ff2738ed3d1fe25e84b6270f66&uparams=e,uipk,nbs,deadline,gen,os,oi,trid,platform&mid=580104086&orderid=0,1&logo=80000000"},"danmaku":{"id":"guoshangche","api":"https://dplayer.moerats.com/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>ps：玩这个过山车的时候，遇到了两个程序员男孩，就排队在我的后面，其中一个害怕想撤退，另一个说来都来了，这不就和我们代码一样嘛，已经执行的代码怎么返回呢？这是原子性操作嘛，我听了，哈哈，然后融入了他们的团队。</p><hr><h3 id="冲浪"><a href="#冲浪" class="headerlink" title="冲浪"></a>冲浪</h3><p>往里走，就是冲浪的水花，哈哈哈，这个不害怕，很好玩。</p><p><img src="https://pic.downk.cc/item/5ed272a5c2a9a83be5e9d7b9.jpg" alt></p><p><img src="https://pic.downk.cc/item/5ed272c0c2a9a83be5ea07c8.jpg" alt></p><p><img src="https://pic.downk.cc/item/5ed272dac2a9a83be5ea3d2e.jpg" alt></p><p>最近视频角度：</p><div id="dplayer8" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer8"),"theme":"#FADFA3","video":{"url":"http://upos-sz-mirrorhw.bilivideo.com/upgcxcode/69/43/197074369/197074369-1-192.mp4?e=ig8euxZM2rNcNbRB7bdVhwdlhWUjhwdVhoNvNC8BqJIzNbfq9rVEuxTEnE8L5F6VnEsSTx0vkX8fqJeYTj_lta53NCM=&uipk=5&nbs=1&deadline=1590907216&gen=playurl&os=hwbv&oi=837395164&trid=98ff1883b3aa464e853290f2f0751d4eT&platform=html5&upsig=f4d8caa8c61d52df7bf988a608c37f23&uparams=e,uipk,nbs,deadline,gen,os,oi,trid,platform&mid=580104086&orderid=0,1&logo=80000000"},"danmaku":{"id":"guoshangche","api":"https://dplayer.moerats.com/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><div id="dplayer9" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px; height:500px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer9"),"theme":"#FADFA3","video":{"url":"http://upos-sz-mirrorks3.bilivideo.com/upgcxcode/75/46/197074675/197074675-1-192.mp4?e=ig8euxZM2rNcNbRMnWdVhwdlhWKHhwdVhoNvNC8BqJIzNbfq9rVEuxTEnE8L5F6VnEsSTx0vkX8fqJeYTj_lta53NCM=&uipk=5&nbs=1&deadline=1590907269&gen=playurl&os=ks3bv&oi=837395164&trid=8620bab707664af09c2ea996cb00cb4fT&platform=html5&upsig=549a64675ab357784c6d4ea18619c17a&uparams=e,uipk,nbs,deadline,gen,os,oi,trid,platform&mid=580104086&orderid=0,1&logo=80000000"},"danmaku":{"id":"guoshangche","api":"https://dplayer.moerats.com/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>夏天的味道，你们爱了嘛？哈哈</p><hr><h3 id="大摆钟"><a href="#大摆钟" class="headerlink" title="大摆钟"></a>大摆钟</h3><p><img src="https://pic.downk.cc/item/5ed27937c2a9a83be5f3f5ef.jpg" alt></p><p>我当时排了一半，不想玩了，问工作人员能撤退嘛？工作人员来句，已经到这里了，没有撤退可言~~~</p><p>工作人员都这么皮的嘛。。。</p><div id="dplayer10" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer10"),"theme":"#FADFA3","video":{"url":"http://upos-sz-mirrorhw.bilivideo.com/upgcxcode/41/48/197074841/197074841-1-192.mp4?e=ig8euxZM2rNcNbRBhbdVhwdlhWUghwdVhoNvNC8BqJIzNbfq9rVEuxTEnE8L5F6VnEsSTx0vkX8fqJeYTj_lta53NCM=&uipk=5&nbs=1&deadline=1590907300&gen=playurl&os=hwbv&oi=837395164&trid=a9384c196c254639b9108471f71771f9T&platform=html5&upsig=bee0fb899a4b115aec70c738a2ee072e&uparams=e,uipk,nbs,deadline,gen,os,oi,trid,platform&mid=580104086&orderid=0,1&logo=80000000"},"danmaku":{"id":"guoshangche","api":"https://dplayer.moerats.com/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><hr><p>今天的旅途就结束了，不敢在玩的时候录视频，拍照，期待我下次的视频吧，毕竟，我办的可是年卡，一年内免费去，奥利给~~~</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北京欢乐谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建图床</title>
      <link href="/2020/05/23/gou-jian-tu-chuang/"/>
      <url>/2020/05/23/gou-jian-tu-chuang/</url>
      
        <content type="html"><![CDATA[<p>大家看到博主博客里面这么多照片，一定想知道是怎么构建的，市面上有很多图床的服务器，可以选择购买，如果大家和博主一样很穷的话，那就只能自己构建免费的图床了。</p><p>那免费的图床怎么构建呢？首页想到的就是使用github的来作为图片的服务器，毕竟github是大公司，短时间内是不会gg的，可以放心使用。</p><p>但是，github是国外的服务器，国内访问该网址网速是很慢的，不能让大家天天看着挂掉的图片，这样影响观看博客的心情，因此可以考虑使用jsDelivr来加快访问速度。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>图床是个啥东西就不用过多介绍了，先来对比一下各路图床：</p><pre><code>微博图床：以前用的人比较多，从2019年4月开始开启了防盗链，凉凉SM.MS：运营四年多了，也变得越来越慢了，到了晚上直接打不开图片，速度堪忧其他小众图床：随时有挂掉的风险Imgur等国外图床：国内访问速度太慢，随时有被墙的风险大厂储存服务：例如七牛云、又拍云、腾讯云COS、阿里云OSS等，容量限制，操作繁琐，又是实名认证又是域名备案的，麻烦，而且还要花钱（有钱又不怕麻烦的当我没说）</code></pre><p>因此，GitHub图床是个不错的选择，利用 jsDelivr CDN 加速访问（jsDelivr 是一个免费开源的 CDN 解决方案），PicGo工具一键上传，操作简单高效，GitHub和jsDelivr都是大厂，不用担心跑路问题，不用担心速度和容量问题，而且完全免费，可以说是目前免费图床的最佳解决方案！</p><h3 id="新建GitHub仓库"><a href="#新建GitHub仓库" class="headerlink" title="新建GitHub仓库"></a>新建GitHub仓库</h3><p>登录/注册GitHub，新建一个仓库，填写好<strong>仓库名</strong>，仓库描述，根据需求选择是否为仓库初始化一个README.md描述文件。</p><p>每天github账号的，自己去注册就行，然后右上角点击加号，创建新的仓库就行。</p><p><img src="https://pic.downk.cc/item/5ec93918c2a9a83be55f45c0.jpg" alt></p><h3 id="生成一个Token"><a href="#生成一个Token" class="headerlink" title="生成一个Token"></a>生成一个Token</h3><p>在主页依次选择【Settings】-【Developer settings】-【Personal access tokens】-【Generate new token】，填写好描述，勾选【repo】，然后点击【Generate token】生成一个Token，注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页。</p><p><img src="https://pic.downk.cc/item/5ec93bc8c2a9a83be56487e0.jpg" alt></p><hr><p><img src="https://pic.downk.cc/item/5ec93c0dc2a9a83be5650d51.jpg" alt></p><hr><p><img src="https://pic.downk.cc/item/5ec93d15c2a9a83be5671187.jpg" alt></p><hr><p><img src="https://pic.downk.cc/item/5ec93e09c2a9a83be568ecfa.jpg" alt></p><h3 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h3><p>前往<a href="https://github.com/Molunerfinn/picgo/releases" target="_blank" rel="noopener">下载PicGo</a>，安装好后开始配置图床。</p><p><img src="/Users/liuzhuo/Library/Application Support/typora-user-images/image-20200523231913511.png" alt></p><p><img src="https://pic.downk.cc/item/5eca776ac2a9a83be5220e25.jpg" alt></p><ul><li><p>设定仓库名：按照【用户名 / 图床仓库名】的格式填写</p></li><li><p>设定分支名：【master】</p></li></ul><ul><li>设定Token：粘贴之前生成的【Token】</li></ul><ul><li>指定存储路径：填写想要储存的路径，如【blog/】，这样就会在仓库下创建一个名为 blog 的文件夹，图片将会储存在此文件夹中</li></ul><ul><li>设定自定义域名：它的作用是，在图片上传后，PicGo会按照【自定义域名+储存路径+上传的图片名】的方式生成<strong>访问链接</strong>，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为【<a href="https://cdn.jsdelivr.net/gh/用户名/图床仓库名" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/用户名/图床仓库名</a> 】，上传完毕后，我们就可以通过【<a href="https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径】加速访问我们的图片了，比如：https://cdn.jsdelivr.net/gh/xxx/ImageHosting/blog/xxx.png" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径】加速访问我们的图片了，比如：https://cdn.jsdelivr.net/gh/xxx/ImageHosting/blog/xxx.png</a></li></ul><h3 id="进行高效创作"><a href="#进行高效创作" class="headerlink" title="进行高效创作"></a>进行高效创作</h3><p>配置好PicGo后，我们就可以进行高效创作了，将图片拖拽到上传区，将会自动上传并复制访问链接，将链接粘贴到博文中就行了，访问速度杠杠的，此外PicGo还有相册功能，可以对已上传的图片进行删除，修改链接等快捷操作，PicGo还可以生成不同格式的链接、支持批量上传、快捷键上传、自定义链接格式、上传前重命名等，更多功能自己去探索吧！</p>]]></content>
      
      
      <categories>
          
          <category> 图床 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea2020-01永久破解</title>
      <link href="/2020/05/23/idea2020-01-yong-jiu-po-jie/"/>
      <url>/2020/05/23/idea2020-01-yong-jiu-po-jie/</url>
      
        <content type="html"><![CDATA[<p>目前，随着2018年后，idea的注册码都一一开始失效了，导致需要随时找注册码，很麻烦。</p><p>这里教大家破解最新的idea版本，目前，博主这里最新的版本是：idea2020-01的版本。如果后面出现新的idea不保证该方法还能破解，因此需要确认你要下载的idea的版本是不是和博主一致。</p><h4 id="彻底删除旧的版本"><a href="#彻底删除旧的版本" class="headerlink" title="彻底删除旧的版本"></a>彻底删除旧的版本</h4><p>请确认要把你的电脑中的旧的idea彻底删除干净！如果彻底删除干净，请自行百度，window和mac的删除方式不一致，注意一下就行。</p><h4 id="下载idea2020-01"><a href="#下载idea2020-01" class="headerlink" title="下载idea2020-01"></a>下载idea2020-01</h4><p>自行下载</p><h4 id="安装并以使用的模式开启"><a href="#安装并以使用的模式开启" class="headerlink" title="安装并以使用的模式开启"></a>安装并以使用的模式开启</h4><p>打开help - register，会发现免费试用：30天。</p><h4 id="下载破解jar"><a href="#下载破解jar" class="headerlink" title="下载破解jar"></a>下载破解jar</h4><p>博主提供的地址</p><p>链接:<a href="https://pan.baidu.com/s/1awruoCkwcT8d7f0PyCtnaQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1awruoCkwcT8d7f0PyCtnaQ</a>  密码:dugy</p><h4 id="直接拖到idea中"><a href="#直接拖到idea中" class="headerlink" title="直接拖到idea中"></a>直接拖到idea中</h4><p>将下载好的包，直接拖到你的idea中即可。</p><p>会提示你重启，重启后，会提示你安装该插件，安装即可。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>打开help - register，会发现到：2089年失效。【如果你真的用到那个时候，我们再说啊~~~】</p><p><img src="https://pic.downk.cc/item/5ec8e6adc2a9a83be5c8d5c7.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BigDecimal一定不丢失精度?</title>
      <link href="/2020/05/23/bigdecimal-yi-ding-bu-diu-shi-jing-du/"/>
      <url>/2020/05/23/bigdecimal-yi-ding-bu-diu-shi-jing-du/</url>
      
        <content type="html"><![CDATA[<p>最近因为接了一个和订单有关的需求，对于优惠力度的计算时，需要精确值，不能丢失精度，一开始无脑使用bigDecimal，后来发现完全不是那么一回事。。。</p><p>我们基本已经形成了常识，需要用到金钱的地方要用BigDecimal而不是其他，而我们也都知道浮点型变量在进行计算的时候会出现丢失精度的问题。</p><p>那么，你知道其实BigDecimal也会丢失精度吗？而使用BigDecimal的背后又有什么值得去探究的地方吗？今天，告诉你，知其然，也知其所以然。</p><p>如下一段代码：</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">0.05</span> <span class="token operator">+</span> <span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> <span class="token number">0.42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">4.015</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">123.3</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><p>输出：<br>0.060000000000000005<br>0.5800000000000001<br>401.49999999999994<br>1.2329999999999999</p><p>可以看到在Java中进行浮点数运算的时候，会出现丢失精度的问题。那么我们如果在进行商品价格计算的时候，就会出现问题。</p><hr><p>很有可能造成我们手中有0.06元，却无法购买一个0.05元和一个0.01元的商品。</p><p>因为如上所示，他们两个的总和为0.060000000000000005。</p><p>这无疑是一个很严重的问题，尤其是当电商网站的并发量上去的时候，出现的问题将是巨大的。可能会导致无法下单，或者对账出现问题。所以接下来我们就可以使用Java中的BigDecimal类来解决这类问题。</p><font color="red"><strong>普及一下：</strong></font><p>Java中float的精度为6-7位有效数字。double的精度为15-16位。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="构造器："><a href="#构造器：" class="headerlink" title="构造器："></a>构造器：</h4><pre class=" language-java"><code class="language-java">构造器                 描述<span class="token function">BigDecimal</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>       创建一个具有参数所指定整数值的对象。<span class="token function">BigDecimal</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>    创建一个具有参数所指定双精度值的对象。<span class="token function">BigDecimal</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>      创建一个具有参数所指定长整数值的对象。<span class="token function">BigDecimal</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>    创建一个具有参数所指定以字符串表示的数值的对象。</code></pre><h4 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h4><pre class=" language-JAVA"><code class="language-JAVA">方法                   描述add(BigDecimal)       BigDecimal对象中的值相加，然后返回这个对象。subtract(BigDecimal)  BigDecimal对象中的值相减，然后返回这个对象。multiply(BigDecimal)  BigDecimal对象中的值相乘，然后返回这个对象。divide(BigDecimal)    BigDecimal对象中的值相除，然后返回这个对象。remainder(BigDecimal) BigDecimal对象中的值取余数，然后返回这个对象。divideAndRemainder(BigDecimal) 返回的是BigDecimal[]的数组，[0]:商，[1]:余数toString()            将BigDecimal对象的数值转换成字符串。doubleValue()         将BigDecimal对象中的值以双精度数返回。floatValue()          将BigDecimal对象中的值以单精度数返回。longValue()           将BigDecimal对象中的值以长整数返回。intValue()            将BigDecimal对象中的值以整数返回。</code></pre><p>由于一般的数值类型，例如double不能准确的表示16位以上的数字。</p><p>PS: 使用bigdecimal的除法，即：divide时，如果不能被整除的话，请记住需要，设置保留的小数点的位数。</p><h3 id="BigDecimal精度也丢失"><a href="#BigDecimal精度也丢失" class="headerlink" title="BigDecimal精度也丢失"></a>BigDecimal精度也丢失</h3><p>我们在使用BigDecimal时，使用它的BigDecimal(String)构造器创建对象才有意义。其他的如BigDecimal b = new BigDecimal(1)这种，还是会发生精度丢失的问题。如下代码：</p><pre class=" language-java"><code class="language-java">BigDecimal a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token number">1.01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>BigDecimal b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token number">1.02</span><span class="token punctuation">)</span><span class="token punctuation">;</span>BigDecimal c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"1.01"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>BigDecimal d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"1.02"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出：<br>2.0300000000000000266453525910037569701671600341796875<br>2.03</p><p>可见论丢失精度BigDecimal显的更为过分。但是使用Bigdecimal的BigDecimal(String)构造器的变量在进行运算的时候却没有出现这种问题。</p><p>究其原因计算机组成原理里面都有，它们的编码决定了这样的结果。</p><p>long可以准确存储19位数字，而double只能准备存储16位数字。</p><p>double由于有exp位，可以存16位以上的数字，但是需要以低位的不精确作为代价。如果需要高于19位数字的精确存储，则必须用BigInteger来保存，当然会牺牲一些性能。</p><p>所以我们一般使用BigDecimal来解决商业运算上丢失精度的问题的时候，<font color="red"><strong>声明BigDecimal对象的时候一定要使用它构造参数为String的类型的构造器。</strong></font></p><p>同时这个原则Effective Java和MySQL 必知必会中也都有提及。float和double只能用来做科学计算和工程计算。商业运算中我们要使用BigDecimal。</p><p>而且我们从源码的注释中官方也给出了说明，如下是BigDecimal类的double类型参数的构造器上的一部分注释说明：</p><pre class=" language-java"><code class="language-java"><span class="token operator">*</span> The results of <span class="token keyword">this</span> constructor can be somewhat unpredictable<span class="token punctuation">.</span>       <span class="token operator">*</span> One might assume that writing <span class="token punctuation">{</span><span class="token annotation punctuation">@codenew</span> <span class="token function">BigDecimal</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">}</span> in       <span class="token operator">*</span> Java creates a <span class="token punctuation">{</span><span class="token annotation punctuation">@code</span> BigDecimal<span class="token punctuation">}</span> which is exactly equal to       <span class="token operator">*</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token function">1</span> <span class="token punctuation">(</span>an unscaled value of <span class="token number">1</span><span class="token punctuation">,</span> with a scale of <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> but it is       <span class="token operator">*</span> actually equal to       <span class="token operator">*</span> <span class="token number">0.1000000000000000055511151231257827021181583404541015625</span><span class="token punctuation">.</span>       <span class="token operator">*</span> This is because <span class="token number">0.1</span> cannot be represented exactly as a       <span class="token operator">*</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@codedouble</span><span class="token punctuation">}</span> <span class="token punctuation">(</span>or<span class="token punctuation">,</span> <span class="token keyword">for</span> that matter<span class="token punctuation">,</span> as a binary fraction of       <span class="token operator">*</span> any finite length<span class="token punctuation">)</span><span class="token punctuation">.</span>  Thus<span class="token punctuation">,</span> the value that is being passed       <span class="token operator">*</span> <span class="token operator">&lt;</span>i<span class="token operator">></span>in<span class="token operator">&lt;</span><span class="token operator">/</span>i<span class="token operator">></span> to the constructor is not exactly equal to <span class="token number">0.1</span><span class="token punctuation">,</span>       <span class="token operator">*</span> appearances notwithstanding<span class="token punctuation">.</span>         ……          <span class="token operator">*</span> When a <span class="token punctuation">{</span><span class="token annotation punctuation">@codedouble</span><span class="token punctuation">}</span> must be used as a source <span class="token keyword">for</span> a       <span class="token operator">*</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@code</span> BigDecimal<span class="token punctuation">}</span><span class="token punctuation">,</span> note that <span class="token keyword">this</span> constructor provides an       <span class="token operator">*</span> exact conversion<span class="token punctuation">;</span> it does not give the same result as       <span class="token operator">*</span> converting the <span class="token punctuation">{</span><span class="token annotation punctuation">@codedouble</span><span class="token punctuation">}</span> to a <span class="token punctuation">{</span><span class="token annotation punctuation">@code</span> String<span class="token punctuation">}</span> using the       <span class="token operator">*</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> Double#<span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">}</span> method and then using the       <span class="token operator">*</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> #<span class="token function">BigDecimal</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token punctuation">}</span> constructor<span class="token punctuation">.</span>  To get that result<span class="token punctuation">,</span>       <span class="token operator">*</span> use the <span class="token punctuation">{</span><span class="token annotation punctuation">@codestatic</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> #<span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">}</span> method<span class="token punctuation">.</span>       <span class="token operator">*</span> <span class="token operator">&lt;</span><span class="token operator">/</span>ol<span class="token operator">></span>  <span class="token keyword">public</span> <span class="token function">BigDecimal</span><span class="token punctuation">(</span><span class="token keyword">double</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span>MathContext<span class="token punctuation">.</span>UNLIMITED<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> </code></pre><p>第一段也说的很清楚它只能计算的无限接近这个数，但是无法精确到这个数。</p><p>第二段则说，如果要想准确计算这个值，那么需要把double类型的参数转化为String类型的。并且使用BigDecimal(String)这个构造方法进行构造。去获取结果。</p><h3 id="正确运用BigDecimal"><a href="#正确运用BigDecimal" class="headerlink" title="正确运用BigDecimal"></a>正确运用BigDecimal</h3><p>另外，BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象，由刚才我们所罗列的API也可看出。</p><p>在一般开发过程中，我们数据库中存储的数据都是float和double类型的。在进行拿来拿去运算的时候还需要不断的转化，这样十分的不方便。这里我写了一个工具类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**   * @author: liuzhuo.   * @date: 11:30 2020/05/22.   */</span>  publicclass BigDecimalUtil <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token function">BigDecimalUtil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> BigDecimal <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span> <span class="token keyword">double</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// v1 + v2  </span>        BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> BigDecimal <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span> <span class="token keyword">double</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>          BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> BigDecimal <span class="token function">mul</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span> <span class="token keyword">double</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>          BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> BigDecimal <span class="token function">div</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span> <span class="token keyword">double</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>          BigDecimal b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          BigDecimal b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 2 = 保留小数点后两位   ROUND_HALF_UP = 四舍五入  </span>        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">divide</span><span class="token punctuation">(</span>b2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> BigDecimal<span class="token punctuation">.</span>ROUND_HALF_UP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 应对除不尽的情况  </span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> </code></pre><p>该工具类提供了double类型的基本的加减乘除运算。直接调用即可。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BigDecimal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人,为什么努力</title>
      <link href="/2020/05/05/ren-wei-shi-me-nu-li/"/>
      <url>/2020/05/05/ren-wei-shi-me-nu-li/</url>
      
        <content type="html"><![CDATA[<p>人为什么要努力啊，也许是为了将来有更多选择，也许是为了报答家人，也许是不辜负父母的期盼，我们在努力的过程中，曾经想过放弃，也许还要在黑暗中行走很久，也许看不到希望。但不要放弃，因为只有努力过我们才能证明自己。献给所有正在努力奋斗的学子们。</p><p>愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。</p><div id="dplayer6" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer6"),"theme":"#FADFA3","loop":true,"video":{"url":"http://upos-sz-mirrorks3.bilivideo.com/upgcxcode/39/85/92328539/92328539-1-208.mp4?e=ig8euxZM2rNcNbKV7wdVhwdl7wdMhwdVhoNvNC8BqJIzNbfq9rVEuxTEnE8L5F6VnEsSTx0vkX8fqJeYTj_lta53NCM=&uipk=5&nbs=1&deadline=1590903332&gen=playurl&os=ks3bv&oi=837395164&trid=4dd555e9f0414f689d88eb088339b632T&platform=html5&upsig=a8363fed9194e5686bf7b7a37aa9afeb&uparams=e,uipk,nbs,deadline,gen,os,oi,trid,platform&mid=580104086&orderid=0,1&logo=80000000"},"danmaku":{"id":"lzsp","api":"https://dplayer.moerats.com/","addition":["https://dplayer.moerats.com/v3/bilibili?aid=1r4411776v"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><hr><p>今天，五四青年节，希望大家都能充满朝气去面对自己的未来，我们90后虽然有很多的不足，但是我们也会有着为国家、民族而努力奋斗的精神。</p><p>我们不能自怨自艾，不能放弃自己的梦想，我们需要有自己的信仰去战胜不安、焦虑。</p><p>一边coding，一边听歌，有过了12点了，我还是真是【时间管理者】，哈哈哈~~~</p><hr><p>以下是[朋友]的留言:</p><p><strong>给我一条秋刀鱼</strong>:</p><p>我是一个平常人，平常不过的人，22岁已经出身社会的我，看直播不发弹幕，网上的各种撕逼不参与，看视频也很少发评论，但是呢，今天刷到这个视频，我想说些话，不管有没有人会看到。</p><p>努力是吧，我们都是受过教育的人，上学的时候我就开始努力了，学习钢琴，光练指法我就练了一年，我还要去学好语数外，我会拼命去背那一个个单词，一个个公式， 我真的够努力了，可是我却连大学都没考上。正值青春，和家里闹掰，不接受家人的复读，无论如何也要去上大学的理念。至此，进入社会。</p><p>努力是吧，我也有过女朋友，为了她，去到陌生的城市，也就是她上大学的城市，租过150一个月的房子，就那种又老又潮湿的小屋，去当网吧服务员，拿着1200一个月的工资还是觉得很开心，能和喜欢的人在一起生活，连刀都没碰过的我，学会了做饭，在她上学的时候，我每天喝粥，吃泡菜，就为了周六她不上课的时候，能买一堆好吃的东西做给她吃，我真的很努力了，我用尽我所有的力气经营这段感情， 两年半就换回来一句， 不爱了。 而我还要安慰自己，没事，不能责怪她， 你不够优秀，但她很优秀，读过大学，价值观有所改变，也能够理解。 没人知道一个人绝望在另一个城市的心酸。</p><p>努力是吧，我现在学灯光控制，就是演唱会那种灯光，看上去很帅不是吗。说好听点，灯光师，说难听一点，你就是一个搬砖的，你入门就能碰到控制台吗，先从装舞台开始，一台光束灯60斤，切割灯120斤，一装就是上百个，每场活动迎接你的都是几晚上躺床上全身酸痛。然而我还要抽空听师傅讲，自己看视频，现在的灯光控台全是英文控台，因为系统比中文控台厉害。 你不努力，不下特别大的功夫，根本不可能学到东西。</p><p>努力过后，我又会怎样呢，我不知道，但我还是想努力，就算是如此的我，我也想努力。</p><p>所以你们一定不要放弃努力啊， 一定要努力下去，要是你努力过后什么都没有得到，要是你累了， 不要难过，世界上还有很多一样难过的人，也总有爱着你的人，总有不希望你放弃努力的人。<br>我可以做你的朋友，我可以抱抱你，我可以陪你喝酒扯淡，我可以给你弹《卡农》，要是你不喜欢，《肖邦》也可以的啊(笑)，我就会这么些东西了，全部都可以给努力的你， 所以，加油吧，加油努力吧！！！ ！！</p><p><strong>晴天晴天ing</strong>:</p><p>为什么要努力？因为我在最低处我羡慕那些站在高处的，我向往光亮处，我想成为那样的人，所以我才要努力啊</p><p><strong>恶魔只抓你</strong>:</p><p>今年高三，虽然一模和二模没考好。但我相信我这三年的努力绝对会有收获的！高考不是我人生的句号，只是我人生的开始！</p><p><strong>西告仙女</strong>:</p><p>求求你救救颓废的自己吧，帮帮未来的你<img src="https://i0.hdslb.com/bfs/emote/d2f26cbdd6c96960320af03f5514c5b524990840.png@100w_100h.webp" alt="[委屈]"></p><p><strong>涤生一世</strong>:</p><p>我是一个游戏代练，每天最少十个小时最多十八个小时都在打游戏，生活规律跟正常人已经完全相反，白天睡觉，晚上通宵。你们眼里可能代练是一个很轻松来钱也快的行业，也很自由，却没有人知道，我们每天躲在房间里拿着手机，只能在网络上么沟通，甚至买包烟也是趁着防沉迷的时间，只是为了不耽误团队的时间。一颗星你们也就给那么些钱，我也从不敢多收钱，价格高了，很多人就吓跑了，价格低了呢，又要被很多人质疑，认为我是骗子。要一个合理的价格吧，又有人说你那几块钱也在乎，你是没见过钱吗？但你们有没有想过我挣几块钱有时候也挺难的，有时候遇见有毒的单子，加上半夜撞车，我为了那么几颗星要打上几个小时，我也不是万能的，也会有没状态的时候，偶尔拿个负战绩都会觉得自己特别没用，遇到脾气好的队友开个玩笑也就过去了，因为我们都是代练，知道彼此的不容易，遇见急着交单的，被骂的头破血淋不说，找队友他们还在群里说我是伪代孤儿。我自己也很怕输，输一局耽误的就是三局的时间才能上去一颗星。作为一个代练我认为真的很累，几乎很长时间才能见一次门外的太阳，虽然只有一步之遥。每天都是实在熬不住，眼睛发红发模糊发痛，才会去睡觉，从来没有固定时间睡觉</p><p><strong>小木矢三郎</strong>:</p><p>人一生要哭两次，为失败哭一次，然后为成功哭一次。</p><p><strong>离歌卜悲</strong>:</p><p>《垫底辣妹》一个平凡而真实的电影，由日本出品！高考的可以去看看！一定有不一样的发现！高考加油学长们！</p><p><strong>我的娜美没有Q吖</strong>:</p><p>我是个播音艺术生，高三集训到过完年考完试才回学校复习文化课，他们都以为学艺术的很轻松，他们看不到我们冬天五点起来去楼下跑两圈然后站在外面裹着一件厚衣服练声练到7点，那时我经常练到嗓子说不出话来，但我明白我要继续，我不能放松，我是山东的，播音没有统考只有一个四校联考和校考，我在大年初二的那一天晚上坐了四个小时的火车到了济南，我在考前找了一个主持人上小课，五天2500元，从大年初二一直到二十，一直都是我一个人在外面各地考试。在川传考配音的时候他们说不让说名字，但在复试的时候我说了名字，我刚考了一项就出来了，我当时心里想：没事还有好多学校呢没关系。但是我的眼泪却流出来了，我也不知道为什么就是想哭，但是有什么用呢，擦干眼泪继续去下一个考点微笑着面对考官。全部考完是二十回的家，二十三来的学校，我在学校一直期待着校考成绩，那时距离高考还有不到100天。我等来等去等来的是一个接一个学校的：不合格。我浑浑噩噩的过了好多天，我和我妈商量，我妈说尊重我的意见，我想复读，但明年高考又改革，最后我给我妈说：算了，我上个专科吧，专升本也是一样。距离高考还有30天的时候，我想，我还是不够努力啊，一个学校都没有过，我真是个废物。我的一个朋友问我，你喜欢播音吗？我说，喜欢。那你就去考专科播音，能考多少分就考多少，专升本一定要成功，到时候再考播音的本科，不要担心啦，有我呢。我不知道怎么就抱着我朋友哭了起来。现在距离高考还有15天，隔一天考一次试，我正在努力上播音的专科。你们呢，有我大的比我小的比我成绩好的比我成绩差的，这都有什么关系呢，对着现在的自己说，努力就完事了！加油！心情不好不开心什么的都可以向我倾诉我可以勉励你们也可以念你们想听的什么故事，毕竟，我只剩下声音这一个优点能排上用场了!</p><p><strong>灬栗泪泪</strong>:</p><p>我要去上海干销售，就算所有人都认为我不行，我也要去拼一把，所有人都放弃我，我也不会放弃自己！我要闯出属于自己的那份成功！加油！叶桐！加油！</p><p><strong>一只药膏</strong>:</p><p>我很害怕，真的。<br>高三，抑郁症休学了一年，每天都努力让自己看起来开心，今年三月份我才开始上学，也就是说高三我上了三个月就要高考了。<br>我离我南艺从模考来看还差10-20分的距离<br>今天爸爸和我说 我觉得这次高考可能……不太行了但是我们不会怪你的，考成什么样子都可以的<br>我可以吗？我能考的上吗？<br>我真的很想考上南艺 然后去考北电的研究生<br>我有梦想 可是我总是会崩溃<br>我可以的，一定可以的。<br>别害怕，要爱自己。<br>大家也是，一起加油。</p><p><strong>今天的我也很开心l</strong>:</p><p>8天后我来为姐姐许愿 25天后我为我自己许愿!</p><p><strong>洛云Moon</strong>:</p><p>我希望这条可以上去让大家看到吧<br>心灵鸡汤唯一的作用，是在你颓废想要放弃时，给予你三分钟热度<br>而真正能改变你的，是你持之以恒的自律<br>请求你们，是请求，不要浪费人生了，人生寥寥可数的几年里，为何不去做一些对现在的自己有意义的事情。<br>对，我知道有一些人啊，在想着“等我死了，还剩些什么呢，又有什么意义呢，不如早些死掉算了。”这也是以前的我<br>正如所有父母老师所说的那句话:“至少不要让以后的自己后悔吧”<br>我理解，一些十几岁的青年们<br>“后悔也是我自己的选择，有什么呢”<br>可是自己想想吧，与其未来后悔，何必不强迫自己现在努力，这里的努力，不是努力“学习”<br>去做自己感兴趣但有意义的事情，请注意是有意义，看书、跑步、健身等所有能够使你变好的东西，过程枯燥无味，但是枯燥无味的背后，是大家对你的赞赏，也可能会有羡慕嫉妒，但这些，不都能成为你装逼的谈资吗？<br>所以努力吧，不管是为了谁，与其颓废活着，不如强迫自律着活，只是后者更加劳累而已，不过你已经有勇气活到现在了，又何必怕这点劳累<br>这番话，能改变一个人就好，就有意义了~</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 励志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es中简单入门案例</title>
      <link href="/2020/05/04/es-zhong-jian-dan-ru-men-an-li/"/>
      <url>/2020/05/04/es-zhong-jian-dan-ru-men-an-li/</url>
      
        <content type="html"><![CDATA[<p>根据前面的学习，我们已经基本上了解了es的内部原理和基本的概念了，现在就让我们开始学习吧~~~</p><h2 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h2><p>让我们来创建一个员工的目录</p><p>假设我们在XXX公司工作，这时人力资源部门出于某种目的需要让我们建立一个员工目录，这个目录用于促进人文关怀和用于实时协同工作，所以它有以下不同的需要：</p><ul><li>数据能包含多个值的标签、数字和纯文本</li><li>检索任何员工的所有信息</li><li>支持结构化搜索，例如查找30岁以上的员工</li><li>支持简单的全文搜索和更复杂的短语（phrase）搜索</li><li>高亮搜索结果中的关键字</li><li>能够利用图表管理分析这些数据</li></ul><h2 id="索引员工文档"><a href="#索引员工文档" class="headerlink" title="索引员工文档"></a>索引员工文档</h2><p>我们首先要做的是存储员工数据，每个文档代表一个员工。在Elasticsearch中存储数据的行为就叫做索引(indexing)，不过 在索引之前，我们需要明确数据应该存储在哪里。</p><p>在Elasticsearch中，文档归属于一种类型(type),而这些类型存在于索引(index)中，我们可以画一些简单的对比图来类比传统 关系型数据库：</p><pre class=" language-java"><code class="language-java">Relational DB <span class="token operator">-</span><span class="token operator">></span> Databases <span class="token operator">-</span><span class="token operator">></span> Tables <span class="token operator">-</span><span class="token operator">></span> Rows <span class="token operator">-</span><span class="token operator">></span> ColumnsElasticsearch <span class="token operator">-</span><span class="token operator">></span> Indices <span class="token operator">-</span><span class="token operator">></span> Types <span class="token operator">-</span><span class="token operator">></span> Documents <span class="token operator">-</span><span class="token operator">></span> Fields</code></pre><p>Elasticsearch集群可以包含多个索引(indices)（数据库），每一个索引可以包含多个类型(types)（表），每一个类型包含多 个文档(documents)（行），然后每个文档包含多个字段(Fields)（列）。</p><p>「索引」含义的区分:</p><p>你可能已经注意到索引(index)这个词在Elasticsearch中有着不同的含义，所以有必要在此做一下区分: </p><ul><li>索引（名词） 如上文所述，一个索引(index)就像是传统关系数据库中的数据库，它是相关文档存储的地方， index的复数是indices 或indexes。</li><li>索引（动词） 「索引一个文档」表示把一个文档存储到索引（名词）里，以便它可以被检索或者查询。这很像 SQL中的 INSERT 关键字，差别是，如果文档已经存在，新的文档将覆盖旧的文档。 </li><li>倒排索引 : 传统数据库为特定列增加一个索引，例如B-Tree索引来加速检索。Elasticsearch和Lucene使用一种叫做 倒排索引(inverted index)的数据结构来达到相同目的。</li></ul><p>ps: <strong>默认情况下，文档中的所有字段都会被索引（拥有一个倒排索引），只有这样他们才是可被搜索的。</strong></p><p>所以为了创建员工目录，我们将进行如下操作：</p><ul><li>为每个员工的文档(document)建立索引，每个文档包含了相应员工的所有信息。 </li><li>每个文档的类型为 employee 。 </li><li>employee 类型归属于索引 gakkij 。</li><li>gakkij 索引存储在Elasticsearch集群中。</li></ul><p>实际上这些都是很容易的（尽管看起来有许多步骤）。我们能通过一个命令执行完成的操作:</p><pre class=" language-java"><code class="language-java">PUT <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">{</span><span class="token string">"first_name"</span> <span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span><span class="token string">"last_name"</span> <span class="token operator">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span><span class="token string">"age"</span> <span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span><span class="token string">"about"</span> <span class="token operator">:</span> <span class="token string">"I love to go rock climbing"</span><span class="token punctuation">,</span><span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token string">"sports"</span><span class="token punctuation">,</span> <span class="token string">"music"</span> <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p><img src="https://pic.downk.cc/item/5eaf5f2fc2a9a83be5411570.jpg" alt></p><p>说明：这里我使用了kibana的工具来发送http请求，大家也可以使用其他工具，都是类似的效果，例如：curl等。</p><p>思考：</p><p>1）在插入这条数据之前，我们的es中只有前面博客创建的 hello，kibana索引。</p><p>2）再没有创建索引和type的情况下，直接插入文档能成功吗？成功后，该索引的分片数和副本是多少呢？mapping的设置呢？</p><p>回答：</p><p>1）通过查看该条插入语句的返回值，可以明显的发现是插入成功的，result：created。</p><p>打开es的head也能看到效果：</p><p><img src="https://pic.downk.cc/item/5eaf6096c2a9a83be5417b75.jpg" alt></p><p>这就是es强大的地方，我们不需要任何配置，es会自动帮我们处理一切工作，透明化处理；我们也能制定化配置，后面，我们慢慢来说吧~~~</p><p>2）通过上面的截图，我们能发现，es会自动帮我们创建一个索引，分片数为5，副本为1，即：10份数据。</p><p>但是，上面的图中，为啥只是显示五份数据呢？那是，因为目前我这里es的节点只有一个，集群中不存在其他的节点，es中需要保证主分片和副本不能在一个节点上面，否则就会毫无意义，主分片和副本在同一个节点的话，该节点失效后，岂不是该数据就都丢失了嘛。</p><p>因此，此时的健康状态是 yellow，大家注意到了么；主分片都可用，部分副本不可用就是 黄色（yellow）状态啦</p><p>3）查看该索引类型的mapping结构</p><p><img src="https://pic.downk.cc/item/5eaf6274c2a9a83be54216e3.jpg" alt></p><p>看到，es会根据我们传入的json串的类似，自动帮我们推测该字段的类型。</p><p>字符串的类型：统一是text，字符串还有一个类型是：keyword。</p><p>整形：long。</p><p>关于es的类型，后面我们再说。</p><hr><p>接下来，让我们在目录中加入更多员工信息：</p><pre class=" language-java"><code class="language-java">PUT <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">{</span><span class="token string">"first_name"</span> <span class="token operator">:</span> <span class="token string">"Jane"</span><span class="token punctuation">,</span><span class="token string">"last_name"</span> <span class="token operator">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span><span class="token string">"age"</span> <span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">,</span><span class="token string">"about"</span> <span class="token operator">:</span> <span class="token string">"I like to collect rock albums"</span><span class="token punctuation">,</span><span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token string">"music"</span> <span class="token punctuation">]</span><span class="token punctuation">}</span>POST <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span>          #这里，我没有传入id，es会自动帮我们创建一个uuid<span class="token punctuation">{</span><span class="token string">"first_name"</span> <span class="token operator">:</span> <span class="token string">"Douglas"</span><span class="token punctuation">,</span><span class="token string">"last_name"</span> <span class="token operator">:</span> <span class="token string">"Fir"</span><span class="token punctuation">,</span><span class="token string">"age"</span> <span class="token operator">:</span> <span class="token number">35</span><span class="token punctuation">,</span><span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I like to build cabinets"</span><span class="token punctuation">,</span><span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token string">"forestry"</span> <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>注意上面，我们插入数据时，带有id和不带id的区别！！！</p><h2 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h2><p>现在Elasticsearch中已经存储了一些数据，我们可以根据业务需求开始工作了。</p><p>第一个需求是能够检索单个员工的信息。 这对于Elasticsearch来说非常简单。</p><p>我们只要执行HTTP GET请求并指出文档的“地址”——索引、类型和ID既可。根据这三部 分信息，我们就可以返回原始JSON文档：</p><pre class=" language-java"><code class="language-java">GET <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span><span class="token number">1</span></code></pre><p><img src="https://pic.downk.cc/item/5eaf6441c2a9a83be542a82a.jpg" alt></p><p>ps：我们通过HTTP方法 GET 来检索文档，同样的，我们可以使用 DELETE 方法删除文档，使用 HEAD 方法检查某文档是否存 在。如果想更新已存在的文档，我们只需再 PUT 一次【<strong>字段会全部替换</strong>，部分替换需要：_update】。</p><p>后面，我不截图了，图片太浪费资源了。。。</p><hr><h2 id="简单搜索"><a href="#简单搜索" class="headerlink" title="简单搜索"></a>简单搜索</h2><p>GET 请求非常简单——你能轻松获取你想要的文档。让我们来进一步尝试一些东西，比如简单的搜索！ 我们尝试一个最简单的搜索全部员工的请求：</p><pre class=" language-java"><code class="language-java">GET <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span>_search</code></pre><p>你可以看到我们依然使用 gakkij 索引和 employee 类型，但是我们在结尾使用关键字 <strong>_search</strong> 来取代原来的文档ID。响应内 容的 hits 数组中包含了我们所有的三个文档。<font color="red"><strong>默认情况下搜索会返回前10个结果。</strong></font></p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"took"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>             <span class="token comment" spellcheck="true">//查询消耗的时长，单位：毫秒</span>  <span class="token string">"timed_out"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// false：未超时</span>  <span class="token string">"_shards"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">//5个分片数</span>    <span class="token string">"successful"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"skipped"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token string">"failed"</span><span class="token operator">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>         <span class="token comment" spellcheck="true">//查询到总数</span>    <span class="token string">"max_score"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>        <span class="token string">"_type"</span><span class="token operator">:</span> <span class="token string">"employee"</span><span class="token punctuation">,</span>        <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"6JQl3XEBkV4diPZu8bHC"</span><span class="token punctuation">,</span>        <span class="token string">"_score"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token string">"_source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"first_name"</span><span class="token operator">:</span> <span class="token string">"Douglas"</span><span class="token punctuation">,</span>          <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"Fir"</span><span class="token punctuation">,</span>          <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">35</span><span class="token punctuation">,</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I like to build cabinets"</span><span class="token punctuation">,</span>          <span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"forestry"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>        <span class="token string">"_type"</span><span class="token operator">:</span> <span class="token string">"employee"</span><span class="token punctuation">,</span>        <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>        <span class="token string">"_score"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token string">"_source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"first_name"</span><span class="token operator">:</span> <span class="token string">"Jane"</span><span class="token punctuation">,</span>          <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span>          <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">,</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I like to collect rock albums"</span><span class="token punctuation">,</span>          <span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"music"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>        <span class="token string">"_type"</span><span class="token operator">:</span> <span class="token string">"employee"</span><span class="token punctuation">,</span>        <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>        <span class="token string">"_score"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token string">"_source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"first_name"</span><span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>          <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span>          <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I love to go rock climbing"</span><span class="token punctuation">,</span>          <span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"sports"</span><span class="token punctuation">,</span>            <span class="token string">"music"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><p>接下来，让我们搜索姓氏中包含“Smith”的员工。要做到这一点，我们将在命令行中使用<strong>轻量级的搜索方法</strong>。这种方法常被 称作<strong>查询字符串(query string)搜索</strong>.</p><h3 id="字符串-query-string-搜索"><a href="#字符串-query-string-搜索" class="headerlink" title="字符串(query string)搜索"></a>字符串(query string)搜索</h3><pre class=" language-java"><code class="language-java">GET <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span>_search<span class="token operator">?</span>q<span class="token operator">=</span>last_name<span class="token operator">:</span>Smith</code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"took"</span><span class="token operator">:</span> <span class="token number">23</span><span class="token punctuation">,</span>  <span class="token string">"timed_out"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token string">"_shards"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"successful"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"skipped"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token string">"failed"</span><span class="token operator">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token string">"max_score"</span><span class="token operator">:</span> <span class="token number">0.2876821</span><span class="token punctuation">,</span>    <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>        <span class="token string">"_type"</span><span class="token operator">:</span> <span class="token string">"employee"</span><span class="token punctuation">,</span>        <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>        <span class="token string">"_score"</span><span class="token operator">:</span> <span class="token number">0.2876821</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">//匹配到的分数：查询的内容对于查询消息的匹配程度</span>        <span class="token string">"_source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"first_name"</span><span class="token operator">:</span> <span class="token string">"Jane"</span><span class="token punctuation">,</span>          <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span>          <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">,</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I like to collect rock albums"</span><span class="token punctuation">,</span>          <span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"music"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>        <span class="token string">"_type"</span><span class="token operator">:</span> <span class="token string">"employee"</span><span class="token punctuation">,</span>        <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>        <span class="token string">"_score"</span><span class="token operator">:</span> <span class="token number">0.2876821</span><span class="token punctuation">,</span>        <span class="token string">"_source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"first_name"</span><span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>          <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span>          <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I love to go rock climbing"</span><span class="token punctuation">,</span>          <span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"sports"</span><span class="token punctuation">,</span>            <span class="token string">"music"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们在请求中依旧使用 _search 关键字，然后将查询语句传递给参数 q= 。这样就可以得到所有姓氏为Smith的结果。</p><h3 id="使用DSL语句查询"><a href="#使用DSL语句查询" class="headerlink" title="使用DSL语句查询"></a>使用DSL语句查询</h3><p>查询字符串搜索便于通过命令行完成特定(ad hoc)的搜索，但是它也有局限性。Elasticsearch提供丰 富且灵活的查询语言叫做 DSL查询(Query DSL) , 它允许你构建更加复杂、强大的查询。</p><p>DSL(Domain Specific Language特定领域语言)以JSON请求体的形式出现。我们可以这样表示之前关于“Smith”的查询:</p><pre class=" language-java"><code class="language-java">GET <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span>_search<span class="token punctuation">{</span>  <span class="token string">"query"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"match"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>       <span class="token string">"last_name"</span> <span class="token operator">:</span> <span class="token string">"Smith"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这会返回与之前查询相同的结果。你可以看到有些东西改变了，我们不再使用查询字符串(query string)做为参数，而是使用 <strong>请求体</strong> 代替。这个请求体使用JSON表示，其中使用了 match 语句（查询类型之一，具体我们以后会学到）。</p><p>说明：我们知道，http请求中，get请求是无法带上请求体的，只能在请求行中传递我们的参数，post请求才能携带请求体，这里为啥GET请求可以携带请求体呢？那是因为es内部帮我们处理了，转化了一下。</p><h2 id="更复杂的搜索"><a href="#更复杂的搜索" class="headerlink" title="更复杂的搜索"></a>更复杂的搜索</h2><p>我们让搜索稍微再变的复杂一些。我们依旧想要找到姓氏为“Smith”的员工，但是我们只想得到年龄大于30岁的员工。我们的 语句将添加过滤器(filter),它使得我们高效率的执行一个结构化搜索：</p><pre class=" language-java"><code class="language-java">GET <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span>_search<span class="token punctuation">{</span>  <span class="token string">"query"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token string">"filtered"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token string">"filter"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"range"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token string">"age"</span> <span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string">"gt"</span> <span class="token operator">:</span> <span class="token number">30</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//&lt;1> 查询大于30岁的</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token string">"query"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token string">"match"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token string">"last_name"</span> <span class="token operator">:</span> <span class="token string">"smith"</span>  <span class="token comment" spellcheck="true">//&lt;2> 名字为：smith</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后呢？一不小心就出错了？</p><p><img src="https://pic.downk.cc/item/5eaf6a8bc2a9a83be544e587.jpg" alt></p><p>然后，查找官方的文档，原来：发现是因为过滤查询被弃用了，并在ES 5.0中删除，而我的ES版本正是6.2.1</p><p><strong>所以，大家需要自己多动手去操作，有可能我现在讲的知识点，以后就会弃用了，执行失败了，大家需要自己去官方文档中去查找相关的知识点来验证正确性！！！</strong></p><p>改用：bool查询</p><pre class=" language-java"><code class="language-java">GET <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span>_search<span class="token punctuation">{</span>  <span class="token string">"query"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token string">"bool"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token string">"filter"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"range"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token string">"age"</span> <span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string">"gt"</span> <span class="token operator">:</span> <span class="token number">30</span> <span class="token punctuation">}</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token string">"must"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token string">"match"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token string">"last_name"</span> <span class="token operator">:</span> <span class="token string">"smith"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>返回结果：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"took"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token string">"timed_out"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token string">"_shards"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"successful"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"skipped"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token string">"failed"</span><span class="token operator">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token string">"max_score"</span><span class="token operator">:</span> <span class="token number">0.2876821</span><span class="token punctuation">,</span>    <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>        <span class="token string">"_type"</span><span class="token operator">:</span> <span class="token string">"employee"</span><span class="token punctuation">,</span>        <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>        <span class="token string">"_score"</span><span class="token operator">:</span> <span class="token number">0.2876821</span><span class="token punctuation">,</span>        <span class="token string">"_source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"first_name"</span><span class="token operator">:</span> <span class="token string">"Jane"</span><span class="token punctuation">,</span>          <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span>          <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">,</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I like to collect rock albums"</span><span class="token punctuation">,</span>          <span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"music"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>年纪大于：30岁，名字为：smith的 只有一个。</p><p>PS：现在不要担心语法太多，我们将会在以后详细的讨论。</p><hr><h2 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h2><p>到目前为止搜索都很简单：搜索特定的名字，通过年龄筛选。</p><p>现在，让我们尝试一种更高级的搜索，全文搜索：<strong>一种传统数据库 很难实现的功能</strong>。 我们将会搜索所有喜欢“rock climbing”的员工：</p><pre class=" language-java"><code class="language-java">GET <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span>_search<span class="token punctuation">{</span>  <span class="token string">"query"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"match"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"about"</span> <span class="token operator">:</span> <span class="token string">"rock climbing"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>返回结果：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"took"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token string">"timed_out"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token string">"_shards"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"successful"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"skipped"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token string">"failed"</span><span class="token operator">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token string">"max_score"</span><span class="token operator">:</span> <span class="token number">0.5753642</span><span class="token punctuation">,</span>    <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>        <span class="token string">"_type"</span><span class="token operator">:</span> <span class="token string">"employee"</span><span class="token punctuation">,</span>        <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>        <span class="token string">"_score"</span><span class="token operator">:</span> <span class="token number">0.5753642</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//相关性高</span>        <span class="token string">"_source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"first_name"</span><span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>          <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span>          <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I love to go rock climbing"</span><span class="token punctuation">,</span>          <span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"sports"</span><span class="token punctuation">,</span>            <span class="token string">"music"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>        <span class="token string">"_type"</span><span class="token operator">:</span> <span class="token string">"employee"</span><span class="token punctuation">,</span>        <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>        <span class="token string">"_score"</span><span class="token operator">:</span> <span class="token number">0.2876821</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//相关性低</span>        <span class="token string">"_source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"first_name"</span><span class="token operator">:</span> <span class="token string">"Jane"</span><span class="token punctuation">,</span>          <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span>          <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">,</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I like to collect rock albums"</span><span class="token punctuation">,</span>          <span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"music"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>全文检索：就是在查询的字段中，查询是否有匹配的字段的内容，不是精确匹配，包含关系。</p><p>默认情况下，Elasticsearch根据结果<strong>相关性评分</strong>来对结果集进行排序，所谓的「结果相关性评分」就是文档与查询条件的匹 配程度。很显然，排名第一的 John Smith 的 about 字段明确的写到“rock climbing”。 但是为什么 Jane Smith 也会出现在结果里呢？原因是“rock”在她的 abuot 字段中被提及了。因为只有“rock”被提及 而“climbing”没有，所以她的 _score 要低于John。 这个例子很好的解释了Elasticsearch如何在各种文本字段中进行全文搜索，并且返回相关性最大的结果集。相关性 (relevance)的概念在Elasticsearch中非常重要，而这个概念在传统关系型数据库中是不可想象的，因为传统数据库对记录的 查询只有匹配或者不匹配。</p><h2 id="短语搜索"><a href="#短语搜索" class="headerlink" title="短语搜索"></a>短语搜索</h2><p>目前我们可以在字段中搜索单独的一个词，这挺好的，但是有时候你想要<strong>确切的匹配</strong>若干个单词或者短语(phrases)。例如我们想要查询 <strong>同时 包含”rock”和”climbing”（并且是相邻的）的员工记录</strong>。</p><p> 要做到这个，我们只要将 match 查询变更为 match_phrase 查询即可:</p><pre class=" language-java"><code class="language-java">GET <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span>_search<span class="token punctuation">{</span>  <span class="token string">"query"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"match_phrase"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"about"</span> <span class="token operator">:</span> <span class="token string">"rock climbing"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>毫无疑问，该查询返回John Smith的文档：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"took"</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>  <span class="token string">"timed_out"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token string">"_shards"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"successful"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"skipped"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token string">"failed"</span><span class="token operator">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token string">"max_score"</span><span class="token operator">:</span> <span class="token number">0.5753642</span><span class="token punctuation">,</span>    <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>        <span class="token string">"_type"</span><span class="token operator">:</span> <span class="token string">"employee"</span><span class="token punctuation">,</span>        <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>        <span class="token string">"_score"</span><span class="token operator">:</span> <span class="token number">0.5753642</span><span class="token punctuation">,</span>        <span class="token string">"_source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"first_name"</span><span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>          <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span>          <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I love to go rock climbing"</span><span class="token punctuation">,</span>          <span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"sports"</span><span class="token punctuation">,</span>            <span class="token string">"music"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="高亮我们的搜索"><a href="#高亮我们的搜索" class="headerlink" title="高亮我们的搜索"></a>高亮我们的搜索</h2><p>很多应用喜欢从每个搜索结果中高亮(highlight)匹配到的关键字，这样用户可以知道为什么这些文档和查询相匹配。</p><p>在 Elasticsearch中高亮片段是非常容易的。 让我们在之前的语句上增加 highlight 参数：</p><pre class=" language-java"><code class="language-java">GET <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span>_search<span class="token punctuation">{</span>  <span class="token string">"query"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"match_phrase"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"about"</span> <span class="token operator">:</span> <span class="token string">"rock climbing"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">"highlight"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"fields"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"about"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当我们运行这个语句时，会命中与之前相同的结果，但是在返回结果中会有一个新的部分叫做 <strong>highlight</strong> ，这里包含了来 自 about 字段中的文本，并且用  来标识匹配到的单词。</p><p>返回：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"took"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token string">"timed_out"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token string">"_shards"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"successful"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"skipped"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token string">"failed"</span><span class="token operator">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token string">"max_score"</span><span class="token operator">:</span> <span class="token number">0.5753642</span><span class="token punctuation">,</span>    <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>        <span class="token string">"_type"</span><span class="token operator">:</span> <span class="token string">"employee"</span><span class="token punctuation">,</span>        <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>        <span class="token string">"_score"</span><span class="token operator">:</span> <span class="token number">0.5753642</span><span class="token punctuation">,</span>        <span class="token string">"_source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"first_name"</span><span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>          <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span>          <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I love to go rock climbing"</span><span class="token punctuation">,</span>          <span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"sports"</span><span class="token punctuation">,</span>            <span class="token string">"music"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token string">"highlight"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"I love to go &lt;em>rock&lt;/em> &lt;em>climbing&lt;/em>"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="分析聚合"><a href="#分析聚合" class="headerlink" title="分析聚合"></a>分析聚合</h2><p>最后，我们还有一个需求需要完成：允许管理者在职员目录中进行一些分析聚合。</p><p>Elasticsearch有一个功能叫做<strong>聚合 (aggregations)</strong>，它允许你在数据上生成复杂的分析统计。</p><p>它很像SQL中的 <strong>GROUP BY</strong> 但是功能更强大。 举个例子，让我们找到所有职员中最大的共同点（兴趣爱好）是什么：</p><pre class=" language-java"><code class="language-java">GET <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span>_search<span class="token punctuation">{</span>  <span class="token string">"aggs"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"all_interests"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"terms"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string">"field"</span><span class="token operator">:</span> <span class="token string">"interests"</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>一不小心又出现错误了。。。</p><p><img src="https://pic.downk.cc/item/5eaf6f75c2a9a83be5469c4c.jpg" alt></p><p>这里很明显，需要使用带有keyword的查询</p><pre class=" language-java"><code class="language-java">GET <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span>_search<span class="token punctuation">{</span>  <span class="token string">"aggs"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"all_interests"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"terms"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string">"field"</span><span class="token operator">:</span> <span class="token string">"interests.keyword"</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>返回：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"took"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token string">"timed_out"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token string">"_shards"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"successful"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"skipped"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token string">"failed"</span><span class="token operator">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>    <span class="token string">"max_score"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>        <span class="token string">"_type"</span><span class="token operator">:</span> <span class="token string">"employee"</span><span class="token punctuation">,</span>        <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"6JQl3XEBkV4diPZu8bHC"</span><span class="token punctuation">,</span>        <span class="token string">"_score"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token string">"_source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"first_name"</span><span class="token operator">:</span> <span class="token string">"Douglas"</span><span class="token punctuation">,</span>          <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"Fir"</span><span class="token punctuation">,</span>          <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">35</span><span class="token punctuation">,</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I like to build cabinets"</span><span class="token punctuation">,</span>          <span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"forestry"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>        <span class="token string">"_type"</span><span class="token operator">:</span> <span class="token string">"employee"</span><span class="token punctuation">,</span>        <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>        <span class="token string">"_score"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token string">"_source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"first_name"</span><span class="token operator">:</span> <span class="token string">"Jane"</span><span class="token punctuation">,</span>          <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span>          <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">,</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I like to collect rock albums"</span><span class="token punctuation">,</span>          <span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"music"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>        <span class="token string">"_type"</span><span class="token operator">:</span> <span class="token string">"employee"</span><span class="token punctuation">,</span>        <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>        <span class="token string">"_score"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token string">"_source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"first_name"</span><span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>          <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span>          <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I love to go rock climbing"</span><span class="token punctuation">,</span>          <span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"sports"</span><span class="token punctuation">,</span>            <span class="token string">"music"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"aggregations"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"all_interests"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token string">"doc_count_error_upper_bound"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token string">"sum_other_doc_count"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token string">"buckets"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          <span class="token string">"key"</span><span class="token operator">:</span> <span class="token string">"music"</span><span class="token punctuation">,</span>          <span class="token string">"doc_count"</span><span class="token operator">:</span> <span class="token number">2</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>          <span class="token string">"key"</span><span class="token operator">:</span> <span class="token string">"forestry"</span><span class="token punctuation">,</span>          <span class="token string">"doc_count"</span><span class="token operator">:</span> <span class="token number">1</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>          <span class="token string">"key"</span><span class="token operator">:</span> <span class="token string">"sports"</span><span class="token punctuation">,</span>          <span class="token string">"doc_count"</span><span class="token operator">:</span> <span class="token number">1</span>        <span class="token punctuation">}</span>      <span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里，我们主要看：aggregations的部分，hits的查询结果可以忽悠。</p><p>我们可以看到两个职员对音乐有兴趣，一个喜欢林学，一个喜欢运动。这些数据并没有被预先计算好，它们是实时的从匹配 查询语句的文档中动态计算生成的。如果我们想知道所有姓”Smith”的人最大的共同点（兴趣爱好），我们只需要增加合适的 语句既可：</p><pre class=" language-java"><code class="language-java">GET <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span>_search<span class="token punctuation">{</span>  <span class="token string">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"smith"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"aggs"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"all_interests"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"terms"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string">"field"</span><span class="token operator">:</span> <span class="token string">"interests.keyword"</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>返回：此时只会在名字中存在smith中聚合数据了。</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"took"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token string">"timed_out"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token string">"_shards"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"successful"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"skipped"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token string">"failed"</span><span class="token operator">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"total"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token string">"max_score"</span><span class="token operator">:</span> <span class="token number">0.2876821</span><span class="token punctuation">,</span>    <span class="token string">"hits"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>        <span class="token string">"_type"</span><span class="token operator">:</span> <span class="token string">"employee"</span><span class="token punctuation">,</span>        <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>        <span class="token string">"_score"</span><span class="token operator">:</span> <span class="token number">0.2876821</span><span class="token punctuation">,</span>        <span class="token string">"_source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"first_name"</span><span class="token operator">:</span> <span class="token string">"Jane"</span><span class="token punctuation">,</span>          <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span>          <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">,</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I like to collect rock albums"</span><span class="token punctuation">,</span>          <span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"music"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token string">"_index"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>        <span class="token string">"_type"</span><span class="token operator">:</span> <span class="token string">"employee"</span><span class="token punctuation">,</span>        <span class="token string">"_id"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>        <span class="token string">"_score"</span><span class="token operator">:</span> <span class="token number">0.2876821</span><span class="token punctuation">,</span>        <span class="token string">"_source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"first_name"</span><span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>          <span class="token string">"last_name"</span><span class="token operator">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span>          <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>          <span class="token string">"about"</span><span class="token operator">:</span> <span class="token string">"I love to go rock climbing"</span><span class="token punctuation">,</span>          <span class="token string">"interests"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"sports"</span><span class="token punctuation">,</span>            <span class="token string">"music"</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"aggregations"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"all_interests"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token string">"doc_count_error_upper_bound"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token string">"sum_other_doc_count"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token string">"buckets"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          <span class="token string">"key"</span><span class="token operator">:</span> <span class="token string">"music"</span><span class="token punctuation">,</span>          <span class="token string">"doc_count"</span><span class="token operator">:</span> <span class="token number">2</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>          <span class="token string">"key"</span><span class="token operator">:</span> <span class="token string">"sports"</span><span class="token punctuation">,</span>          <span class="token string">"doc_count"</span><span class="token operator">:</span> <span class="token number">1</span>        <span class="token punctuation">}</span>      <span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><p>聚合也允许分级汇总。例如，让我们统计每种兴趣下职员的平均年龄：</p><pre class=" language-java"><code class="language-java">GET <span class="token operator">/</span>gakkij<span class="token operator">/</span>employee<span class="token operator">/</span>_search<span class="token punctuation">{</span>  <span class="token string">"aggs"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"all_interests"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token string">"terms"</span> <span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string">"field"</span> <span class="token operator">:</span> <span class="token string">"interests"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token string">"aggs"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"avg_age"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>              <span class="token string">"avg"</span> <span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string">"field"</span> <span class="token operator">:</span> <span class="token string">"age"</span> <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>返回：</p><pre><code>{  &quot;took&quot;: 1,  &quot;timed_out&quot;: false,  &quot;_shards&quot;: {    &quot;total&quot;: 5,    &quot;successful&quot;: 5,    &quot;skipped&quot;: 0,    &quot;failed&quot;: 0  },  &quot;hits&quot;: {    &quot;total&quot;: 3,    &quot;max_score&quot;: 1,    &quot;hits&quot;: [~]  },  &quot;aggregations&quot;: {    &quot;all_interests&quot;: {      &quot;doc_count_error_upper_bound&quot;: 0,      &quot;sum_other_doc_count&quot;: 0,      &quot;buckets&quot;: [        {          &quot;key&quot;: &quot;music&quot;,          &quot;doc_count&quot;: 2,          &quot;avg_age&quot;: {            &quot;value&quot;: 28.5          }        },        {          &quot;key&quot;: &quot;forestry&quot;,          &quot;doc_count&quot;: 1,          &quot;avg_age&quot;: {            &quot;value&quot;: 35          }        },        {          &quot;key&quot;: &quot;sports&quot;,          &quot;doc_count&quot;: 1,          &quot;avg_age&quot;: {            &quot;value&quot;: 25          }        }      ]    }  }}</code></pre><p>该聚合结果比之前的聚合结果要更加丰富。我们依然得到了兴趣以及数量（指具有该兴趣的员工人数）的列表，但是现在每 个兴趣额外拥有 avg_age 字段来显示具有该兴趣员工的平均年龄。 即使你还不理解语法，但你也可以大概感觉到通过这个特性可以完成相当复杂的聚合工作，你可以处理任何类型的数据。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望这个简短的教程能够很好的描述Elasticsearch的功能。当然这只是一些皮毛，为了保持简短，还有很多的特性未提及 ——像推荐、定位、渗透、模糊以及部分匹配等。但这也突出了构建高级搜索功能是多么的容易。无需配置，只需要添加数 据然后开始搜索！</p>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es中的基本概念</title>
      <link href="/2020/05/03/es-zhong-de-ji-ben-gai-nian/"/>
      <url>/2020/05/03/es-zhong-de-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Elasticsearch是一个高可扩展的开源全文搜索和分析引擎，它允许存储、搜索和分析大量的数据，并且这个过程是近实时（NRT）的。它通常被用作底层引擎和技术，为复杂的搜索功能和要求提供动力。</p><h3 id="近实时-NRT"><a href="#近实时-NRT" class="headerlink" title="近实时(NRT)"></a>近实时(NRT)</h3><p>近实时(Near Realtime NRT)，Elasticsearch是一个<strong><em>近实时</em></strong>的搜索平台，近实时的意思是指从你建立索引到你能够搜索这个文档这个过程，这个过程时间大概是1秒钟。</p><h3 id="节点-node"><a href="#节点-node" class="headerlink" title="节点(node)"></a>节点(node)</h3><p>ElasticSearch 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 ElasticSearch 实例。</p><p>单个 ElasticSearch 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p><p>在集群中一个节点是一个单独的服务，用来存储数据，为集群的索引和搜索提供能力。</p><p>集群中的节点，也有唯一标识的，默认在节点启动的时候会随机指定一个UUID(Universally Unique IDentifiter)。如果不使用默认名称，可以为其指定一个名称。节点名称对于集群管理也是很重要的。<br> 一个节点要加入到指定集群，需要为节点指定集群名称。默认情况下，每个节点都设置集群名称为”elasticsearch”，所以当在同一网络环境中，默认启动一些节点，这些节点会组装成一个名为elasticsearch集群。</p><p>查看node节点列表：</p><pre><code>$ curl -X GET http://127.0.0.1:9200/_cat/nodes?v</code></pre><p><img src="https://pic.downk.cc/item/5eae3a0bc2a9a83be55ee9ea.jpg" alt></p><p><strong>可以启动Kibana，使用Dev Tools工具来查询，就不演示了。下面操作也都可以使用Kibana。</strong></p><h3 id="集群-cluster"><a href="#集群-cluster" class="headerlink" title="集群(cluster)"></a>集群(cluster)</h3><p>一个集群包含一个或多个节点(node)，用来保存全部数据，并且这些节点<strong>联合</strong>提供索引和搜索能力。集群使用<font color="red"><strong>唯一名称</strong> </font>进行不同集群间的区分，默认名称是”elasticsearch”。集群的名称很重要，因为一个节点如果要加入到一个集群中，需要设置节点的集群名称。<br> 在实际应用中，需要确保你的不同环境，所使用的名称是不同的，否则会导致节点加入到其它集群环境中。比如你可以使用:logging-dev、logging-stage、logging-prod分别用来搭建开发、过渡、生产环境。<br> 集群可以只有一个节点，这个集群也能正常提供工作能力。此外，也可以搭建多个Elasticsearch集群，通过集群名称区分。</p><h3 id="索引-Index"><a href="#索引-Index" class="headerlink" title="索引(Index)"></a>索引(Index)</h3><p>一个索引包含许多<strong>特征类似</strong>的文档。例如，有一个索引用来索引用户数据，另一个索引用来索引产品目录，其它的索引可以索引其它数据。</p><p>一个索引（名词）需要指定一个名称(<font color="red"><strong>必须全部小写</strong></font>)，当执行索引（动词）、搜索、修改和删除操作，需要指定对应的索引名称。</p><p> 在一个集群中，你可以创建多个索引。</p><p>下面的命令可以查看当前节点的所有 Index。</p><pre class=" language-java"><code class="language-java">$ curl <span class="token operator">-</span>X GET <span class="token string">'http://localhost:9200/_cat/indices?v'</span></code></pre><p><img src="https://pic.downk.cc/item/5eae34adc2a9a83be559d20c.jpg" alt></p><h3 id="类型-Type"><a href="#类型-Type" class="headerlink" title="类型(Type)"></a>类型(Type)</h3><font color="red">类型type，只有在低于7版本中存在，现在最新的es7版本中已经移除了type的概念，一个索引只有有一个type，而且是es自带的type，不允许用户自己来创建，默认就是：_doc （type）。</font><p>不过在这里还是需要说明一下这个概念：</p><p>在<strong>低版本</strong>中，一个索引中，可以定义多个类型。一个类型可以管理索引中符合特定逻辑的一部分数据。一般来说，类型定义具有公共字段的文档。例如你想创建一个博客平台，并且使用一个索引存储所有数据。在这个索引中，你可以定义一个类型用来存储用户数据，另一个类型用来存储博客数据，还可以创建一个类型用来存储评论。</p><p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率，这是对于数据库中表的差异，数据库中的表结构是预定义的，定义之后是不允许修改和插入没有定义的field的！！！</p><hr><p>PS: 可以类比一下数据库中的概念，索引index ：数据库，类型type：表。</p><p>1）下面的命令可以列出<strong>每个 Index</strong> 所包含的 Type。</p><pre class=" language-java"><code class="language-java">$ curl <span class="token string">'localhost:9200/_mapping?pretty=true'</span></code></pre><p><img src="https://pic.downk.cc/item/5eae35c2c2a9a83be55aeddf.jpg" alt></p><p>2）列出指定的index的type</p><pre class=" language-java"><code class="language-java">$ curl <span class="token string">'localhost:9200/${index}/_mapping?pretty=true'</span></code></pre><p><img src="https://pic.downk.cc/item/5eae363bc2a9a83be55b5c1c.jpg" alt></p><h3 id="文档-Doc"><a href="#文档-Doc" class="headerlink" title="文档(Doc)"></a>文档(Doc)</h3><p>文档是能够被索引的基础单元。例如一个文档存储一个用户信息，另一个文档存储一个产品信息。Elasticsearch文档使用JSON(JavaScript Object Notation)来表现数据。<br> 在一个索引/文档中可以存储许多文档。需要注意，尽管一个文档在物理存储上是存储在一个索引中的，但文档必须被索引或分配给索引的类型中。</p><p>Document 使用 JSON 格式表示，下面是一个例子。</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"ide"</span><span class="token operator">:</span> <span class="token string">"543543565465"</span>  <span class="token string">"user"</span><span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>  <span class="token string">"title"</span><span class="token operator">:</span> <span class="token string">"工程师"</span><span class="token punctuation">,</span>  <span class="token string">"desc"</span><span class="token operator">:</span> <span class="token string">"数据库管理"</span><span class="token punctuation">}</span></code></pre><h3 id="分片-Shard-amp-副本-Replicas"><a href="#分片-Shard-amp-副本-Replicas" class="headerlink" title="分片(Shard)&amp;副本(Replicas)"></a>分片(Shard)&amp;副本(Replicas)</h3><p>在实际应用中可能存在这样的场景，一个索引存储超过了一个节点的<strong>物理存储能力</strong>。例如一个索引有十亿的文档，超过了1TB的存储，在单个节点无法完全存储，并且对于单个节点的搜索请求是非常慢的。<br> 为了解决这些问题，Elasticsearch提供了为索引切分成多个分片(Shard)的能力，当你创建一个索引的时候，你能够定义索引被分割成多少个shard。每一个shard都是功能完全，能够独立索引的，可以分配到集群中任何一个节点中。</p><p>使用分片有两个重要原因：</p><ul><li>允许水平分割文档，分布存储。</li><li>允许你分配并且执行分片，在多个节点中能够提供查询性能和吞吐量。</li></ul><p>shard如何分布，当一个请求发来后如何组织数据，这些对于用户来说都是透明的。<br> 当在一个网络环境中，有可能某个节点或分片丢失。Elasticsearch提供了一种针对这种故障转移的功能，就是副本。Elasticsearch允许你为一个分片创建一个或多个副本。分片和副本又称为主/副分片。</p><p>使用副本有两个重要原因：</p><ul><li>当一个节点或分片丢失后，能够继续使用。因此，需要注意的是主/副分片不会存储在一个节点中。</li><li>当进行搜索的时候，允许搜索所有的副本，所以提高了搜索性能。</li></ul><p>所以一个索引能够分割成多个shard，一个索引能够可以有零个或多个副本。每个索引都有主分片(索引切割后的分片，又称原始分片)和副本分片(从原始分片复制过来的)。分片数量和副本数量在创建索引的时候可以被指定，<strong><font color="red">当索引创建后，可以指定改变副本数量，但是不能改变主分片数量</font></strong>。<strong>默认情况下每个索引在Elasticsearch有5个分片和1个副本</strong>，也就是说总共10个shard(副本是对分片来说的，每个shard又一个副本)。每一个shard内部都是一个Lucene索引实例，单个lucene索引最多能够存储2,147,483,519(Integer.MAX_value-128)个文档。</p><h3 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h3><p>集群健康检查，这里会用到_cat语法：</p><pre class=" language-java"><code class="language-java">$ curl http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">9200</span><span class="token operator">/</span>_cat<span class="token operator">/</span>health<span class="token operator">?</span>v</code></pre><p><img src="https://pic.downk.cc/item/5eae3876c2a9a83be55d5c8d.jpg" alt></p><p> 从结果可以看到，集群名称为gakki，集群状态为绿色(green)。 </p><p>集群状态分为绿色(green)、黄色(yellow)和红色(red)。</p><ul><li>绿色代表集群当前状态是好的(集群功能齐全)。</li><li>黄色代表所有数据(主分片)都可用，但是一些副本(副分片)还没有分配(集群功能齐全)。</li><li>红色代表一些数据(主分片)不可用。</li></ul><p>需要注意的是，即使集群是红色的，它仍然部分功能可用。例如：可用的shard能够继续为搜索提供服务。但是你应该尽快去解决你丢失的数据。<br> 从上面的信息来看，我们就有一个节点(node)，并且可以看到有2个shard。</p><p>需要注意一点，Elasticsearch启动使用默认名称是elasticsearch。我这里修改了es的配置文件，将集群的名字改为了gakki，以后有新的es节点要加入这个集群，只需要将该节点的配置文件中的集群名称改为：gakki 即可。Elasticsearch默认采用单播网络去发现其它节点，所以如果你启动了多个Elasticsearch实例，则会自动加入这个名称为”gakki”的集群。</p>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es中Kibana的安装</title>
      <link href="/2020/05/02/es-zhong-kibana-de-an-zhuang/"/>
      <url>/2020/05/02/es-zhong-kibana-de-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>根据上篇博客，我们已经了解了es的基本概念和es的安装环境和启动命令，以及简单的crud指令操作。</p><p>现在，让我们开始学习kibana的安装与使用。</p><p>Kibana是专门用来为ElasticSearch设计开发的，可以提供数据查询，数据可视化等功能。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://www.elastic.co/cn/downloads/past-releases#kibana" target="_blank" rel="noopener">kibana的各种下载版本</a></p><p>博主这里下载的是6.2.1的，各位可以选择与自己安装es的版本一致就行。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装步骤比较简单。</p><ol><li>下载完后解压到任意目录。</li><li>启动es</li><li>配置config目录下的kibana.yml的elasticsearch.url指向es地址</li><li>运行bin目录下的kibana</li><li>如果没有修改配置文件的端口，那么在浏览器中输入<a href="http://localhost:5601" target="_blank" rel="noopener">http://localhost:5601</a></li><li>启动Kibana后，Kibana会自动在配置的es中创建一个名为.kibana的索引，用来存储数据，注意不要删除了。</li></ol><hr><p>修改kibana的配置文件：</p><p><img src="https://pic.downk.cc/item/5ead8cc6c2a9a83be5e7bc86.jpg" alt></p><p><img src="https://pic.downk.cc/item/5ead8e39c2a9a83be5e95cdd.jpg" alt></p><p><code>./bin/kibana</code>启动kibana</p><p><img src="https://pic.downk.cc/item/5ead91a4c2a9a83be5edee22.jpg" alt></p><p>ps：后台启动：<code>nohup ./bin/kibana &amp;</code></p><p>验证kibana是否启动成功：</p><p>在浏览器中输入：<code>http://localhost:5601/</code></p><p><img src="https://pic.downk.cc/item/5ead95c8c2a9a83be5f2e59c.jpg" alt></p><p><img src="https://pic.downk.cc/item/5ead9632c2a9a83be5f34bce.jpg" alt></p><p>那，我们来创建一个索引pattern吧：</p><p><img src="https://pic.downk.cc/item/5ead9798c2a9a83be5f4ca07.jpg" alt></p><p><img src="https://pic.downk.cc/item/5ead97fdc2a9a83be5f52f43.jpg" alt></p><p><img src="https://pic.downk.cc/item/5ead99e2c2a9a83be5f6c54f.jpg" alt></p><p>创建成功后：</p><p><img src="https://pic.downk.cc/item/5ead9a1fc2a9a83be5f6efe1.jpg" alt></p><p>再次点击Discover：</p><p><img src="https://pic.downk.cc/item/5ead9a4dc2a9a83be5f70de9.jpg" alt></p><p>能直观的看到hello索引中的数据。</p><h2 id="Kibana中执行restAPI"><a href="#Kibana中执行restAPI" class="headerlink" title="Kibana中执行restAPI"></a>Kibana中执行restAPI</h2><p>点击：Dev Tools</p><h3 id="查看es索引的mapping结构"><a href="#查看es索引的mapping结构" class="headerlink" title="查看es索引的mapping结构"></a>查看es索引的mapping结构</h3><p>GET index/_mapping</p><p><img src="https://pic.downk.cc/item/5ead9b0cc2a9a83be5f7c6fb.jpg" alt></p><h3 id="es中插入数据"><a href="#es中插入数据" class="headerlink" title="es中插入数据"></a>es中插入数据</h3><pre class=" language-java"><code class="language-java">POST hello<span class="token operator">/</span>people<span class="token punctuation">{</span>  <span class="token string">"id"</span><span class="token operator">:</span><span class="token string">"34567"</span><span class="token punctuation">,</span>  <span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"li's"</span><span class="token punctuation">}</span></code></pre><p><img src="https://pic.downk.cc/item/5ead9b75c2a9a83be5f83145.jpg" alt></p><h3 id="es中查询数据"><a href="#es中查询数据" class="headerlink" title="es中查询数据"></a>es中查询数据</h3><p>1) 查询指定的 _id</p><pre class=" language-java"><code class="language-java">GET hello<span class="token operator">/</span>people<span class="token operator">/</span>MGcn1nEB9ShQhk7DF0Ql这里的 MGcn1nEB9ShQhk7DF0Ql 是 文档的_id，该字段是唯一的标识符</code></pre><p><img src="https://pic.downk.cc/item/5ead9bfcc2a9a83be5f8c2b0.jpg" alt></p><p>2) 查询所有的数据</p><pre class=" language-java"><code class="language-java">GET hello<span class="token operator">/</span>people<span class="token operator">/</span>_search</code></pre><p><img src="https://pic.downk.cc/item/5ead9c8dc2a9a83be5f970a6.jpg" alt></p><p>3) es中的match查询（匹配）</p><pre class=" language-java"><code class="language-java">GET hello<span class="token operator">/</span>people<span class="token operator">/</span>_search<span class="token punctuation">{</span>  <span class="token string">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"张"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="https://pic.downk.cc/item/5ead9ce7c2a9a83be5f9dec9.jpg" alt></p><p>可以看到，只查询到了name中包含张的数据，match后续会解释，现在只需要懂得match是匹配一个字符串中是否包含指定的parse即可。</p><hr><p>ps：使用Kibana的工具中的Dev Tools时，输入restAPI时会有提示！</p><p>最终打开es-head，你会发现多了一个索引：.kibana</p><p><img src="/Users/liuzhuo/Library/Application Support/typora-user-images/image-20200503001957825.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch的入门</title>
      <link href="/2020/05/01/elasticsearch-de-ru-men/"/>
      <url>/2020/05/01/elasticsearch-de-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Elasticsearch是一个高度可扩展的开源的分布式Restful全文搜索和分析引擎。它允许用户快速的（近实时的）存储、搜索和分析海量数据。它通常用作底层引擎技术，为具有复杂搜索功能和要求的应用程序提供支持。<br>以下是ES可用于的一些场景：</p><ol><li>电商网站提供搜索功能：可使用ES来存储产品的目录和库存，并为它们提供搜索和自动填充建议。</li><li>收集日志和交易数据，并进行分析：可使用Logstash来收集、聚合和解析数据， 然后让Logstash将此数据提供给ES。然后可在ES中搜索和聚合开发者感兴趣的信息。</li><li>需要快速调查、分析、可视化查询大量数据的特定问题：可以使用ES存储数据，然后使用Kibana构建自定义仪表板，来可视化展示数据。还可以使用ES的聚合功能针对这些数据进行复杂的商业分析。</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>本文章主要介绍在mac上面安装的过程，其他操作系统类似。</p><p>下载地址如下：</p><p><a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">es的中文官方文档</a></p><p><img src="https://pic.downk.cc/item/5eac316fc2a9a83be5a3325a.jpg" alt></p><p>可以看到最新的版本是：7.6.2.</p><p>es每个版本改动很大，7版本中去掉了es中的type类型，博主还没有去研究7的版本，因此，我下载的是6的版本，6.2.1的。</p><p>下载历史版本：</p><p><img src="https://pic.downk.cc/item/5eac31f8c2a9a83be5a4084a.jpg" alt></p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><img src="https://pic.downk.cc/item/5eac326fc2a9a83be5a4ff3b.jpg" alt></p><p>es的安装目录简单介绍：</p><p>1）bin目录：主要是es的启动，停止，安装插件的可执行程序</p><p>2）config目录：es的配置文件，修改es启动的ip地址，端口号等</p><p>3）lib目录：es执行依赖的jar包</p><p>4）logs目录：es运行过程中产生的日志文件</p><p>5）plugins目录：es可以自定义插件来扩展es的功能，此目录就是用来安装es插件的。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>1）前台运行</p><p>在es的解压后的目录下：</p><p><code>./bin/elasticsearch</code></p><p><img src="/Users/liuzhuo/Library/Application Support/typora-user-images/image-20200501223708875.png" alt></p><p>2) 后台运行</p><p><code>nohup ./bin/elasticsearhc &amp;</code></p><p>执行后，在当前目录下，可以看到 nohup的文件，<code>tail -f nohup</code> 来实时查看es的运行情况。</p><p>3）验证是否启动成功</p><p>在浏览器中输入：<code>http://localhost:9200/</code></p><p><img src="https://pic.downk.cc/item/5eac34a5c2a9a83be5a8d37f.jpg" alt></p><p>可以看到此时es的启动情况：</p><p>节点的name：node-1</p><p>集群的名字：gakki</p><p>es的版本号，lucene的版本号等。</p><h2 id="es的head插件"><a href="#es的head插件" class="headerlink" title="es的head插件"></a>es的head插件</h2><p>博主下载了es的head的谷歌浏览器的插件，可以很方便的查看es的健康、集群、索引的情况</p><p><img src="https://pic.downk.cc/item/5eac3570c2a9a83be5aae685.jpg" alt></p><h2 id="es的简单restAPI介绍"><a href="#es的简单restAPI介绍" class="headerlink" title="es的简单restAPI介绍"></a>es的简单restAPI介绍</h2><p>今天，这里博主首先使用postman工具来发送http请求，后面会使用Kibana来操作。</p><h3 id="es启动验证"><a href="#es启动验证" class="headerlink" title="es启动验证"></a>es启动验证</h3><p><img src="https://pic.downk.cc/item/5eac3700c2a9a83be5ad142b.jpg" alt></p><p>可以看到，使用get请求，输入：<code>http://localhost:9200/</code></p><p>返回的结果和我们直接使用浏览器访问的结果一致。</p><h3 id="es中创建索引"><a href="#es中创建索引" class="headerlink" title="es中创建索引"></a>es中创建索引</h3><p><img src="https://pic.downk.cc/item/5eac3a44c2a9a83be5b0cb70.jpg" alt></p><p>这里，创建了一个名称为：hello，type：people，主分片数为：1，副本为：0的索引。因为，我这里只有一个节点，不再集群的环境，因此就一个主分配数，没有副本，如果后期搭建集群环境，创建索引时，可以合理安排这两个值。</p><p>验证：</p><p>在我们的es-head的插件中，可以非常直观的看到索引的信息，这也是我安装这个插件的原因</p><p><img src="https://pic.downk.cc/item/5eac3b19c2a9a83be5b18f41.jpg" alt></p><h3 id="es中往索引中插入数据"><a href="#es中往索引中插入数据" class="headerlink" title="es中往索引中插入数据"></a>es中往索引中插入数据</h3><p><img src="https://pic.downk.cc/item/5eac3c6ac2a9a83be5b2fcd9.jpg" alt></p><p>根据我们创建的索引中的type类型来插入数据，上面我们创建了people类型，字段有id和name，类型都是String类型，String类型分为：keyword 和 text 类型，这个后面会介绍，现在只要知道是String类型即可。</p><h3 id="es中的查询"><a href="#es中的查询" class="headerlink" title="es中的查询"></a>es中的查询</h3><p>1）查询所有文档</p><p><code>http://localhost:9200/hello/people/_search</code></p><p><img src="https://pic.downk.cc/item/5eac3e9ec2a9a83be5b5902f.jpg" alt></p><p>2) 查询指定的id的文档</p><p><code>http://localhost:9200/hello/people/${_id}</code></p><p><img src="https://pic.downk.cc/item/5eac3f18c2a9a83be5b625d1.jpg" alt></p><p>3) 高级查询</p><p>根据name字段来查询</p><p><img src="https://pic.downk.cc/item/5eac404ec2a9a83be5b76fb9.jpg" alt></p><p>es-head插件中也能直接看到数据：</p><p><img src="https://pic.downk.cc/item/5eac40abc2a9a83be5b7e823.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ProtoBuffer的简介</title>
      <link href="/2020/01/24/protobuffer-de-jian-jie/"/>
      <url>/2020/01/24/protobuffer-de-jian-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是protocol-buffers"><a href="#什么是protocol-buffers" class="headerlink" title="什么是protocol buffers"></a>什么是protocol buffers</h3><p> protocol buffers是一个灵活的、高效的、自动化的用于对结构化数据进行序列化的协议，与json、xml相比，protocol buffers序列化后的码流更小、速度更快、操作更简单。你只需要将要被序列化的数据结构定义一次(使用.proto文件定义)，便可以使用特别生成的源代码(使用protobuf提供的生成工具protoc)轻松的使用不同的数据流完成对这些结构数据的读写操作，即使你使用不同的语言（protobuf的跨语言支持特性）。你甚至可以更新你的数据结构的定义（就是更新.proto文件内容）而不会破坏依“老”格式编译出来的程序。</p><h3 id="protobuffer的安装"><a href="#protobuffer的安装" class="headerlink" title="protobuffer的安装"></a>protobuffer的安装</h3><h4 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h4><p>下面是在mac的电脑上安装protobuf步骤,如下</p><pre class=" language-java"><code class="language-java">git clone https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>google<span class="token operator">/</span>protobufgit checkout 版本号</code></pre><p><a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener"><em>下载地址</em></a></p><p><img src="https://pic.downk.cc/item/5e2ab7fb2fb38b8c3c5fdad7.jpg" alt></p><p><img src="https://pic.downk.cc/item/5e2ab8692fb38b8c3c5fe2a3.jpg" alt></p><hr><h4 id="安装automake和libtool"><a href="#安装automake和libtool" class="headerlink" title="安装automake和libtool"></a>安装automake和libtool</h4><pre class=" language-java"><code class="language-java">brew install automakebrew install libtool</code></pre><p>前提：你的Mac需要先安装了brew！！！</p><p>如果没有安装的话，请自行百度解决，安装如果很慢，需要切换成清华的源。</p><p><a href="https://blog.csdn.net/sinat_38184748/article/details/99450330" target="_blank" rel="noopener">macOS安装Homebrew太慢，换用清华镜像</a></p><h4 id="运行自动生成脚本"><a href="#运行自动生成脚本" class="headerlink" title="运行自动生成脚本"></a>运行自动生成脚本</h4><pre class=" language-java"><code class="language-java"><span class="token punctuation">.</span>/autogen<span class="token punctuation">.</span>sh</code></pre><h4 id="安装protobuf"><a href="#安装protobuf" class="headerlink" title="安装protobuf"></a>安装protobuf</h4><pre class=" language-java"><code class="language-java"><span class="token punctuation">.</span>/configuremake checkmakesudo make install </code></pre><h4 id="查看安装版本"><a href="#查看安装版本" class="headerlink" title="查看安装版本"></a>查看安装版本</h4><pre class=" language-java"><code class="language-java">protoc <span class="token operator">--</span>version</code></pre><p><img src="https://pic.downk.cc/item/5e2aba9f2fb38b8c3c600887.jpg" alt></p><hr><h3 id="定义Message"><a href="#定义Message" class="headerlink" title="定义Message"></a>定义Message</h3><p>首先看一个简单的例子，比如说你定义一个搜索请求的message，每一个搜索请求会包含一个搜索的字符串，返回第几页的结果，以及结果集的大小。在<code>.proto</code>文件中定义如下：</p><h4 id="proto3的格式"><a href="#proto3的格式" class="headerlink" title="proto3的格式"></a>proto3的格式</h4><pre class=" language-java"><code class="language-java">syntax <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//必须是文件中非空非注释行的第一行</span>message SearchRequest <span class="token punctuation">{</span>  string query <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  int32 page_number <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  int32 result_per_page <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><code>.proto</code>文件的第一行指定了使用<code>proto3</code>语法。如果省略protocol buffer编译器默认使用<code>proto2</code>语法。<font color="red"><strong>它必须是文件中非空非注释行的第一行</strong>。</font></li><li><code>SearchRequest</code>定义中指定了三个字段(name/value键值对)，每个字段都会有名称和类型。</li></ul><hr><h4 id="proto2的格式"><a href="#proto2的格式" class="headerlink" title="proto2的格式"></a>proto2的格式</h4><pre class=" language-java"><code class="language-java">message Person <span class="token punctuation">{</span>  required string name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//required：表示必须字段</span>  required int32 id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  optional string email <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//optional：表示可选字段</span>  <span class="token keyword">enum</span> PhoneType <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//枚举类型</span>    MOBILE <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    HOME <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    WORK <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  message PhoneNumber <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 嵌套message</span>    required string number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    optional PhoneType type <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">[</span><span class="token keyword">default</span> <span class="token operator">=</span> HOME<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  repeated PhoneNumber phone <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>第一行不写，或者写：<code>syntax = &quot;proto2&quot;</code>才是proto2.0协议。</p><h4 id="proto3和proto2的区别"><a href="#proto3和proto2的区别" class="headerlink" title="proto3和proto2的区别"></a>proto3和proto2的区别</h4><ul><li><p>在第一行非空白非注释行，必须写：<code>syntax = &quot;proto3&quot;</code>;</p></li><li><p>字段规则移除了 <code>“required”</code>，并把<code>“optional”</code> 改名为 <code>“singular”</code> ；</p><p>在 proto2 中 required 也是不推荐使用的。proto3 直接从语法层面上移除了 required 规则。其实可以做的更彻底，把所有字段规则描述都撤销，原来的 repeated 改为在类型或字段名后加一对中括号。这样是不是更简洁？</p></li><li><p><code>“repeated”</code>字段默认采用 <code>packed</code> 编码 [ proto3.0]</p></li></ul><p>​       在 proto2 中，需要明确使用 <code>[packed=true]</code> 来为字段指定比较紧凑的 <code>packed</code> 编码方式。</p><ul><li><p>语言增加 Go、Ruby、JavaNano 支持</p></li><li><p>移除了 default 选项</p><p>在 proto2 中，可以使用 default 选项为某一字段指定默认值。在 proto3 中，字段的默认值只能根据字段类型由系统决定。也就是说，<strong>默认值全部是约定好的，而不再提供指定默认值的语法</strong>。</p><p>在字段被设置为默认值的时候，该字段不会被序列化，这样可以节省空间，提高效率。</p><p>但这样就无法区分某字段是根本没赋值，还是赋值了默认值。这在 proto3 中问题不大，但在 proto2 中会有问题。</p><p>比如，在更新协议的时候使用 default 选项为某个字段指定了一个与原来不同的默认值，旧代码获取到的该字段的值会与新代码不一样。</p></li><li><p>枚举类型的第一个字段必须为 0。</p><p>这也是一个约定。</p></li><li><p>移除了对分组的支持</p><p>分组的功能完全可以用消息嵌套的方式来实现，并且更清晰。在 proto2 中已经把分组语法标注为『过期』了。这次也算清理垃圾了。</p></li><li><p>旧代码在解析新增字段时，会把不认识的字段丢弃，再序列化后新增的字段就没了；</p><p>在 proto2 中，旧代码虽然会忽视不认识的新增字段，但并不会将其丢弃，再序列化的时候那些字段会被原样保留。</p><p>我觉得还是 proto2 的处理方式更好一些。能尽量保持兼容性和扩展能力，或许实现起来也更简单。proto3 现在的处理方式，没有带来明显的好处，但丢掉了部分兼容性和灵活性。</p><p><strong>[2017-06-15 更新]</strong>：经过漫长的<a href="https://github.com/google/protobuf/issues/272" target="_blank" rel="noopener">讨论</a>，官方终于同意在 proto3 中恢复 proto2 的处理方式了。 可以通过<a href="https://docs.google.com/document/d/1KMRX-G91Aa-Y2FkEaHeeviLRRNblgIahbsk4wA14gRk/view" target="_blank" rel="noopener">这个文档</a>了解前因后果及时间线。</p></li><li><p>移除了对扩展的支持，新增了 Any 类型。</p><p>Any 类型是用来替代 proto2 中的扩展的。目前还在开发中。</p><p>proto2 中的扩展特性很像 Swift 语言中的扩展。理解起来有点困难，使用起来更是会带来不少混乱。</p><p>相比之下，proto3 中新增的 Any 类型有点像 C/C++ 中的 void* ，好理解，使用起来逻辑也更清晰。</p></li><li><p>增加了 JSON 映射特性</p><p>语言的活力来自于与时俱进。当前，JSON 的流行有其充分的理由。很多『现代化』的语言都内置了对 JSON 的支持，比如 Go、PHP 等。而 C++ 这种看似保罗万象的学院派语言，因循守旧、故步自封，以致于现出了式微的苗头。</p></li></ul><hr><h4 id="message数据格式中需要知道的"><a href="#message数据格式中需要知道的" class="headerlink" title="message数据格式中需要知道的"></a>message数据格式中需要知道的</h4><pre class=" language-java"><code class="language-java">proto2<span class="token number">.0</span>required<span class="token operator">:</span> 必须赋值，不能为空，否则该条message会被认为是“uninitialized”。build一个“uninitialized” message会抛出一个RuntimeException异常，解析一条“uninitialized” message会抛出一条IOException异常。除此之外，“required”字段跟“optional”字段并无差别。optional<span class="token operator">:</span> 字段可以赋值，也可以不赋值。假如没有赋值的话，会被赋上默认值。repeated<span class="token operator">:</span> 该字段可以重复任意次数，包括<span class="token number">0</span>次。重复数据的顺序将会保存在protocol buffer中，将这个字段想象成一个可以自动设置size的数组就可以了。<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>proto3<span class="token number">.0</span>去掉了 required。singular：一个遵循singular规则的字段，在一个结构良好的message消息体<span class="token punctuation">(</span>编码后的message<span class="token punctuation">)</span>可以有<span class="token number">0</span>或<span class="token number">1</span>个该字段（但是不可以有多个）。这是proto3语法的默认字段规则。（这个理解起来有些晦涩，举例来说上面例子中三个字段都是singular类型的字段，在编码后的消息体中可以有<span class="token number">0</span>或者<span class="token number">1</span>个query字段，但不会有多个。）repeated：遵循repeated规则的字段在消息体重可以有任意多个该字段值，这些值的顺序在消息体重可以保持（就是数组类型的字段）</code></pre><h4 id="指定字段类型"><a href="#指定字段类型" class="headerlink" title="指定字段类型"></a>指定字段类型</h4><p>protobuffer支持的数据类型如下： </p><p><img src="https://pic.downk.cc/item/5e2acc362fb38b8c3c613db0.jpg" alt></p><h4 id="指定字段编号"><a href="#指定字段编号" class="headerlink" title="指定字段编号"></a>指定字段编号</h4><p>在message定义中每个字段都有一个<strong>唯一的编号</strong>，这些编号被用来在二进制消息体中识别你定义的这些字段，一旦你的message类型被用到后就不应该在修改这些编号了。注意在将message编码成二进制消息体时字段编号1-15将会占用1个字节，16-2047将占用两个字节。所以在一些频繁使用用的message中，你应该总是先使用前面1-15字段编号。</p><p>你可以指定的最小编号是1，最大是2E29 - 1（536,870,911）。<font color="red"><strong>其中19000到19999是给protocol buffers实现保留的字段标号，定义message时不能使用</strong></font>。<strong>同样的你也不能重复使用任何当前message定义里已经使用过和预留的字段编号。</strong></p><h4 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h4><p><code>.proto</code>文件中的注释和C，C++的注释风格相同，使用// 和 /<em> … </em>/</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* SearchRequest represents a search query, with pagination options to * indicate which results to include in the response. */</span>message SearchRequest <span class="token punctuation">{</span>  string query <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  int32 page_number <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Which page number do we want?</span>  int32 result_per_page <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Number of results to return per page.</span><span class="token punctuation">}</span></code></pre><h4 id="保留字段"><a href="#保留字段" class="headerlink" title="保留字段"></a>保留字段</h4><p>当你删掉或者注释掉message中的一个字段时，未来其他开发者在更新message定义时就可以重用之前的字段编号。如果他们意外载入了老版本的<code>.proto</code>文件将会导致严重的问题，比如数据损坏、隐私泄露等。一种避免问题发生的方式是<strong>指定保留的字段编号和字段名称</strong>。如果未来有人用了这些字段标识那么在编译时protocol buffer的编译器会报错。</p><pre class=" language-java"><code class="language-java">message Foo <span class="token punctuation">{</span>  reserved <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">9</span> to <span class="token number">11</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 定义字段编号为保留字段。2、15 和 9 到 11 都是保留字段，不许使用</span>  reserved <span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义字段名称为保留字段</span><span class="token punctuation">}</span></code></pre><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>当时一个被编码的message体中不存在某个message定义中的singular字段时，在message体解析成的对象中，相应字段会被设置为message定义中该字段的默认值。默认值依类型而定：</p><ul><li>对于字符串，默认值为空字符串。</li><li>对于字节，默认值为空字节。</li><li>对于bools，默认值为false。</li><li>对于数字类型，默认值为零。</li><li>对于枚举，默认值是第一个定义的枚举值，该值必须为0。</li><li>对于消息字段，未设置该字段。它的确切值取决于语言。有关详细信息。</li></ul><hr><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>在定义消息类型时，您可能希望其中一个字段只有一个预定义的值列表中的值。例如，假设您要为每个<code>SearchRequest</code>添加<code>corpus</code>字段，其中<code>corpus</code>可以是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS或VIDEO。您可以非常简单地通过向消息定义添加枚举，并为每个可能的枚举值值添加常量来实现。</p><p>在下面的例子中，我们添加了一个名为<code>Corpus</code>的枚举类型，和一个<code>Corpus</code>类型的字段：</p><pre class=" language-java"><code class="language-java">message SearchRequest <span class="token punctuation">{</span>  string query <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  int32 page_number <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  int32 result_per_page <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token keyword">enum</span> Corpus <span class="token punctuation">{</span>    UNIVERSAL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    WEB <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    IMAGES <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    LOCAL <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    NEWS <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    PRODUCTS <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    VIDEO <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  Corpus corpus <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如你所见，<code>Corpus</code>枚举的第一个常量映射到了0：所有枚举定义都需要包含一个常量映射到0并且作为定义的首行，这是因为：</p><ul><li>必须有0值，这样我们就可以将0作为枚举的默认值。</li><li>proto2语法中首行的枚举值总是默认值，为了兼容0值必须作为定义的首行。</li></ul><hr><h4 id="使用其他Message类型"><a href="#使用其他Message类型" class="headerlink" title="使用其他Message类型"></a>使用其他Message类型</h4><p>可以使用其他message类型作为字段的类型，假设你想在每个<code>SearchResponse</code>消息中携带类型为<code>Result</code>的消息，</p><p>你可以在同一个<code>.proto</code>文件中定义一个<code>Result</code>消息类型，然后在<code>SearchResponse</code>中指定一个<code>Result</code>类型的字段。</p><pre class=" language-java"><code class="language-java">message SearchResponse <span class="token punctuation">{</span>  repeated Result results <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>message Result <span class="token punctuation">{</span>  string url <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  string title <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  repeated string snippets <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="导入消息定义"><a href="#导入消息定义" class="headerlink" title="导入消息定义"></a>导入消息定义</h4><p>在上面的示例中，<code>Result</code>消息类型在与<code>SearchResponse</code>相同的文件中定义 - 如果要用作字段类型的消息类型已在另一个<code>.proto</code>文件中定义，该怎么办？</p><p>您可以通过导入来使用其他.proto文件中的定义。要导入另一个.proto的定义，请在文件顶部添加一个import语句：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token string">"myproject/other_protos.proto"</span><span class="token punctuation">;</span></code></pre><p>默认情况下，您只能使用直接导入的<code>.proto</code>文件中的定义。但是，有时你可能需要将<code>.proto</code>文件移动到新位置。现在，你可以在旧位置放置一个虚拟<code>.proto</code>文件，在文件中使用<code>import public</code>语法将所有导入转发到新位置，而不是直接移动<code>.proto</code>文件并在一次更改中更新所有调用点。任何导入包含<code>import public</code>语句的<code>proto</code>文件的人都可以<strong>传递依赖</strong>导入公共依赖项。例如:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// new.proto</span><span class="token comment" spellcheck="true">// All definitions are moved here</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// old.proto</span><span class="token comment" spellcheck="true">// This is the proto that all clients are importing.</span><span class="token keyword">import</span> <span class="token keyword">public</span> <span class="token string">"new.proto"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">"other.proto"</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// client.proto</span><span class="token keyword">import</span> <span class="token string">"old.proto"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// You use definitions from old.proto and new.proto, but not other.proto</span></code></pre><p>编译器会在通过命令行参数<code>-I</code>或者<code>--proto-path</code>中指定的文件夹中搜索<code>.proto</code>文件，如果没有提供编译器会在唤其编译器的目录中进行搜索。通常来说你应该将<code>--proto-path</code>的值设置为你项目的根目录，并对所有导入使用完全限定名称。</p><h4 id="嵌套消息类型"><a href="#嵌套消息类型" class="headerlink" title="嵌套消息类型"></a>嵌套消息类型</h4><p>消息类型可以被定义和使用在其他消息类型中，下面的例子里<code>Result</code>消息被定义在<code>SearchResponse</code>消息中:</p><pre class=" language-java"><code class="language-java">message SearchResponse <span class="token punctuation">{</span>  message Result <span class="token punctuation">{</span>    string url <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    string title <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    repeated string snippets <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  repeated Result results <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果你想在外部使用定义在父消息中的子消息，使用<code>Parent.Type</code>引用他们</p><pre class=" language-java"><code class="language-java">message SomeOtherMessage <span class="token punctuation">{</span>  SearchResponse<span class="token punctuation">.</span>Result result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>你可以嵌套任意多层消息:</p><pre class=" language-java"><code class="language-java">message Outer <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// Level 0</span>  message MiddleAA <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Level 1</span>    message Inner <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// Level 2</span>      int64 ival <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      bool  booly <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  message MiddleBB <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Level 1</span>    message Inner <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// Level 2</span>      int32 ival <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      bool  booly <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="更新Message"><a href="#更新Message" class="headerlink" title="更新Message"></a>更新Message</h4><p>如果一个现存的消息类型不再满足你当前的需求–比如说你希望在消息中增加一个额外的字段–但是仍想使用由旧版的消息格式生成的代码，不用担心！只要记住下面的规则，在更新消息定义的同时又不破坏现有的代码就非常简单。</p><ul><li>不要更改任何已存字段的字段编号。</li><li>如果添加了新字段，任何由旧版消息格式生成的代码所序列化的消息，仍能被依据新消息格式生成的代码所解析。你应该记住这些元素的默认值这些新生成的代码就能够正确地与由旧代码序列化创建的消息交互了。类似的，新代码创建的消息也能由旧版代码解析：旧版消息（二进制）在解析时简单地忽略了新增的字段.</li><li>只要在更新后的消息类型中不再重用字段编号，就可以删除该字段。你也可以重命名字段，比如说添加<code>OBSOLETE_</code>前缀或者将字段编号设置为<code>reserved</code>，这些未来其他用户就不会意外地重用该字段编号了。</li></ul><hr><h4 id="未知字段"><a href="#未知字段" class="headerlink" title="未知字段"></a>未知字段</h4><p>未知字段是格式良好的协议缓冲区序列化数据，表示解析器无法识别的字段。例如，当旧二进制文件解析具有新字段的新二进制文件发送的数据时，这些新字段将成为旧二进制文件中的未知字段。</p><p>最初，proto3消息在解析期间总是丢弃未知字段，但在3.5版本中，我们重新引入了未知字段的保留以匹配proto2行为。在版本3.5及更高版本中，未知字段在解析期间保留，并包含在序列化输出中。</p><h4 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h4><p>如果你想创建一个映射作为message定义的一部分，protocol buffers提供了一个简易便利的语法。</p><pre class=" language-java"><code class="language-java">map<span class="token operator">&lt;</span>key_type<span class="token punctuation">,</span> value_type<span class="token operator">></span> map_field <span class="token operator">=</span> N<span class="token punctuation">;</span></code></pre><p><code>key_type</code>可以是任意整数或者字符串（除了浮点数和bytes以外的所有标量类型）。注意<code>enum</code>不是一个有效的<code>key_type</code>。<code>value_type</code>可以是除了映射以外的任意类型（意思是protocol buffers的消息体中不允许有嵌套map）。</p><p>举例来说，假如你想创建一个名为projects的映射，每一个<code>Project</code>消息关联一个字符串键，你可以像如下来定义：</p><pre class=" language-java"><code class="language-java">map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> Project<span class="token operator">></span> projects <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre><ul><li><p>映射里的字段不能是follow repeated规则的（意思是映射里字段的值不能是数组）。</p></li><li><p>映射里的值是无序的，所以不能依赖映射里元素的顺序。</p></li><li><p>生成.proto的文本格式时，映射按键排序。数字键按数字排序。</p></li><li><p>从线路解析或合并时，如果有重复的映射键，则使用最后看到的键。从文本格式解析映射时，如果存在重复键，则解析可能会失败。</p></li><li><p>如果未给映射的字段指定值，字段被序列化时的行为依语言而定。在C++， Java和Python中字段类型的默认值会被序列化作为字段值，而其他语言则不会。</p></li></ul><h4 id="给Message加包名"><a href="#给Message加包名" class="headerlink" title="给Message加包名"></a>给Message加包名</h4><p>你可以在<code>.proto</code>文件中添加一个可选的<code>package</code>符来防止消息类型之前的名称冲突。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> foo<span class="token punctuation">.</span>bar<span class="token punctuation">;</span>message Open <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><p>在定义message的字段时像如下这样使用package名称</p><pre class=" language-java"><code class="language-java">message Foo <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  foo<span class="token punctuation">.</span>bar<span class="token punctuation">.</span>Open open <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>package：对生成代码的影响视编程语言而定。</p><h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><p>要生成：Java，Python，C ++，Go，Ruby，Objective-C 或 C＃代码，你需要使用<code>.proto</code>文件中定义的消息类型，你需要在<code>.proto</code>上运行protocol buffer编译器<code>protoc</code>。如果尚未安装编译器，请下载<a href="https://developers.google.com/protocol-buffers/docs/downloads.html" target="_blank" rel="noopener">该软件包</a>并按照README文件中的说明进行操作。对于Go，还需要为编译器安装一个特殊的代码生成器插件：你可以在GitHub上的<a href="https://github.com/golang/protobuf/" target="_blank" rel="noopener">golang/protobuf</a>项目中找到这个插件和安装说明。</p><p>编译器像下面这样唤起：</p><pre class=" language-java"><code class="language-java">protoc <span class="token operator">--</span>proto_path<span class="token operator">=</span>IMPORT_PATH <span class="token operator">--</span>cpp_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>java_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>python_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>go_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>ruby_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>objc_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>csharp_out<span class="token operator">=</span>DST_DIR path<span class="token operator">/</span>to<span class="token operator">/</span>file<span class="token punctuation">.</span>proto</code></pre><p><code>IMPORT_PATH</code>指定了在解析<code>import</code>命令时去哪里搜索<code>.proto</code>文件，如果忽略将在当前工作目录进行查找，可以通过传递多次<code>--proto_path</code>参数来指定多个import目录，他们将会按顺序被编译器搜索。<code>-I=IMPORT_PATH</code>是<code>--proto_path</code>的简短形式。</p><hr><p>你可以提供一个或多个输出命令：</p><pre class=" language-java"><code class="language-java"><span class="token operator">--</span>cpp_out generates C<span class="token operator">++</span> code in DST_DIR<span class="token punctuation">.</span> See the C<span class="token operator">++</span> generated code reference <span class="token keyword">for</span> more<span class="token punctuation">.</span><span class="token operator">--</span>java_out generates Java code in DST_DIR<span class="token punctuation">.</span> See the Java generated code reference <span class="token keyword">for</span> more<span class="token punctuation">.</span><span class="token operator">--</span>python_out generates Python code in DST_DIR<span class="token punctuation">.</span> See the Python generated code reference <span class="token keyword">for</span> more<span class="token punctuation">.</span><span class="token operator">--</span>go_out generates Go code in DST_DIR<span class="token punctuation">.</span> See the Go generated code reference <span class="token keyword">for</span> more<span class="token punctuation">.</span><span class="token operator">--</span>ruby_out generates Ruby code in DST_DIR<span class="token punctuation">.</span> Ruby generated code reference is coming soon<span class="token operator">!</span><span class="token operator">--</span>objc_out generates Objective<span class="token operator">-</span>C code in DST_DIR<span class="token punctuation">.</span> See the Objective<span class="token operator">-</span>C generated code reference <span class="token keyword">for</span> more<span class="token punctuation">.</span><span class="token operator">--</span>csharp_out generates C# code in DST_DIR<span class="token punctuation">.</span> See the C# generated code reference <span class="token keyword">for</span> more<span class="token punctuation">.</span><span class="token operator">--</span>php_out generates PHP code in DST_DIR<span class="token punctuation">.</span> See the PHP generated code reference <span class="token keyword">for</span> more<span class="token punctuation">.</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> protobuffer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> protobuffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019,see you</title>
      <link href="/2020/01/04/2019-see-you/"/>
      <url>/2020/01/04/2019-see-you/</url>
      
        <content type="html"><![CDATA[<p>2019年，是我最丧的一年，不能怪外力，只怪自己不够努力。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>2019年毕业后，直接就去工作了，对于工作已经没有了之前的那种好奇，热血，激情了。因为，研究生就出去实习过，所以比较平淡，但是还是认识了很多优秀的同届同事。</p><p>目前对于自己的工作还算满意，只是从之前的熟悉的环境中，去学习新的技术来完成工作，一开始会比较吃力，毕竟从零开始，快速学习能力比较重要。想告诫很多学生，自我学习能力真的很重要，不要养成靠别人教你的习惯，这样会形成惰性，不好；现在，社会发展很快，如果不能够快速学习，跟不上的话，很容易被淘汰掉，说起来好像很残酷，但是现实就是这样，请养成做笔记的习惯，多总结，多思考，回家后少看手机，多看书，多学习新的知识，每天进步一点也是最大的进步，共勉。</p><h3 id="足迹"><a href="#足迹" class="headerlink" title="足迹"></a>足迹</h3><p>本想着工作后就去日本，然后发现好像时间特别珍贵，还没来及思考，2019就过去了。</p><p>日本一定会去的，不会缺席，只会滞后啦~~~</p><h4 id="上海圣地巡游"><a href="#上海圣地巡游" class="headerlink" title="上海圣地巡游"></a>上海圣地巡游</h4><p>19的五一长假去了上海，来了一次与gakki的隔空旅行。起因：偶然发现了gakki在上海06年拍摄的短篇《相遇》，然后就想着去上海把她走过的旅途再走一遍。</p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","video":{"url":"http://upos-sz-mirrorhw.bilivideo.com/upgcxcode/65/07/32650765/32650765-1-208.mp4?e=ig8euxZM2rNcNbNBhwdVhwdlhbUVhwdVhoNvNC8BqJIzNbfq9rVEuxTEnE8L5F6VnEsSTx0vkX8fqJeYTj_lta53NCM=&uipk=5&nbs=1&deadline=1590904239&gen=playurl&os=hwbv&oi=837395164&trid=ede775841df049da83057362d47cf65dT&platform=html5&upsig=9d6cb71fd7ddeb4119e67262d6e8d868&uparams=e,uipk,nbs,deadline,gen,os,oi,trid,platform&mid=580104086&orderid=0,1&logo=80000000","pic":"https://pic.superbed.cn/item/5d024694451253d1783b809b.jpg"},"danmaku":{"id":"dplayerOfgakki","api":"https://dplayer.moerats.com/","addition":["https://dplayer.moerats.com/v3/bilibili?aid=20015128"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>PS: 完整的旅行记录在我另外的博客中有，大家感兴趣可以去看看：</p><p><a href="https://liuzhuo19940206.coding.me/2019/07/13/%E4%B8%8A%E6%B5%B7gakki%E5%9C%A3%E5%9C%B0%E5%B7%A1%E6%B8%B8/" target="_blank" rel="noopener">上海圣地巡游</a></p><hr><h4 id="毕业视频"><a href="#毕业视频" class="headerlink" title="毕业视频"></a>毕业视频</h4><p>我毕业了，读书生涯，真的真的真的结束了。现在，想起来，仿佛还在校园里面，背着书包、骑着单车。</p><p>再见了 相互嫌弃的同学<br>再见了 来不及说出的谢谢</p><p>你我都来自五湖四海的小镇乡村<br>曾发誓 要做了不起的人</p><p>相信爱会永恒 相信每个陌生人<br>相信你会成为最想成为的人</p><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","video":{"url":"http://upos-sz-mirrorks3.bilivideo.com/upgcxcode/00/88/197078800/197078800-1-192.mp4?e=ig8euxZM2rNcNbRMhbdVhwdlhWKghwdVhoNvNC8BqJIzNbfq9rVEuxTEnE8L5F6VnEsSTx0vkX8fqJeYTj_lta53NCM=&uipk=5&nbs=1&deadline=1590906661&gen=playurl&os=ks3bv&oi=837395164&trid=d270ba03954f4e6199abe05e670c40e4T&platform=html5&upsig=a5e6145ed916ac94ed04646575b96019&uparams=e,uipk,nbs,deadline,gen,os,oi,trid,platform&mid=580104086&orderid=0,1&logo=80000000"},"danmaku":{"id":"biyeing","api":"https://dplayer.moerats.com/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>PS：完成历程：</p><p><a href="https://liuzhuo19940206.coding.me/2019/07/04/%E7%8C%AE%E7%BB%99416%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E7%AB%A5%E5%AD%A9/" target="_blank" rel="noopener">嗨，416实验室的同学们</a></p><h4 id="苏州失恋博物馆"><a href="#苏州失恋博物馆" class="headerlink" title="苏州失恋博物馆"></a>苏州失恋博物馆</h4><p>这里说明下，我没有失恋呀，毕竟还没有恋过，而来的失恋一说，哈哈。只是，因为是刚修建，有点兴趣才去的。</p><p><img src="https://pic.downk.cc/item/5e10042c76085c3289a70b54.jpg" style="zoom:50%;"></p><p><img src="https://pic.downk.cc/item/5e10046776085c3289a71319.jpg" style="zoom:50%;"></p><p><img src="https://pic.downk.cc/item/5e10049776085c3289a7194e.jpg" style="zoom:50%;"></p><h4 id="彭锣鼓巷"><a href="#彭锣鼓巷" class="headerlink" title="彭锣鼓巷"></a>彭锣鼓巷</h4><p>中央戏剧学院附近，人超多。本来是一条比较小清新的街道，后来发展成了商业街，卖各种商品了。</p><p><img src="https://pic.downk.cc/item/5e10088b76085c3289a79c76.jpg" alt></p><h4 id="Bilibili漫展"><a href="#Bilibili漫展" class="headerlink" title="Bilibili漫展"></a>Bilibili漫展</h4><p>特别大，总共3天。三天都会有不同的展厅，经费不足，只能玩一天，vip门票太贵，真的hold住三天的票钱，就去了一天，第一次去，感觉挺high的，我和小姐姐的合照，就不展示了，丢人~~~</p><p><img src="https://pic.downk.cc/item/5e1009ad76085c3289a7c42a.jpg" style="zoom:50%;"></p><p><img src="https://pic.downk.cc/item/5e1009d676085c3289a7c97d.jpg" style="zoom:50%;"></p><p><img src="https://pic.downk.cc/item/5e100a0e76085c3289a7d0b5.jpg" style="zoom:50%;"></p><p><img src="https://pic.downk.cc/item/5e100a2676085c3289a7d3f4.jpg" style="zoom:50%;"></p><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"theme":"#FADFA3","video":{"url":"http://upos-sz-mirrorks3.bilivideo.com/upgcxcode/32/93/197079332/197079332-1-192.mp4?e=ig8euxZM2rNcNbNVnWdVhwdlhbdHhwdVhoNvNC8BqJIzNbfq9rVEuxTEnE8L5F6VnEsSTx0vkX8fqJeYTj_lta53NCM=&uipk=5&nbs=1&deadline=1590906960&gen=playurl&os=ks3bv&oi=837395164&trid=4a2e06f6683148f198513c235f0a3082T&platform=html5&upsig=d01cff0465735d96414a6a8ef4f5c9cb&uparams=e,uipk,nbs,deadline,gen,os,oi,trid,platform&mid=580104086&orderid=0,1&logo=80000000"},"danmaku":{"id":"bilibili","api":"https://dplayer.moerats.com/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><hr><h4 id="798艺术街"><a href="#798艺术街" class="headerlink" title="798艺术街"></a>798艺术街</h4><p>艺术的天堂，很有感jio</p><p><img src="https://pic.downk.cc/item/5e100f0b76085c3289a8874c.jpg" style="zoom:50%;"></p><p><img src="https://pic.downk.cc/item/5e100f2476085c3289a88b21.jpg" style="zoom:50%;"></p><p><img src="https://pic.downk.cc/item/5e100f4076085c3289a8902f.jpg" style="zoom:50%;"></p><hr><p>PS: 还去了故宫、首都博物馆、电影博物馆、火车博物馆、北海公园等</p><p>下年，一定要去日本啊啊啊！！！</p><h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><p>舞蹈没学完···</p><p>画画学了一点点···</p><p>滑雪摔得狗吃屎···</p><p>感觉，我是与这些无缘了。学这些，进程很慢····</p><p>我还是会努力去学的，能不能成功，就看俺的天赋了，哈哈</p><h3 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h3><p>运动是不可少的，天气好，夏天和秋天，去奥森跑步，打篮球。</p><p>一切的计划，都必须有好的身体，因此，祝愿大家身体一定要好，多运动。</p><h3 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h3><p>额···，这个跳过吧，反正又没实现，这个爱情已经离我很远了，不敢奢求什么了，友谊都快没了，哈哈。</p><p>友谊没了，有点夸张了，只是大家现在都基本上工作了，平时交流的时间就会少很多了，都会有自己的事情了，不好去打扰，毕竟不打扰是我的温柔嘛，我还是比较喜欢独处的，大家就不要学我了，容易变成单身贵族的，哈哈。</p><p>下一年，继续喜欢gakki。</p><p><img src="https://pic.downk.cc/item/5e0c339876085c3289325f0b.jpg" alt></p><p>我老婆，美如画。</p><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>游戏，我都太遗忘了，lol已经不怎么玩了，平时喜欢玩一些单机的小游戏，魂斗罗、三国战纪、西游记等。</p><p>准备，买个ps 或者 switch 回家过年玩。</p><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>每周的计划，都在执行着。感觉，自己没啥优点，除了执行力还行，哈哈。</p><p><img src="https://pic.downk.cc/item/5e10142176085c3289a936ec.png" alt></p><h3 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h3><p>今年，电影界还是很厉害的。</p><h4 id="动漫"><a href="#动漫" class="headerlink" title="动漫"></a>动漫</h4><p>大圣归来，给国内的动漫开辟了先河，取得了巨大的成功；今年的《哪吒，魔童降世》已经把国内的动漫推向了顶峰了，我估计以后想打破这个记录估计很难了。</p><p>其实，今年的国漫，我还推荐一下：《白蛇·缘起》。这个，真的很遗憾，由于没有做宣传，新闻很少，让大家以为就是熟知的新白娘子的故事，其实是改编版的，讲得是前传的故事，许仙不再是书生，而是一个”捕蛇人”。</p><p>《白蛇·缘起》，从某种意义上推动了哪吒的成功。</p><p>还有我喜欢的新海诚电影：《天气之子》，诚哥又回到了他的风格，不再是君名的商业片，纯粹是两个年轻人为了自己的爱情的故事，从故事情节，确实不如你的名字，但是着就是新海诚。</p><p>《爱，死亡和机器人》：不多bb，去看就知道了。</p><h4 id="科幻"><a href="#科幻" class="headerlink" title="科幻"></a>科幻</h4><p>年初的《流浪地球》开启了国内的科幻片，虽然后期的煽情有点过分强求，但不得不说，还是很优良的制作，喜欢国内的科幻片越来越好吧。</p><p>今年是漫威粉的高潮了，最终战，合情合理，在意料之中，也有亮点。</p><p>希望，国内也有自己的宇宙世界就完美了。</p><h4 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h4><p>《少年的你》，两位年轻的主角，演技都很棒，对于我来说，挑不出刺，希望他们演技越来越好。</p><h4 id="番剧"><a href="#番剧" class="headerlink" title="番剧"></a>番剧</h4><p>《鬼灭之刃》：首推，打破了无敌海贼王的销量，你想想一下，这是多么恐怖的事情，13年《进击的巨人》横空出世也没有打破的记录呀。</p><p>是一部热血、燃到爆炸那种，男孩子不管多大，心中都还是会有一个手握长剑的翩翩少年。</p><p>《进击的巨人》</p><p>《青春猪头少年不会梦到怀梦美少女》 </p><p>《约定的梦幻岛》 </p><p>《多罗罗》 </p><p>《动物狂想曲 / BEASTARS》 </p><p>《高分少女》 </p><p>《五等分的花嫁》：推荐漫画，动漫就···</p><p>《辉夜大小姐想让我告白~<em>天才</em>们的恋爱头脑战~》：书记舞蹈，席卷整个年初。</p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>推荐大家看木鱼水心的视频：</p><p><a href="https://www.bilibili.com/video/av81552476" target="_blank" rel="noopener">映像2019</a></p><h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>阅读说来惭愧，看得书，大多数是技术书，和工作有关的书籍；本来也想着看一些其他书籍，一直被自己滞后，总说以后再看。唉，俺的惰性太强了，以后慢慢强迫自己改吧。</p><p>2020年，顺其自然，再坚持一下。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>今年虽然过得不顺人意，但也大致完成了去年的目标「让自己变得充实有趣起来」，希望 2020 自己能更加完美，努力去做到自己的目标，也祝愿大家越来越好。</p><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px; height:500px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"theme":"#FADFA3","loop":true,"video":{"url":"http://upos-sz-mirrorhw.bilivideo.com/upgcxcode/59/82/197078259/197078259-1-208.mp4?e=ig8euxZM2rNcNbhanWdVhwdlhzuHhwdVhoNvNC8BqJIzNbfq9rVEuxTEnE8L5F6VnEsSTx0vkX8fqJeYTj_lta53NCM=&uipk=5&nbs=1&deadline=1590907010&gen=playurl&os=hwbv&oi=837395164&trid=33e1469cf09b43999709f23aed0b7974T&platform=html5&upsig=a3f34d31febdc194081f109a08860c99&uparams=e,uipk,nbs,deadline,gen,os,oi,trid,platform&mid=580104086&orderid=0,1&logo=80000000","pic":"https://ae01.alicdn.com/kf/H4dd1264744c34187b8782de35fbed8d5s.jpg"},"danmaku":{"id":"my2019baibai","api":"https://dplayer.moerats.com/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 情感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jackson的进阶&lt;三&gt;</title>
      <link href="/2020/01/02/jackson-de-jin-jie-san/"/>
      <url>/2020/01/02/jackson-de-jin-jie-san/</url>
      
        <content type="html"><![CDATA[<p>使用jackson annotations简化和增强的json解析与生成。</p><p>Jackson-2.x通用annotations列表：<a href="https://github.com/FasterXML/jackson-annotations/wiki/Jackson-Annotations" target="_blank" rel="noopener">链接</a></p><p>Jackson-1.x通用annotations列表：<a href="http://wiki.fasterxml.com/JacksonAnnotations" target="_blank" rel="noopener">链接</a></p><hr><h3 id="Jackson-Annotations"><a href="#Jackson-Annotations" class="headerlink" title="Jackson - Annotations"></a>Jackson - Annotations</h3><p>想要了解更多内容，请查看annotations列表。下面只列出一些常用的Json注解。</p><ul><li><strong>@JsonProperty</strong></li></ul><p>它关联json字符串中的字段到java属性的映射。可以标记属性，也可以用来标记属性的getter/setter方法。当标记属性时，可以对属性字段重命名。当标记方法时，可以把json字段关联到java属性的getter或setter方法。</p><ul><li><strong>@JsonCreator</strong></li></ul><p>json反序列化为java对象时，该注解用于定义构造函数。当从json创建java时，@JsonCreator注解的构造函数被会调用，如果没有@JsonCreator注解，则默认调用java类的无参构造函数，此时，如果java类中只有有参构造函数，而无默认的无参构造函数，在反序列化时会抛出这样的异常：com.fasterxml.jackson.databind.JsonMappingException，所以，当我们不使用@JsonCreator指定反序列化的构造函数，而又在java类中重载了构造函数时，一定要记得编写类的无参构造函数。</p><ul><li><strong>@JsonAnyGetter</strong>和<strong>@JsonAnySetter</strong></li></ul><p>用于标记类方法，设置和读取json字段作为键值对存储到map中，这两个注解标记的方法不会处理任何java类中已经定义过的属性变量，只对java中未定义的json字段作处理。</p><ul><li><strong>@JsonIgnoreProperties</strong>和<strong>@JsonIgnore</strong></li></ul><p>用于标记属性，在json与java之间相互转化时，将忽略被此注解标记的属性。@JsonIgnoreProperties是类级别注解，可以忽略多个属性，@JsonIgnore用来标注单个属性。</p><ul><li><strong>@JsonTypeInfo</strong>和<strong>@JsonSubTypes</strong></li></ul><p>于维持java类的子类信息，将子类对象类型信息嵌入到json中，以便反序列化创建具体的对象。</p><hr><h3 id="JsonProperty"><a href="#JsonProperty" class="headerlink" title="@JsonProperty"></a>@JsonProperty</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>ANNOTATION_TYPE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>PARAMETER<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@JacksonAnnotation</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">JsonProperty</span> <span class="token punctuation">{</span>    String USE_DEFAULT_NAME <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> INDEX_UNKNOWN <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//更改json对应pojo的属性的别名</span>    <span class="token keyword">boolean</span> <span class="token function">required</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//是否是必须的属性</span>    <span class="token keyword">int</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//序列化的顺序</span>    String <span class="token function">defaultValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//json字符串中没有对应的属性时的默认值</span>    JsonProperty<span class="token punctuation">.</span>Access <span class="token function">access</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> JsonProperty<span class="token punctuation">.</span>Access<span class="token punctuation">.</span>AUTO<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">enum</span> Access <span class="token punctuation">{</span>        AUTO<span class="token punctuation">,</span>        READ_ONLY<span class="token punctuation">,</span>        WRITE_ONLY<span class="token punctuation">,</span>        READ_WRITE<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token function">Access</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>User:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> String name<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>        <span class="token keyword">private</span> String address<span class="token punctuation">;</span>        <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//省略set、get、无参构造函数</span><span class="token punctuation">}</span></code></pre><p>没使用注解之前：</p><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{\"name\":\"gakki\",\"age\":18,\"address\":\"东京\"}"</span><span class="token punctuation">;</span>        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>null<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"东京"</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><p>使用注解JsonProperty：value</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JsonProperty</span><span class="token punctuation">(</span><span class="token string">"MyName"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{\"MyName\":\"gakki\",\"address\":\"东京\",\"birthday\":\"2020-01-01\"}"</span><span class="token punctuation">;</span>        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">)</span><span class="token punctuation">;</span>        SimpleDateFormat dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span>dateFormat<span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Wed Jan <span class="token number">01</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2020</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"东京"</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2020-01-01"</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>注意：这里配置忽略不存在的属性：DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES，否则会出错，</p><p>而且name改成了MyName。</p><hr><p>一般，我只使用value来修改json字符串与pojo属性的名字的对应关系，该注解的其它属性使用的少，大家可以去尝试。</p><h3 id="JsonAlias"><a href="#JsonAlias" class="headerlink" title="@JsonAlias"></a>@JsonAlias</h3><p>别名。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AliasBean</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JsonAlias</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"fName"</span><span class="token punctuation">,</span> <span class="token string">"f_name"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String firstName<span class="token punctuation">;</span>       <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">    String json <span class="token operator">=</span> <span class="token string">"{\"fName\": \"John\", \"lastName\": \"Green\"}"</span><span class="token punctuation">;</span>    AliasBean aliasBean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readerFor</span><span class="token punctuation">(</span>AliasBean<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">,</span> aliasBean<span class="token punctuation">.</span><span class="token function">getFirstName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="JsonGetter"><a href="#JsonGetter" class="headerlink" title="@JsonGetter"></a>@JsonGetter</h3><p>该注解主要用来单独改变序列化的属性名称</p><p>作用在get方法上面</p><p>User:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JsonProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"MyName"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 省略get、set、toString方法</span> <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{\"MyName\":\"gakki\",\"xxxx\":\"yyyy\",\"birthday\":\"2020-01-01\"}"</span><span class="token punctuation">;</span>        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">)</span><span class="token punctuation">;</span>        SimpleDateFormat dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span>dateFormat<span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Wed Jan <span class="token number">01</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2020</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2020-01-01"</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>此时，序列化的属性名称，除了name改变了，其它的都没有改变，使用@JsonProperty是将反序列和序列化都改变了。</p><p>现在给address的get方法添加该注解：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@JsonGetter</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"myAddress"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAddress</span><span class="token punctuation">(</span>String address<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{\"MyName\":\"gakki\",\"xxxx\":\"yyyy\",\"address\":\"冲绳\",\"birthday\":\"2020-01-01\"}"</span><span class="token punctuation">;</span>        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">)</span><span class="token punctuation">;</span>        SimpleDateFormat dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span>dateFormat<span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Wed Jan <span class="token number">01</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2020</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2020-01-01"</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"myAddress"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><p>此时，address确实名称改成了myAddress了，但是反序列化的值没了？？？</p><p>需要添加：@JsonSetter注解了。</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@JsonGetter</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"myAddress"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@JsonSetter</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"address"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAddress</span><span class="token punctuation">(</span>String address<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Wed Jan <span class="token number">01</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2020</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2020-01-01"</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"myAddress"</span><span class="token operator">:</span><span class="token string">"冲绳"</span><span class="token punctuation">}</span></code></pre><h3 id="JsonSetter"><a href="#JsonSetter" class="headerlink" title="@JsonSetter"></a>@JsonSetter</h3><p>该注解用于反序列化时给属性命名</p><p>作用与：set方法上面。</p><p>上面已经给出了案例，就不演示了。</p><h3 id="JsonPropertyOrder"><a href="#JsonPropertyOrder" class="headerlink" title="@JsonPropertyOrder"></a>@JsonPropertyOrder</h3><p>定制序列化的顺序：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>ANNOTATION_TYPE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>CONSTRUCTOR<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@JacksonAnnotation</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">JsonPropertyOrder</span> <span class="token punctuation">{</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">alphabetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@JsonPropertyOrder</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"birthday"</span><span class="token punctuation">,</span><span class="token string">"myAddress"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>···<span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Wed Jan <span class="token number">01</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2020</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2020-01-01"</span><span class="token punctuation">,</span><span class="token string">"myAddress"</span><span class="token operator">:</span><span class="token string">"冲绳"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>看到，序列化的顺序，全部都是按照注解中的顺序来的。</p><p>注意：书写注解中的顺序时，如果属性名字改了，请换成改后的名称，例如这里的name，改成了MyName。</p><h3 id="JsonRawValue"><a href="#JsonRawValue" class="headerlink" title="@JsonRawValue"></a>@JsonRawValue</h3><p>该注解用于序列化时，原样输出。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JsonProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"MyName"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JsonRawValue</span>    <span class="token keyword">public</span> String json<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String json<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>json <span class="token operator">=</span> json<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"{\"name\":\"jacklove\"}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>null<span class="token punctuation">,</span> json<span class="token operator">=</span><span class="token string">'{"name":"jacklove"}'</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"birthday"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"myAddress"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"json"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"jacklove"</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里的json本身也是一个json对象字符串。</p><h3 id="JsonRootName"><a href="#JsonRootName" class="headerlink" title="@JsonRootName"></a>@JsonRootName</h3><p>给序列化后的字符串添加一个根名字：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@JsonRootName</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JsonProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"MyName"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">enable</span><span class="token punctuation">(</span>SerializationFeature<span class="token punctuation">.</span>INDENT_OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//序列化成漂亮的格式</span>        mapper<span class="token punctuation">.</span><span class="token function">enable</span><span class="token punctuation">(</span>SerializationFeature<span class="token punctuation">.</span>WRAP_ROOT_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//允许添加根名称</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"gakkij"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"冲绳"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakkij'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>null<span class="token punctuation">}</span><span class="token punctuation">{</span>  <span class="token string">"user"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"age"</span> <span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>    <span class="token string">"birthday"</span> <span class="token operator">:</span> null<span class="token punctuation">,</span>    <span class="token string">"MyName"</span> <span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>    <span class="token string">"myAddress"</span> <span class="token operator">:</span> <span class="token string">"冲绳"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="JsonIgnore"><a href="#JsonIgnore" class="headerlink" title="@JsonIgnore"></a>@JsonIgnore</h3><p>该注解用于忽略属性是否该序列化和反序列化。</p><p>可以修饰属性，也可以修饰set和get方法。</p><p>User:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JsonProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"MyName"</span><span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Wed Jan <span class="token number">01</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2020</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2020-01-01"</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>可以看出，address属性没有被反序列，而且也没有序列化。</p><hr><p>修改：get方法</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">public</span> String <span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAddress</span><span class="token punctuation">(</span>String address<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Wed Jan <span class="token number">01</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2020</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2020-01-01"</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>反序列化和序列化都忽略了。</p><hr><p>修饰：set方法</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//@JsonIgnore</span>    <span class="token keyword">public</span> String <span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAddress</span><span class="token punctuation">(</span>String address<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Wed Jan <span class="token number">01</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2020</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2020-01-01"</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>效果一样！！！</p><h3 id="JsonIgnoreProperties"><a href="#JsonIgnoreProperties" class="headerlink" title="@JsonIgnoreProperties"></a><strong>@JsonIgnoreProperties</strong></h3><p>该注解与<strong>@JsonIgnore</strong>类似，但是它是作用于类的。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>ANNOTATION_TYPE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>CONSTRUCTOR<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@JacksonAnnotation</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">JsonIgnoreProperties</span> <span class="token punctuation">{</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">ignoreUnknown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">allowGetters</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">allowSetters</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span></code></pre><p>User:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@JsonIgnoreProperties</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"MyName"</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JsonProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"MyName"</span><span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>null<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"东京"</span><span class="token punctuation">}</span></code></pre><hr><p>我们知道，当json串中有pojo没有匹配的属性时，就会报错！需要我们配置：</p><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//忽略不匹配的属性</span></code></pre><p>这样比较麻烦，我们可以使用：<strong>@JsonIgnoreProperties</strong>的<code>ignoreUnknown</code>为true来到达相同的效果：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@JsonIgnoreProperties</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"MyName"</span><span class="token punctuation">,</span> <span class="token string">"birthday"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> ignoreUnknown <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JsonProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"MyName"</span><span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{\"MyName\":\"gakki\",\"unknow\":\"unknow\",\"address\":\"东京\",\"birthday\":\"2020-01-01\"}"</span><span class="token punctuation">;</span>        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span>        SimpleDateFormat dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span>dateFormat<span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>null<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"东京"</span><span class="token punctuation">}</span></code></pre><p>现在添加了，unknown属性，依然没有报错！！！</p><hr><p>使用：allowGetters 和 allowSetters。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@JsonIgnoreProperties</span><span class="token punctuation">(</span>ignoreUnknown <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> allowGetters <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>····    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">public</span> String <span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAddress</span><span class="token punctuation">(</span>String address<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Wed Jan <span class="token number">01</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2020</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2020-01-01"</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@JsonIgnoreProperties</span><span class="token punctuation">(</span>ignoreUnknown <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> allowSetters <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>···    <span class="token comment" spellcheck="true">//@JsonIgnore</span>    <span class="token keyword">public</span> String <span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAddress</span><span class="token punctuation">(</span>String address<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Wed Jan <span class="token number">01</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2020</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2020-01-01"</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>一样的效果···</p><h3 id="JsonCreator"><a href="#JsonCreator" class="headerlink" title="@JsonCreator"></a><strong>@JsonCreator</strong></h3><p>User：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JsonProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"MyName"</span><span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>去掉了无参的构造函数</p><p>运行：</p><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span>exc<span class="token punctuation">.</span>InvalidDefinitionException<span class="token operator">:</span> Cannot construct instance of `com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>User` <span class="token punctuation">(</span>no Creators<span class="token punctuation">,</span> like <span class="token keyword">default</span> construct<span class="token punctuation">,</span> exist<span class="token punctuation">)</span><span class="token operator">:</span> cannot deserialize from Object <span class="token function">value</span> <span class="token punctuation">(</span>no delegate<span class="token operator">-</span> or property<span class="token operator">-</span>based Creator<span class="token punctuation">)</span> at <span class="token punctuation">[</span>Source<span class="token operator">:</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token string">"{"</span>MyName<span class="token string">":"</span>gakki<span class="token string">","</span>unknow<span class="token string">":"</span>unknow<span class="token string">","</span>address<span class="token string">":"</span>东京<span class="token string">","</span>birthday<span class="token string">":"</span><span class="token number">2020</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">01</span><span class="token string">"}"</span><span class="token punctuation">;</span> line<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> column<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">]</span></code></pre><p>报：没有无参的构造函数问题！</p><hr><p>修改：User</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@JsonIgnoreProperties</span><span class="token punctuation">(</span>ignoreUnknown <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JsonCreator</span>    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token annotation punctuation">@JsonProperty</span><span class="token punctuation">(</span><span class="token string">"MyName"</span><span class="token punctuation">)</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{\"MyName\":\"gakki\",\"unknow\":\"unknow\",\"address\":\"东京\",\"birthday\":\"2020-01-01\"}"</span><span class="token punctuation">;</span>        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span>        SimpleDateFormat dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span>dateFormat<span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Wed Jan <span class="token number">01</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2020</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"东京"</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2020-01-01"</span><span class="token punctuation">}</span></code></pre><hr><h3 id="JsonAnySetter"><a href="#JsonAnySetter" class="headerlink" title="@JsonAnySetter"></a><strong>@JsonAnySetter</strong></h3><p>User:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JsonProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"MyName"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JsonAnySetter</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> unknow <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{\"MyName\":\"gakki\",\"xxxx\":\"yyyy\",\"address\":\"东京\",\"birthday\":\"2020-01-01\"}"</span><span class="token punctuation">;</span>        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span>        SimpleDateFormat dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span>dateFormat<span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Wed Jan <span class="token number">01</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2020</span><span class="token punctuation">,</span> unknow<span class="token operator">=</span><span class="token punctuation">{</span>xxxx<span class="token operator">=</span>yyyy<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"东京"</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2020-01-01"</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>可以看到，即使我们没有配置：</p><ul><li>mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</li><li>@JsonIgnoreProperties( ignoreUnknown = true)</li></ul><p>也不会报错了，会把不匹配的属性放到使用@JsonAnySetter注解的map中。</p><font color="red">注意：这里的map请直接初始化，不需要添加get和set方法，否则会序列化出去的。</font><h3 id="JsonInclude"><a href="#JsonInclude" class="headerlink" title="@JsonInclude"></a><strong>@JsonInclude</strong></h3><p>例如：<strong>@JsonInclude(JsonInclude.Include.NON_NULL)</strong></p><p>这个注解表示，如果<strong>值为null，则不返回</strong>，还可以在类上添加这个注释，当实体类与json互相转换的时候，<strong>属性值为null的不参与序列化</strong>。</p><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{\"MyName\":\"gakki\",\"xxxx\":\"yyyy\",\"birthday\":\"2020-01-01\"}"</span><span class="token punctuation">;</span>        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span>        SimpleDateFormat dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span>dateFormat<span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Wed Jan <span class="token number">01</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2020</span><span class="token punctuation">,</span> unknow<span class="token operator">=</span><span class="token punctuation">{</span>xxxx<span class="token operator">=</span>yyyy<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2020-01-01"</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>此时，address为null也序列化出来了。</p><p>给address添加该注解后：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@JsonInclude</span><span class="token punctuation">(</span>JsonInclude<span class="token punctuation">.</span>Include<span class="token punctuation">.</span>NON_NULL<span class="token punctuation">)</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Wed Jan <span class="token number">01</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2020</span><span class="token punctuation">,</span> unknow<span class="token operator">=</span><span class="token punctuation">{</span>xxxx<span class="token operator">=</span>yyyy<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2020-01-01"</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>此时，address也为null，但是不再序列化出来了。</p><p>给age添加该注解后：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@JsonInclude</span><span class="token punctuation">(</span>JsonInclude<span class="token punctuation">.</span>Include<span class="token punctuation">.</span>NON_DEFAULT<span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Wed Jan <span class="token number">01</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2020</span><span class="token punctuation">,</span> unknow<span class="token operator">=</span><span class="token punctuation">{</span>xxxx<span class="token operator">=</span>yyyy<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2020-01-01"</span><span class="token punctuation">,</span><span class="token string">"MyName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>此时，age=0也不被序列化出来了。</p><p>Include是一个枚举类型：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">enum</span> Include <span class="token punctuation">{</span>        ALWAYS<span class="token punctuation">,</span>        NON_NULL<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 不序列化null值</span>        NON_ABSENT<span class="token punctuation">,</span>        NON_EMPTY<span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// null 和 "" 都不序列化</span>        NON_DEFAULT<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 不序列化默认值</span>        CUSTOM<span class="token punctuation">,</span>        USE_DEFAULTS<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token function">Include</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.baeldung.com/jackson-annotations" target="_blank" rel="noopener">jackson的注解使用</a></p>]]></content>
      
      
      <categories>
          
          <category> Jackson </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jackson的进阶&lt;二&gt;</title>
      <link href="/2019/12/29/jackson-de-jin-jie-er/"/>
      <url>/2019/12/29/jackson-de-jin-jie-er/</url>
      
        <content type="html"><![CDATA[<h3 id="readValue"><a href="#readValue" class="headerlink" title="readValue"></a>readValue</h3><h4 id="POJO对象"><a href="#POJO对象" class="headerlink" title="POJO对象"></a>POJO对象</h4><p>User：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//省略get、set、toString方法   </span> <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> <span class="token string">"{'name':'gakkij','age':18}"</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行：</p><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>core<span class="token punctuation">.</span>JsonParseException<span class="token operator">:</span> Unexpected <span class="token function">character</span> <span class="token punctuation">(</span><span class="token string">''</span>' <span class="token punctuation">(</span>code <span class="token number">39</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span> was expecting <span class="token keyword">double</span><span class="token operator">-</span>quote to start field name at <span class="token punctuation">[</span>Source<span class="token operator">:</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token string">"{'name':'gakkij','age':18}"</span><span class="token punctuation">;</span> line<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> column<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">]</span></code></pre><p>报错：因为好像Jackson的json字符串必须要符合标准的形式，字符串中的key、vlaue如果是String类型，必须是双引号！！！</p><p>之前，我们使用Gson或FastJson时，因为不想写转义符：<code>\</code>，因此都是使用单引号来表示字符串的。</p><p>Jackson必须使用双引号：</p><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> <span class="token string">"{\"name\":\"gakkij\",\"age\":18}"</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakkij'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">}</span></code></pre><hr><p>当反序列化的字符串中有POJO中不存在的属性时：</p><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> <span class="token string">"{\"name\":\"gakkij\",\"age\":18,\"address\":\"东京\"}"</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里，添加了address的key，但是User中是没有address的属性的。</p><p>运行后：</p><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span>exc<span class="token punctuation">.</span>UnrecognizedPropertyException<span class="token operator">:</span> Unrecognized field <span class="token string">"address"</span> <span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token class-name">com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>User</span><span class="token punctuation">)</span><span class="token punctuation">,</span> not marked as <span class="token function">ignorable</span> <span class="token punctuation">(</span><span class="token number">2</span> known properties<span class="token operator">:</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> at <span class="token punctuation">[</span>Source<span class="token operator">:</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token string">"{"</span>name<span class="token string">":"</span>gakkij<span class="token string">","</span>age<span class="token string">":18,"</span>address<span class="token string">":"</span>东京<span class="token string">"}"</span><span class="token punctuation">;</span> line<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> column<span class="token operator">:</span> <span class="token number">38</span><span class="token punctuation">]</span> <span class="token punctuation">(</span>through reference chain<span class="token operator">:</span> com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>User<span class="token punctuation">[</span><span class="token string">"address"</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>出现，不能解析address属性的异常！！！</p><p>这里，我们需要配置mapper的特性，来控制当出现无法解析的属性时，不需要抛出异常！</p><ul><li><p><code>mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</code></p></li><li><p><code>mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);</code></p></li></ul><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span>        mapper<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//和上面等价</span>        String json <span class="token operator">=</span> <span class="token string">"{\"name\":\"gakkij\",\"age\":18,\"address\":\"东京\"}"</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h4 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h4><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> <span class="token string">"[{\"name\":\"gakkij\",\"age\":18,\"address\":\"东京\"},{\"name\":\"jackLove\",\"age\":20,\"address\":\"冲绳\"}]"</span><span class="token punctuation">;</span>        List list <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> List<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User<span class="token punctuation">[</span><span class="token punctuation">]</span> users <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token punctuation">{</span>name<span class="token operator">=</span>gakkij<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span>东京<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token operator">=</span>jackLove<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> address<span class="token operator">=</span>冲绳<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">[</span>Lcom<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token annotation punctuation">@91161c7</span></code></pre><p>这里看来没有问题，当我们使用带有泛型的List集合呢？</p><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> <span class="token string">"[{\"name\":\"gakkij\",\"age\":18,\"address\":\"东京\"},{\"name\":\"jackLove\",\"age\":20,\"address\":\"冲绳\"}]"</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> userList <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> List<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token punctuation">{</span>name<span class="token operator">=</span>gakkij<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span>东京<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token operator">=</span>jackLove<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> address<span class="token operator">=</span>冲绳<span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><p>看似没有出错，但是你们注意到了吗？此时的User对象居然打印出了address！！！颠覆了我们的认知，我们的User对象里面是没有address属性的。</p><pre class=" language-java"><code class="language-java">        List<span class="token operator">&lt;</span>User<span class="token operator">></span> userList <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> List<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>user <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当我们遍历List集合来打印时，问题就出来了：</p><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassCastException<span class="token operator">:</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedHashMap cannot be cast to com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>User    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>ArrayList<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1257</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>jacksonDataBindTest02<span class="token punctuation">.</span><span class="token function">testDataBindListPOJO2</span><span class="token punctuation">(</span>jacksonDataBindTest02<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">48</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>jacksonDataBindTest02<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>jacksonDataBindTest02<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">59</span><span class="token punctuation">)</span></code></pre><p>说明，此时<code>List&lt;user&gt;</code>根本不是我们想象中的<code>List&lt;User&gt;</code>。</p><p><strong>带泛型的集合，必须使用：</strong></p><ul><li>objectMapper.getTypeFactory().constructParametricType(collectionClass, elementClasses);</li><li>TypeReference&lt;&gt;的子类</li></ul><p>1）使用：constructParametricType</p><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> <span class="token string">"[{\"name\":\"gakkij\",\"age\":18,\"address\":\"东京\"},{\"name\":\"jackLove\",\"age\":20,\"address\":\"冲绳\"}]"</span><span class="token punctuation">;</span>        JavaType javaType <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">getTypeFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">constructParametricType</span><span class="token punctuation">(</span>List<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> userList <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> javaType<span class="token punctuation">)</span><span class="token punctuation">;</span>        userList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>user <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>2）使用：TypeReference&lt;&gt;的子类</p><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> <span class="token string">"[{\"name\":\"gakkij\",\"age\":18,\"address\":\"东京\"},{\"name\":\"jackLove\",\"age\":20,\"address\":\"冲绳\"}]"</span><span class="token punctuation">;</span>        TypeReference<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>User<span class="token operator">>></span> type <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TypeReference</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>User<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> userList <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>        userList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>user <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakkij'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">}</span>User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'jackLove'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">[</span>User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakkij'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">,</span> User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'jackLove'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><hr><h4 id="Map类型"><a href="#Map类型" class="headerlink" title="Map类型"></a>Map类型</h4><p>1）不带泛型的Map解析</p><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> <span class="token string">"{\"a\":\"1\",\"b\":2,\"c\":true}"</span><span class="token punctuation">;</span>        Map map <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> Map<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> <span class="token string">"{\"a\":\"1\",\"b\":2,\"c\":true}"</span><span class="token punctuation">;</span>        Map map <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> Map<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object a <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object b <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object c <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String</span><span class="token number">1</span><span class="token keyword">class</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Integer</span><span class="token number">2</span><span class="token keyword">class</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Boolean</span><span class="token boolean">true</span><span class="token punctuation">{</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><p>2）带泛型的Map解析</p><ul><li><p>mapper.getTypeFactory().constructParametricType(MapClass, keyClass, valueClass)</p></li><li><p>new TypeReference&lt;&gt;() {}</p></li></ul><p>方法一：</p><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> <span class="token string">"{\"a\":\"1\",\"b\":2,\"c\":true}"</span><span class="token punctuation">;</span>        JavaType javaType <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">getTypeFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">constructParametricType</span><span class="token punctuation">(</span>HashMap<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> javaType<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object a <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object b <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object c <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String</span><span class="token number">1</span><span class="token keyword">class</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String</span><span class="token number">2</span><span class="token keyword">class</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String</span><span class="token boolean">true</span><span class="token punctuation">{</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><p>此时，都是Map中的key和value都是字符串类型。</p><hr><p>方法二：</p><pre class=" language-java"><code class="language-java">        TypeReference<span class="token operator">&lt;</span>HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> type <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TypeReference</span><span class="token operator">&lt;</span>HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Jackson处理一般的JavaBean和Json之间的转换只要使用ObjectMapper 对象的<strong>readValue</strong>和<strong>writeValueAsString</strong>两个方法就能实现。</p><p>但是如果要转换复杂类型Collection如<code>List&lt;YourBean&gt;</code>，那么就需要先反序列化复杂类型为泛型的Collection Type。</p><p>如果是<code>ArrayList&lt;YourBean&gt;</code>那么使用ObjectMapper 的getTypeFactory().constructParametricType(collectionClass, yourBean.class);</p><p>如果是<code>HashMap&lt;String,YourBean&gt;</code>那么 ObjectMapper 的getTypeFactory().constructParametricType(MapClass,String.class, YourBean.class);</p><p>带泛型的 List  和 Map ，也可以统一使用：new TypeReference&lt;&gt;() {}的子类来实现。</p><p>例如：<code>new TypeReference&lt;List&lt;youBean&gt;(){}</code>  和  <code>new TypeReference&lt;HashMap&lt;String,youBean&gt;(){}</code></p><hr><h3 id="writeValue"><a href="#writeValue" class="headerlink" title="writeValue"></a>writeValue</h3><h4 id="默认序列化："><a href="#默认序列化：" class="headerlink" title="默认序列化："></a>默认序列化：</h4><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"gakki"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsBytes</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>B<span class="token annotation punctuation">@2669b199</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">}</span></code></pre><p>当POJO对象中存在null值时：</p><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"jacklove"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"jacklove"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">}</span></code></pre><p>这里因为，age是基本类型int，有默认值：0。</p><hr><p>User：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//多加一个引用属性</span>    ···<span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"jacklove"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><p><strong>Jackson默认是会帮我们序列化null的属性值的，Gson和FastJson默认是不会帮我们序列化null值！</strong></p><h4 id="不序列化null"><a href="#不序列化null" class="headerlink" title="不序列化null"></a>不序列化null</h4><p>不想序列化null值呢？使用如下配置：</p><pre class=" language-java"><code class="language-java">mapper<span class="token punctuation">.</span><span class="token function">setDefaultPropertyInclusion</span><span class="token punctuation">(</span>JsonInclude<span class="token punctuation">.</span>Include<span class="token punctuation">.</span>NON_NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>mapper<span class="token punctuation">.</span><span class="token function">setSerializationInclusion</span><span class="token punctuation">(</span>JsonInclude<span class="token punctuation">.</span>Include<span class="token punctuation">.</span>NON_NULL<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置属性特性，不包括null的值</span>        mapper<span class="token punctuation">.</span><span class="token function">setDefaultPropertyInclusion</span><span class="token punctuation">(</span>JsonInclude<span class="token punctuation">.</span>Include<span class="token punctuation">.</span>NON_NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"jacklove"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"jacklove"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">}</span></code></pre><hr><p>Incluede的参数配置：</p><pre class=" language-java"><code class="language-java">Include<span class="token punctuation">.</span>Include<span class="token punctuation">.</span>ALWAYS 默认   Include<span class="token punctuation">.</span>NON_DEFAULT 属性为默认值不序列化   Include<span class="token punctuation">.</span>NON_EMPTY 属性为 空（<span class="token string">""</span>） 或者为 null 都不序列化   Include<span class="token punctuation">.</span>NON_NULL 属性为NULL 不序列化  </code></pre><hr><h4 id="日期格式化："><a href="#日期格式化：" class="headerlink" title="日期格式化："></a>日期格式化：</h4><p>User</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//添加一个时间类型</span>    ···   <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">setSerializationInclusion</span><span class="token punctuation">(</span>JsonInclude<span class="token punctuation">.</span>Include<span class="token punctuation">.</span>NON_DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"jacklove"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setBirthday</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//日期默认序列化为时间戳，不够友好。</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"jacklove"</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token number">1577606398838</span><span class="token punctuation">}</span></code></pre><hr><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">setSerializationInclusion</span><span class="token punctuation">(</span>JsonInclude<span class="token punctuation">.</span>Include<span class="token punctuation">.</span>NON_DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>        SimpleDateFormat dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置日期的格式</span>        mapper<span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span>dateFormat<span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"jacklove"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setBirthday</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//日期默认序列化为时间戳，不够友好。</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"jacklove"</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2019-12-29"</span><span class="token punctuation">}</span></code></pre><h4 id="格式化序列化"><a href="#格式化序列化" class="headerlink" title="格式化序列化"></a>格式化序列化</h4><p>将序列化后的字符串以人为友好的形式：</p><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SimpleDateFormat dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span>dateFormat<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//友好的形式</span>        mapper<span class="token punctuation">.</span><span class="token function">enable</span><span class="token punctuation">(</span>SerializationFeature<span class="token punctuation">.</span>INDENT_OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"jacklove"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setBirthday</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//日期默认序列化为时间戳，不够友好。</span>        String userStr <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"name"</span> <span class="token operator">:</span> <span class="token string">"jacklove"</span><span class="token punctuation">,</span>  <span class="token string">"age"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token string">"address"</span> <span class="token operator">:</span> null<span class="token punctuation">,</span>  <span class="token string">"birthday"</span> <span class="token operator">:</span> <span class="token string">"2019-12-29"</span><span class="token punctuation">}</span></code></pre><hr><h3 id="readTree"><a href="#readTree" class="headerlink" title="readTree"></a>readTree</h3><p>1）使用：mapper.readTree();  //构建JsonNode</p><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"gakki"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//根节点</span>        JsonNode jsonNode <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readTree</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jsonNode<span class="token punctuation">.</span><span class="token function">getNodeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jsonNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> name <span class="token operator">=</span> jsonNode<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonNode name1 <span class="token operator">=</span> jsonNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jsonNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jsonNode<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//虽然addrss为null，但是返回true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jsonNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//address存在，但是值为null</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jsonNode<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">"notExit"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不存在，返回false</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jsonNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"notExit"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回null，是本身不存在，返回null</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span>null<span class="token punctuation">}</span>OBJECT<span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span>null<span class="token punctuation">}</span><span class="token boolean">true</span><span class="token string">"gakki"</span><span class="token number">18</span><span class="token boolean">true</span>null<span class="token boolean">false</span>null</code></pre><p>2）使用JsonNodeFactory来创建ObjectNode和ArrayNode节点</p><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonNodeFactory nodeFactory <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">getNodeFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectNode objNode <span class="token operator">=</span> nodeFactory<span class="token punctuation">.</span><span class="token function">objectNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        objNode<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"gakki"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        objNode<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectNode boyfriend <span class="token operator">=</span> objNode<span class="token punctuation">.</span><span class="token function">putObject</span><span class="token punctuation">(</span><span class="token string">"boyfriend"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "boyfriend":{</span>        boyfriend<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"liuzhuo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        boyfriend<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ArrayNode hobby <span class="token operator">=</span> objNode<span class="token punctuation">.</span><span class="token function">putArray</span><span class="token punctuation">(</span><span class="token string">"hobby"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "hobby":[</span>        hobby<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"看电影"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hobby<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"爬山"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hobby<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"游泳"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hobby<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"读书"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String value <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>objNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"boyfriend"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"liuzhuo"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"hobby"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"看电影"</span><span class="token punctuation">,</span><span class="token string">"爬山"</span><span class="token punctuation">,</span><span class="token string">"游泳"</span><span class="token punctuation">,</span><span class="token string">"读书"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>平时一般使用readValue，将json字符串反序列化为POJO对象，注意，json字符串有多余的属性默认会报错，必须配置：<code>mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)</code>。POJO的属性如果要反序列化成功，要么使用public修饰，要么配上相应的get和set方法。</li><li>readValue带泛型的POJO：方法一：TypeReference&lt;&gt;的子类，方法二：mapper.getTypeFactory().constructParametricType(collectionClass, yourBean.class);</li><li>writerValue: 序列化POJO对象，默认会序列化值为null、空字符串等，想去掉使用：<code>mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</code></li><li>readTree：是比较底层的用法了，更加灵活一些，可以自己组建要序列化的JsonNode。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Jackson </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jackson的进阶&lt;一&gt;</title>
      <link href="/2019/12/29/jackson-de-jin-jie-yi/"/>
      <url>/2019/12/29/jackson-de-jin-jie-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="处理Json"><a href="#处理Json" class="headerlink" title="处理Json"></a>处理Json</h3><p>Jackson提供了三种可选的Json处理方法：流式API(Streaming API) 、树模型(Tree Model)、数据绑定(Data Binding)。三种处理Json的方式的特性：</p><ul><li>Streaming API：是效率最高的处理方式(开销低、读写速度快，但程序编写复杂度高) </li><li>Tree Model：是最灵活的处理方式</li><li>Data Binding：是最常用的处理方式</li></ul><hr><p>Tree Model 和 Data Binding 的底层都是使用：Streaming API 来完成的，就是Streaming API的编程特别麻烦，通过之前的文章也体会到， 主要使用：JsonGenerator 和 JsonParser 来操作。</p><pre class=" language-java"><code class="language-java">JsonFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>JsonGenerator jsonGenerator <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createGenerator</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">,</span> JsonEncoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">)</span><span class="token punctuation">;</span>JsonParser parser <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createParser</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="https://pic.downk.cc/item/5e0821b876085c32893142f6.jpg" alt></p><p>可以看到：createGenerator主要有6中重载方法。</p><p>File、DataOutput、OutputStream、Writer。</p><p>解析后的文件，可以存储到文件File中，也可以解析到输出流中或控制台中。</p><hr><p><img src="https://pic.downk.cc/item/5e0822ba76085c3289317095.jpg" alt></p><p>可以看到：createParser主要有10中重载的方法。</p><p>分别从，字符串、文件、URL、reader，byte数组、DataInput、char[]、InputStream等</p><hr><h4 id="jsonGenerator"><a href="#jsonGenerator" class="headerlink" title="jsonGenerator"></a>jsonGenerator</h4><p>主要通过各种writerXXX方法来序列化：</p><pre class=" language-java"><code class="language-java">        jsonGenerator <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createGenerator</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">,</span> JsonEncoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">)</span><span class="token punctuation">;</span>        String str <span class="token operator">=</span> <span class="token string">"hello,world!jackson!"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出字符串</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeString</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 输出字节</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeBinary</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 输出布尔型</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeBoolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// null</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 输出字符型</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeNumber</span><span class="token punctuation">(</span><span class="token number">2.2f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用Raw方法会执行字符中的特殊字符</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeRaw</span><span class="token punctuation">(</span><span class="token string">"\tc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 输出换行符</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeRaw</span><span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出构造的pojo对象</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeStartObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeObjectField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"gakki"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeObjectField</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeObjectField</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">,</span> <span class="token string">"冲绳岛"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeEndObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//注意这里必须关闭，否则不会输出。</span></code></pre><font color="red"><strong>注意：使用工厂创建的jsonGenerator，注意序列化自己构造的POJO对象，不能直接使用：jsonGenerator.writeObject(new User()) ,这里会出现错误！！！</strong></font><p>必须使用：</p><pre class=" language-java"><code class="language-java"> ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonGenerator jsonGenerator <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">getJsonFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createJsonGenerator</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">,</span> JsonEncoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述方法已经过期了，建议我们序列化POJO对象，直接使用objectMapper的各种wirterValue方法：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 第一个参数：File、OutputStream、JsonGenerator、Writer等，第二个参数：需要序列化的对象。      </span>mapper<span class="token punctuation">.</span><span class="token function">writeValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  mapper<span class="token punctuation">.</span><span class="token function">writeValueAsBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//序列化为byte[]数组</span>mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//序列化为String字符串</span></code></pre><h4 id="jsonParser"><a href="#jsonParser" class="headerlink" title="jsonParser"></a>jsonParser</h4><p>jsonParser的各种，nextToken、getXXX来反序列化</p><pre class=" language-java"><code class="language-java">JsonParser parser <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createParser</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>parser<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>parser<span class="token punctuation">.</span><span class="token function">getIntValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>和解析XML文件一样，比较繁琐，需要判断当前的：JsonToken 类型来做出处理。</p><p>JsonToken的类型：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> JsonToken <span class="token punctuation">{</span>    <span class="token function">NOT_AVAILABLE</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>null<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">START_OBJECT</span><span class="token punctuation">(</span><span class="token string">"{"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">END_OBJECT</span><span class="token punctuation">(</span><span class="token string">"}"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">START_ARRAY</span><span class="token punctuation">(</span><span class="token string">"["</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">END_ARRAY</span><span class="token punctuation">(</span><span class="token string">"]"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">FIELD_NAME</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>null<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">VALUE_EMBEDDED_OBJECT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>null<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">VALUE_STRING</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>null<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">VALUE_NUMBER_INT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>null<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">VALUE_NUMBER_FLOAT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>null<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">VALUE_TRUE</span><span class="token punctuation">(</span><span class="token string">"true"</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">VALUE_FALSE</span><span class="token punctuation">(</span><span class="token string">"false"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">VALUE_NULL</span><span class="token punctuation">(</span><span class="token string">"null"</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ····<span class="token punctuation">}</span></code></pre><h4 id="TreeModel"><a href="#TreeModel" class="headerlink" title="TreeModel"></a>TreeModel</h4><p>1）TreeModel的序列化：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建一个节点工厂,为我们提供所有节点</span>JsonNodeFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonNodeFactory</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// "{"</span>ObjectNode objNode <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">objectNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>objNode<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"country_id"</span><span class="token punctuation">,</span> <span class="token string">"China"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>objNode<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"birthDate"</span><span class="token punctuation">,</span> <span class="token string">"1949-10-01"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在Java中，List和Array转化为json后对应的格式符号都是"obj:[]"</span>ArrayNode arrayNode <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">arrayNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>arrayNode<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Han"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Meng"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Hui"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"WeiWuEr"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Zang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>objNode<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"nation"</span><span class="token punctuation">,</span> nation<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建一个json factory来写tree modle为json</span>JsonFactory jsonFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建一个json生成器</span>JsonGenerator generator <span class="token operator">=</span> jsonFactory<span class="token punctuation">.</span><span class="token function">createGenerator</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"country.json"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//注意，默认情况下对象映射器不会指定根节点，下面设根节点为country</span>ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mapper<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>SerializationFeature<span class="token punctuation">.</span>INDENT_OUTPUT<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mapper<span class="token punctuation">.</span><span class="token function">writeTree</span><span class="token punctuation">(</span>generator<span class="token punctuation">,</span> objNode<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>2）TreeModel的反序列化：</p><pre class=" language-java"><code class="language-java">ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Jackson提供一个树节点被称为"JsonNode",ObjectMapper提供方法来读json作为树的JsonNode根节点</span>JsonNode node <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readTree</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"country.json"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// as.Text的作用是有值返回值，无值返回空字符串</span>JsonNode country_id <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"country_id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"country_id:"</span><span class="token operator">+</span>country_id<span class="token punctuation">.</span><span class="token function">asText</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" JsonNodeType:"</span><span class="token operator">+</span>country_id<span class="token punctuation">.</span><span class="token function">getNodeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>JsonNode nation <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"nation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"nation:"</span><span class="token operator">+</span> nation<span class="token operator">+</span> <span class="token string">" JsonNodeType:"</span><span class="token operator">+</span>nation<span class="token punctuation">.</span><span class="token function">getNodeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>PS: 当node不存在时,get方法返回null,而path返回MISSING类型的JsonNode</p><pre class=" language-java"><code class="language-java">        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonNode node <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readTree</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"country.json"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//path方法获取JsonNode时，当对象不存在时，返回MISSING类型的JsonNode</span>        JsonNode missingNode <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>missingNode<span class="token punctuation">.</span><span class="token function">isMissingNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"JsonNodeType : "</span> <span class="token operator">+</span> missingNode<span class="token punctuation">.</span><span class="token function">getNodeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><hr><h3 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h3><p>这是jackson最常用的方法，即：使用 ObjectMapper。</p><p>1）java对象转化成json:</p><p>Province.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Province</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> population<span class="token punctuation">;</span>    <span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> city<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>Country.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Country</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注意：被序列化的bean的private属性字段需要创建getter方法或者属性字段应该为public</span>    <span class="token keyword">private</span> String country_id<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthDate<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> nation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> lakes<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Province<span class="token operator">></span> provinces <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Province<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> traffic <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//省略：set、get、toString方法</span><span class="token punctuation">}</span></code></pre><p>main：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaBeanSerializeToJson</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">convert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用ObjectMapper来转化对象为Json</span>        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 添加功能，让时间格式更具有可读性</span>        SimpleDateFormat dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span>dateFormat<span class="token punctuation">)</span><span class="token punctuation">;</span>        Country country <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Country</span><span class="token punctuation">(</span><span class="token string">"China"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        country<span class="token punctuation">.</span><span class="token function">setBirthDate</span><span class="token punctuation">(</span>dateFormat<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"1949-10-01"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        country<span class="token punctuation">.</span><span class="token function">setLakes</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token string">"Qinghai Lake"</span><span class="token punctuation">,</span> <span class="token string">"Poyang Lake"</span><span class="token punctuation">,</span>                <span class="token string">"Dongting Lake"</span><span class="token punctuation">,</span> <span class="token string">"Taihu Lake"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> nation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nation<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Han"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nation<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Meng"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nation<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Hui"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nation<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"WeiWuEr"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nation<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Zang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        country<span class="token punctuation">.</span><span class="token function">setNation</span><span class="token punctuation">(</span>nation<span class="token punctuation">)</span><span class="token punctuation">;</span>        Province province <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Province</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        province<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Shanxi"</span><span class="token punctuation">;</span>        province<span class="token punctuation">.</span>population <span class="token operator">=</span> <span class="token number">37751200</span><span class="token punctuation">;</span>        Province province2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Province</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        province2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"ZheJiang"</span><span class="token punctuation">;</span>        province2<span class="token punctuation">.</span>population <span class="token operator">=</span> <span class="token number">55080000</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Province<span class="token operator">></span> provinces <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Province<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        provinces<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>province<span class="token punctuation">)</span><span class="token punctuation">;</span>        provinces<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>province2<span class="token punctuation">)</span><span class="token punctuation">;</span>        country<span class="token punctuation">.</span><span class="token function">setProvinces</span><span class="token punctuation">(</span>provinces<span class="token punctuation">)</span><span class="token punctuation">;</span>        country<span class="token punctuation">.</span><span class="token function">addTraffic</span><span class="token punctuation">(</span><span class="token string">"Train(KM)"</span><span class="token punctuation">,</span> <span class="token number">112000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        country<span class="token punctuation">.</span><span class="token function">addTraffic</span><span class="token punctuation">(</span><span class="token string">"HighWay(KM)"</span><span class="token punctuation">,</span> <span class="token number">4240000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为了使JSON视觉上的可读性，增加一行如下代码，注意，在生产中不需要这样，因为这样会增大Json的内容</span>        mapper<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>SerializationFeature<span class="token punctuation">.</span>INDENT_OUTPUT<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 配置mapper忽略空属性</span>        mapper<span class="token punctuation">.</span><span class="token function">setSerializationInclusion</span><span class="token punctuation">(</span>Include<span class="token punctuation">.</span>NON_EMPTY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 默认情况，Jackson使用Java属性字段名称作为 Json的属性名称,也可以使用Jackson annotations(注解)改变Json属性名称</span>        mapper<span class="token punctuation">.</span><span class="token function">writeValue</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"country.json"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> country<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token function">convert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"country_id"</span> <span class="token operator">:</span> <span class="token string">"China"</span><span class="token punctuation">,</span>  <span class="token string">"birthDate"</span> <span class="token operator">:</span> <span class="token string">"1949-10-01"</span><span class="token punctuation">,</span>  <span class="token string">"nation"</span> <span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token string">"Han"</span><span class="token punctuation">,</span> <span class="token string">"Meng"</span><span class="token punctuation">,</span> <span class="token string">"Hui"</span><span class="token punctuation">,</span> <span class="token string">"WeiWuEr"</span><span class="token punctuation">,</span> <span class="token string">"Zang"</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">"lakes"</span> <span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token string">"Qinghai Lake"</span><span class="token punctuation">,</span> <span class="token string">"Poyang Lake"</span><span class="token punctuation">,</span> <span class="token string">"Dongting Lake"</span><span class="token punctuation">,</span> <span class="token string">"Taihu Lake"</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">"provinces"</span> <span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token punctuation">{</span>    <span class="token string">"name"</span> <span class="token operator">:</span> <span class="token string">"Shanxi"</span><span class="token punctuation">,</span>    <span class="token string">"population"</span> <span class="token operator">:</span> <span class="token number">37751200</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token string">"name"</span> <span class="token operator">:</span> <span class="token string">"ZheJiang"</span><span class="token punctuation">,</span>    <span class="token string">"population"</span> <span class="token operator">:</span> <span class="token number">55080000</span>  <span class="token punctuation">}</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">"traffic"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token string">"HighWay(KM)"</span> <span class="token operator">:</span> <span class="token number">4240000</span><span class="token punctuation">,</span>    <span class="token string">"Train(KM)"</span> <span class="token operator">:</span> <span class="token number">112000</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2）Json字符串反序列化为java对象：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JsonDeserializeToJava</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//ObjectMapper类用序列化与反序列化映射器</span>        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        File json <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"country.json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//当反序列化json时，未知属性会引起的反序列化被打断，这里我们禁用未知属性打断反序列化功能，</span>        <span class="token comment" spellcheck="true">//因为，例如json里有10个属性，而我们的bean中只定义了2个属性，其它8个属性将被忽略</span>        mapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从json映射到java对象，得到country对象后就可以遍历查找,下面遍历部分内容，能说明问题就可以了</span>        Country country <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> Country<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"country_id:"</span><span class="token operator">+</span>country<span class="token punctuation">.</span><span class="token function">getCountry_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置时间格式，便于阅读</span>        SimpleDateFormat dateformat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String birthDate <span class="token operator">=</span> dateformat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>country<span class="token punctuation">.</span><span class="token function">getBirthDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"birthDate:"</span><span class="token operator">+</span>birthDate<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Province<span class="token operator">></span> provinces <span class="token operator">=</span> country<span class="token punctuation">.</span><span class="token function">getProvinces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Province province <span class="token operator">:</span> provinces<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"province:"</span><span class="token operator">+</span>province<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"\n"</span> <span class="token operator">+</span> <span class="token string">"population:"</span><span class="token operator">+</span>province<span class="token punctuation">.</span>population<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">country_id<span class="token operator">:</span>ChinabirthDate<span class="token operator">:</span><span class="token number">1949</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span>province<span class="token operator">:</span>Shanxipopulation<span class="token operator">:</span><span class="token number">37751200</span>province<span class="token operator">:</span>ZheJiangpopulation<span class="token operator">:</span><span class="token number">55080000</span></code></pre><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1）Stream API方式是开销最低、效率最高，但编写代码复杂度也最高，在生成Json时，需要逐步编写符号和字段拼接json,在解析Json时，需要根据token指向也查找json值，生成和解析json都不是很方便，代码可读性也很低。</p><p>2）TreeModel处理Json，是以树型结构来生成和解析json，生成json时，根据json内容结构，我们创建不同类型的节点对象，组装这些节点生成json。解析json时，它不需要绑定json到java bean，根据json结构，使用path或get方法轻松查找内容。</p><p>3）Databinding处理Json是最常用的json处理方式，生成json时，创建相关的java对象，并根据json内容结构把java对象组装起来，最后调用writeValue方法即可生成json,解析时，就更简单了，直接把json映射到相关的java对象，然后就可以遍历java对象来获取值了。</p>]]></content>
      
      
      <categories>
          
          <category> Jackson </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jackson的使用</title>
      <link href="/2019/12/28/jackson-de-shi-yong/"/>
      <url>/2019/12/28/jackson-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>Json已经成为当前服务器与 WEB 应用之间数据传输的公认标准。Java 中常见的 Json 类库有 <strong>JSON-lib 、Gson、FastJson和 Jackson </strong>等。相比于其他的解析工具，Jackson 简单易用，不依赖于外部jar 包，而且更新速度比较快。其也是 SpringMVC 框架 json 格式化输出的默认实现。</p><hr><h3 id="jackson的版本"><a href="#jackson的版本" class="headerlink" title="jackson的版本"></a>jackson的版本</h3><ul><li>codehaus</li><li>fasterxml</li></ul><p>他们是 Jackson 的两大分支。从 2.0 版本开始，Jackson 开始改用新的包名 <code>com.fasterxml.jackson</code>；其源代码也托管到了 Github(<a href="https://github.com/FasterXML/jackson" target="_blank" rel="noopener">FasterXML/Jackson</a>)。1.x 版本现在只提供 bug-fix 。另外版本 1 和版本 2 的 <code>artifactId</code> 也不相同。 在使用的过程中需要注意！</p><h3 id="fasterxml"><a href="#fasterxml" class="headerlink" title="fasterxml"></a>fasterxml</h3><p>Jackson 主要有三部分组成，除了三个模块之间存在依赖，不依赖任何外部 jar 包。三个模块的 作用及 <code>artifactId</code> 如下：</p><ul><li><code>jackson-core</code>: 核心包</li><li><code>jackson-annotations</code> : 注解包</li><li><code>jackson-databind</code> : 数据绑定（依赖 <code>core</code> 和 <code>annotations</code>）</li></ul><hr><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>Jackson 提供了三种 json 处理方式：</p><ul><li>Streaming API : 其他两种方式都依赖于它而实现，如果要从底层细粒度控制 json 的解析生成，可以使用这种方式;</li><li>Tree Model : 通过基于内存的树形结构来描述 json 数据。json 结构树由 JsonNode 组成。不需要绑定任何类和实体，可以方便的对 JsonNode 来进行操作。</li><li>Data Binding : 最常用的方式，基于属性的 get 和 set方法以及注解来实现 JavaBean 和 json 的互转，底层实现还是 Streaming API.</li></ul><hr><h3 id="Streaming-API"><a href="#Streaming-API" class="headerlink" title="Streaming API"></a>Streaming API</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JackSonDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> JsonFactory factory<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> JsonGenerator jsonGenerator<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 工厂全局设置</span>        factory<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>JsonFactory<span class="token punctuation">.</span>Feature<span class="token punctuation">.</span>CANONICALIZE_FIELD_NAMES<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置解析器</span>        factory<span class="token punctuation">.</span><span class="token function">enable</span><span class="token punctuation">(</span>JsonParser<span class="token punctuation">.</span>Feature<span class="token punctuation">.</span>ALLOW_SINGLE_QUOTES<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置生成器</span>        factory<span class="token punctuation">.</span><span class="token function">enable</span><span class="token punctuation">(</span>JsonGenerator<span class="token punctuation">.</span>Feature<span class="token punctuation">.</span>WRITE_NUMBERS_AS_STRINGS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>说明：使用jsonFactory来配置一些序列化和反序列化的特性。</p><h4 id="jsonGenerator"><a href="#jsonGenerator" class="headerlink" title="jsonGenerator"></a>jsonGenerator</h4><p>jsonGenerator主要用来生成json字符串的，即：所谓的序列化操作。</p><p>1) 输出基本类型</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testJsonGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        jsonGenerator <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createGenerator</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">,</span> JsonEncoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">)</span><span class="token punctuation">;</span>        String str <span class="token operator">=</span> <span class="token string">"hello,world!jackson!"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 输出字节</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeBinary</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 输出布尔型</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeBoolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// null</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 输出字符型</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeNumber</span><span class="token punctuation">(</span><span class="token number">2.2f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用Raw方法会执行字符中的特殊字符</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeRaw</span><span class="token punctuation">(</span><span class="token string">"\tc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 输出换行符</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeRaw</span><span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出构造的pojo对象</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeStartObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeObjectField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"gakki"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeObjectField</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeObjectField</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">,</span> <span class="token string">"冲绳岛"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeEndObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//注意这里必须关闭，否则不会输出。</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token string">"aGVsbG8sd29ybGQhamFja3NvbiE="</span> <span class="token boolean">true</span> null <span class="token string">"2.2"</span>    c <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token string">"18"</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"冲绳岛"</span><span class="token punctuation">}</span></code></pre><hr><p>2）输出POJO对象和数组类型的POJO</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testJsonGenerator2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"gakkij"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createGenerator</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">,</span> JsonEncoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        User<span class="token punctuation">[</span><span class="token punctuation">]</span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"jack"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"rose"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> userList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"bbb"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>IllegalStateException<span class="token operator">:</span> No ObjectCodec defined <span class="token keyword">for</span> the generator<span class="token punctuation">,</span> can only serialize simple wrapper <span class="token function">types</span> <span class="token punctuation">(</span>type passed com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>User<span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>core<span class="token punctuation">.</span>JsonGenerator<span class="token punctuation">.</span><span class="token function">_writeSimpleObject</span><span class="token punctuation">(</span>JsonGenerator<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">2168</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>core<span class="token punctuation">.</span>base<span class="token punctuation">.</span>GeneratorBase<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>GeneratorBase<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">391</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>JackSonDemo<span class="token punctuation">.</span><span class="token function">testJsonGenerator2</span><span class="token punctuation">(</span>JackSonDemo<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">38</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>JackSonDemo<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>JackSonDemo<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">26</span><span class="token punctuation">)</span></code></pre><p><strong>报错了？</strong></p><p><strong>这里，我们必须使用ObjectMapper。</strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testJsonGenerator2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonGenerator jsonGenerator <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">getJsonFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createJsonGenerator</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">,</span> JsonEncoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"gakkij"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeRaw</span><span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User<span class="token punctuation">[</span><span class="token punctuation">]</span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"jack"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"rose"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeRaw</span><span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> userList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"bbb"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonGenerator<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakkij"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">}</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"jack"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"rose"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"aaa"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"bbb"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">16</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><h4 id="jsonParse"><a href="#jsonParse" class="headerlink" title="jsonParse"></a>jsonParse</h4><p>1) 简单的解析</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//省略：set、get、toString方法</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testParse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        String json <span class="token operator">=</span> <span class="token string">"{'name':'jacklove','age':18}"</span><span class="token punctuation">;</span>        JsonParser parser <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createParser</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonToken jsonToken <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>jsonToken <span class="token operator">!=</span> JsonToken<span class="token punctuation">.</span>START_OBJECT<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// {</span>            <span class="token comment" spellcheck="true">//说明json字符串格式有问题</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"json格式有问题！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>jsonToken <span class="token operator">!=</span> JsonToken<span class="token punctuation">.</span>END_OBJECT<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// }</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>jsonToken <span class="token operator">==</span> JsonToken<span class="token punctuation">.</span>FIELD_NAME <span class="token operator">&amp;&amp;</span> parser<span class="token punctuation">.</span><span class="token function">currentName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// jacklove</span>                String name <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>jsonToken <span class="token operator">==</span> JsonToken<span class="token punctuation">.</span>FIELD_NAME <span class="token operator">&amp;&amp;</span> parser<span class="token punctuation">.</span><span class="token function">currentName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> age <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">getIntValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            jsonToken <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        parser<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'jacklove'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">}</span></code></pre><hr><p>2）复杂的解析</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testParse2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        String json <span class="token operator">=</span> <span class="token string">"{'name':'gakki','age':18,'hobby':['aaa','bbb','ccc'],'boyfriend':{'name':'liuzhuo','age':18}}"</span><span class="token punctuation">;</span>        JsonParser parser <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createParser</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonToken token <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>token <span class="token operator">!=</span> JsonToken<span class="token punctuation">.</span>END_OBJECT<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">==</span> JsonToken<span class="token punctuation">.</span>FIELD_NAME <span class="token operator">&amp;&amp;</span> parser<span class="token punctuation">.</span><span class="token function">currentName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                String name <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name:"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">==</span> JsonToken<span class="token punctuation">.</span>FIELD_NAME <span class="token operator">&amp;&amp;</span> parser<span class="token punctuation">.</span><span class="token function">currentName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> age <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">getIntValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"age:"</span> <span class="token operator">+</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">==</span> JsonToken<span class="token punctuation">.</span>FIELD_NAME <span class="token operator">&amp;&amp;</span> parser<span class="token punctuation">.</span><span class="token function">currentName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"hobby"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                token <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hobby:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>token <span class="token operator">!=</span> JsonToken<span class="token punctuation">.</span>END_ARRAY<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">==</span> JsonToken<span class="token punctuation">.</span>VALUE_STRING<span class="token punctuation">)</span><span class="token punctuation">{</span>                        String hobby <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">getValueAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hobby<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    token <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">==</span> JsonToken<span class="token punctuation">.</span>FIELD_NAME <span class="token operator">&amp;&amp;</span> parser<span class="token punctuation">.</span><span class="token function">currentName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"boyfriend"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                token <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>token <span class="token operator">!=</span> JsonToken<span class="token punctuation">.</span>END_OBJECT<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">==</span> JsonToken<span class="token punctuation">.</span>FIELD_NAME <span class="token operator">&amp;&amp;</span> parser<span class="token punctuation">.</span><span class="token function">currentName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        String name <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"bf_name:"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">==</span> JsonToken<span class="token punctuation">.</span>FIELD_NAME <span class="token operator">&amp;&amp;</span> parser<span class="token punctuation">.</span><span class="token function">currentName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">int</span> age <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">getIntValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"bf_age:"</span> <span class="token operator">+</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    token <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            token <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        parser<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">name<span class="token operator">:</span>gakkiage<span class="token operator">:</span><span class="token number">18</span>hobby<span class="token operator">:</span>aaabbbcccbf_name<span class="token operator">:</span>liuzhuobf_age<span class="token operator">:</span><span class="token number">18</span></code></pre><p>这样的解析恶心到我了！！！！</p><p>注意：这里解析数组结构时的判断条件：<code>token == JsonToken.VALUE_STRING</code></p><hr><h3 id="TreeMode"><a href="#TreeMode" class="headerlink" title="TreeMode"></a>TreeMode</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        objectMapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果为空则不输出</span>        objectMapper<span class="token punctuation">.</span><span class="token function">setSerializationInclusion</span><span class="token punctuation">(</span>JsonInclude<span class="token punctuation">.</span>Include<span class="token punctuation">.</span>NON_EMPTY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 对于空的对象转json的时候不抛出错误</span>        objectMapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>SerializationFeature<span class="token punctuation">.</span>FAIL_ON_EMPTY_BEANS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 禁用序列化日期为timestamps</span>        objectMapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>SerializationFeature<span class="token punctuation">.</span>WRITE_DATES_AS_TIMESTAMPS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 禁用遇到未知属性抛出异常</span>        objectMapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 视空字符传为null</span>        objectMapper<span class="token punctuation">.</span><span class="token function">enable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>ACCEPT_EMPTY_STRING_AS_NULL_OBJECT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 低层级配置</span>        objectMapper<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>JsonParser<span class="token punctuation">.</span>Feature<span class="token punctuation">.</span>ALLOW_COMMENTS<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 允许属性名称没有引号</span>        objectMapper<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>JsonParser<span class="token punctuation">.</span>Feature<span class="token punctuation">.</span>ALLOW_UNQUOTED_FIELD_NAMES<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 允许单引号</span>        objectMapper<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>JsonParser<span class="token punctuation">.</span>Feature<span class="token punctuation">.</span>ALLOW_SINGLE_QUOTES<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 取消对非ASCII字符的转码</span>        objectMapper<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>JsonGenerator<span class="token punctuation">.</span>Feature<span class="token punctuation">.</span>ESCAPE_NON_ASCII<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testTreeModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        JsonNodeFactory nodeFactory <span class="token operator">=</span> objectMapper<span class="token punctuation">.</span><span class="token function">getNodeFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建一个model</span>        ObjectNode node <span class="token operator">=</span> nodeFactory<span class="token punctuation">.</span><span class="token function">objectNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        node<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 新增</span>        node<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"周杰伦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果存在同名的则是替换操作</span>        node<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ArrayNode coursesNode <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">putArray</span><span class="token punctuation">(</span><span class="token string">"courses"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coursesNode<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"思想政治"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coursesNode<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"高等数学"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取节点类型</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">getNodeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>coursesNode<span class="token punctuation">.</span><span class="token function">getNodeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 移除第一个</span>        coursesNode<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 输出</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String jsonStr <span class="token operator">=</span> <span class="token string">"{\"age\":19,\"name\":\"周杰伦\",\"courses\":[\"高等数学\"]}"</span><span class="token punctuation">;</span>        JsonNode jsonNode <span class="token operator">=</span> objectMapper<span class="token punctuation">.</span><span class="token function">readTree</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">)</span><span class="token punctuation">;</span>        ArrayNode arrayNode <span class="token operator">=</span> <span class="token punctuation">(</span>ArrayNode<span class="token punctuation">)</span> jsonNode<span class="token punctuation">.</span><span class="token function">withArray</span><span class="token punctuation">(</span><span class="token string">"courses"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayNode<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"马列"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrayNode<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jsonNode<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">OBJECTARRAY<span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"周杰伦"</span><span class="token punctuation">,</span><span class="token string">"courses"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"高等数学"</span><span class="token punctuation">]</span><span class="token punctuation">}</span>高等数学马列<span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"周杰伦"</span><span class="token punctuation">,</span><span class="token string">"courses"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"高等数学"</span><span class="token punctuation">,</span><span class="token string">"马列"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><hr><h3 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JacksonDataBindTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> ObjectMapper baseMapper<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> ObjectMapper prettyMapper1<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> ObjectMapper prettyMapper2<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> ObjectMapper nonEmptyMapper<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        baseMapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 对于空的对象转json的时候不抛出错误</span>        baseMapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>SerializationFeature<span class="token punctuation">.</span>FAIL_ON_EMPTY_BEANS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 禁用遇到未知属性抛出异常</span>        baseMapper<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">)</span><span class="token punctuation">;</span>        baseMapper<span class="token punctuation">.</span><span class="token function">enable</span><span class="token punctuation">(</span>DeserializationFeature<span class="token punctuation">.</span>ACCEPT_EMPTY_STRING_AS_NULL_OBJECT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 低层级配置</span>        baseMapper<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>JsonParser<span class="token punctuation">.</span>Feature<span class="token punctuation">.</span>ALLOW_COMMENTS<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        baseMapper<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>JsonParser<span class="token punctuation">.</span>Feature<span class="token punctuation">.</span>ALLOW_UNQUOTED_FIELD_NAMES<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        baseMapper<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>JsonParser<span class="token punctuation">.</span>Feature<span class="token punctuation">.</span>ALLOW_SINGLE_QUOTES<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 配置两个副本</span>        prettyMapper1 <span class="token operator">=</span> baseMapper<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        prettyMapper2 <span class="token operator">=</span> baseMapper<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 高级配置</span>        prettyMapper1<span class="token punctuation">.</span><span class="token function">enable</span><span class="token punctuation">(</span>SerializationFeature<span class="token punctuation">.</span>INDENT_OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>        prettyMapper1<span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        prettyMapper1<span class="token punctuation">.</span><span class="token function">enable</span><span class="token punctuation">(</span>SerializationFeature<span class="token punctuation">.</span>WRITE_ENUMS_USING_TO_STRING<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 禁用序列化日期为timestamps</span>        prettyMapper1<span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span>SerializationFeature<span class="token punctuation">.</span>WRITE_DATES_AS_TIMESTAMPS<span class="token punctuation">)</span><span class="token punctuation">;</span>        prettyMapper1<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>JsonGenerator<span class="token punctuation">.</span>Feature<span class="token punctuation">.</span>ESCAPE_NON_ASCII<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Json格式化展示</span>        prettyMapper2<span class="token punctuation">.</span><span class="token function">setSerializationInclusion</span><span class="token punctuation">(</span>JsonInclude<span class="token punctuation">.</span>Include<span class="token punctuation">.</span>NON_NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>        prettyMapper2<span class="token punctuation">.</span><span class="token function">enable</span><span class="token punctuation">(</span>SerializationFeature<span class="token punctuation">.</span>INDENT_OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>        prettyMapper2<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>JsonGenerator<span class="token punctuation">.</span>Feature<span class="token punctuation">.</span>ESCAPE_NON_ASCII<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        prettyMapper2<span class="token punctuation">.</span><span class="token function">enable</span><span class="token punctuation">(</span>SerializationFeature<span class="token punctuation">.</span>WRITE_ENUMS_USING_INDEX<span class="token punctuation">)</span><span class="token punctuation">;</span>        nonEmptyMapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nonEmptyMapper<span class="token punctuation">.</span><span class="token function">setSerializationInclusion</span><span class="token punctuation">(</span>JsonInclude<span class="token punctuation">.</span>Include<span class="token punctuation">.</span>NON_EMPTY<span class="token punctuation">)</span><span class="token punctuation">;</span>        nonEmptyMapper<span class="token punctuation">.</span><span class="token function">enable</span><span class="token punctuation">(</span>SerializationFeature<span class="token punctuation">.</span>INDENT_OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>        nonEmptyMapper<span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>TessBean:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestBean</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String course<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date now<span class="token punctuation">;</span>    <span class="token keyword">private</span> Sexy sexy<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 省略set、get、toString方法</span><span class="token punctuation">}</span></code></pre><p>Sexy：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> Sexy <span class="token punctuation">{</span>    <span class="token function">MEN</span><span class="token punctuation">(</span><span class="token string">"男"</span><span class="token punctuation">,</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">WOMEN</span><span class="token punctuation">(</span><span class="token string">"女"</span><span class="token punctuation">,</span> <span class="token string">"W"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String text<span class="token punctuation">;</span>    <span class="token keyword">private</span> String code<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Sexy</span><span class="token punctuation">(</span>String text<span class="token punctuation">,</span> String code<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>text <span class="token operator">=</span> text<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> text<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> code<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"{\"text\":\""</span> <span class="token operator">+</span> <span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\",\"code\":\""</span> <span class="token operator">+</span> <span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\"}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testReadValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        String json <span class="token operator">=</span> <span class="token string">"{\n"</span> <span class="token operator">+</span>                <span class="token string">"  \"name\" : \"发如雪\",\n"</span> <span class="token operator">+</span>                <span class="token string">"  \"now\" : \"2015-12-17 17:25:13\",\n"</span> <span class="token operator">+</span>                <span class="token string">"  \"sexy\" : \"MEN\"\n"</span> <span class="token operator">+</span>                <span class="token string">"}"</span><span class="token punctuation">;</span>        TestBean testBean <span class="token operator">=</span> nonEmptyMapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> TestBean<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>testBean<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">TestBean<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'发如雪'</span><span class="token punctuation">,</span> course<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> now<span class="token operator">=</span>Thu Dec <span class="token number">17</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">25</span><span class="token operator">:</span><span class="token number">13</span> CST <span class="token number">2015</span><span class="token punctuation">,</span> sexy<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"text"</span><span class="token operator">:</span><span class="token string">"男"</span><span class="token punctuation">,</span><span class="token string">"code"</span><span class="token operator">:</span><span class="token string">"M"</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testWriteValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        TestBean testBean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestBean</span><span class="token punctuation">(</span><span class="token string">"发如雪"</span><span class="token punctuation">,</span> Sexy<span class="token punctuation">.</span>MEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>baseMapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>testBean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>prettyMapper1<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>testBean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>prettyMapper2<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>testBean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>nonEmptyMapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>testBean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"发如雪"</span><span class="token punctuation">,</span><span class="token string">"course"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"now"</span><span class="token operator">:</span><span class="token number">1577587336749</span><span class="token punctuation">,</span><span class="token string">"sexy"</span><span class="token operator">:</span><span class="token string">"MEN"</span><span class="token punctuation">}</span><span class="token punctuation">{</span>  <span class="token string">"name"</span> <span class="token operator">:</span> <span class="token string">"发如雪"</span><span class="token punctuation">,</span>  <span class="token string">"course"</span> <span class="token operator">:</span> null<span class="token punctuation">,</span>  <span class="token string">"now"</span> <span class="token operator">:</span> <span class="token string">"2019-12-29 10:42:16"</span><span class="token punctuation">,</span>  <span class="token string">"sexy"</span> <span class="token operator">:</span> <span class="token string">"{\"text\":\"男\",\"code\":\"M\"}"</span><span class="token punctuation">}</span><span class="token punctuation">{</span>  <span class="token string">"name"</span> <span class="token operator">:</span> <span class="token string">"\u53D1\u5982\u96EA"</span><span class="token punctuation">,</span>  <span class="token string">"now"</span> <span class="token operator">:</span> <span class="token number">1577587336749</span><span class="token punctuation">,</span>  <span class="token string">"sexy"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">{</span>  <span class="token string">"name"</span> <span class="token operator">:</span> <span class="token string">"发如雪"</span><span class="token punctuation">,</span>  <span class="token string">"now"</span> <span class="token operator">:</span> <span class="token string">"2019-12-29 10:42:16"</span><span class="token punctuation">,</span>  <span class="token string">"sexy"</span> <span class="token operator">:</span> <span class="token string">"MEN"</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Jackson </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastJson的进阶&lt;五&gt;</title>
      <link href="/2019/12/28/fastjson-de-jin-jie-wu/"/>
      <url>/2019/12/28/fastjson-de-jin-jie-wu/</url>
      
        <content type="html"><![CDATA[<p>当需要处理超大JSON文本时，需要Stream API，在fastjson-1.1.32版本中开始提供Stream API。</p><hr><p>实例对象：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VO</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> attributes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">VO</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> attributes<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"VO [id="</span> <span class="token operator">+</span> id <span class="token operator">+</span> <span class="token string">", attributes="</span> <span class="token operator">+</span> attributes <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="超大JSON对象的序列化"><a href="#超大JSON对象的序列化" class="headerlink" title="超大JSON对象的序列化"></a>超大JSON对象的序列化</h4><p>如果你的JSON格式是一个巨大的JSONObject，有很多Key/Value对，则先调用startObject，然后挨个写入Key和Value，然后调用endObject。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestHugeObjectSerialize</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        JSONWriter writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"hugeObject.json"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        writer<span class="token punctuation">.</span><span class="token function">startObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            writer<span class="token punctuation">.</span><span class="token function">writeKey</span><span class="token punctuation">(</span><span class="token string">"x"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            writer<span class="token punctuation">.</span><span class="token function">writeValue</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">VO</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        writer<span class="token punctuation">.</span><span class="token function">endObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        writer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>文件内容：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"x0"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"x1"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"x2"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"x3"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"x4"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"x5"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"x6"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"x7"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"x8"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"x9"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="超大JSON数组序列化"><a href="#超大JSON数组序列化" class="headerlink" title="超大JSON数组序列化"></a><strong>超大JSON数组序列化</strong></h4><p>如果你的JSON格式是一个巨大的JSON数组，有很多元素，则先调用startArray，然后挨个写入对象，然后调用endArray。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestHugeArraySerialize</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        JSONWriter writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"hugeArray.json"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        writer<span class="token punctuation">.</span><span class="token function">startArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            writer<span class="token punctuation">.</span><span class="token function">writeValue</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">VO</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        writer<span class="token punctuation">.</span><span class="token function">endArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        writer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>文件内容：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"attributes"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><hr><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a><strong>反序列化</strong></h3><h4 id="超大JSON对象反序列化"><a href="#超大JSON对象反序列化" class="headerlink" title="超大JSON对象反序列化"></a><strong>超大JSON对象反序列化</strong></h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestHugeObjectDeserialize</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 读入上面输出的文件</span>        JSONReader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"hugeObject.json"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reader<span class="token punctuation">.</span><span class="token function">startObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String key <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            VO vo <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span>VO<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">"："</span> <span class="token operator">+</span> vo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        reader<span class="token punctuation">.</span><span class="token function">endObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre class=" language-java"><code class="language-java">x0：VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>x1：VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>x2：VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>x3：VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>x4：VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>x5：VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>x6：VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>x7：VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>x8：VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>x9：VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><h4 id="超大JSON数组反序列化"><a href="#超大JSON数组反序列化" class="headerlink" title="超大JSON数组反序列化"></a><strong>超大JSON数组反序列化</strong></h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestHugeArrayDeserialize</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 读入上面输出的文件</span>        JSONReader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"hugeArray.json"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reader<span class="token punctuation">.</span><span class="token function">startArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            VO vo <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span>VO<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>vo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        reader<span class="token punctuation">.</span><span class="token function">endArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre class=" language-java"><code class="language-java">VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> FastJson </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastJson的进阶&lt;四&gt;</title>
      <link href="/2019/12/22/fastjson-de-jin-jie-si/"/>
      <url>/2019/12/22/fastjson-de-jin-jie-si/</url>
      
        <content type="html"><![CDATA[<p>ParseProcess是编程扩展定制反序列化的接口。fastjson支持如下ParseProcess：</p><ul><li>ExtraProcessor 用于处理多余的字段；</li><li>ExtraTypeProvider 用于处理多余字段时提供类型信息。</li></ul><hr><h3 id="使用-ExtraProcessor-处理多余字段"><a href="#使用-ExtraProcessor-处理多余字段" class="headerlink" title="使用 ExtraProcessor 处理多余字段"></a><strong>使用 ExtraProcessor 处理多余字段</strong></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VO</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> attributes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> attributes<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"VO [id="</span> <span class="token operator">+</span> id <span class="token operator">+</span> <span class="token string">", attributes="</span> <span class="token operator">+</span> attributes <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里，使用Map来存储反序列化多余的字段，什么叫做多余的字段呢？</p><p>就是当我们使用FastJson反序列时，那些不能被匹配的字段。</p><pre class=" language-java"><code class="language-java">ExtraProcessor processor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExtraProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processExtra</span><span class="token punctuation">(</span>Object object<span class="token punctuation">,</span> String key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---------------object = "</span> <span class="token operator">+</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---------------key = "</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---------------value = "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                VO vo <span class="token operator">=</span> <span class="token punctuation">(</span>VO<span class="token punctuation">)</span> object<span class="token punctuation">;</span>                vo<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">789</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 修改一下id值</span>                vo<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里name和phone是多余的，在VO里没有</span>        VO vo <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span><span class="token string">"{\"id\":123,\"name\":\"abc\",\"phone\":\"18603396954\"}"</span><span class="token punctuation">,</span> VO<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> processor<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"vo.getId() = "</span> <span class="token operator">+</span> vo<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"vo.getAttributes().get(\"name\") = "</span> <span class="token operator">+</span> vo<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"vo.getAttributes().get(\"phone\") = "</span> <span class="token operator">+</span> vo<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"phone"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>object <span class="token operator">=</span> VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">123</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>key <span class="token operator">=</span> name<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>value <span class="token operator">=</span> abc<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>object <span class="token operator">=</span> VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">789</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span>name<span class="token operator">=</span>abc<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>key <span class="token operator">=</span> phone<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>value <span class="token operator">=</span> <span class="token number">18603396954</span>vo<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">789</span>vo<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> <span class="token operator">=</span> abcvo<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"phone"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">18603396954</span></code></pre><p>我们可以看到，调用processExtra方法时，是FastJson已经帮我们序列化之后再进行，通过打印出来的object可以看出，id是能够匹配成功的，没有走processExtra方法。只有 name 和 phone 这些没有匹配的字段才会走：processExtra方法。</p><hr><h3 id="使用ExtraTypeProvider-为多余的字段提供类型"><a href="#使用ExtraTypeProvider-为多余的字段提供类型" class="headerlink" title="使用ExtraTypeProvider 为多余的字段提供类型"></a><strong>使用ExtraTypeProvider 为多余的字段提供类型</strong></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyExtraProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">ExtraProcessor</span><span class="token punctuation">,</span> ExtraTypeProvider <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processExtra</span><span class="token punctuation">(</span>Object object<span class="token punctuation">,</span> String key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        VO vo <span class="token operator">=</span> <span class="token punctuation">(</span>VO<span class="token punctuation">)</span> object<span class="token punctuation">;</span>        vo<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Type <span class="token function">getExtraType</span><span class="token punctuation">(</span>Object object<span class="token punctuation">,</span> String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---------------object = "</span> <span class="token operator">+</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---------------key = "</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">ExtraProcessor processor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyExtraProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        VO vo <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span><span class="token string">"{\"id\":123,\"value\":\"123456\"}"</span><span class="token punctuation">,</span> VO<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> processor<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"vo.getId() = "</span> <span class="token operator">+</span> vo<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"vo.getAttributes().get(\"value\") = "</span> <span class="token operator">+</span> vo<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"vo.getAttributes().get(\"value\").getClass() = "</span> <span class="token operator">+</span> vo<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// value本应该是字符串类型的，通过getExtraType的处理变成Integer类型了。</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>object <span class="token operator">=</span> VO <span class="token punctuation">[</span>id<span class="token operator">=</span><span class="token number">123</span><span class="token punctuation">,</span> attributes<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>key <span class="token operator">=</span> valuevo<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">123</span>vo<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">123456</span>vo<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Integer</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> FastJson </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastJson的进阶&lt;三&gt;</title>
      <link href="/2019/12/22/fastjson-de-jin-jie-san/"/>
      <url>/2019/12/22/fastjson-de-jin-jie-san/</url>
      
        <content type="html"><![CDATA[<p>通过SerializeFilter可以使用扩展编程的方式实现定制序列化。fastjson提供了多种SerializeFilter：</p><pre><code>PropertyFilter 根据PropertyName和PropertyValue来判断是否序列化；PropertyPreFilter 根据PropertyName判断是否序列化；NameFilter 可以修序列化后的Key;ValueFilter 可以修改序列化后的Value；BeforeFilter 序列化时在最前添加内容；AfterFilter 序列化时在最后添加内容。</code></pre><h3 id="PropertyFilter"><a href="#PropertyFilter" class="headerlink" title="PropertyFilter"></a>PropertyFilter</h3><p>根据PropertyName和PropertyValue来判断是否序列化；</p><p>PropertyFilter 接口：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PropertyFilter</span> <span class="token keyword">extends</span> <span class="token class-name">SerializeFilter</span> <span class="token punctuation">{</span>      <span class="token keyword">boolean</span> <span class="token function">apply</span><span class="token punctuation">(</span>Object object<span class="token punctuation">,</span> String propertyName<span class="token punctuation">,</span> Object propertyValue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>可以通过扩展实现根据object或者属性名称或者属性值进行判断是否需要序列化。例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    省略：get、set、toString方法 <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        PropertyFilter filter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PropertyFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">apply</span><span class="token punctuation">(</span>Object object<span class="token punctuation">,</span> String name<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"source:"</span> <span class="token operator">+</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name:"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"value:"</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> id <span class="token operator">>=</span> <span class="token number">20</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"gakki"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"冲绳"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> filter<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> filter<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">source<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳'</span><span class="token punctuation">}</span>name<span class="token operator">:</span>addressvalue<span class="token operator">:</span>冲绳<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>source<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳'</span><span class="token punctuation">}</span>name<span class="token operator">:</span>idvalue<span class="token operator">:</span><span class="token number">18</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>source<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳'</span><span class="token punctuation">}</span>name<span class="token operator">:</span>namevalue<span class="token operator">:</span>gakki<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token punctuation">{</span><span class="token punctuation">}</span>source<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">21</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳'</span><span class="token punctuation">}</span>name<span class="token operator">:</span>addressvalue<span class="token operator">:</span>冲绳<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>source<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">21</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳'</span><span class="token punctuation">}</span>name<span class="token operator">:</span>idvalue<span class="token operator">:</span><span class="token number">21</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>source<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">21</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳'</span><span class="token punctuation">}</span>name<span class="token operator">:</span>namevalue<span class="token operator">:</span>gakki<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">}</span></code></pre><p>说明：PropertyFilter中的apply方法中，第一个参数：Object就是原始数据，这里指代User对象，第二个参数就是序列化时属性的名字，如果使用@JSONField注解的话，就是name中的指定的名字，没有的话，就是属性本身的名字，第三个参数就是属性的值。</p><p>这里，我只序列化了name为：id的属性 并且 id的值大于20，最终输出：{“id”:21}。</p><hr><h3 id="PropertyPreFilter"><a href="#PropertyPreFilter" class="headerlink" title="PropertyPreFilter"></a>PropertyPreFilter</h3><p>根据PropertyName判断是否序列化</p><p>PropertyPreFilter接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">NameFilter</span> <span class="token keyword">extends</span> <span class="token class-name">SerializeFilter</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">apply</span><span class="token punctuation">(</span>JSONSerializer serializer<span class="token punctuation">,</span> Object object<span class="token punctuation">,</span> String propertyName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        PropertyPreFilter filter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PropertyPreFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">apply</span><span class="token punctuation">(</span>JSONSerializer serializer<span class="token punctuation">,</span> Object object<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"source:"</span> <span class="token operator">+</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name:"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"jackoflove"</span><span class="token punctuation">,</span> <span class="token string">"东京"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> filter<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">source<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">19</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'jackoflove'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">}</span>name<span class="token operator">:</span>addresssource<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">19</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'jackoflove'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">}</span>name<span class="token operator">:</span>idsource<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">19</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'jackoflove'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">}</span>name<span class="token operator">:</span>name<span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"jackoflove"</span><span class="token punctuation">}</span></code></pre><p>这里，通过只序列化name的属性。</p><hr><h3 id="NameFilter"><a href="#NameFilter" class="headerlink" title="NameFilter"></a>NameFilter</h3><p>序列化时修改Key</p><p>NameFilter 接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">NameFilter</span> <span class="token keyword">extends</span> <span class="token class-name">SerializeFilter</span> <span class="token punctuation">{</span>    String <span class="token function">process</span><span class="token punctuation">(</span>Object object<span class="token punctuation">,</span> String propertyName<span class="token punctuation">,</span> Object propertyValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        NameFilter filter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NameFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> String <span class="token function">process</span><span class="token punctuation">(</span>Object object<span class="token punctuation">,</span> String name<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"source:"</span> <span class="token operator">+</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name:"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"value:"</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token string">"xxx_id"</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token string">"My_name"</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> name<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"jackoflove"</span><span class="token punctuation">,</span> <span class="token string">"东京"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> filter<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">source<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">19</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'jackoflove'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">}</span>name<span class="token operator">:</span>addressvalue<span class="token operator">:</span>东京source<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">19</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'jackoflove'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">}</span>name<span class="token operator">:</span>idvalue<span class="token operator">:</span><span class="token number">19</span>source<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">19</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'jackoflove'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">}</span>name<span class="token operator">:</span>namevalue<span class="token operator">:</span>jackoflove<span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"东京"</span><span class="token punctuation">,</span><span class="token string">"xxx_id"</span><span class="token operator">:</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token string">"My_name"</span><span class="token operator">:</span><span class="token string">"jackoflove"</span><span class="token punctuation">}</span></code></pre><p>PS： fastjson内置一个PascalNameFilter，用于输出将首字符大写的Pascal风格</p><pre class=" language-java"><code class="language-java">String json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">PascalNameFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 序列化的时候传入filter</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"PascalNameFilter序列化："</span> <span class="token operator">+</span> json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="ValueFilter"><a href="#ValueFilter" class="headerlink" title="ValueFilter"></a><strong>ValueFilter</strong></h3><p>序列化时修改Value</p><p>ValueFilter 接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ValueFilter</span> <span class="token keyword">extends</span> <span class="token class-name">SerializeFilter</span> <span class="token punctuation">{</span>      Object <span class="token function">process</span><span class="token punctuation">(</span>Object object<span class="token punctuation">,</span> String propertyName<span class="token punctuation">,</span> Object propertyValue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        ValueFilter filter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ValueFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Object <span class="token function">process</span><span class="token punctuation">(</span>Object object<span class="token punctuation">,</span> String name<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"source:"</span> <span class="token operator">+</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name:"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"value:"</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> value<span class="token punctuation">;</span>                    <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    String nameValue <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> nameValue <span class="token operator">+</span> <span class="token string">"_gakkij"</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> value<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"jackoflove"</span><span class="token punctuation">,</span> <span class="token string">"东京"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> filter<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">source<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">19</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'jackoflove'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">}</span>name<span class="token operator">:</span>addressvalue<span class="token operator">:</span>东京source<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">19</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'jackoflove'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">}</span>name<span class="token operator">:</span>idvalue<span class="token operator">:</span><span class="token number">19</span>source<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">19</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'jackoflove'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">}</span>name<span class="token operator">:</span>namevalue<span class="token operator">:</span>jackoflove<span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"东京"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"jackoflove_gakkij"</span><span class="token punctuation">}</span></code></pre><h3 id="BeforeFilter"><a href="#BeforeFilter" class="headerlink" title="BeforeFilter"></a><strong>BeforeFilter</strong></h3><p>序列化时在最前添加内容</p><p>BeforeFilter 接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">BeforeFilter</span> <span class="token keyword">implements</span> <span class="token class-name">SerializeFilter</span> <span class="token punctuation">{</span>      <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">writeKeyValue</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 需要实现的抽象方法，在实现中调用writeKeyValue添加内容</span>      <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">writeBefore</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>在序列化对象的所有属性之前执行某些操作，例如调用 writeKeyValue 添加内容：</p><pre class=" language-java"><code class="language-java">        BeforeFilter filter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeforeFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeBefore</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//System.out.println("source:" + object);</span>                User user <span class="token operator">=</span> <span class="token punctuation">(</span>User<span class="token punctuation">)</span> object<span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"id:"</span><span class="token operator">+</span>user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name:"</span><span class="token operator">+</span>user<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"address:"</span><span class="token operator">+</span>user<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//修改id的值</span>                user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"jackoflove"</span><span class="token punctuation">,</span> <span class="token string">"东京"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> filter<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">id<span class="token operator">:</span><span class="token number">19</span>name<span class="token operator">:</span>jackofloveaddress<span class="token operator">:</span>东京<span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"东京"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">28</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"jackoflove"</span><span class="token punctuation">}</span></code></pre><p>在序列化之前，我们打印出了要序列化的对象的属性，然后修改了id的值。</p><h3 id="AfterFilter"><a href="#AfterFilter" class="headerlink" title="AfterFilter"></a><strong>AfterFilter</strong></h3><p>序列化时在最后添加内容</p><p>AfterFilter 接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AfterFilter</span> <span class="token keyword">implements</span> <span class="token class-name">SerializeFilter</span> <span class="token punctuation">{</span>      <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">writeKeyValue</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 需要实现的抽象方法，在实现中调用writeKeyValue添加内容</span>      <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">writeAfter</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        AfterFilter filter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AfterFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeAfter</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span> <span class="token punctuation">{</span>                User user <span class="token operator">=</span> <span class="token punctuation">(</span>User<span class="token punctuation">)</span> object<span class="token punctuation">;</span>                user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"老女人"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"你猜ya!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"jackoflove"</span><span class="token punctuation">,</span> <span class="token string">"东京"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> filter<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">19</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'jackoflove'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"东京"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"jackoflove"</span><span class="token punctuation">}</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">28</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'老女人'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'你猜ya!'</span><span class="token punctuation">}</span></code></pre><p>修改的是要序列化的对象本身，序列化是不会变的。</p>]]></content>
      
      
      <categories>
          
          <category> FastJson </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastJson的进阶&lt;二&gt;</title>
      <link href="/2019/12/22/fastjson-de-jin-jie-er/"/>
      <url>/2019/12/22/fastjson-de-jin-jie-er/</url>
      
        <content type="html"><![CDATA[<p>根据前面的FastJson的学习，我们已经掌握了FastJson的基础用法了，可以完成我们的日常开发了，今天我们来学习FastJson中的几个注解的用法</p><h3 id="JSONField-介绍"><a href="#JSONField-介绍" class="headerlink" title="JSONField 介绍"></a><strong>JSONField 介绍</strong></h3><p>注意：1、若属性是私有的，必须有set*方法。否则无法反序列化。</p><p>JSONField注解：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>PARAMETER<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">JSONField</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 配置序列化和反序列化的顺序，1.1.42版本之后才支持</span>    <span class="token keyword">int</span> <span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指定字段的名称</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指定字段的格式，对日期格式有用</span>    String <span class="token function">format</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 是否序列化</span>    <span class="token keyword">boolean</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 是否反序列化</span>    <span class="token keyword">boolean</span> <span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指定对该字段的特性</span>    SerializerFeature<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">serialzeFeatures</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    Feature<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">parseFeatures</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    String <span class="token function">label</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">jsonDirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指定使用的序列化类</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">serializeUsing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> Void<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指定使用的反序列化的类</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">deserializeUsing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> Void<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 别名</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">alternateNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">unwrapped</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="JSONField-配置方式"><a href="#JSONField-配置方式" class="headerlink" title="JSONField 配置方式"></a><strong>JSONField 配置方式</strong></h3><p>可以配置在getter/setter方法或者字段上。例如：</p><h4 id="配置在getter-setter上"><a href="#配置在getter-setter上" class="headerlink" title="配置在getter/setter上"></a><strong>配置在getter/setter上</strong></h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"My_id"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"My_id"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    省略了其他字段的set、get方法<span class="token punctuation">,</span>toString方法  <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{'My_id':18,'name':'gakki'}"</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"My_id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>这里的@JSONField注解，就和GSON中的@SerializedName(value = “My_id”)一样，修改了反序列化的key。</p><p>@JSONField注解在set方法上：是反序列化的作用，@JSONField注解在get方法上：是序列化的作用。</p><hr><p>去掉id的set上面的注解后：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"My_id"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    省略了其他字段的set、get方法，toString方法  <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"My_id"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>反序列化失败，因为json字符串中是My_id，不能和User中的id想匹配！</p><hr><p>去掉id的get上面的注解后：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"My_id"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    省略了其他字段的set、get方法，toString方法  <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>可以看到，反序列化成功，序列化时还是使用的id！！！</p><hr><h4 id="配置在field上"><a href="#配置在field上" class="headerlink" title="配置在field上"></a><strong>配置在field上</strong></h4><p>和配置在set、get方法一样，只是配置在field上，相当于在set、get上面配置了，即：反序列化和序列化都起作用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"My_id"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    省略字段的set、get方法，toString方法<span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{'My_id':18,'name':'gakki'}"</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"My_id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><hr><p>验证：当我们javaBean对象的属性使用：private修饰时，不配置set、get方法，看FastJson是否能正确的反序列化和序列化成功。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Person{"</span> <span class="token operator">+</span>                <span class="token string">"id="</span> <span class="token operator">+</span> id <span class="token operator">+</span>                <span class="token string">", name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">", address='"</span> <span class="token operator">+</span> address <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{'id':18,'name':'gakki'}"</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        String s <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">Person<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>发现，不配置私有属性的get和set方法，反序列化和序列化是失败的！！！</p><hr><p>我们加上构造方法呢？</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> String name<span class="token punctuation">,</span> String address<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Person{"</span> <span class="token operator">+</span>                <span class="token string">"id="</span> <span class="token operator">+</span> id <span class="token operator">+</span>                <span class="token string">", name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">", address='"</span> <span class="token operator">+</span> address <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Person<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>发现，反序列化成功了，但是序列化失败了，加上构造方法后，就会使用构造方法来反序列化了，和加上set方法是同样的作用。</p><h4 id="使用format配置日期格式化"><a href="#使用format配置日期格式化" class="headerlink" title="使用format配置日期格式化"></a><strong>使用format配置日期格式化</strong></h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>format<span class="token operator">=</span><span class="token string">"yyyyMMdd"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    ···<span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{'id':18,'name':'gakki','birthday':'20191222'}"</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        String s <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">Person<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Sun Dec <span class="token number">22</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2019</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"20191222"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>可以看到，json字符串中的birthday字符串格式的日期，反序列化成功为Person对象中的Date类型，序列化时又变成了我们配置的格式。</p><h4 id="使用serialize-deserialize指定字段不序列化"><a href="#使用serialize-deserialize指定字段不序列化" class="headerlink" title="使用serialize/deserialize指定字段不序列化"></a><strong>使用serialize/deserialize指定字段不序列化</strong></h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>serialize <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>deserialize <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>format <span class="token operator">=</span> <span class="token string">"yyyyMMdd"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    ··· <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{'id':18,'name':'gakki','birthday':'20191222'}"</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        String s <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span>SerializerFeature<span class="token punctuation">.</span>WriteMapNullValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">Person<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Sun Dec <span class="token number">22</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2019</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"20191222"</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><p>说明：id反序列化成功为18，但是禁止序列化，没有输出，name反序列化失败，允许序列化。</p><p>默认情况下：serialize 和 deserialize 都是 true。</p><p>注意：<font color="red"><strong>当你写了javaBean的有参的构造函数后，必须补全无参的构造函数</strong>！！！</font></p><hr><p>如果，我们想指定某些属性为null序列化，其他为null的属性不序列化，该怎么办呢？</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>serialize <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>deserialize <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>serialzeFeatures <span class="token operator">=</span> <span class="token punctuation">{</span>SerializerFeature<span class="token punctuation">.</span>WriteMapNullValue<span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>format <span class="token operator">=</span> <span class="token string">"yyyyMMdd"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    ··· <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String json <span class="token operator">=</span> <span class="token string">"{'id':18,'name':'gakki','birthday':'20191222'}"</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        String s <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Person<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Sun Dec <span class="token number">22</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2019</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"20191222"</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><p>这里，我们在name属性上，配置了：serialzeFeatures = {SerializerFeature.WriteMapNullValue 。</p><p>在JSON.toJSONString()时，没有配置SerializerFeature.WriteMapNullValue。此时只会当name为null时，才会输出null，address为null，不会输出。</p><p>JSON.toJSONString() 配置：SerializerFeature 是全局的作用，即所有的属性都起作用，对当个属性使用@JSONField注解来配置SerializerFeature只对当前的属性起作用。</p><hr><h4 id="使用ordinal指定字段的顺序"><a href="#使用ordinal指定字段的顺序" class="headerlink" title="使用ordinal指定字段的顺序"></a><strong>使用ordinal指定字段的顺序</strong></h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>format <span class="token operator">=</span> <span class="token string">"yyyyMMdd"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{'id':18,'name':'gakki','birthday':'20191222'}"</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        String s <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">Person<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Sun Dec <span class="token number">22</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2019</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"20191222"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>此时序列化的顺序，应该是按照英文字母的顺序，birthday因为是b开头是最早的，所以序列化时排在第一位。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>ordinal <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>ordinal <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>ordinal <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>ordinal <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>format <span class="token operator">=</span> <span class="token string">"yyyyMMdd"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Person<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Sun Dec <span class="token number">22</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2019</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"20191222"</span><span class="token punctuation">}</span></code></pre><p>此时，按照：ordinal给定的顺序来序列化，ordinal值越小越先被序列化。</p><font color="red">这是：FastJson相对于GSON的优势，GSON中没有注解来配置序列化的顺序，必须重新配置序列化解析器来自定义顺序，比较麻烦。</font><hr><h4 id="使用serializeUsing制定属性的序列化类"><a href="#使用serializeUsing制定属性的序列化类" class="headerlink" title="使用serializeUsing制定属性的序列化类"></a><strong>使用serializeUsing制定属性的序列化类</strong></h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>ordinal <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>ordinal <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> serializeUsing <span class="token operator">=</span> NameSerialized<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>ordinal <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>ordinal <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> format <span class="token operator">=</span> <span class="token string">"yyyyMMdd"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>单独给name属性配置序列化类：NameSerialized 【实现ObjectSerializer接口】</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NameSerialized</span> <span class="token keyword">implements</span> <span class="token class-name">ObjectSerializer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span>JSONSerializer jsonSerializer<span class="token punctuation">,</span> Object object<span class="token punctuation">,</span> Object fieldName<span class="token punctuation">,</span> Type fieldType<span class="token punctuation">,</span> <span class="token keyword">int</span> features<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fieldName<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fieldType<span class="token punctuation">.</span><span class="token function">getTypeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>features<span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonSerializer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"你名字是"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{'id':18,'name':'gakki','birthday':'20191222'}"</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        String s <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">Person<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Sun Dec <span class="token number">22</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2019</span><span class="token punctuation">}</span>gakkinamejava<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token number">0</span><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"你名字是"</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"20191222"</span><span class="token punctuation">}</span></code></pre><p>说明：write函数中，第一个参数是：jsonSerializer 序列化器，使用其来进行序列化的，第二个参数就是 name属性的值，第三个Object是 name属性的名字，第四个参数是name属性的类型，此处是String类型，第五个参数，features是序列化时的顺序，即：第几个被序列化的，此处是对name单独进行序列化的，所以是0。（默认是从0开始的）。</p><h4 id="使用deserializeUsing制定属性的反序列化类"><a href="#使用deserializeUsing制定属性的反序列化类" class="headerlink" title="使用deserializeUsing制定属性的反序列化类"></a><strong>使用deserializeUsing制定属性的反序列化类</strong></h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>ordinal <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> deserializeUsing <span class="token operator">=</span> IdDeserialized<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>ordinal <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>ordinal <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>ordinal <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> format <span class="token operator">=</span> <span class="token string">"yyyyMMdd"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>IdDeserialized 实现：ObjectDeserializer 接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IdDeserialized</span> <span class="token keyword">implements</span> <span class="token class-name">ObjectDeserializer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">deserialze</span><span class="token punctuation">(</span>DefaultJSONParser parser<span class="token punctuation">,</span> Type type<span class="token punctuation">,</span> Object fieldName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">getTypeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fieldName<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object o <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>fieldName<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer value <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Integer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> o<span class="token punctuation">;</span>            value <span class="token operator">+=</span> <span class="token number">20</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getFastMatchToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{'id':20,'name':'gakki','birthday':'20191222'}"</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        String s <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span>id<span class="token number">20</span>Person<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">40</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Sun Dec <span class="token number">22</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2019</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"20191222"</span><span class="token punctuation">}</span></code></pre><p>此时：id原来的值为：20，我们自定义的反序列化类将其加了20，最后反序列的值为：40。</p><p>一般，我们开发的过程中是不会随便修改传递过来的值，这里只是为了演示反序列化类的作用。</p><hr><h4 id="alternateNames-别名"><a href="#alternateNames-别名" class="headerlink" title="alternateNames 别名"></a>alternateNames 别名</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>alternateNames <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"my_id"</span><span class="token punctuation">,</span><span class="token string">"My_id"</span><span class="token punctuation">,</span><span class="token string">"MyId"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JSONField</span><span class="token punctuation">(</span>format <span class="token operator">=</span> <span class="token string">"yyyyMMdd"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{'id':18,'MyId':22,'My_id':24,'name':'gakki','birthday':'20191222'}"</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        String s <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">Person<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">24</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Sun Dec <span class="token number">22</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span> CST <span class="token number">2019</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"20191222"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>多个匹配时，以最后一个匹配为准，这里就是匹配了：My_id，最后输出为：24。</p><hr><p>@JSONType 和 @JSONField类似，只是@JSONType作用与类上面而已。</p>]]></content>
      
      
      <categories>
          
          <category> FastJson </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastJson的进阶&lt;一&gt;</title>
      <link href="/2019/12/22/fastjson-de-jin-jie-yi/"/>
      <url>/2019/12/22/fastjson-de-jin-jie-yi/</url>
      
        <content type="html"><![CDATA[<p>该篇，会总结FastJson中的一些常用API</p><h3 id="FastJson主要的API"><a href="#FastJson主要的API" class="headerlink" title="FastJson主要的API"></a><strong>FastJson主要的API</strong></h3><p>fastjson入口类是com.alibaba.fastjson.JSON, 主要API是<strong>JSON.toJSONString</strong>和<strong>parseObject</strong>，使用fastjson要注意要转换的类必须有默认的无参构造方法。</p><ul><li><p>序列化:<br><code>String jsonString = JSON.toJSONString(obj);</code></p></li><li><p>反序列化:<br><code>VO vo = JSON.parseObject(&quot;jsonString&quot;, VO.class);</code></p></li><li><p>泛型反序列化:</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>VO<span class="token operator">></span> list <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span><span class="token string">"jsonString"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TypeReference</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>VO<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>注意：VO必须有默认无参构造方法</code></pre></li><li><p>其他主要API:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object <span class="token function">parse</span><span class="token punctuation">(</span>String text<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 把JSON文本parse为JSONObject或者JSONArray </span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> JSONObject <span class="token function">parseObject</span><span class="token punctuation">(</span>String text<span class="token punctuation">)</span>； <span class="token comment" spellcheck="true">// 把JSON文本parse成JSONObject    </span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">parseObject</span><span class="token punctuation">(</span>String text<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> clazz<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 把JSON文本parse为JavaBean </span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> JSONArray <span class="token function">parseArray</span><span class="token punctuation">(</span>String text<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 把JSON文本parse成JSONArray </span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">parseArray</span><span class="token punctuation">(</span>String text<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> clazz<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把JSON文本parse成JavaBean集合 </span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String <span class="token function">toJSONString</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将JavaBean序列化为JSON文本 </span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String <span class="token function">toJSONString</span><span class="token punctuation">(</span>Object object<span class="token punctuation">,</span> <span class="token keyword">boolean</span> prettyFormat<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将JavaBean序列化为带格式的JSON文本 </span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object <span class="token function">toJSON</span><span class="token punctuation">(</span>Object javaObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将JavaBean转换为JSONObject或者JSONArray。</span></code></pre><p>说明：<br>SerializeWriter：相当于StringBuffer<br>JSONArray：相当于List<br>JSONObject：相当于Map</p></li></ul><pre class=" language-java"><code class="language-java">JSON<span class="token punctuation">.</span>DEFFAULT_DATE_FORMAT <span class="token operator">=</span> <span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">;</span>  JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> SerializerFeature<span class="token punctuation">.</span>WriteDateUseDateFormat<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>反序列化能够自动识别如下日期格式：</li></ul><pre class=" language-java"><code class="language-java">ISO<span class="token operator">-</span><span class="token number">8601</span>日期格式yyyy<span class="token operator">-</span>MM<span class="token operator">-</span>ddyyyy<span class="token operator">-</span>MM<span class="token operator">-</span>dd HH<span class="token operator">:</span>mm<span class="token operator">:</span>ssyyyy<span class="token operator">-</span>MM<span class="token operator">-</span>dd HH<span class="token operator">:</span>mm<span class="token operator">:</span>ss<span class="token punctuation">.</span>SSS毫秒数字毫秒数字字符串NET JSON日期格式<span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">198293238</span><span class="token punctuation">)</span></code></pre><ul><li>SerializerFeature序列化属性</li></ul><pre class=" language-java"><code class="language-java">DisableCheckSpecialChar：一个对象的字符串属性中如果有特殊字符如双引号，将会在转成json时带有反斜杠转移符。如果不需要转义，可以使用这个属性。默认为<span class="token boolean">false</span> QuoteFieldNames———<span class="token operator">-</span>输出key时是否使用双引号<span class="token punctuation">,</span>默认为<span class="token boolean">true</span> WriteMapNullValue——–是否输出值为null的字段<span class="token punctuation">,</span>默认为<span class="token boolean">false</span> WriteNullNumberAsZero—<span class="token operator">-</span>数值字段如果为null<span class="token punctuation">,</span>输出为<span class="token number">0</span><span class="token punctuation">,</span>而非null WriteNullListAsEmpty—–List字段如果为null<span class="token punctuation">,</span>输出为<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>而非null WriteNullStringAsEmpty—字符类型字段如果为null<span class="token punctuation">,</span>输出为<span class="token string">""</span><span class="token punctuation">,</span>而非null WriteNullBooleanAsFalse–Boolean字段如果为null<span class="token punctuation">,</span>输出为<span class="token boolean">false</span><span class="token punctuation">,</span>而非nullWriteClassName<span class="token operator">:</span>支持序列化时写入类型信息，从而使得反序列化时不丢失类型信息。例如：Color color <span class="token operator">=</span> Color<span class="token punctuation">.</span>RED<span class="token punctuation">;</span> String text <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span>SerializerFeature<span class="token punctuation">.</span>WriteClassName<span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span> 输出结果：<span class="token punctuation">{</span><span class="token string">"@type"</span><span class="token operator">:</span><span class="token string">"java.awt.Color"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token operator">:</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token string">"g"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"alpha"</span><span class="token operator">:</span><span class="token number">255</span><span class="token punctuation">}</span>由于序列化带了类型信息，使得反序列化时能够自动进行类型识别，例如：String text <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{"@type":"java.awt.Color","r":255,"g":0,"b":0,"alpha":255}</span>Color color <span class="token operator">=</span> <span class="token punctuation">(</span>Color<span class="token punctuation">)</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>反序列一个javaBean对象：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{'id':18,'name':'gakki'}"</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">}</span></code></pre><p>说明：这里我们直接将json字符串反序列了javaBean对象：user，使用是带有Class参数的parseObject方法，不需要再操作JSOObject对象了，方便了很多。</p><hr><p>反序列化json数组《一》：</p><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"[{'id':18,'name':'gakki'},{'id':19,'name':'dj','address':'东京'},{'id':20,'name':'ldlove','address':'冲绳'}]"</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> userList <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseArray</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">19</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'dj'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'ldlove'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳'</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><p>看到这里，小伙伴们，是否发现了FastJson对于GSON的区别，GSON反序列化数组类型时，需要使用TypeToken来保存泛型类型，这里FastJson直接使用User.class即可，不过使用的是：parseArray 方法，注意区别 parseObejc。</p><hr><p>反序列化json数组《二》：</p><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"[{'id':18,'name':'gakki'},{'id':19,'name':'dj','address':'东京'},{'id':20,'name':'ldlove','address':'冲绳'}]"</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> userList <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TypeReference</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>User<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span></code></pre><p>这里，我们使用的是：parseObject方法，但是第二个参数不再是User.class，而是: TypeReference对象，这里就和GSON中的：TypeToken对象类似了，都是创建匿名子类对象来保存泛型信息。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化一个javaBean对象：</p><pre class=" language-java"><code class="language-java">        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"冲绳"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"冲绳"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>说明：直接使用：toJSONString方法，不再使用JSONObject对象来put一系列操作了，方便了很多。</p><hr><p>序列化javaBean数组或List集合</p><pre class=" language-java"><code class="language-java">        List<span class="token operator">&lt;</span>User<span class="token operator">></span> userList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"gakki"</span><span class="token punctuation">,</span> <span class="token string">"冲绳"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span> <span class="token string">"东京"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">"gakkil"</span><span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"冲绳"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"东京"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakkij"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"上海"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakkil"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><hr><p>当序列化的javaBean对象中，有null值的情况：</p><pre class=" language-java"><code class="language-java">        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"gakki"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>默认情况是：不序列化值为null，如果我们也想序列化值为null的情况呢? 就和GSON中使用GsonBuilder一样。</p><pre class=" language-java"><code class="language-java">        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"gakki"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> SerializerFeature<span class="token punctuation">.</span>WriteMapNullValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>我们只需要使用 toJSONString的其他重载的方法，带上：SerializerFeature的参数即可，比GSON中需要使用GsonBuilder来的方便有没有！</p><p>SerializerFeature.WriteMapNullValue：将值为null的也输出为 null。</p><p>SerializerFeature还有很多选择的类型，大家可以自己去试试：</p><pre class=" language-java"><code class="language-java">        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"gakki"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> SerializerFeature<span class="token punctuation">.</span>WriteNullStringAsEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>SerializerFeature.WriteNullStringAsEmpty：输出为：” “ ，不再是 null 。</p><pre class=" language-java"><code class="language-java">        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"gakki"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span>SerializerFeature<span class="token punctuation">.</span>PrettyFormat<span class="token punctuation">,</span>SerializerFeature<span class="token punctuation">.</span>WriteNullStringAsEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">}</span><span class="token punctuation">{</span>    <span class="token string">"address"</span><span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">,</span>    <span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span>    <span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">}</span></code></pre><p>SerializerFeature.PrettyFormat：输出为漂亮的格式。</p><p>PS：JSON.toJSONString中的SerializerFeature.XXXX 可以是多个。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">toJSONString</span><span class="token punctuation">(</span>Object object<span class="token punctuation">,</span> SerializerFeature<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> features<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">toJSONString</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> DEFAULT_GENERATE_FEATURE<span class="token punctuation">,</span> features<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>人家是可变参数！！！</p>]]></content>
      
      
      <categories>
          
          <category> FastJson </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastJson的入门</title>
      <link href="/2019/12/22/fastjson-de-ru-men/"/>
      <url>/2019/12/22/fastjson-de-ru-men/</url>
      
        <content type="html"><![CDATA[<p>今天开始，让我们一起来学习FastJson的用法，FastJson也是一款开源的Json的解析工具，在接下来的篇章中，我们会看到它与Gson的不同之处的，FastJson号称是最快的Json解析器。</p><h3 id="FastJson简介"><a href="#FastJson简介" class="headerlink" title="FastJson简介"></a>FastJson简介</h3><p>JSON协议使用方便，越来越流行,JSON的处理器有很多,这里我介绍一下FastJson,FastJson是阿里的开源框架,被不少企业使用,是一个极其优秀的Json框架,Github地址: <a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">FastJson</a></p><h3 id="FastJson三个核心类"><a href="#FastJson三个核心类" class="headerlink" title="FastJson三个核心类"></a>FastJson三个核心类</h3><ul><li>JSON：fastjson的解析器，用于json字符串和javaBean、Json对象的转换</li><li>JSONObject：fastJson提供的json对象</li><li>JSONArray：fastJson提供json数组对象</li></ul><h3 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h3><p>这里，我使用的是Maven工程：</p><pre class=" language-java"><code class="language-java">        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>com<span class="token punctuation">.</span>alibaba<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>fastjson<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">1.2</span><span class="token punctuation">.</span><span class="token number">58</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre><p>1.2.58的版本，尽量更新到最新版本，因为，最近fastjson报出系统漏洞问题，最新版本的已经解决该漏洞，存在循环解析死循环的问题！！！</p><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>反序列化一个简单Json字符串</p><p>创建JavaBean的User类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAddress</span><span class="token punctuation">(</span>String address<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"User{"</span> <span class="token operator">+</span>                <span class="token string">"id="</span> <span class="token operator">+</span> id <span class="token operator">+</span>                <span class="token string">", name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">", address='"</span> <span class="token operator">+</span> address <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{'id':18,'name':'gakki'}"</span><span class="token punctuation">;</span>        JSONObject jsonObject <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//JSONObject jsonObject1 = JSONObject.parseObject(json);  //与上面等价</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">getInteger</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">}</span></code></pre><p>说明：首先我们判断json字符串的根是Json对象还是JsonArray数组，这里是Json对象，因此使用：Json.parseObject()方法 ，或者是：JSONObject.parseObject() 方法。</p><p>通过：containsKey 方法来判断是否存在key值来给JavaBean对象相应的属性赋值！</p><p>这里，因为json字符串中没有address的key，因此，最后输出的User对象中，address为null。</p><p>注意：<font color="red">JSON，JSONObject，JSONArray是：com.alibaba.fastjson.JSON，com.alibaba.fastjson.JSONObject，com.alibaba.fastjson.JSONArray。不是：官方的org.json.JSONObject，org.json.JSONArray。</font></p><hr><p>反序列化一个简单JSON字符串成Java对象组【数组中都是相同类型对象】</p><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"[{'id':18,'name':'gakki'},{'id':19,'name':'dj','address':'东京'},{'id':20,'name':'ldlove','address':'冲绳'}]"</span><span class="token punctuation">;</span>        JSONArray jsonArray <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseArray</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//JSONArray jsonArray1 = JSONArray.parseArray(json); //同上</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> userList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> jsonArray<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            JSONObject jsonObject <span class="token operator">=</span> jsonArray<span class="token punctuation">.</span><span class="token function">getJSONObject</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">getInteger</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            userList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">19</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'dj'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'ldlove'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳'</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><p>说明：首先判断json字符串的根是Json对象还是Json数组，很明显这里是json数组，因此使用：JSON.parseArray</p><p>然后，循环遍历jsonArray，jsonArray有多个getXXXX方法，我们需要确定json数组字符串中是不是都是json对象，这里都是User对象，因此统一都使用：jsonArray.getJSONObject(i)来获取：JSONObject。如果不统一，请分开处理。</p><hr><p>反序列化一个简单JSON字符串成Java对象组【数组中是不同类型对象】</p><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"[1,'gakkij',{'id':18,'name':'gakki','address':'冲绳'}]"</span><span class="token punctuation">;</span>        JSONArray jsonArray <span class="token operator">=</span> JSONArray<span class="token punctuation">.</span><span class="token function">parseArray</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer id <span class="token operator">=</span> jsonArray<span class="token punctuation">.</span><span class="token function">getInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String name <span class="token operator">=</span> jsonArray<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JSONObject jsonObject <span class="token operator">=</span> jsonArray<span class="token punctuation">.</span><span class="token function">getJSONObject</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">getInteger</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"id:"</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name:"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"User:"</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">id<span class="token operator">:</span><span class="token number">1</span>name<span class="token operator">:</span>gakkijUser<span class="token operator">:</span>User<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳'</span><span class="token punctuation">}</span></code></pre><p>大家应该看出与上一个例子的差别了吧！！！</p><hr><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>序列化一个Java Bean对象</p><pre class=" language-java"><code class="language-java">        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"gakki"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"冲绳"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JSONObject jsonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json1 <span class="token operator">=</span> JSONObject<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//等价</span>        String json2 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//等价</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"冲绳"</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"冲绳"</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"冲绳"</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">}</span></code></pre><p>序列化一个对象就是使用：JSONObject来序列化。</p><p>注意：序列化的顺序不是我们put的先后顺序！！！</p><hr><p>序列化一个java数组</p><pre class=" language-java"><code class="language-java">        JSONArray jsonArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> userList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"gakki"</span><span class="token punctuation">,</span> <span class="token string">"冲绳"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">"jackLove"</span><span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        userList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> userList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            JSONObject jsonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">,</span> userList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> userList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">,</span> userList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            jsonArray<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String json <span class="token operator">=</span> jsonArray<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json1 <span class="token operator">=</span> JSONArray<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>jsonArray<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//等价</span>        String json2 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>jsonArray<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//等价</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"冲绳"</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"上海"</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"jackLove"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"冲绳"</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"上海"</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"jackLove"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"冲绳"</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"上海"</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"jackLove"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><h4 id="序列化和反序列日期"><a href="#序列化和反序列日期" class="headerlink" title="序列化和反序列日期"></a>序列化和反序列日期</h4><pre class=" language-java"><code class="language-java">Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String dateString <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONStringWithDateFormat</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dateString<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出结果 "2019-12-22 09:44:21"</span>String dateString1 <span class="token operator">=</span> <span class="token string">"{\"time\":\"2019-12-22 22:22:22\"}"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>dateString1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出结果 {"time":"2019-12-22 22:22:22"}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> FastJson </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSON的进阶&lt;四&gt;</title>
      <link href="/2019/12/21/gson-de-jin-jie-si/"/>
      <url>/2019/12/21/gson-de-jin-jie-si/</url>
      
        <content type="html"><![CDATA[<h3 id="TypeAdapter"><a href="#TypeAdapter" class="headerlink" title="TypeAdapter"></a>TypeAdapter</h3><p><code>TypeAdapter</code> 是GSON自2.0（源码注释上说的是2.1）开始版本提供的一个抽象类，用于<strong>接管某种类型的序列化和反序列化过程</strong>，包含两个注要方法 <code>write(JsonWriter,T)</code> 和 <code>read(JsonReader)</code> 其它的方法都是<code>final</code>方法并最终调用这两个抽象方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">TypeAdapter</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span>JsonWriter out<span class="token punctuation">,</span> T value<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> T <span class="token function">read</span><span class="token punctuation">(</span>JsonReader in<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//其它final 方法就不贴出来了，包括`toJson`、`toJsonTree`、`toJson`和`nullSafe`方法。</span><span class="token punctuation">}</span></code></pre><p><strong>注意：</strong>TypeAdapter 以及 JsonSerializer 和 JsonDeserializer 都需要与 <code>GsonBuilder.registerTypeAdapter</code> 或<code>GsonBuilder.registerTypeHierarchyAdapter</code>配合使用，下面将不再重复说明。</p><p>使用示例：</p><pre class=" language-java"><code class="language-java">        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUserName</span><span class="token punctuation">(</span><span class="token string">"gakki"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUserAge</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUserAddress</span><span class="token punctuation">(</span><span class="token string">"冲绳"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerTypeAdapter</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">UserTypeAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>UserTypeAdapter:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserTypeAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">TypeAdapter</span><span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span>JsonWriter jsonWriter<span class="token punctuation">,</span> User user<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">int</span> userAge <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">getUserAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String userName <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">getUserName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String userAddress <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">getUserAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonWriter<span class="token punctuation">.</span><span class="token function">beginObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonWriter<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"xxxx_age"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>userAge <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"xxx_name"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>userName <span class="token operator">+</span> <span class="token string">" love dj"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"xxxx_address"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>userAddress <span class="token operator">+</span> <span class="token string">" 东京"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonWriter<span class="token punctuation">.</span><span class="token function">endObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonWriter<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> User <span class="token function">read</span><span class="token punctuation">(</span>JsonReader jsonReader<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"xxxx_age"</span><span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token string">"xxx_name"</span><span class="token operator">:</span><span class="token string">"gakki love dj"</span><span class="token punctuation">,</span><span class="token string">"xxxx_address"</span><span class="token operator">:</span><span class="token string">"冲绳 东京"</span><span class="token punctuation">}</span></code></pre><p>大家感受到了，TypeAdapter的强大的吧！[完全自定义，序列化和反序列化的过程，顺序，重命名，修改value值]。</p><p>注意：当我们为<code>User.class</code> 注册了 <code>TypeAdapter</code>之后，只要是操作<code>User.class</code> 那些之前介绍的<code>@SerializedName</code> 、<code>FieldNamingStrategy</code>、<code>@Since</code>、<code>@Until</code>、<code>@Expose</code>通通都黯然失色，失去了效果，只会调用我们实现的<code>UserTypeAdapter.write(JsonWriter, User)</code> 方法，我想怎么写就怎么写。</p><hr><p>再说一个场景，在该系列的第一篇文章就说到了Gson有一定的容错机制，比如将字符串 <code>&quot;24&quot;</code> 转成int 的<code>24</code>,但如果有些情况下给你返了个空字符串怎么办（有人给我评论问到这个问题）?虽然这是服务器端的问题，但这里我们只是做一个示范。</p><p>int型会出错是吧，根据我们上面介绍的，我注册一个TypeAdapter 把 序列化和反序列化的过程接管不就行了?</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer integer <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token string">"''"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 和下面等同，都是空字符串的意思</span>        <span class="token comment" spellcheck="true">//Integer integer = gson.fromJson("\"\"", int.class); </span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>JsonSyntaxException<span class="token operator">:</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>NumberFormatException<span class="token operator">:</span> empty String    at com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>TypeAdapters$<span class="token number">7</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>TypeAdapters<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">228</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>TypeAdapters$<span class="token number">7</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>TypeAdapters<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">218</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>Gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>Gson<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">927</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>Gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>Gson<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">892</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>Gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>Gson<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">841</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>Gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>Gson<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">813</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>GsonDemo3<span class="token punctuation">.</span><span class="token function">testInteger</span><span class="token punctuation">(</span>GsonDemo3<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">135</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>GsonDemo3<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>GsonDemo3<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">148</span><span class="token punctuation">)</span>Caused by<span class="token operator">:</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>NumberFormatException<span class="token operator">:</span> empty String    at sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>FloatingDecimal<span class="token punctuation">.</span><span class="token function">readJavaFormatString</span><span class="token punctuation">(</span>FloatingDecimal<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1842</span><span class="token punctuation">)</span>    at sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>FloatingDecimal<span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>FloatingDecimal<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">110</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Double<span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">538</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>JsonReader<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>JsonReader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1201</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>TypeAdapters$<span class="token number">7</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>TypeAdapters<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">226</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token number">7</span> more</code></pre><p>报错了，说明默认反序列空串到int类型时是出错的，我们该怎么办呢？我们完全可以自定义int类型的序列化和反序列化。</p><pre class=" language-java"><code class="language-java">        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerTypeAdapter</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TypeAdapter</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span>JsonWriter jsonWriter<span class="token punctuation">,</span> Integer integer<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//System.out.println(integer);</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>integer <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    jsonWriter<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>integer <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    jsonWriter<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Integer <span class="token function">read</span><span class="token punctuation">(</span>JsonReader jsonReader<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                String s <span class="token operator">=</span> jsonReader<span class="token punctuation">.</span><span class="token function">nextString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NumberFormatException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer integer <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token string">"\"\""</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token operator">-</span><span class="token number">1</span><span class="token string">"9"</span></code></pre><p>当反序化的int类型是空串时，我进行Integer.parseInt解析时就出抛出异常，然后返回-1。</p><p>当序列化-1时，我们直接加了10。</p><p>完全自控有没有！！！这里注意的是：jsonWriter使用时，如果没有name的要求，就不需要写，如果你写了begin，就必须写name！！！</p><hr><p>注：测试空串的时候一定是<code>&quot;\&quot;\&quot;&quot;</code>而不是<code>&quot;&quot;</code>，<code>&quot;&quot;</code>代表的是没有json串，<code>&quot;\&quot;\&quot;&quot;</code>才代表json里的<code>&quot;&quot;</code>。</p><p>你说这一接管就要管两样好麻烦呀，我明明只想管序列化（或反列化）的过程的，另一个过程我并不关心，难道没有其它更简单的方法么? 当然有！就是接下来要介绍的 <strong>JsonSerializer与JsonDeserializer</strong>。</p><h3 id="JsonSerializer与JsonDeserializer"><a href="#JsonSerializer与JsonDeserializer" class="headerlink" title="JsonSerializer与JsonDeserializer"></a>JsonSerializer与JsonDeserializer</h3><p><code>JsonSerializer</code> 和<code>JsonDeserializer</code> 不用像<code>TypeAdapter</code>一样，必须要实现序列化和反序列化的过程，你可以据需要选择，如只接管序列化的过程就用 <code>JsonSerializer</code> ，只接管反序列化的过程就用 <code>JsonDeserializer</code> ，如上面的需求可以用下面的代码。</p><pre class=" language-java"><code class="language-java">Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">registerTypeAdapter</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">JsonDeserializer</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Integer <span class="token function">deserialize</span><span class="token punctuation">(</span>JsonElement json<span class="token punctuation">,</span> Type typeOfT<span class="token punctuation">,</span> JsonDeserializationContext context<span class="token punctuation">)</span> <span class="token keyword">throws</span> JsonParseException <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> json<span class="token punctuation">.</span><span class="token function">getAsInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NumberFormatException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//结果：100</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token string">"\"\""</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//结果-1</span></code></pre><p>下面是所有数字都转成序列化为字符串的例子:</p><pre class=" language-java"><code class="language-java">JsonSerializer<span class="token operator">&lt;</span>Number<span class="token operator">></span> numberJsonSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonSerializer</span><span class="token operator">&lt;</span>Number<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> JsonElement <span class="token function">serialize</span><span class="token punctuation">(</span>Number src<span class="token punctuation">,</span> Type typeOfSrc<span class="token punctuation">,</span> JsonSerializationContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JsonPrimitive</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">registerTypeAdapter</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> numberJsonSerializer<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">registerTypeAdapter</span><span class="token punctuation">(</span>Long<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> numberJsonSerializer<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">registerTypeAdapter</span><span class="token punctuation">(</span>Float<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> numberJsonSerializer<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">registerTypeAdapter</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> numberJsonSerializer<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span><span class="token number">100.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//结果："100.0"</span></code></pre><p>注：<code>registerTypeAdapter</code>必须使用包装类型，所以<code>int.class</code>,<code>long.class</code>,<code>float.class</code>和<code>double.class</code>是行不通的。同时不能使用父类来替上面的子类型，这也是为什么要分别注册而不直接使用<code>Number.class</code>的原因。</p><p>上面特别说明了<code>registerTypeAdapter</code>不行，那就是有其它方法可行咯?当然！换成<strong><code>registerTypeHierarchyAdapter</code> </strong>就可以使用<code>Number.class</code>而不用一个一个的当独注册啦！</p><p><strong>registerTypeAdapter与registerTypeHierarchyAdapter的区别：</strong></p><table><thead><tr><th></th><th><strong>registerTypeAdapter</strong></th><th><strong>registerTypeHierarchyAdapter</strong></th></tr></thead><tbody><tr><td>支持泛型</td><td>是</td><td>否</td></tr><tr><td>支持继承</td><td>否</td><td>是</td></tr></tbody></table><hr><p>注：如果一个被序列化的对象本身就带有泛型，且注册了相应的<code>TypeAdapter</code>，那么必须调用<code>Gson.toJson(Object,Type)</code>，明确告诉Gson对象的类型。</p><h3 id="TypeAdapterFactory"><a href="#TypeAdapterFactory" class="headerlink" title="TypeAdapterFactory"></a>TypeAdapterFactory</h3><p>TypeAdapterFactory,见名知意，用于创建TypeAdapter的工厂类，通过对比<code>Type</code>，确定有没有对应的<code>TypeAdapter</code>，没有就返回null，与<code>GsonBuilder.registerTypeAdapterFactory</code>配合使用。</p><pre class=" language-java"><code class="language-java">Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">registerTypeAdapterFactory</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeAdapterFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> TypeAdapter<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>Gson gson<span class="token punctuation">,</span> TypeToken<span class="token operator">&lt;</span>T<span class="token operator">></span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>注意：</strong><code>JsonAdapter</code>的优先级比<code>GsonBuilder.registerTypeAdapter</code>的优先级更高。</p><h3 id="JsonAdapter注解"><a href="#JsonAdapter注解" class="headerlink" title="@JsonAdapter注解"></a>@JsonAdapter注解</h3><p><code>JsonAdapter</code>相较之前介绍的<code>SerializedName</code> 、<code>FieldNamingStrategy</code>、<code>Since</code>、<code>Until</code>、<code>Expos</code>这几个注解都是比较特殊的，其它的几个都是用在POJO的字段上，而这一个是用在POJO类上的，接收一个参数，且必须是<code>TypeAdpater</code>，<code>JsonSerializer</code>或<code>JsonDeserializer</code>这三个其中之一。</p><p>上面说<code>JsonSerializer</code>和<code>JsonDeserializer</code>都要配合<code>GsonBuilder.registerTypeAdapter</code>使用，但每次使用都要注册也太麻烦了，<code>JsonAdapter</code>就是为了解决这个痛点的。</p><p>使用方法（以User为例）：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@JsonAdapter</span><span class="token punctuation">(</span>UserTypeAdapter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//加在类上</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> String email<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>email <span class="token operator">=</span> email<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SerializedName</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"emailAddress"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String email<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用时不用再使用 <code>GsonBuilder</code>去注册<code>UserTypeAdapter</code>了。<br> <strong>注：</strong> <code>@JsonAdapter</code> 仅支持 <code>TypeAdapter</code>或<code>TypeAdapterFactory</code>( 2.7开始已经支持 JsonSerializer/JsonDeserializer)</p><pre class=" language-java"><code class="language-java">Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"怪盗kidou"</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token string">"ikidou@example.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//结果：{"name":"怪盗kidou","age":24,"email":"ikidou@example.com"}</span><span class="token comment" spellcheck="true">//为区别结果，特意把email字段与@SerializedName注解中设置的不一样</span></code></pre><p><strong>注意：</strong><code>@JsonAdapter</code>的优先级比<code>GsonBuilder.registerTypeAdapter</code>的优先级更高。</p><h3 id="TypeAdapter实例"><a href="#TypeAdapter实例" class="headerlink" title="TypeAdapter实例"></a>TypeAdapter实例</h3><p>注：这里的TypeAdapter泛指<code>TypeAdapter</code>、<code>JsonSerializer</code>和<code>JsonDeserializer</code>。<br> 这里的TypeAdapter 上面讲了一个自动将 字符串形式的数值转换成int型时可能出现 空字符串的问题，下面介绍一个其它读者的需求：</p><p>服务器返回的数据中data字段类型不固定，比如请求成功data是一个List,不成功的时候是String类型，这样前端在使用泛型解析的时候，怎么去处理呢？</p><p>其实这个问题的原因主要由服务器端造成的，接口设计时没有没有保证数据的一致性，正确的数据返回姿势：<strong>同一个接口任何情况下不得改变返回类型，要么就不要返，要么就返空值，如<code>null</code>、<code>[]</code>,<code>{}</code></strong>。</p><p>方案一：</p><pre class=" language-java"><code class="language-java">Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerTypeHierarchyAdapter</span><span class="token punctuation">(</span>List<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">JsonDeserializer</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">deserialize</span><span class="token punctuation">(</span>JsonElement json<span class="token punctuation">,</span> Type typeOfT<span class="token punctuation">,</span> JsonDeserializationContext context<span class="token punctuation">)</span> <span class="token keyword">throws</span> JsonParseException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>json<span class="token punctuation">.</span><span class="token function">isJsonArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//这里要自己负责解析了</span>            Gson newGson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> newGson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span>typeOfT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//和接口类型不符，返回空List</span>            <span class="token keyword">return</span> Collections<span class="token punctuation">.</span>EMPTY_LIST<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>方案二：</p><pre class=" language-java"><code class="language-java"> Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerTypeHierarchyAdapter</span><span class="token punctuation">(</span>List<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">JsonDeserializer</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">deserialize</span><span class="token punctuation">(</span>JsonElement json<span class="token punctuation">,</span> Type typeOfT<span class="token punctuation">,</span> JsonDeserializationContext context<span class="token punctuation">)</span> <span class="token keyword">throws</span> JsonParseException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>json<span class="token punctuation">.</span><span class="token function">isJsonArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            JsonArray array <span class="token operator">=</span> json<span class="token punctuation">.</span><span class="token function">getAsJsonArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Type itemType <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> typeOfT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            List list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                JsonElement element <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                Object item <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">deserialize</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> itemType<span class="token punctuation">)</span><span class="token punctuation">;</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//和接口类型不符，返回空List</span>            <span class="token keyword">return</span> Collections<span class="token punctuation">.</span>EMPTY_LIST<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>要注意的点：</p><ul><li>必须使用<code>registerTypeHierarchyAdapter</code>方法，不然对List的子类无效，但如果POJO中都是使用List，那么可以使用<code>registerTypeAdapter</code>。</li><li>于是数组的情况，需要创建一个新的Gson，不可以直接使用context,不然gson又会调我们自定义的<code>JsonDeserializer</code>造成递归调用，方案二没有重新创建Gson，那么就需要提取出List<e>中E的类型，然后分别反序列化适合为E手动注册了TypeAdaper的情况。</e></li><li>从效率上推荐方案二，免去重新实例化Gson和注册其它TypeAdapter的过程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> GSON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSON的进阶&lt;三&gt;</title>
      <link href="/2019/12/20/gson-de-jin-jie-san/"/>
      <url>/2019/12/20/gson-de-jin-jie-san/</url>
      
        <content type="html"><![CDATA[<h3 id="过滤的几种方法"><a href="#过滤的几种方法" class="headerlink" title="过滤的几种方法"></a>过滤的几种方法</h3><p>字段过滤是Gson中比较常用的技巧，特别是在Android中，在处理业务逻辑时可能需要在设置的POJO中加入一些字段，但显然在序列化的过程中是不需要的，并且如果序列化还可能带来一个问题就是 <strong>循环引用</strong> ，那么在用Gson序列化之前为了防止这样的事件情发生，你不得不作另外的处理。</p><p>以一个商品分类<code>Category</code> 为例。</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"id"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"电脑"</span><span class="token punctuation">,</span>  <span class="token string">"children"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token string">"id"</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>      <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"笔记本"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token string">"id"</span><span class="token operator">:</span> <span class="token number">101</span><span class="token punctuation">,</span>      <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"台式机"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>一个大分类，可以有很多小分类，那么显然我们在设计<code>Category</code>类时<code>Category</code>本身既可以是大分类，也可以是小分类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Category</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">public</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Category<span class="token operator">></span> children<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>但是为了处理业务，我们还需要在子分类中保存父分类，最终会变成下面的情况</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Category</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">public</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Category<span class="token operator">></span> children<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//因业务需要增加，但并不需要序列化</span>    <span class="token keyword">public</span> Category parent<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>但是上面的<code>parent</code>字段是因业务需要增加的，那么在序列化是并不需要，所以在序列化时就必须将其排除，那么在<code>Gson</code>中如何排除符合条件的字段呢?下面提供4种方法，大家可根据需要自行选择合适的方式。</p><hr><h4 id="基于-Expose注解"><a href="#基于-Expose注解" class="headerlink" title="基于@Expose注解"></a>基于@Expose注解</h4><p><strong>@Expose</strong>提供了两个属性，且都有默认值，开发者可以根据需要设置不同的值。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Expose</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>@Expose</strong> 注解从名字上就可以看出是<strong>暴露</strong>的意思，所以该注解是用于对外暴露字段的。可是我们以前用Gson的时候也没有使用<strong>@Expose</strong> 注解，但是还不是可以正确的序列化为JSON嘛? 是的，所以<font color="red">该注解在使用<code>new Gson()</code> 时是不会发生作用</font>。毕竟最常用的API要最简单，所以该注解必须和<code>GsonBuilder</code>配合使用。</p><p><strong>使用方法：</strong> 简单说来就是需要导出的字段上加上<strong>@Expose</strong> 注解，不导出的字段不加。注意是<strong>不导出的不加</strong>。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Expose</span> <span class="token comment" spellcheck="true">//默认值是，序列化和反序列都为true</span><span class="token annotation punctuation">@Expose</span><span class="token punctuation">(</span>deserialize <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>serialize <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//序列化和反序列化都都生效，等价于上一条</span><span class="token annotation punctuation">@Expose</span><span class="token punctuation">(</span>deserialize <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>serialize <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//反序列化时生效</span><span class="token annotation punctuation">@Expose</span><span class="token punctuation">(</span>deserialize <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>serialize <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//序列化时生效</span><span class="token annotation punctuation">@Expose</span><span class="token punctuation">(</span>deserialize <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>serialize <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 和不写注解一样</span></code></pre><p>注：根据上面可以得出，所有值为<code>true</code>的属性都是可以不写的（默认值是true）。</p><hr><p>拿上面的例子来说就是</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Category</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Expose</span> <span class="token keyword">public</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Expose</span> <span class="token keyword">public</span> String name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Expose</span> <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Category<span class="token operator">></span> children<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//不需要序列化,所以不加 @Expose 注解，</span>    <span class="token comment" spellcheck="true">//等价于 @Expose(deserialize = false,serialize = false)</span>    <span class="token keyword">public</span> Category parent<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        Category category <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serializeNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">excludeFieldsWithoutExposeAnnotation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>category<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"children"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><p>因为，parent没有加上@Expose注解，所以不会被序列化。</p><h4 id="基于版本"><a href="#基于版本" class="headerlink" title="基于版本"></a>基于版本</h4><p>Gson在对基于版本的字段导出提供了两个注解 <code>@Since</code> 和 <code>@Until</code>,和<code>GsonBuilder.setVersion(Double double)</code>配合使用。<code>@Since</code> 和 <code>@Until</code>都接收一个<code>Double</code>值。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Since</span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Until</span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用方法：当前版本(GsonBuilder中设置的版本) <strong>大于等于Since</strong>的值时该字段导出，<strong>小于Until</strong>的值时该该字段导出。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SinceUntilSample</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Since</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String since<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Until</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String until<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sineUtilTest</span><span class="token punctuation">(</span><span class="token keyword">double</span> version<span class="token punctuation">)</span><span class="token punctuation">{</span>        SinceUntilSample sinceUntilSample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SinceUntilSample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sinceUntilSample<span class="token punctuation">.</span>since <span class="token operator">=</span> <span class="token string">"since"</span><span class="token punctuation">;</span>        sinceUntilSample<span class="token punctuation">.</span>until <span class="token operator">=</span> <span class="token string">"until"</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setVersion</span><span class="token punctuation">(</span>version<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>sinceUntilSample<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//当version &lt;4时，结果：{"until":"until"}</span><span class="token comment" spellcheck="true">//当version >=4 &amp;&amp; version &lt;5时，结果：{"since":"since","until":"until"}</span><span class="token comment" spellcheck="true">//当version >=5时，结果：{"since":"since"}</span></code></pre><p>注：当一个字段被同时注解时，需两者同时满足条件。</p><h4 id="基于访问修饰符"><a href="#基于访问修饰符" class="headerlink" title="基于访问修饰符"></a>基于访问修饰符</h4><p>什么是修饰符? <code>public</code>、<code>static</code> 、<code>final</code>、<code>private</code>、<code>protected</code> 这些就是，所以这种方式也是比较特殊的。<br>使用方式：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ModifierSample</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> String finalField <span class="token operator">=</span> <span class="token string">"final"</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> String staticField <span class="token operator">=</span> <span class="token string">"static"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String publicField <span class="token operator">=</span> <span class="token string">"public"</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> String protectedField <span class="token operator">=</span> <span class="token string">"protected"</span><span class="token punctuation">;</span>    String defaultField <span class="token operator">=</span> <span class="token string">"default"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String privateField <span class="token operator">=</span> <span class="token string">"private"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用<code>GsonBuilder.excludeFieldsWithModifiers</code>构建gson,支持<code>int</code>形的<strong>可变参数</strong>，值由<code>java.lang.reflect.Modifier</code>提供，下面的程序排除了<code>privateField</code> 、 <code>finalField</code> 和<code>staticField</code> 三个字段。</p><pre class=" language-java"><code class="language-java">ModifierSample modifierSample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ModifierSample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">excludeFieldsWithModifiers</span><span class="token punctuation">(</span>Modifier<span class="token punctuation">.</span>FINAL<span class="token punctuation">,</span> Modifier<span class="token punctuation">.</span>STATIC<span class="token punctuation">,</span> Modifier<span class="token punctuation">.</span>PRIVATE<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>modifierSample<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 结果：{"publicField":"public","protectedField":"protected","defaultField":"default"}</span></code></pre><p>到此为止，Gson提供的所有注解就还有一个<code>@JsonAdapter</code>没有介绍了，而<code>@JsonAdapter</code>将和<code>TypeAdapter</code>将作为该系列第4篇也是最后一篇文章的主要内容。</p><p>注意：<font color="red">使用基于修饰符的策略后，会覆盖默认的修饰词transient修饰词的座椅，即：transient将会失效！</font></p><h4 id="基于策略（自定义规则）"><a href="#基于策略（自定义规则）" class="headerlink" title="基于策略（自定义规则）"></a>基于策略（自定义规则）</h4><p>上面介绍了3种排除字段的方法，说实话我除了@Expose以外，其它的都是只在Demo用上过，用得最多的就是马上要介绍的自定义规则，好处是功能强大、灵活，缺点是相比其它3种方法稍麻烦一点，但也仅仅只是想对其它3种稍麻烦一点而已。</p><p>基于策略是利用Gson提供的<code>ExclusionStrategy</code>接口，同样需要使用<code>GsonBuilder</code>,相关API 2个，分别是<code>addSerializationExclusionStrategy</code> 和<code>addDeserializationExclusionStrategy</code> 分别针对序列化和反序化时。这里以序列化为例。</p><pre class=" language-java"><code class="language-java">Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">addSerializationExclusionStrategy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ExclusionStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldSkipField</span><span class="token punctuation">(</span>FieldAttributes f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 这里作判断，决定要不要排除该字段,return true为排除</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"finalField"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//按字段名排除</span>                Expose expose <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>Expose<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span>expose <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> expose<span class="token punctuation">.</span><span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//按注解排除</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldSkipClass</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 直接排除某个类 ，return true为排除</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span>clazz <span class="token operator">==</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">||</span> clazz <span class="token operator">==</span> Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Test:</p><pre class=" language-java"><code class="language-java">        Category category <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                <span class="token function">addSerializationExclusionStrategy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ExclusionStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldSkipField</span><span class="token punctuation">(</span>FieldAttributes fieldAttributes<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldSkipClass</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> aClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>aClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"com.liuzhuo.gson.domain.Category"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serializeNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>category<span class="token punctuation">)</span><span class="token punctuation">;</span>        String toJson <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>toJson<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">null<span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"userName"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><p>Category该类被排除了，而User类没有被排除掉。</p><pre class=" language-java"><code class="language-java">        Category category <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                <span class="token function">addSerializationExclusionStrategy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ExclusionStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldSkipField</span><span class="token punctuation">(</span>FieldAttributes fieldAttributes<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>fieldAttributes<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldSkipClass</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> aClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serializeNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>category<span class="token punctuation">)</span><span class="token punctuation">;</span>        String toJson <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>toJson<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>User 和 Category 都有name字段因此，两个类的name都被排除掉了。</p><hr><pre class=" language-java"><code class="language-java">        Category category <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                <span class="token function">addSerializationExclusionStrategy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ExclusionStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldSkipField</span><span class="token punctuation">(</span>FieldAttributes fieldAttributes<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fieldAttributes<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//                        if (fieldAttributes.getName().equals("id")) {</span><span class="token comment" spellcheck="true">//                            return true;</span><span class="token comment" spellcheck="true">//                        }</span>                        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldSkipClass</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> aClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serializeNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>category<span class="token punctuation">)</span><span class="token punctuation">;</span>        String toJson <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>toJson<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">idnamechildrenparentagenameaddressbirthday<span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"children"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"parent"</span><span class="token operator">:</span>null<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"userName"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><p>fieldAttributes : 是序列化类中的每一个属性。</p><hr><pre class=" language-java"><code class="language-java">        Category category <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                <span class="token function">addSerializationExclusionStrategy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ExclusionStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldSkipField</span><span class="token punctuation">(</span>FieldAttributes fieldAttributes<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//System.out.println(fieldAttributes.getName());</span><span class="token comment" spellcheck="true">//                        if (fieldAttributes.getName().equals("id")) {</span><span class="token comment" spellcheck="true">//                            return true;</span><span class="token comment" spellcheck="true">//                        }</span>                        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldSkipClass</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> aClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serializeNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>category<span class="token punctuation">)</span><span class="token punctuation">;</span>        String toJson <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>toJson<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>Category</span><span class="token keyword">int</span><span class="token keyword">int</span><span class="token keyword">class</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String</span><span class="token keyword">class</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String</span><span class="token keyword">interface</span> <span class="token class-name">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List</span><span class="token keyword">interface</span> <span class="token class-name">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List</span><span class="token keyword">class</span> <span class="token class-name">com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>Category</span><span class="token keyword">class</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Integer</span><span class="token keyword">class</span> <span class="token class-name">com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>json<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>User</span><span class="token keyword">int</span><span class="token keyword">class</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String</span><span class="token keyword">class</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String</span><span class="token keyword">class</span> <span class="token class-name">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date</span><span class="token keyword">class</span> <span class="token class-name">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date</span><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"children"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"parent"</span><span class="token operator">:</span>null<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"userName"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><p>这里将所有的类型都打印出来了，但是为啥会有两个 int ，博主也不清楚，QAQ~~~。</p><h4 id="基于transient关键字"><a href="#基于transient关键字" class="headerlink" title="基于transient关键字"></a>基于transient关键字</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Category</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Category<span class="token operator">></span> children<span class="token punctuation">;</span>    <span class="token keyword">private</span> Category parent<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里：id 加上了 transient 关键字。</p><pre class=" language-java"><code class="language-java">Category category <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serializeNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String s <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>category<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"children"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"parent"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><p>很明显，id没有被序列化。</p><p>注意：<code>被transient修饰的属性，反序列化也不能成功的。</code></p><h3 id="POJO与JSON的字段映射规则"><a href="#POJO与JSON的字段映射规则" class="headerlink" title="POJO与JSON的字段映射规则"></a>POJO与JSON的字段映射规则</h3><p>之前在属性重命名时 介绍了<code>@SerializedName</code>这个注解的使用，本节的内容与上一次差不多的，但既然叫<strong>映射规则</strong>那么说的自然是有规律的情况。<br> 还是之前User的例子，已经去除所有注解：</p><pre class=" language-java"><code class="language-java">User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"gakki"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span>emailAddress <span class="token operator">=</span> <span class="token string">"gakkij@example.com"</span><span class="token punctuation">;</span></code></pre><p><code>GsonBuilder</code>提供了<code>FieldNamingStrategy</code>接口和<code>setFieldNamingPolicy</code>和<code>setFieldNamingStrategy</code> 两个方法。</p><p><code>setFieldNamingPolicy</code>: 命名政策</p><p><code>setFieldNamingStrategy</code>：命名战略</p><h4 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h4><p><code>GsonBuilder.setFieldNamingPolicy</code> 方法与Gson提供的另一个枚举类<code>FieldNamingPolicy</code>配合使用，该枚举类提供了5种实现方式分别为：</p><table><thead><tr><th><strong>FieldNamingPolicy</strong></th><th><strong>结果（仅输出emailAddress字段）</strong></th></tr></thead><tbody><tr><td>IDENTITY</td><td>{“emailAddress”:”<a href="mailto:gakki@example.com" target="_blank" rel="noopener">gakki@example.com</a>“}</td></tr><tr><td>LOWER_CASE_WITH_DASHES</td><td>{“email-address”:”<a href="mailto:gakki@example.com" target="_blank" rel="noopener">gakki@example.com</a>“}</td></tr><tr><td>LOWER_CASE_WITH_UNDERSCORES</td><td>{“email_address”:”<a href="mailto:gakki@example.com" target="_blank" rel="noopener">gakki@example.com</a>“}</td></tr><tr><td>UPPER_CAMEL_CASE</td><td>{“EmailAddress”:”<a href="mailto:gakki@example.com" target="_blank" rel="noopener">gakki@example.com</a>“}</td></tr><tr><td>UPPER_CAMEL_CASE_WITH_SPACES</td><td>{“Email Address”:”<a href="mailto:gakki@example.com" target="_blank" rel="noopener">gakki@example.com</a>“}</td></tr></tbody></table><p>注意：这里的命名规则必须是：小写开头的驼峰命名才行！！！，例如：<code>emailAddress</code></p><h4 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h4><p><code>GsonBuilder.setFieldNamingStrategy</code> 方法需要与Gson提供的<code>FieldNamingStrategy</code>接口配合使用，用于实现将POJO的字段与JSON的字段相对应。上面的<code>FieldNamingPolicy</code>实际上也实现了<code>FieldNamingStrategy</code>接口，也就是说<code>FieldNamingPolicy</code>也可以使用<code>setFieldNamingStrategy</code>方法。</p><p>用法：</p><pre class=" language-java"><code class="language-java">Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">setFieldNamingStrategy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FieldNamingStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> String <span class="token function">translateName</span><span class="token punctuation">(</span>Field f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//实现自己的规则</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>注意：</strong> <code>@SerializedName</code>注解拥有最高优先级，在加有<code>@SerializedName</code>注解的字段上<code>FieldNamingStrategy</code>不生效！</p><pre class=" language-java"><code class="language-java">        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUserAge</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUserName</span><span class="token punctuation">(</span><span class="token string">"gakki"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUserAddress</span><span class="token punctuation">(</span><span class="token string">"东京"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setFieldNamingStrategy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FieldNamingStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> String <span class="token function">translateName</span><span class="token punctuation">(</span>Field field<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"userAge"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token string">"gakkiAge"</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"userName"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token string">"gakkiName"</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> field<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String s <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"gakkiAge"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"gakkiName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"userAddress"</span><span class="token operator">:</span><span class="token string">"东京"</span><span class="token punctuation">}</span></code></pre><hr><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> userAge<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SerializedName</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"gakki_name"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String userName<span class="token punctuation">;</span>    <span class="token keyword">private</span> String userAddress<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"gakkiAge"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"gakki_name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"userAddress"</span><span class="token operator">:</span><span class="token string">"东京"</span><span class="token punctuation">}</span></code></pre><p>证明：@SerializedName的优先级是最高的！！！</p><hr><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>GSON的排除不必要的序列化时，需要在所有的需要序列化上面加上@Expose注解，确实不方便，因为一般情况下，都是少数不需要序列化，因此会添加很多@Expose注解，麻烦！有什么方法来减少这种操作呢？</p><p>使用基于策略的方法，自己创建一个注解用来排除掉不需要序列化的字段。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@FilterAnnotation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> userAge<span class="token punctuation">;</span>    <span class="token keyword">private</span> String userName<span class="token punctuation">;</span>    <span class="token keyword">private</span> String userAddress<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">FilterAnnotation</span> <span class="token punctuation">{</span>    String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUserName</span><span class="token punctuation">(</span><span class="token string">"gakki"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUserAge</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUserAddress</span><span class="token punctuation">(</span><span class="token string">"冲绳"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addSerializationExclusionStrategy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ExclusionStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldSkipField</span><span class="token punctuation">(</span>FieldAttributes fieldAttributes<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//根据字段上面有么有注解来过滤</span>                FilterAnnotation annotation <span class="token operator">=</span> fieldAttributes<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>FilterAnnotation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>annotation <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldSkipClass</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> aClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"userName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"userAddress"</span><span class="token operator">:</span><span class="token string">"冲绳"</span><span class="token punctuation">}</span></code></pre><p>因为，userAge上面有：FilterAnnotation因此被过滤掉了，不再被序列化了。</p><p>这样，就不需要在需要的字段上面通通加上@Expose来进行序列化了，减少了不必要的工作量。</p>]]></content>
      
      
      <categories>
          
          <category> GSON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSON的进阶&lt;二&gt;</title>
      <link href="/2019/12/15/gson-de-jin-jie-er/"/>
      <url>/2019/12/15/gson-de-jin-jie-er/</url>
      
        <content type="html"><![CDATA[<h4 id="GSON的流式反序列化"><a href="#GSON的流式反序列化" class="headerlink" title="GSON的流式反序列化"></a>GSON的流式反序列化</h4><h5 id="自动方式"><a href="#自动方式" class="headerlink" title="自动方式"></a>自动方式</h5><pre class=" language-java"><code class="language-java">Gson提供了<span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token punctuation">)</span>和<span class="token function">toJson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 两个直接用于解析和生成的方法，前者实现反序列化，后者实现了序列化。同时每个方法都提供了重载方法，我常用的总共有<span class="token number">5</span>个。</code></pre><pre class=" language-java"><code class="language-java">Gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span><span class="token punctuation">;</span>Gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>Reader<span class="token punctuation">,</span>Class<span class="token punctuation">)</span><span class="token punctuation">;</span>Gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>String<span class="token punctuation">,</span>Class<span class="token punctuation">)</span><span class="token punctuation">;</span>Gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>Reader<span class="token punctuation">,</span>Type<span class="token punctuation">)</span><span class="token punctuation">;</span>Gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>String<span class="token punctuation">,</span>Type<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>自动方式就是使用：多个formJson的重载方法而已，就是这么简单，粗暴。</p><h5 id="手动方式"><a href="#手动方式" class="headerlink" title="手动方式"></a>手动方式</h5><p>手动的方式就是使用<code>stream</code>包下的<code>JsonReader</code>类来手动实现反序列化，和Android中使用pull解析XML是比较类似的。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parseJsonStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        String json <span class="token operator">=</span> <span class="token string">"{\"name\":\"gakki\",\"age\":18,\"address\":\"冲绳岛\"}"</span><span class="token punctuation">;</span>        JsonReader jsonReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringReader</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonReader<span class="token punctuation">.</span><span class="token function">beginObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//throws IOException</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>jsonReader<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String name <span class="token operator">=</span> jsonReader<span class="token punctuation">.</span><span class="token function">nextName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">switch</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">case</span> <span class="token string">"name"</span><span class="token operator">:</span>                    user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>jsonReader<span class="token punctuation">.</span><span class="token function">nextString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token string">"age"</span><span class="token operator">:</span>                    user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span>jsonReader<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token string">"address"</span><span class="token operator">:</span>                    user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span>jsonReader<span class="token punctuation">.</span><span class="token function">nextString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">default</span><span class="token operator">:</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        jsonReader<span class="token punctuation">.</span><span class="token function">endObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>结果：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">}</span></code></pre><p>数组的例子：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parseJsonStrArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        String json <span class="token operator">=</span> <span class="token string">"[{\"name\":\"gakki\",\"age\":18,\"address\":\"冲绳岛\"},"</span> <span class="token operator">+</span>                <span class="token string">"{\"name\":\"liuzhuo\",\"age\":20,\"address\":\"梦幻岛\"},"</span> <span class="token operator">+</span>                <span class="token string">"{\"name\":\"gakkij\",\"age\":22,\"address\":\"东京\"}]"</span><span class="token punctuation">;</span>        JsonReader jsonReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringReader</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonReader<span class="token punctuation">.</span><span class="token function">beginArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//throws IOException</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> userList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>jsonReader<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            jsonReader<span class="token punctuation">.</span><span class="token function">beginObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>jsonReader<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String name <span class="token operator">=</span> jsonReader<span class="token punctuation">.</span><span class="token function">nextName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">switch</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">case</span> <span class="token string">"name"</span><span class="token operator">:</span>                        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>jsonReader<span class="token punctuation">.</span><span class="token function">nextString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">case</span> <span class="token string">"age"</span><span class="token operator">:</span>                        user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span>jsonReader<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">case</span> <span class="token string">"address"</span><span class="token operator">:</span>                        user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span>jsonReader<span class="token punctuation">.</span><span class="token function">nextString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">default</span><span class="token operator">:</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            jsonReader<span class="token punctuation">.</span><span class="token function">endObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            userList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        jsonReader<span class="token punctuation">.</span><span class="token function">endArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>结果：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'liuzhuo'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'梦幻岛'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakkij'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">22</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'东京'</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><p>注意：每个一个begin都必须在最后接一个end结束，beginObject 对应：endObject；beginArray 对应endArray。</p><p>通过hasNext来判断是否有下一个元素，nextName取出当前的key，nextXXX来取出对应类型的value值【必须先nextName，才能nextXXX】。</p><hr><p>其实自动反序列化最终也是采用：JsonReader的方式：</p><p><img src="https://pic1.superbed.cn/item/5df6262ca4fbc8614a955800.jpg" alt></p><h4 id="GSON的流式序列化"><a href="#GSON的流式序列化" class="headerlink" title="GSON的流式序列化"></a>GSON的流式序列化</h4><h5 id="自动方式-1"><a href="#自动方式-1" class="headerlink" title="自动方式"></a>自动方式</h5><pre class=" language-java"><code class="language-java"><span class="token function">toJson</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="https://pic1.superbed.cn/item/5df627aba4fbc8614a959d72.jpg" alt></p><p>提示：<code>PrintStream</code>(System.out) 、<code>StringBuilder</code>、<code>StringBuffer</code>和<code>*Writer</code>都实现了<code>Appendable</code>接口。</p><pre class=" language-java"><code class="language-java">        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"冲绳岛"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">PrintStream</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">这样就是直接把序列化的结果打印到控制台上：<span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"userName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"冲绳岛"</span><span class="token punctuation">}</span></code></pre><h5 id="手动方式-1"><a href="#手动方式-1" class="headerlink" title="手动方式"></a>手动方式</h5><pre class=" language-java"><code class="language-java">JsonWriter writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>writer<span class="token punctuation">.</span><span class="token function">beginObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// throws IOException</span>        <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token string">"怪盗kidou"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"email"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nullValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//演示null</span>        <span class="token punctuation">.</span><span class="token function">endObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// throws IOException</span>writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// throws IOException</span><span class="token comment" spellcheck="true">//{"name":"怪盗kidou","age":24,"email":null}</span></code></pre><hr><h4 id="GsonBuilder的简单使用"><a href="#GsonBuilder的简单使用" class="headerlink" title="GsonBuilder的简单使用"></a>GsonBuilder的简单使用</h4><h5 id="序列化null值"><a href="#序列化null值" class="headerlink" title="序列化null值"></a>序列化null值</h5><p>serializeNulls()</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parsePojoForNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Gson gson1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serializeNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String user1 <span class="token operator">=</span> gson1<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String user2 <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"userName"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><p>age 是 int，默认值是0，不是 null。</p><h5 id="序列化格式化"><a href="#序列化格式化" class="headerlink" title="序列化格式化"></a>序列化格式化</h5><p>setPrettyPrinting()</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">formatJsonStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"gakki"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"冲绳岛"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String user1 <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPrettyPrinting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String user2 <span class="token operator">=</span> gson2<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"userName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"冲绳岛"</span><span class="token punctuation">}</span><span class="token punctuation">{</span>  <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>  <span class="token string">"userName"</span><span class="token operator">:</span> <span class="token string">"gakki"</span><span class="token punctuation">,</span>  <span class="token string">"address"</span><span class="token operator">:</span> <span class="token string">"冲绳岛"</span><span class="token punctuation">}</span></code></pre><h5 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h5><p>setDateFormat()</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">formatJsonStrDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"gakki"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"冲绳岛"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String user1 <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPrettyPrinting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String user2 <span class="token operator">=</span> gson2<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"userName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"冲绳岛"</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"Dec 15, 2019 8:47:03 PM"</span><span class="token punctuation">}</span><span class="token punctuation">{</span>  <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>  <span class="token string">"userName"</span><span class="token operator">:</span> <span class="token string">"gakki"</span><span class="token punctuation">,</span>  <span class="token string">"address"</span><span class="token operator">:</span> <span class="token string">"冲绳岛"</span><span class="token punctuation">,</span>  <span class="token string">"birthday"</span><span class="token operator">:</span> <span class="token string">"2019-12-15 20:47:03"</span><span class="token punctuation">}</span></code></pre><p>时间的反序列化：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parseJsonStrDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String json <span class="token operator">=</span> <span class="token string">"{\"age\":18,\"userName\":\"gakki\",\"address\":\"冲绳岛\",\"birthday\":\"Dec 15, 2019 8:47:03 PM\"}"</span><span class="token punctuation">;</span>        String json2 <span class="token operator">=</span> <span class="token string">"{\"age\":18,\"userName\":\"gakki\",\"address\":\"冲绳岛\",\"birthday\":\"2019-06-11 11:11:11\"}"</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user1 <span class="token operator">=</span> gson2<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json2<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Sun Dec <span class="token number">15</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">47</span><span class="token operator">:</span><span class="token number">03</span> CST <span class="token number">2019</span><span class="token punctuation">}</span>User<span class="token punctuation">{</span>age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">,</span> birthday<span class="token operator">=</span>Tue Jun <span class="token number">11</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">11</span><span class="token operator">:</span><span class="token number">11</span> CST <span class="token number">2019</span><span class="token punctuation">}</span></code></pre><p>注意：json1 和 json2 的birthday的字符串格式的区别！！！</p><hr><p>其他类似的，就不一一列举了：</p><pre class=" language-java"><code class="language-java">Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//序列化null</span>        <span class="token punctuation">.</span><span class="token function">serializeNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 设置日期时间格式，另有2个重载方法</span>        <span class="token comment" spellcheck="true">// 在序列化和反序化时均生效</span>        <span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 禁此序列化内部类</span>        <span class="token punctuation">.</span><span class="token function">disableInnerClassSerialization</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//生成不可执行的Json（多了 )]}' 这4个字符）</span>        <span class="token punctuation">.</span><span class="token function">generateNonExecutableJson</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//禁止转义html标签</span>        <span class="token punctuation">.</span><span class="token function">disableHtmlEscaping</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//格式化输出</span>        <span class="token punctuation">.</span><span class="token function">setPrettyPrinting</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>注意：内部类(Inner Class)和嵌套类(Nested Class)的区别</p>]]></content>
      
      
      <categories>
          
          <category> GSON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSON的进阶&lt;一&gt;</title>
      <link href="/2019/12/15/gson-de-jin-jie-yi/"/>
      <url>/2019/12/15/gson-de-jin-jie-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="GSON的说明"><a href="#GSON的说明" class="headerlink" title="GSON的说明"></a>GSON的说明</h3><p>Gson（又称Google Gson）是Google公司发布的一个开放源代码的Java库，主要用途为序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象。而JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成，广泛应用于各种数据的交互中，尤其是服务器与客户端的交互。</p><h3 id="GSON的创建"><a href="#GSON的创建" class="headerlink" title="GSON的创建"></a>GSON的创建</h3><h4 id="直接new-Gson对象"><a href="#直接new-Gson对象" class="headerlink" title="直接new Gson对象"></a>直接new Gson对象</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用new方法</span>Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// toJson 将bean对象转换为json字符串</span>String jsonStr <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// fromJson 将json字符串转为bean对象</span>Student user<span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 序列化List</span>String jsonStr2 <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 反序列化成List时需要使用到TypeToken getType()</span>List<span class="token operator">&lt;</span>User<span class="token operator">></span> retList <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>jsonStr2<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">TypeToken</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>User<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//type的使用，User代表解析出来的Bean对象，result为后台返回的json格式字符串，</span><span class="token comment" spellcheck="true">//List&lt;UserBean>代表通过Gson按照type格式解析json格式字符串后返回的对象列表</span>   如：Type type <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TypeToken</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>User<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> List<span class="token operator">&lt;</span>UserBean<span class="token operator">></span> UserBeans <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="使用GsonBuilder"><a href="#使用GsonBuilder" class="headerlink" title="使用GsonBuilder"></a>使用GsonBuilder</h4><p>使用new Gson()，此时会创建一个带有<strong>默认配置</strong>选项的Gson实例，如果不想使用默认配置，那么就可以使用GsonBuilder。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//serializeNulls()是GsonBuilder提供的一种配置，当字段值为空或null时，依然对该字段进行转换</span>Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serializeNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>使用GsonBuilder创建Gson实例的步骤：</p><p>首先创建GsonBuilder,然后调用GsonBuilder提供的各种配置方法进行配置，</p><p>最后调用GsonBuilder的create方法，将基于当前的配置创建一个Gson实例。</p><p>GsonBuilder的一些配置：</p><pre class=" language-java"><code class="language-java">Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token punctuation">.</span><span class="token function">excludeFieldsWithoutExposeAnnotation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//不对没有用@Expose注解的属性进行操作</span>         <span class="token punctuation">.</span><span class="token function">enableComplexMapKeySerialization</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//当Map的key为复杂对象时,需要开启该方法</span>         <span class="token punctuation">.</span><span class="token function">serializeNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//当字段值为空或null时，依然对该字段进行转换</span>         <span class="token punctuation">.</span><span class="token function">setDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss:SSS"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//时间转化为特定格式</span>         <span class="token punctuation">.</span><span class="token function">setPrettyPrinting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//对结果进行格式化，增加换行</span>         <span class="token punctuation">.</span><span class="token function">disableHtmlEscaping</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//防止特殊字符出现乱码</span>         <span class="token punctuation">.</span><span class="token function">registerTypeAdapter</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">UserAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//为某特定对象设置固定的序列或反序列方式，自定义Adapter需实现JsonSerializer或者JsonDeserializer接口</span>         <span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="GSON的基本使用"><a href="#GSON的基本使用" class="headerlink" title="GSON的基本使用"></a>GSON的基本使用</h3><p>Gson提供了fromJson() 和toJson() 两个直接用于解析和生成的方法，前者实现反序列化，后者实现了序列化；同时每个方法都提供了重载方法</p><h4 id="基本类型的解析"><a href="#基本类型的解析" class="headerlink" title="基本类型的解析"></a>基本类型的解析</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parseBasicType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer id <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// int</span>        Float aFloat <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token string">"13.89"</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//float</span>        Float aFloat2 <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token string">"\"13.89\""</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Double aDouble <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token string">"78.89"</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//double</span>        Boolean aTrue <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token string">"true"</span><span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//boolean</span>        String gakkki <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token string">"gakkki"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//String</span>        Color red <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token string">"RED"</span><span class="token punctuation">,</span> Color<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//枚举</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>id <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> aFloat <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> aDouble <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> aTrue <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> gakkki <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> red<span class="token punctuation">.</span><span class="token function">getFieldName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aFloat2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><code>注意：aFloat 和 aFloat2的区别！</code></p><p>输出结果：</p><pre class=" language-java"><code class="language-java"><span class="token number">1</span>    <span class="token number">13.89</span>    <span class="token number">78.89</span>    <span class="token boolean">true</span>    gakkki    red<span class="token number">13.89</span></code></pre><p>Color枚举类型：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> Color <span class="token punctuation">{</span>    <span class="token function">RED</span><span class="token punctuation">(</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">BLUE</span><span class="token punctuation">(</span><span class="token string">"blue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">YELLOW</span><span class="token punctuation">(</span><span class="token string">"yyyy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String fieldName<span class="token punctuation">;</span>    <span class="token function">Color</span><span class="token punctuation">(</span>String fieldName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>fieldName <span class="token operator">=</span> fieldName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Color <span class="token function">getColorByFieldName</span><span class="token punctuation">(</span>String fieldName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Color value <span class="token operator">:</span> Color<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>fieldName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>fieldName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> value<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getFieldName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> fieldName<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>PS: 通过ide我们可以看到 fromJson的7种重载方法。(目前使用的是第5个重载的方法)</p><p><img src="https://pic1.superbed.cn/item/5df5b394a4fbc8614a7f14f8.jpg" alt></p><hr><h4 id="基本类型的生成"><a href="#基本类型的生成" class="headerlink" title="基本类型的生成"></a>基本类型的生成</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createBasicType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String intType <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//int</span>        String floatType <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span><span class="token number">12.56</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// float</span>        String booleanType <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// boolean</span>        String string <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span><span class="token string">"gakki"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//String</span>        Color blue <span class="token operator">=</span> Color<span class="token punctuation">.</span><span class="token function">getColorByFieldName</span><span class="token punctuation">(</span><span class="token string">"blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String enumType <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>blue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// enum</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>intType <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> floatType <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> booleanType <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> string <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> enumType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre class=" language-java"><code class="language-java"><span class="token number">1</span>    <span class="token number">12.56</span>    <span class="token boolean">true</span>    <span class="token string">"gakki"</span>    <span class="token string">"BLUE"</span></code></pre><p>PS: toJson有8中重载方法。（目前，使用的是第四种）</p><p><img src="https://pic.superbed.cn/item/5df5b8f4a4fbc8614a7febf5.jpg" alt></p><hr><h4 id="POJO的生成与解析"><a href="#POJO的生成与解析" class="headerlink" title="POJO的生成与解析"></a>POJO的生成与解析</h4><p>User</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> String address<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"User{"</span> <span class="token operator">+</span>                <span class="token string">"name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">", age="</span> <span class="token operator">+</span> age <span class="token operator">+</span>                <span class="token string">", address='"</span> <span class="token operator">+</span> address <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>create:</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parsePojo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr1 <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        User user2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"gakki"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"冲绳岛"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr2 <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"冲绳岛"</span><span class="token punctuation">}</span></code></pre><font color="red">说明：通过new Gson得到的 gson实例 是不会帮我们序列化值为null的key。这里user1就是因为没有给属性赋值，age是int基本类型，默认值是0，因此，最后只是序列化了age。</font><p>parse：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parsePojo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String json <span class="token operator">=</span> <span class="token string">"{\"name\":\"gakki\",\"age\":18,\"address\":\"冲绳岛\"}"</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>结果：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">}</span></code></pre><hr><p>如果，我们想序列化key的值为null呢？</p><p>此时，我们需要使用：GsonBuilder，构造出我们自定义的Gson实例，不再使用默认的Gson实例。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parsePojoForNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serializeNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String userSer <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userSer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>结果：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><p>serializeNulls() 就是帮助我们序列化value为null的意思。</p><hr><p>PS：Gson序列化的顺序是什么呢？是书写POJO的属性的顺序，还是与POJO的toString()方法有关呢？</p><p>修改User中，属性字段的顺序，将age排在第一位，之前是name排在第一位。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    省略set、get，toString方法<span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><p>说明：Gson默认的序列化是根据POJO属性的书写顺序来序列化的。</p><p>如果，我们去掉toString方法呢？</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><p>说明：Gson的序列化与POJO的 toString方法没有关系，它是根据POJO的属性自己构造序列化的格式。</p><hr><h4 id="属性重命名：-SerializedName-注解"><a href="#属性重命名：-SerializedName-注解" class="headerlink" title="属性重命名：@SerializedName 注解"></a>属性重命名：@SerializedName 注解</h4><p>我们有时收到的json字符串中的key的命名不符合我们java的规范该怎么呢？</p><p>上一节，我们了解到了，POJO的属性命名必须要与json字符串中key命名一致才能反序列化成功的，比如：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parsePojo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String json <span class="token operator">=</span> <span class="token string">"{\"user_name\":\"gakki\",\"age\":18,\"address\":\"冲绳岛\"}"</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>这里，我将json字符串中的 name ，改成了：user_name，然后反序列化，结果如下：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">}</span></code></pre><p>发现，User的name字段是null，说明反序列化是失败的，因为我们知道json的反序列化是通过反射来完成的，因此字段名必须一致才能反序列化成功。</p><hr><p>一般，前端的命名，或者 数据库中的命名都是 ：下划线来拼接的 ，例如：msg_type、msg_action等。</p><p>我们java的命名一般都是：驼峰命名法，msgType 、msgAction。我们不能为了反序列化成功，把命名规则改了吧，因此，Gson提供了相应的注解来帮助我们解决该类问题：</p><p>@SerializedName 注解</p><p>User:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SerializedName</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"user_name"</span><span class="token punctuation">)</span>     <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span></code></pre><p>Parse：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parsePojo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String json <span class="token operator">=</span> <span class="token string">"{\"user_name\":\"gakki\",\"age\":18,\"address\":\"冲绳岛\"}"</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>结果：</p><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">}</span></code></pre><p>说明：使用：@SerializedName(value = “user_name”) 注解，将json字符串中的 user_name 与 User的name联系起来了。</p><hr><p>我们看看使用：@SerializedName(value = “user_name”) 注解后的，序列化的结果：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parsePojoForNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serializeNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String userSer <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userSer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"user_name"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><font color="red">我们看到，序列化的结果也是把 <strong>name</strong>换成了<strong>user_name</strong>。</font><hr><p>测试：将@SerializedName注解放到 get、set方法上面：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@SerializedName</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"user_name"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@SerializedName</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"user_name"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">        String json <span class="token operator">=</span> <span class="token string">"{\"user_name\":\"gakki\",\"age\":18,\"address\":\"冲绳岛\"}"</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serializeNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String userSer <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userSer<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span>null<span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span>null<span class="token punctuation">}</span></code></pre><p>发现并不好使，但是@SerializedName注解却又能在方法上注解，这点我不明白，我此处 Gson是：2.8.5版本的。</p><p>因此：<font color="red">@SerializedName注解：只能放在属性级别，不能放到getter /setter</font></p><p><code>PS: 还有，User的属性，即使没有get、set方法也能序列化和反序列化成功！！</code></p><h4 id="SerializedName注解的别名"><a href="#SerializedName注解的别名" class="headerlink" title="@SerializedName注解的别名"></a>@SerializedName注解的别名</h4><p>有时，我们获取到的json字符串中，key的命名有多种该怎么办呢？</p><p>例如：User中的name 属性 需要对应多个 json字符串中的 key值，name 、user_name 、userName 、Name等</p><p>我们点开：@SerializedName注解</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SerializedName</span> <span class="token punctuation">{</span>    String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">alternate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>能看到，除了 默认的 value字段外，还有一个 alternate字段，alternate就用来取别名的，可以取多个，匹配多个的话，以最后一个为准！</p><p>测试：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SerializedName</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"name"</span><span class="token punctuation">,</span> alternate <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"user_name"</span><span class="token punctuation">,</span> <span class="token string">"userName"</span><span class="token punctuation">,</span> <span class="token string">"Name"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p> 注解中的数组是使用 {} 来表示的，此处的 alternate是 String[] 数组。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parsePojo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String json1 <span class="token operator">=</span> <span class="token string">"{\"name\":\"gakki1\",\"age\":18,\"address\":\"冲绳岛\"}"</span><span class="token punctuation">;</span>        String json2 <span class="token operator">=</span> <span class="token string">"{\"user_name\":\"gakki2\",\"age\":18,\"address\":\"冲绳岛\"}"</span><span class="token punctuation">;</span>        String json3 <span class="token operator">=</span> <span class="token string">"{\"userName\":\"gakki3\",\"age\":18,\"address\":\"冲绳岛\"}"</span><span class="token punctuation">;</span>        String json4 <span class="token operator">=</span> <span class="token string">"{\"Name\":\"gakki4\",\"age\":18,\"address\":\"冲绳岛\"}"</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user1 <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json1<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user2 <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json2<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user3 <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json3<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user4 <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json4<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki1'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">}</span>User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki2'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">}</span>User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki3'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">}</span>User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki4'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">}</span></code></pre><p>说明：此时，不管json字符串中的 name是哪种都能反序列化成功。</p><p>如果，同一个json字符串中，有多个匹配的别名呢？</p><pre><code>    public static void parsePojo() {        String json1 = &quot;{\&quot;name\&quot;:\&quot;gakki1\&quot;,\&quot;user_name\&quot;:\&quot;gakki2\&quot;,\&quot;userName\&quot;:\&quot;gakki3\&quot;,\&quot;age\&quot;:18,\&quot;address\&quot;:\&quot;冲绳岛\&quot;}&quot;;        //String json2 = &quot;{\&quot;user_name\&quot;:\&quot;gakki2\&quot;,\&quot;age\&quot;:18,\&quot;address\&quot;:\&quot;冲绳岛\&quot;}&quot;;        //String json3 = &quot;{\&quot;userName\&quot;:\&quot;gakki3\&quot;,\&quot;age\&quot;:18,\&quot;address\&quot;:\&quot;冲绳岛\&quot;}&quot;;        //String json4 = &quot;{\&quot;Name\&quot;:\&quot;gakki4\&quot;,\&quot;age\&quot;:18,\&quot;address\&quot;:\&quot;冲绳岛\&quot;}&quot;;        Gson gson = new Gson();        User user1 = gson.fromJson(json1, User.class);        //User user2 = gson.fromJson(json2, User.class);        //User user3 = gson.fromJson(json3, User.class);        //User user4 = gson.fromJson(json4, User.class);        System.out.println(user1);        //System.out.println(user2);        //System.out.println(user3);        //System.out.println(user4);    }</code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki3'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">}</span></code></pre><p>说明：json1字符串中，同时存在：name、user_name 、userName的情况，是以：json1中最后一个匹配的为主，此处是：userName。不是以：@SerializedName(value = “name”, alternate = {“user_name”, “userName”, “Name”})中最后一个匹配为主！！！</p><p>比如：现在修改成：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SerializedName</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"userName"</span><span class="token punctuation">,</span> alternate <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"user_name"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Name"</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki3'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">}</span></code></pre><p>结果还是：gakki3，和@SerializedName注解编写的顺序无关的，是以json字符串最后一个匹配的为主。</p><hr><p>现在，修改json1中的顺序：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parsePojo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String json1 <span class="token operator">=</span> <span class="token string">"{\"userName\":\"gakki3\",\"user_name\":\"gakki2\",\"name\":\"gakki1\",\"age\":18,\"address\":\"冲绳岛\"}"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//String json2 = "{\"user_name\":\"gakki2\",\"age\":18,\"address\":\"冲绳岛\"}";</span>        <span class="token comment" spellcheck="true">//String json3 = "{\"userName\":\"gakki3\",\"age\":18,\"address\":\"冲绳岛\"}";</span>        <span class="token comment" spellcheck="true">//String json4 = "{\"Name\":\"gakki4\",\"age\":18,\"address\":\"冲绳岛\"}";</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user1 <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json1<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//User user2 = gson.fromJson(json2, User.class);</span>        <span class="token comment" spellcheck="true">//User user3 = gson.fromJson(json3, User.class);</span>        <span class="token comment" spellcheck="true">//User user4 = gson.fromJson(json4, User.class);</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//System.out.println(user2);</span>        <span class="token comment" spellcheck="true">//System.out.println(user3);</span>        <span class="token comment" spellcheck="true">//System.out.println(user4);</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki1'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">}</span></code></pre><p>此时输出的结果就是：name中的value值。</p><hr><h4 id="SerializedName最佳实践"><a href="#SerializedName最佳实践" class="headerlink" title="@SerializedName最佳实践"></a>@SerializedName最佳实践</h4><p>现在，我们想重命名：序列化和反序列化，怎么办呢？</p><p>使用：@SerializedName注解的 value 来 控制 序列化的名字，alternate 来控制反序列化的名字：</p><p>反序列化：user_name</p><p>POJO: name</p><p>序列化：userName</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SerializedName</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"userName"</span><span class="token punctuation">,</span> alternate <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"user_name"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parsePojo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String json <span class="token operator">=</span> <span class="token string">"{\"user_name\":\"gakki\",\"age\":18,\"address\":\"冲绳岛\"}"</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        String userStr <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'gakki'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> address<span class="token operator">=</span><span class="token string">'冲绳岛'</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">"userName"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"冲绳岛"</span><span class="token punctuation">}</span></code></pre><h4 id="SerializedName总结"><a href="#SerializedName总结" class="headerlink" title="@SerializedName总结"></a>@SerializedName总结</h4><font color="red">@SerializedName(value=”序列化、反序列化默认名称”,alternate={“反序列化名称备选”})</font><h4 id="GSON中泛型的使用"><a href="#GSON中泛型的使用" class="headerlink" title="GSON中泛型的使用"></a>GSON中泛型的使用</h4><p>上面了解的JSON中的Number、boolean、Object和String，现在说一下Array。</p><p>例：JSON字符串数组</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token string">"Android"</span><span class="token punctuation">,</span><span class="token string">"Java"</span><span class="token punctuation">,</span><span class="token string">"PHP"</span><span class="token punctuation">]</span></code></pre><p>当我们要通过Gson解析这个json时，一般有两种方式：使用数组，使用List。而List对于增删都是比较方便的，所以实际使用是还是List比较多。</p><ul><li>数组</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parseArrayJson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String json <span class="token operator">=</span> <span class="token string">"[\"java\",\"c++\",\"PHP\"]"</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> strings <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">javac<span class="token operator">++</span>PHP</code></pre><ul><li>List</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parseListJson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String json <span class="token operator">=</span> <span class="token string">"[\"java\",\"c++\",\"PHP\"]"</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List strings <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> List<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        strings<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">javac<span class="token operator">++</span>PHP</code></pre><p>如果把List带上泛型呢？</p><p><img src="https://pic2.superbed.cn/item/5df5def1a4fbc8614a86decc.jpg" alt></p><p>直接编译器就出错了！！！！</p><p>为啥呢？</p><p>因为，对于Java来说<code>List&lt;String&gt;</code> 和<code>List&lt;User&gt;</code> 这俩个的字节码文件只有一个，那就是<code>List.class</code>，这是Java泛型使用时要注意的问题 <strong>泛型擦除</strong>。</p><p>为了解决的上面的问题，Gson为我们提供了<code>TypeToken</code>来实现对泛型的支持，所以当我们希望使用将以上的数据解析为<code>List&lt;String&gt;</code>时需要这样写。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parseListFanJson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String json <span class="token operator">=</span> <span class="token string">"[\"java\",\"c++\",\"PHP\"]"</span><span class="token punctuation">;</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Type type <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TypeToken</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>        strings<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>注意：<code>TypeToken</code>的构造方法是<code>protected</code>修饰的,所以上面才会写成<code>new TypeToken&gt;() {}.getType()</code> 而不是  <code>new TypeToken&gt;().getType()</code></p><p>其实就是创建了TypeToken的匿名子类，和Thread线程一样，我们一般创建的都是Thread的匿名子类。</p><h4 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h4><p>例如：我们处理完数据后，需要返回到前端：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"code"</span><span class="token operator">:</span><span class="token string">"0"</span><span class="token punctuation">,</span><span class="token string">"message"</span><span class="token operator">:</span><span class="token string">"success"</span><span class="token punctuation">,</span><span class="token string">"data"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"code"</span><span class="token operator">:</span><span class="token string">"0"</span><span class="token punctuation">,</span><span class="token string">"message"</span><span class="token operator">:</span><span class="token string">"success"</span><span class="token punctuation">,</span><span class="token string">"data"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>我们真正需要的<code>data</code>所包含的数据，而<code>code</code>只使用一次，<code>message</code>则几乎不用。如果Gson不支持泛型或不知道Gson支持泛型的同学一定会这么定义POJO。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserResponse</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> code<span class="token punctuation">;</span>    <span class="token keyword">public</span> String message<span class="token punctuation">;</span>    <span class="token keyword">public</span> User data<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当要返回其他接口的时候又重新定义一个<code>XXResponse</code>将<code>data</code>的类型改成XX，很明显<code>code</code>，和<code>message</code>被重复定义了多次，通过泛型的话我们可以将<code>code</code>和<code>message</code>字段抽取到一个<code>Result</code>的类中，这样我们只需要编写<code>data</code>字段所对应的POJO即可，更专注于我们的业务逻辑。如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> code<span class="token punctuation">;</span>    <span class="token keyword">public</span> String message<span class="token punctuation">;</span>    <span class="token keyword">public</span> T data<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>那么对于<code>data</code>字段是<code>User</code>时则可以写为 <code>Result&lt;User&gt;</code> ,当是个列表的时候为 <code>Result&lt;List&lt;User&gt;&gt;</code>，其它同理。</p><p>例子：</p><p>不使用泛型时：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserResult</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> code<span class="token punctuation">;</span>    <span class="token keyword">public</span> String message<span class="token punctuation">;</span>    <span class="token keyword">public</span> User data<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//=========</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserListResult</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> code<span class="token punctuation">;</span>    <span class="token keyword">public</span> String message<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//=========</span>String json <span class="token operator">=</span> <span class="token string">"{..........}"</span><span class="token punctuation">;</span>Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>UserResult userResult <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span>UserResult<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>User user <span class="token operator">=</span> userResult<span class="token punctuation">.</span>data<span class="token punctuation">;</span>UserListResult userListResult <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span>UserListResult<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> userListResult<span class="token punctuation">.</span>data<span class="token punctuation">;</span></code></pre><p>上面有两个类<code>UserResult</code>和<code>UserListResult</code>，有两个字段重复，一两个接口就算了，如果有上百个怎么办?不得累死?所以引入泛型。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//不再重复定义Result类</span>Type userType <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TypeToken</span><span class="token operator">&lt;</span>Result<span class="token operator">&lt;</span>User<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Result<span class="token operator">&lt;</span>User<span class="token operator">></span> userResult <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span>userType<span class="token punctuation">)</span><span class="token punctuation">;</span>User user <span class="token operator">=</span> userResult<span class="token punctuation">.</span>data<span class="token punctuation">;</span>Type userListType <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TypeToken</span><span class="token operator">&lt;</span>Result<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>User<span class="token operator">>>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Result<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>User<span class="token operator">>></span> userListResult <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span>userListType<span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> userListResult<span class="token punctuation">.</span>data<span class="token punctuation">;</span></code></pre><p>看出区别了么?引入了泛型之后虽然要多写一句话用于获取泛型信息，但是返回值类型很直观，也少定义了很多无关类。</p>]]></content>
      
      
      <categories>
          
          <category> GSON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSON的基础入门</title>
      <link href="/2019/12/14/gson-de-ji-chu-ru-men/"/>
      <url>/2019/12/14/gson-de-ji-chu-ru-men/</url>
      
        <content type="html"><![CDATA[<h4 id="GSON的基础用法"><a href="#GSON的基础用法" class="headerlink" title="GSON的基础用法"></a>GSON的基础用法</h4><p>GSON是google提供的java包，用来序列化和反序列化json对象的。</p><p>Gson提供了<code>fromJson()</code> 和<code>toJson()</code> 两个直接用于解析和生成的方法，前者实现反序列化，后者实现了序列化。同时每个方法都提供了重载方法，我常用的总共有5个。</p><pre class=" language-java"><code class="language-java">Gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//序列化</span>Gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>Reader<span class="token punctuation">,</span>Class<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//反序列化</span>Gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>String<span class="token punctuation">,</span>Class<span class="token punctuation">)</span><span class="token punctuation">;</span>Gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>Reader<span class="token punctuation">,</span>Type<span class="token punctuation">)</span><span class="token punctuation">;</span>Gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>String<span class="token punctuation">,</span>Type<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="GSON的基本用法"><a href="#GSON的基本用法" class="headerlink" title="GSON的基本用法"></a>GSON的基本用法</h4><p>我们了解了json的官方解析中，是使用：JSONObject来表示json对象，JSONArray来表现列表即数组。</p><p>GSON也提供了这样的基础用法，我们先来学习一下基础的用法，后面再学习高级的用法。</p><p>在GSON中：JsonObject表示对象，JsonArray表示数组，JsonParser表示解析器：将json字符串解析为JsonObject或者JsonArray。</p><p><strong><code>PS：注意和Json官方解析中对象和数组的区别</code></strong></p><h4 id="json字符串解析为Json对象"><a href="#json字符串解析为Json对象" class="headerlink" title="json字符串解析为Json对象"></a>json字符串解析为Json对象</h4><p>本例子都是使用的：GSON的2.8.5版本</p><pre class=" language-java"><code class="language-java">        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>code<span class="token punctuation">.</span>gson<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>gson<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">2.8</span><span class="token punctuation">.</span><span class="token number">5</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre><pre class=" language-javascript"><code class="language-javascript">        String str <span class="token operator">=</span> <span class="token string">"{\"id\":1234545,\"name\":\"gakki\",\"birthday\":\"2019-12-14T22:35:11.468\"}"</span><span class="token punctuation">;</span>        JsonParser jsonParser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonElement jsonElement <span class="token operator">=</span> jsonParser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonObject jsonObject <span class="token operator">=</span> jsonElement<span class="token punctuation">.</span><span class="token function">getAsJsonObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonElement element <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        int id <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token function">getAsInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String name <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String birthday <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"birthday"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LocalDateTime localDateTime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>birthday<span class="token punctuation">)</span><span class="token punctuation">;</span>        DateTimeFormatter dateTimeFormatter <span class="token operator">=</span> DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"YYYY-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String format <span class="token operator">=</span> dateTimeFormatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>localDateTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"id:"</span> <span class="token operator">+</span> id <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> <span class="token string">"name:"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> <span class="token string">"birthday:"</span> <span class="token operator">+</span> format<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>说明：</p><p>通过JsonParser解析后，得到的是：JsonElement对象。</p><p>然后，我们通过观察<font color="red">：根元素是对象还是数组，来决定 JsonElement是调用：getAsJsonObjec 还是：getAsJsonArray 。</font></p><p>我们这里是{}包裹的对象，因此使用 getAsJsonObjec 来获取对象元素。如果你使用：getAsJsonArray，会抛出异常：</p><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>IllegalStateException<span class="token operator">:</span> Not a JSON Array<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">1234545</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2019-12-14T22:35:11.468"</span><span class="token punctuation">}</span>    at com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>JsonElement<span class="token punctuation">.</span><span class="token function">getAsJsonArray</span><span class="token punctuation">(</span>JsonElement<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">107</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>GsonUtil<span class="token punctuation">.</span><span class="token function">parseJsonStrToJsonObj</span><span class="token punctuation">(</span>GsonUtil<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">27</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>GsonUtil<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>GsonUtil<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">45</span><span class="token punctuation">)</span></code></pre><p>程序输出的结果：</p><pre class=" language-java"><code class="language-java">id<span class="token operator">:</span><span class="token number">1234545</span>    name<span class="token operator">:</span>gakki    birthday<span class="token operator">:</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">14</span> <span class="token number">22</span><span class="token operator">:</span><span class="token number">35</span><span class="token operator">:</span><span class="token number">11</span></code></pre><p>PS: 通过使用：jsonObject的get方法得到的对象还是jsonElement对象，然后根据key对应的value类型，分别调用对应的 getAsInt 、getAsString 等方法。如果key本身不存的话，get方法返回的JsonElement对象是null，因此会出现空指针异常，所以需要确定key本身存在，或者使用之前进行判断。</p><hr><h4 id="json数组字符串解析为JSON数组对象"><a href="#json数组字符串解析为JSON数组对象" class="headerlink" title="json数组字符串解析为JSON数组对象"></a>json数组字符串解析为JSON数组对象</h4><pre class=" language-java"><code class="language-java">        String str <span class="token operator">=</span> <span class="token string">"[{\"id\":123,\"name\":\"gakki\",\"birthday\":\"2019-6-11T22:35:11.468\"},{\"id\":456,\"name\":\"liuzhuo\",\"birthday\":\"2019-6-12T22:35:11.468\"}]"</span><span class="token punctuation">;</span>        JsonParser jsonParser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonArray jsonArray <span class="token operator">=</span> jsonParser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAsJsonArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> jsonArray<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            JsonObject jsonObject <span class="token operator">=</span> jsonArray<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAsJsonObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> id <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAsInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String name <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String birthday <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"birthday"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"id:"</span> <span class="token operator">+</span> id <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> <span class="token string">"name:"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> <span class="token string">"birthday:"</span> <span class="token operator">+</span> birthday<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre class=" language-java"><code class="language-java">id<span class="token operator">:</span><span class="token number">123</span>    name<span class="token operator">:</span>gakki    birthday<span class="token operator">:</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">6</span><span class="token operator">-</span>11T22<span class="token operator">:</span><span class="token number">35</span><span class="token operator">:</span><span class="token number">11.468</span>id<span class="token operator">:</span><span class="token number">456</span>    name<span class="token operator">:</span>liuzhuo    birthday<span class="token operator">:</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">6</span><span class="token operator">-</span>12T22<span class="token operator">:</span><span class="token number">35</span><span class="token operator">:</span><span class="token number">11.468</span></code></pre><hr><h4 id="手动创建Json对象"><a href="#手动创建Json对象" class="headerlink" title="手动创建Json对象"></a>手动创建Json对象</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createJsonObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        JsonObject jsonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonObject<span class="token punctuation">.</span><span class="token function">addProperty</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">,</span> <span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonObject<span class="token punctuation">.</span><span class="token function">addProperty</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"gakkij"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonObject<span class="token punctuation">.</span><span class="token function">addProperty</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{"id":6666,"name":"gakkij","age":18}</span>    <span class="token punctuation">}</span></code></pre><p><code>PS: 如果后添加的 key 已经存在了，会覆盖之前的key的value值。</code></p><p>JsonObject 和 JsonArray 都是 JsonElement 的 子类。</p><ul><li>JsonObject 通过 get方法获取 JsonElement对象后，根据相应的类型调用 getAsXXX来获取对象。</li><li>JsonObject 可以通过：getAsJsonObject(String name) 来直接获取 JsonObject对象。</li><li>JsonObject 可以通过：getAsJsonArray(String name) 来直接获取 JsonArray对象。</li></ul><hr><h4 id="手动创建Json数组对象"><a href="#手动创建Json数组对象" class="headerlink" title="手动创建Json数组对象"></a>手动创建Json数组对象</h4><pre><code>public static void createJsonArray() {        JsonObject jsonObject1 = new JsonObject();        jsonObject1.addProperty(&quot;id&quot;, 6666);        jsonObject1.addProperty(&quot;name&quot;, &quot;gakkij&quot;);        jsonObject1.addProperty(&quot;age&quot;, 18);        JsonObject jsonObject2 = new JsonObject();        jsonObject2.addProperty(&quot;id&quot;, 8888);        jsonObject2.addProperty(&quot;name&quot;, &quot;liuzhuo&quot;);        jsonObject2.addProperty(&quot;age&quot;, 20);        JsonArray jsonArray = new JsonArray();        jsonArray.add(jsonObject1);        jsonArray.add(jsonObject2);        System.out.println(jsonArray);       //[{&quot;id&quot;:6666,&quot;name&quot;:&quot;gakkij&quot;,&quot;age&quot;:18},{&quot;id&quot;:8888,&quot;name&quot;:&quot;liuzhuo&quot;,&quot;age&quot;:20}]    }</code></pre><p><code>注意：不是 JsonArray只能添加 JsonObject，其他的基本类型都能添加的,只是一般我们都是添加JsonObject对象，业务上好处理</code></p><pre><code>    public static void createJsonArray() {        JsonObject jsonObject1 = new JsonObject();        jsonObject1.addProperty(&quot;id&quot;, 6666);        jsonObject1.addProperty(&quot;name&quot;, &quot;gakkij&quot;);        jsonObject1.addProperty(&quot;age&quot;, 18);        JsonObject jsonObject2 = new JsonObject();        jsonObject2.addProperty(&quot;id&quot;, 8888);        jsonObject2.addProperty(&quot;name&quot;, &quot;liuzhuo&quot;);        jsonObject2.addProperty(&quot;age&quot;, 20);        JsonArray jsonArray = new JsonArray();        jsonArray.add(jsonObject1);        jsonArray.add(jsonObject2);        //添加其他类型的数据        jsonArray.add(4355);        jsonArray.add(&quot;address&quot;);        jsonArray.add(true);        System.out.println(jsonArray);        //[{&quot;id&quot;:6666,&quot;name&quot;:&quot;gakkij&quot;,&quot;age&quot;:18},{&quot;id&quot;:8888,&quot;name&quot;:&quot;liuzhuo&quot;,&quot;age&quot;:20},4355,&quot;address&quot;,true]    }</code></pre><hr><h4 id="删除JsonObject中的某一个属性"><a href="#删除JsonObject中的某一个属性" class="headerlink" title="删除JsonObject中的某一个属性"></a>删除JsonObject中的某一个属性</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">delJsonObjProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String str <span class="token operator">=</span> <span class="token string">"{\"id\":1234545,\"name\":\"gakki\",\"birthday\":\"2019-12-14T22:35:11.468\"}"</span><span class="token punctuation">;</span>        JsonElement parse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonObject jsonObject <span class="token operator">=</span> parse<span class="token punctuation">.</span><span class="token function">getAsJsonObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除之前："</span> <span class="token operator">+</span> jsonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>        String name <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除："</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">",之后："</span> <span class="token operator">+</span> jsonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-java"><code class="language-java">删除之前：<span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">1234545</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2019-12-14T22:35:11.468"</span><span class="token punctuation">}</span>删除：gakki<span class="token punctuation">,</span>之后：<span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">1234545</span><span class="token punctuation">,</span><span class="token string">"birthday"</span><span class="token operator">:</span><span class="token string">"2019-12-14T22:35:11.468"</span><span class="token punctuation">}</span></code></pre><hr><h4 id="修改Json对象中的某一个属性"><a href="#修改Json对象中的某一个属性" class="headerlink" title="修改Json对象中的某一个属性"></a>修改Json对象中的某一个属性</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">updateJsonObjProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String str <span class="token operator">=</span> <span class="token string">"{\"id\":1234545,\"name\":\"gakki\",\"birthday\":\"2019-12-14T22:35:11.468\"}"</span><span class="token punctuation">;</span>        JsonElement parse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonObject jsonObject <span class="token operator">=</span> parse<span class="token punctuation">.</span><span class="token function">getAsJsonObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改name属性之前："</span> <span class="token operator">+</span> jsonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>        jsonObject<span class="token punctuation">.</span><span class="token function">addProperty</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"liuzhuo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改name属性之后："</span> <span class="token operator">+</span> jsonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>PS: 修改属性其实就是和添加一样：使用 addProperty 方法，key存在就替换，不存在就添加。</p><hr><h4 id="获取Json对象中的某一个属性"><a href="#获取Json对象中的某一个属性" class="headerlink" title="获取Json对象中的某一个属性"></a>获取Json对象中的某一个属性</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getJsonObjProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String str <span class="token operator">=</span> <span class="token string">"{\"id\":1234545,\"name\":\"gakki\",\"birthday\":\"2019-12-14T22:35:11.468\"}"</span><span class="token punctuation">;</span>        JsonElement parse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonObject jsonObject <span class="token operator">=</span> parse<span class="token punctuation">.</span><span class="token function">getAsJsonObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String name <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name:"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">"unknow"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre class=" language-java"><code class="language-java">name<span class="token operator">:</span>gakki<span class="token boolean">false</span></code></pre><p>GSON 和 json官方的 JSONObject对象一样，可以使用has方法来判断是否存在：key。</p><p>但是，GSON没有官方的optXXX方法，当key不存在时，返回默认值或者返回指定的值。</p><hr><h4 id="创建复杂的Json对象"><a href="#创建复杂的Json对象" class="headerlink" title="创建复杂的Json对象"></a>创建复杂的Json对象</h4><pre><code>public static void createComplexPerson() {    /**     * 实际应用中：构建该json对象     * [{&quot;id&quot;:123,&quot;name&quot;:&quot;gakki&quot;,&quot;age&quot;:18,&quot;dog&quot;:{&quot;dName&quot;:&quot;小黄&quot;,&quot;color&quot;:&quot;yellow&quot;}},     * {&quot;id&quot;:345,&quot;name&quot;:&quot;liuzhuo&quot;,&quot;age&quot;:20,&quot;dog&quot;:{&quot;dName&quot;:&quot;小黑&quot;,&quot;color&quot;:&quot;black&quot;}}]     */    // 首先分析：数组中有几个对象，两个。对象下是否还有子对象：dog    JsonObject dog1 = new JsonObject();    dog1.addProperty(&quot;dName&quot;, &quot;小黄&quot;);    dog1.addProperty(&quot;color&quot;, &quot;yellow&quot;);    JsonObject dog2 = new JsonObject();    dog2.addProperty(&quot;dName&quot;, &quot;小黑&quot;);    dog2.addProperty(&quot;color&quot;, &quot;black&quot;);    JsonObject person1 = new JsonObject();    person1.addProperty(&quot;id&quot;, 123);    person1.addProperty(&quot;name&quot;, &quot;gakki&quot;);    JsonObject person2 = new JsonObject();    person2.addProperty(&quot;id&quot;, 123);    person2.addProperty(&quot;name&quot;, &quot;gakki&quot;);    person1.add(&quot;dog&quot;, dog1);    person2.add(&quot;dog&quot;, dog2);    JsonArray jsonArray = new JsonArray();    jsonArray.add(person1);    jsonArray.add(person2);    System.out.println(jsonArray);}</code></pre><p>输出结果：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">123</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"dog"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"dName"</span><span class="token operator">:</span><span class="token string">"小黄"</span><span class="token punctuation">,</span><span class="token string">"color"</span><span class="token operator">:</span><span class="token string">"yellow"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"id"</span><span class="token operator">:</span><span class="token number">123</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"gakki"</span><span class="token punctuation">,</span><span class="token string">"dog"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"dName"</span><span class="token operator">:</span><span class="token string">"小黑"</span><span class="token punctuation">,</span><span class="token string">"color"</span><span class="token operator">:</span><span class="token string">"black"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span>Process finished with exit code <span class="token number">0</span></code></pre><font color="red">PS: JsonObject对象中添加基本的元素是通过：addProperty 来添加的，如果是添加复杂对象，例如：JsonObject 或 JsonArray 就是使用：add 方法来添加。</font><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>GSON的基本使用方法：主要是使用：JsonParser对象、JsonObject对象、JsonArray对象。</p><ul><li>JsonObject 对应于json官方的：JSONObject</li><li>JsonArray 对应于json官方的：JSONArray</li><li>JsonParser对象解析json字符串后，得到是JsonElement对象，JsonObject的get，JsonArray的get都是得到JsonElement对象，JsonElement对象会有一系列的getAsXXX方法，例如：getAsInt , getAsString , getAsBoolean等。</li><li>当key不存在时，会返回null，所以需要使用 has 方法来判断是否存在该key</li><li><code>GSON没有json官方的 optXXX 方法,当key不存在时，返回默认值或指定的值。</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> GSON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Json的官方解析</title>
      <link href="/2019/12/14/json-de-guan-fang-jie-xi/"/>
      <url>/2019/12/14/json-de-guan-fang-jie-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="JSON介绍"><a href="#JSON介绍" class="headerlink" title="JSON介绍"></a>JSON介绍</h3><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。</p><h4 id="JSON的两种格式"><a href="#JSON的两种格式" class="headerlink" title="JSON的两种格式"></a>JSON的两种格式</h4><ul><li>​    “名称/值”对的集合（A collection of name/value pairs）。</li><li>值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。</li></ul><h4 id="JSON的具体格式"><a href="#JSON的具体格式" class="headerlink" title="JSON的具体格式"></a>JSON的具体格式</h4><ul><li>对象是一个<strong><code>无序</code></strong>的“‘名称/值’对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号）分隔。</li><li>值的<strong><code>有序</code></strong>列表（An ordered list of values）。在大部分语言中，它被实现为数组（array），矢量（vector），列表（list），序列（sequence）。</li></ul><h4 id="JSON的例子"><a href="#JSON的例子" class="headerlink" title="JSON的例子"></a>JSON的例子</h4><pre class=" language-java"><code class="language-java">对象的格式：<span class="token punctuation">{</span>  <span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"xxxx"</span><span class="token punctuation">,</span>  <span class="token string">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span>  <span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"yyyyy"</span><span class="token punctuation">}</span>列表的格式：<span class="token punctuation">[</span>  <span class="token punctuation">{</span>  <span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"xxxx"</span><span class="token punctuation">,</span>  <span class="token string">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span>  <span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"yyyyy"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>  <span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"xxxx"</span><span class="token punctuation">,</span>  <span class="token string">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span>  <span class="token string">"address"</span><span class="token operator">:</span><span class="token string">"yyyyy"</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><p>ps:</p><p>JSONObject是无序的<br>JSONArray是有序的</p><p>标准的json格式：key都是字符串且使用双引号包裹，value可以是任意的数据类型，例如：整形，字符串，对象，数组等。</p><p><a href="http://www.json.org.cn/" target="_blank" rel="noopener">JSON中国</a>    </p><hr><h3 id="JSON官方的解析"><a href="#JSON官方的解析" class="headerlink" title="JSON官方的解析"></a>JSON官方的解析</h3><h4 id="jsonObject的例子"><a href="#jsonObject的例子" class="headerlink" title="jsonObject的例子"></a>jsonObject的例子</h4><p>在resource下的user.json文件</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"gakkij"</span><span class="token punctuation">,</span>  <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>  <span class="token string">"address"</span><span class="token operator">:</span> <span class="token string">"东京"</span><span class="token punctuation">}</span></code></pre><p>博主创建的maven项目，可以自行选择IDE。</p><p>pom：</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>dependencies<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>mvnrepository<span class="token punctuation">.</span>com<span class="token operator">/</span>artifact<span class="token operator">/</span>org<span class="token punctuation">.</span>springframework<span class="token operator">/</span>spring<span class="token operator">-</span>core <span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>core<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">5.2</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">.</span>RELEASE<span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>mvnrepository<span class="token punctuation">.</span>com<span class="token operator">/</span>artifact<span class="token operator">/</span>commons<span class="token operator">-</span>io<span class="token operator">/</span>commons<span class="token operator">-</span>io <span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>commons<span class="token operator">-</span>io<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>commons<span class="token operator">-</span>io<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">2.4</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>mvnrepository<span class="token punctuation">.</span>com<span class="token operator">/</span>artifact<span class="token operator">/</span>org<span class="token punctuation">.</span>json<span class="token operator">/</span>json <span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>json<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>json<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">20160810</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>commons<span class="token operator">-</span>lang3<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">3.1</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>commons<span class="token operator">-</span>beanutils<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>commons<span class="token operator">-</span>beanutils<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">1.8</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>commons<span class="token operator">-</span>logging<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>commons<span class="token operator">-</span>logging<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">1.1</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>commons<span class="token operator">-</span>collections<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>commons<span class="token operator">-</span>collections<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">3.2</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>ezmorph<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>ezmorph<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">1.0</span><span class="token punctuation">.</span><span class="token number">6</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependencies<span class="token operator">></span></code></pre><h5 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h5><pre class=" language-java"><code class="language-java">        File jsonFile <span class="token operator">=</span> ResourceUtils<span class="token punctuation">.</span><span class="token function">getFile</span><span class="token punctuation">(</span><span class="token string">"classpath:user.json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> FileUtils<span class="token punctuation">.</span><span class="token function">readFileToString</span><span class="token punctuation">(</span>jsonFile<span class="token punctuation">)</span><span class="token punctuation">;</span>        JSONObject jsonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        String name <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String address <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    省略： set<span class="token punctuation">,</span>get 方法<span class="token punctuation">}</span></code></pre><p>说明：首先判断你的json文件的根是对象，还是列表，是对象就使用：JSONObject，是列表就使用：JSONArray。</p><p>jsonObject对象，可以通过各种：getXXX方法来获取 key 对应的 value 值，int类型就是：getInt；String类型就是：getString，如果value是 {}对象，就是：getJSONObject；如果是[] 列表类型，就是：getJSONArray。</p><hr><h4 id="jsonArray的例子"><a href="#jsonArray的例子" class="headerlink" title="jsonArray的例子"></a>jsonArray的例子</h4><p>在resource目录下：</p><p>section.json</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token number">1580615</span><span class="token punctuation">,</span>        <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"皮的嘛"</span><span class="token punctuation">,</span>        <span class="token string">"packageName"</span><span class="token punctuation">:</span> <span class="token string">"com.renren.mobile.android"</span><span class="token punctuation">,</span>        <span class="token string">"iconUrl"</span><span class="token punctuation">:</span> <span class="token string">"app/com.renren.mobile.android/icon.jpg"</span><span class="token punctuation">,</span>        <span class="token string">"stars"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>        <span class="token string">"size"</span><span class="token punctuation">:</span> <span class="token number">21803987</span><span class="token punctuation">,</span>        <span class="token string">"downloadUrl"</span><span class="token punctuation">:</span> <span class="token string">"app/com.renren.mobile.android/com.renren.mobile.android.apk"</span><span class="token punctuation">,</span>        <span class="token string">"des"</span><span class="token punctuation">:</span> <span class="token string">"2011-2017 你的铁头娃一直在这儿。中国最大的实名制SNS网络平台，嫩头青"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token number">1540629</span><span class="token punctuation">,</span>        <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"不存在的"</span><span class="token punctuation">,</span>        <span class="token string">"packageName"</span><span class="token punctuation">:</span> <span class="token string">"com.ct.client"</span><span class="token punctuation">,</span>        <span class="token string">"iconUrl"</span><span class="token punctuation">:</span> <span class="token string">"app/com.ct.client/icon.jpg"</span><span class="token punctuation">,</span>        <span class="token string">"stars"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>        <span class="token string">"size"</span><span class="token punctuation">:</span> <span class="token number">4794202</span><span class="token punctuation">,</span>        <span class="token string">"downloadUrl"</span><span class="token punctuation">:</span> <span class="token string">"app/com.ct.client/com.ct.client.apk"</span><span class="token punctuation">,</span>        <span class="token string">"des"</span><span class="token punctuation">:</span> <span class="token string">"斗鱼271934走过路过不要错过，这里有最好的鸡儿"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><h5 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h5><pre class=" language-java"><code class="language-java">File jsonFile <span class="token operator">=</span> ResourceUtils<span class="token punctuation">.</span><span class="token function">getFile</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> FileUtils<span class="token punctuation">.</span><span class="token function">readFileToString</span><span class="token punctuation">(</span><span class="token string">"classpath:section.json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==========="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JSONArray jsonArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONArray</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Section<span class="token operator">></span> sectionList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> jsonArray<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            JSONObject jsonObject <span class="token operator">=</span> jsonArray<span class="token punctuation">.</span><span class="token function">getJSONObject</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            String des <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"des"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"size"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String name <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String downloadUrl <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"downloadUrl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> id <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String packageName <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"packageName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String iconUrl <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"iconUrl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> stars <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"stars"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Section section <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Section</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> packageName<span class="token punctuation">,</span> iconUrl<span class="token punctuation">,</span> stars<span class="token punctuation">,</span> size<span class="token punctuation">,</span> downloadUrl<span class="token punctuation">,</span> des<span class="token punctuation">)</span><span class="token punctuation">;</span>            sectionList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>section<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sectionList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>section <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>section<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>说明：</p><p>json文件的根是：[] 开头的话，就使用 ：JSONArray 来解析。</p><p>通过遍历 JSONArray 对象来 获取其中的值，注意：JSONArray是有序的。</p><p>jsonArray的各种 get 方法，是需要判断 json文件中[]列表的value具体的类型，这里因为都是{}对象，因此，我统一都是使用：jsonArray.getJSONObject(i) 来解析的，如果[]中的类型不一致，那就需要分开处理了。</p><hr><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span>  <span class="token number">12</span><span class="token punctuation">,</span>  <span class="token string">"gakkj"</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"jacklove"</span><span class="token punctuation">,</span>    <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">,</span>    <span class="token string">"address"</span><span class="token punctuation">:</span> <span class="token string">"北京"</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><pre class=" language-java"><code class="language-java">        File jsonFile <span class="token operator">=</span> ResourceUtils<span class="token punctuation">.</span><span class="token function">getFile</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> FileUtils<span class="token punctuation">.</span><span class="token function">readFileToString</span><span class="token punctuation">(</span>jsonFile<span class="token punctuation">)</span><span class="token punctuation">;</span>        JSONArray jsonArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONArray</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> jsonArray<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String love <span class="token operator">=</span> jsonArray<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JSONObject jsonObject <span class="token operator">=</span> jsonArray<span class="token punctuation">.</span><span class="token function">getJSONObject</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String name <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String address <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"id:"</span><span class="token operator">+</span>id<span class="token operator">+</span><span class="token string">",love:"</span><span class="token operator">+</span>love<span class="token operator">+</span>"<span class="token punctuation">,</span>                             <span class="token punctuation">[</span><span class="token string">"+"</span>name<span class="token operator">:</span><span class="token string">"+name+"</span><span class="token punctuation">,</span>age<span class="token operator">:</span><span class="token string">"+age+"</span><span class="token punctuation">,</span>address<span class="token operator">:</span><span class="token string">"+address+"</span><span class="token punctuation">]</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>当json文件中，没有出现该key时，解析会出现什么呢？</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"gakki"</span><span class="token punctuation">,</span>  <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>  <span class="token string">"address"</span><span class="token operator">:</span> <span class="token string">"东京"</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">File jsonFile <span class="token operator">=</span> ResourceUtils<span class="token punctuation">.</span><span class="token function">getFile</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>String json <span class="token operator">=</span> FileUtils<span class="token punctuation">.</span><span class="token function">readFileToString</span><span class="token punctuation">(</span>jsonFile<span class="token punctuation">)</span><span class="token punctuation">;</span>JSONObject jsonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>String name <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>String nokown <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"unkown"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>nokown<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="https://pic2.superbed.cn/item/5df44e131f8f59f4d6faf363.jpg" alt></p><p>能看到：gakki解析出来了，但是不存在：unknow，就会直接抛出异常了。</p><hr><p>因此，为了提供程序的鲁棒性，解析之前请先判断是否存在：</p><pre class=" language-java"><code class="language-java">        File jsonFile <span class="token operator">=</span> ResourceUtils<span class="token punctuation">.</span><span class="token function">getFile</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> FileUtils<span class="token punctuation">.</span><span class="token function">readFileToString</span><span class="token punctuation">(</span>jsonFile<span class="token punctuation">)</span><span class="token punctuation">;</span>        JSONObject jsonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String name <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">boolean</span> unknow1 <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">"unknow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>unknow1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="https://pic2.superbed.cn/item/5df44f421f8f59f4d6fbc0a8.jpg" alt></p><p>可以看到，我们可以使用：has(“xxx”) 来判断是否存在该key。</p><hr><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"gakki"</span><span class="token punctuation">,</span>  <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>  <span class="token string">"address"</span><span class="token operator">:</span> <span class="token string">"东京"</span><span class="token punctuation">,</span>  <span class="token string">"host"</span><span class="token operator">:</span> null<span class="token punctuation">}</span></code></pre><p>当前：host是null。</p><pre class=" language-java"><code class="language-java">        File jsonFile <span class="token operator">=</span> ResourceUtils<span class="token punctuation">.</span><span class="token function">getFile</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> FileUtils<span class="token punctuation">.</span><span class="token function">readFileToString</span><span class="token punctuation">(</span>jsonFile<span class="token punctuation">)</span><span class="token punctuation">;</span>        JSONObject jsonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> host <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">"host"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> aNull <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span><span class="token string">"host"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aNull<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>执行：</p><pre class=" language-java"><code class="language-java"><span class="token boolean">true</span><span class="token boolean">true</span></code></pre><p>说明：只有key存在，has函数就返回true，不管value是不是null，isNull函数来判断value是不是null。</p><hr><p>有没有更好的方法，不需要判断key是否存在，如果key存在就返回value，不存在就返回Null，不抛出异常呢？</p><pre class=" language-java"><code class="language-java">        JSONObject jsonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        String unknow <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">optString</span><span class="token punctuation">(</span><span class="token string">"unknow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>unknow <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>unknow<span class="token punctuation">)</span><span class="token punctuation">;</span>        String host <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">optString</span><span class="token punctuation">(</span><span class="token string">"host"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>host <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">optInt</span><span class="token punctuation">(</span><span class="token string">"size"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="https://pic3.superbed.cn/item/5df4516e1f8f59f4d6fdbb59.jpg" alt></p><p>说明：使用optXXX() 方法，当key不存在，返回默认值，例如：optString()就是返回：””, 注意不是null。optInt()：返回0；optBoolean：返回：false。</p><p>ps：optXXX() 方法还有一个重载的方法，optSting(“xxx”,”default”) ，第二个参数就是当xxx不存在时，返回的值，不再是默认的空字符串！！！</p><pre class=" language-java"><code class="language-java">        JSONObject jsonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>        String unknow <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">optString</span><span class="token punctuation">(</span><span class="token string">"unknow"</span><span class="token punctuation">,</span><span class="token string">"you know"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>unknow<span class="token punctuation">)</span><span class="token punctuation">;</span>        String host <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">optString</span><span class="token punctuation">(</span><span class="token string">"host"</span><span class="token punctuation">,</span><span class="token string">"皇家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">optInt</span><span class="token punctuation">(</span><span class="token string">"size"</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">.</span><span class="token function">optBoolean</span><span class="token punctuation">(</span><span class="token string">"sss"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">you know皇家<span class="token number">17</span><span class="token boolean">true</span></code></pre><hr><p>枚举类型的解析：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"color"</span><span class="token operator">:</span> <span class="token string">"RED"</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>json<span class="token punctuation">.</span>domain<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author liuzhuo * @Date 2019/12/14 11:20 上午 * @Version 1.0 */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> Color <span class="token punctuation">{</span>    RED<span class="token punctuation">,</span>    BULE<span class="token punctuation">,</span>    YELLOW<span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">JSONObject jsonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>Color color <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">getEnum</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"color"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java">REDProcess finished with exit code <span class="token number">0</span></code></pre><hr><p>枚举定义自己的字段时：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>json<span class="token punctuation">.</span>domain<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Author liuzhuo * @Date 2019/12/14 11:20 上午 * @Version 1.0 */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> Color <span class="token punctuation">{</span>    <span class="token function">RED</span><span class="token punctuation">(</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">BULE</span><span class="token punctuation">(</span><span class="token string">"bule"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">YELLOW</span><span class="token punctuation">(</span><span class="token string">"yyyy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String fieldName<span class="token punctuation">;</span>    <span class="token function">Color</span><span class="token punctuation">(</span>String fieldName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>fieldName <span class="token operator">=</span> fieldName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Color <span class="token function">getColorByFieldName</span><span class="token punctuation">(</span>String fieldName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Color value <span class="token operator">:</span> Color<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>fieldName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>fieldName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> value<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getFieldName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> fieldName<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>  <span class="token string">"color"</span><span class="token operator">:</span> <span class="token string">"red"</span>  <span class="token comment" spellcheck="true">// 这里是我自己定义的field字段的值</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> org<span class="token punctuation">.</span>json<span class="token punctuation">.</span>JSONException<span class="token operator">:</span> JSONObject<span class="token punctuation">[</span><span class="token string">"color"</span><span class="token punctuation">]</span> is not an <span class="token keyword">enum</span> of type <span class="token string">"Color"</span><span class="token punctuation">.</span>    at org<span class="token punctuation">.</span>json<span class="token punctuation">.</span>JSONObject<span class="token punctuation">.</span><span class="token function">getEnum</span><span class="token punctuation">(</span>JSONObject<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">495</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>json<span class="token punctuation">.</span>JsonParse<span class="token punctuation">.</span><span class="token function">parseJson3</span><span class="token punctuation">(</span>JsonParse<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">46</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>json<span class="token punctuation">.</span>JsonParse<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>JsonParse<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">36</span><span class="token punctuation">)</span>Process finished with exit code <span class="token number">1</span></code></pre><p>运行抛出异常，说明不能使用自己定义 的字段 来获取，枚举类型。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>解析之前，请观看根是对象还是列表（数组），对象使用：JSONObject，数组使用：JSONArray。</p></li><li><p>对象解析时，根据value的类型，调用相应的 getXXX() 方法来获取value值。</p></li><li><p>数组解析时，因为数组是有序的，因此请注意，每个数组中元素类型是否是一致的，如果是就使用for循环遍历来解析，否则就必须根据数组中，不同的坐标下的元素来分开解析。</p></li><li><p>当key不存在时，使用：getXXX() 方法会抛出异常，可以使用：has() 方法提前判断是否存在，isNull()方法来判断值是不是null。</p></li><li><p>当key不存在时，不想抛出异常，请使用 optXXX() 方法，不存在会返回相应类型的默认值，String：空字符串，int：0，boolean：false。也可以使用 带有两个参数的optXXX(,) 方法，指定需要返回的值。</p></li><li><p>缺点：没有直接将json字符串解析出javaBean对象，这个 不太方便，每个javaBean的属性需要我们自己解析出来后，手动拼接。</p></li></ul><p>  后续，我会陆续介绍：GSON、fastJSON，jackSon， 并且分析这些json解析的优缺点。</p>]]></content>
      
      
      <categories>
          
          <category> json </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gakki水手服</title>
      <link href="/2019/12/08/gakki-shui-shou-fu/"/>
      <url>/2019/12/08/gakki-shui-shou-fu/</url>
      
        <content type="html"><![CDATA[<p>第一遍可爱，第二遍可爱，第三遍还是可爱。</p><div id="dplayer4" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer4"),"theme":"#FADFA3","loop":true,"video":{"url":"http://upos-sz-mirrorkodo.bilivideo.com/upgcxcode/38/87/37898738/37898738-1-208.mp4?e=ig8euxZM2rNcNbKVhWdVhwdl7wd1hwdVhoNvNC8BqJIzNbfq9rVEuxTEnE8L5F6VnEsSTx0vkX8fqJeYTj_lta53NCM=&uipk=5&nbs=1&deadline=1590903894&gen=playurl&os=kodobv&oi=837395164&trid=c42feb18f84f4120bf85f3e4f9e5efdbT&platform=html5&upsig=19deed6e1dd03870a0261e140d3ba574&uparams=e,uipk,nbs,deadline,gen,os,oi,trid,platform&mid=580104086&orderid=0,1&logo=80000000"},"danmaku":{"id":"dplayerOfgakkishui","api":"https://dplayer.moerats.com/","addition":["https://dplayer.moerats.com/v3/bilibili?aid=22818330"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><hr><p>马上快要新年了，博主祝各位接下来的每一天都是元气满满的~~~</p><p>素材：日剧《父女七日变》</p><p>BGM：《さようなら、花泥棒さん》锁那 </p><p>强烈安利这部剧！gakki太可爱了 </p><p>水手服gakki简直太太太好看了~~~</p>]]></content>
      
      
      <categories>
          
          <category> gakki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gakki的表白day</title>
      <link href="/2019/12/08/gakki-de-biao-bai-day/"/>
      <url>/2019/12/08/gakki-de-biao-bai-day/</url>
      
        <content type="html"><![CDATA[<p>B站up在5月20号制作的表白Gakki的视频，觉得非常有意思，因此保存到自己的博客上，如果侵权请告知。</p><div id="dplayer5" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer5"),"theme":"#FADFA3","loop":true,"video":{"url":"http://upos-sz-mirrorcos.bilivideo.com/upgcxcode/39/75/39547539/39547539-1-208.mp4?e=ig8euxZM2rNcNbNa7bdVhwdlhbujhwdVhoNvNC8BqJIzNbfq9rVEuxTEnE8L5F6VnEsSTx0vkX8fqJeYTj_lta53NCM=&uipk=5&nbs=1&deadline=1590904057&gen=playurl&os=cosbv&oi=837395164&trid=391e0973cc5a4c5ba95778e3bbd5cebbT&platform=html5&upsig=49d524248dfa86bb2a661e46e80ee072&uparams=e,uipk,nbs,deadline,gen,os,oi,trid,platform&mid=580104086&orderid=0,1&logo=80000000","pic":"https://pic.superbed.cn/item/5d0246c1451253d1783b86b2.jpg"},"danmaku":{"id":"dplayerOfgakki520","api":"https://dplayer.moerats.com/","addition":["https://dplayer.moerats.com/v3/bilibili?aid=23675732"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><hr><p>【520】表白我们最最最可爱的Gakki</p><p>在以后的日子里，也会一直一直一直的喜欢你！</p><p>虽然，我嘎已经过了30岁生日，但是在我心中一直是可爱的少女。</p><p>素材：gakki的历年CM以及小黛，今日子，白石。</p><p>BGM：《爱很美》Sara/刘佳</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gakki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ的基础实战&lt;二&gt;</title>
      <link href="/2019/05/11/rabbitmq-de-ji-chu-shi-zhan-er/"/>
      <url>/2019/05/11/rabbitmq-de-ji-chu-shi-zhan-er/</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章中，我们已经了解到了RabbitMQ中的基本操作了，现在让我们开始实战演习吧！</p><h3 id="最简单的模型"><a href="#最简单的模型" class="headerlink" title="最简单的模型"></a>最简单的模型</h3><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511145315.png" alt="最简单的模型"></p><p>从上图可以看出，最简单的模型就是：一个生产者、一个队列、一个消费者。</p><font color="red">注意：</font><p>其实，在Rabbitmq中，生产者是不能直接发送消息到队列中的，当发送消息时，不指定交换器的话，Rabbitmq会默认使用一个交换器来路由消息到队列中。（前面的博客中，我已经解释过了，不清楚的，可以再去看看！）</p><p>（1）获取连接</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 描述: * * @author liuzhuo * @create 2019-04-25 15:31 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConnectionUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String USERNAME <span class="token operator">=</span> <span class="token string">"gakkij"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String PASSWORD <span class="token operator">=</span> <span class="token string">"gakkij"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String IPADDRESS <span class="token operator">=</span> <span class="token string">"192.168.69.200"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> PORT <span class="token operator">=</span> <span class="token number">5672</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String VHOST <span class="token operator">=</span> <span class="token string">"/"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Connection <span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建连接工厂</span>        ConnectionFactory connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置相关的属性值</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span>USERNAME<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>PASSWORD<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置地址</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span>IPADDRESS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置端口号</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span>PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置虚拟主机</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span>VHOST<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//根据连接工厂创建连接</span>        Connection connection <span class="token operator">=</span> connectionFactory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> connection<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（2）生产者</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>simplest<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ConnectionUtil<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Channel<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Connection<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 描述: * * @author liuzhuo * @create 2019-04-25 15:45 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Productor</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 注意，这里是最简单的消息队列的使用，没有使用交换机的例子。         * 生产者"直接"把消息发送到队列中，发送消息时的routingKey必须与队列queue的名字相同才行。         */</span>        Connection connection <span class="token operator">=</span> null<span class="token punctuation">;</span>        Channel channel <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取信道</span>        connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//消息</span>        String message <span class="token operator">=</span> <span class="token string">"simplest queue!"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//发送消息到队列中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//没有指定交换器，使用的的空字符串，路由键是："simple_queue"</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"simple_queue"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送消息完毕！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭信道</span>        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（3）消费者</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>simplest<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ConnectionUtil<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeoutException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 描述: * * @author liuzhuo * @create 2019-04-25 15:57 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明队列</span>        <span class="token comment" spellcheck="true">//持久化队列、非排他队列、非自动删除队列，队列参数为null</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"simple_queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//不是自动应答，需要手动应答</span>            Boolean autoAck <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"simple_queue"</span><span class="token punctuation">,</span> autoAck<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=========================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"consumerTag: "</span> <span class="token operator">+</span> consumerTag<span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"envelope: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"exchange: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"routingKey: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getRoutingKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"deliveryTag: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接受到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//确认应对，如果不确认消息的话，队列里面的消息是不会消除的！！！</span>                    <span class="token comment" spellcheck="true">//envelope.getDeliveryTag()：消息的标识。</span>                    <span class="token comment" spellcheck="true">//multiple：false,只应答该条消息。true的话，应答所有比当前消息标识小的消息</span>                    channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（4）运行结果</p><p>先运行消费者：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511153422.png" alt></p><p>查看Rabbitmq的管控台：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511153545.png" alt></p><p>运行生产者：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511153641.png" alt></p><p>再看消费者的控制台：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511153721.png" alt></p><p>五条消息已经从生产者发送到队列中，然后消费者从队列中将消息给消费了。</p><hr><p>上述中，我们提到了，自动应答和手动应答的作用，如果是手动应答的话，需要我们人工来应答已经成功消费的消息，否则消息是不会从队列中删除的，如果在生产中，忘记了人工应答的话，会导致消息重复消费的，这里需要重点提醒大家！</p><p>现在，我们将手动应答的那条代码注释掉：</p><pre class=" language-java"><code class="language-java">                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=========================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"consumerTag: "</span> <span class="token operator">+</span> consumerTag<span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"envelope: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"exchange: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"routingKey: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getRoutingKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"deliveryTag: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接受到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//确认应对，如果不确认消息的话，队列里面的消息是不会消除的！！！</span>                    <span class="token comment" spellcheck="true">//将这条手动应答的代码注释掉！！！</span>                    <span class="token comment" spellcheck="true">//channel.basicAck(envelope.getDeliveryTag(), false);</span>        <span class="token punctuation">}</span></code></pre><p>再次运行，消费者，和生产者：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511154310.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511154403.png" alt></p><p><strong>似乎和刚刚没有什么区别</strong>？其实有很大的区别，现在的这五条消息根本没有删除，不信打开Rabbitmq的管控台：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511154553.png" alt></p><font color="red"><strong>所以，请大家注意</strong>：当你使用手动应答时，不要忘记主动编写应答的代码，不要忘记了，否则会重复消费消息的！！！</font><h3 id="工作队列模型"><a href="#工作队列模型" class="headerlink" title="工作队列模型"></a>工作队列模型</h3><p>上面的简单模式，只有一个消费者，现在我们尝试多个消费者的情况：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511155231.png" alt></p><p>工作队列模型时，生产者发送到队列中的消息，会<font color="red"><strong>均摊</strong></font>到各个消费者中，而不是将队列中的每个消息都发给所有的消费者。意思就是，如果现在队列中有：3，2，1，三条消息，1这条首先发送的消息，要么被Consumer1消费，要么被Consumer2消费，不会同时被这两个消费者消费！</p><p>（1）生产者：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Productor</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * work模式的消息队列，会存在多个消费者，每个消费者是均摊来消费消息的         * 即：每个消费者轮询来消费一个消息，不会考虑消费者的性能问题，会导致         * 性能强的消费者会空闲，性能差的消费者一直忙于消费消息。         *         * 我们可以通过设置： channel.basicQos(prefetchCount);来控制消费者的强度。         * prefetchCount：越大说明这个消费者的消费能力越强，否则，反之。         */</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"work_queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//循环十次来发送消息。</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String message <span class="token operator">=</span> <span class="token string">"work_queue_"</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"work_queue"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（2）消费者1：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Worker01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>            Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"work_queue"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>                String consumerTag<span class="token punctuation">,</span>                 Envelope envelope<span class="token punctuation">,</span>                 AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span>                 <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException             <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接受到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//确认应答</span>                channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//故意让这个消费者耗时，来代表这个消费者的业务难度高！！！</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（3）消费者2：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Worker02</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"work_queue"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接受到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//故意让这个消费者耗时短，来代表这个消费者的业务难度低</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们能看到，消费者1的业务逻辑复杂些，通过睡眠时间来代表的！按照我们之前的理论，多个消费者连接同一个队列的话，队列中的消息会均摊到每个消费者中，由于消费者1的业务处理花的时间交久些，消费者2的业务逻辑简单些，那样的话，消费者2处理的消息照理应该消费更多的消息，因为处理速度更快，接受到的消息会更多，下面我们来运行程序，看看是否符合我们的推理</p><p>如果先运行消费者的话，会出现异常，因为队列是在生产者中声明的，所以先运行生产者，声明：”work_queue”成功后，再运行两个消费者，最后再运行一次生产者：</p><p>首先看到管控台：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511161348.png" alt></p><p>再运行两个消费者：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511161524.png" alt></p><p>最后运行生产者：</p><p>查看两个消费者的控制台：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511161736.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511161822.png" alt></p><p>我们发现，为啥消费者1和消费者2，都是消费五条消息，而不是消费者2消费更多的消息呢？</p><p>这是因为，在Rabbitmq中，还有一个 <strong>basicQos</strong>属性，当不指定 basicQos属性的时候，Rabbitmq不管消费者的性能多强，队列中的消息都会均摊到每个消费者中，不管你是否是消费完毕了当前的消息。</p><hr><p>现在，我们在消费者1中，添加：channel.basicQos(1); </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Worker01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>            Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//这个消费者的性能差，我们就让它消费的慢一些。</span>            <span class="token comment" spellcheck="true">//说明最多发给这个消费者的消息就是一个，必须等这个消息消费完毕后，才会发送第二个。</span>            channel<span class="token punctuation">.</span><span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"work_queue"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接受到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//故意让这个消费者耗时，来代表这个消费者的业务难度高</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>channel.basicQos(1)</code>：表示当前的消费者，只能处理一个消息，当前的消息没有处理完的话，Rabbitmq是不会将队列中的消息再发给这个消费者的，怎么衡量消费者是否已经消费当前消息呢？就是应答处理，当Broker收到了消息应答，那么表示当前的消息已经处理完了，就可以发送下一条消息了。</p><p>在消费者2中，添加：channel.basicQos(3)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Worker02</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这个消费者的性能强，我们就让它消费的快一些。</span>        <span class="token comment" spellcheck="true">//说明最多发给这个消费者的消息是三条，不管当前消费者是否消费完毕当前消息。</span>        channel<span class="token punctuation">.</span><span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"work_queue"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接受到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//故意让这个消费者耗时，来代表这个消费者的业务难度低</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>channel.basicQos(3)</code>：表示Rabbitmq发送给这个消费者的<strong>没有应答</strong>的消息为三条，消费者可以慢慢处理这三条消息，当处理完当前的消息后，Rabbitmq会继续发送下一条消息，意思就是这个消费者中可以暂存三条消息。</p><hr><p>再次，测试：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511162957.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511163057.png" alt></p><p>现在，大家应该明白了，<code>channel.basicQos(prefetchCount)</code>的作用了。</p><h3 id="发布与订阅模型"><a href="#发布与订阅模型" class="headerlink" title="发布与订阅模型"></a>发布与订阅模型</h3><p>上面的演示中，都没有涉及到交换器（其实涉及到了默认的交换器），在我们平时的开发中，都是需要涉及到交换器的，现在开始我们的交换器的旅途吧。</p><p>发布与订阅模型，为了解决队列不能广播的问题，上述中，队列中的消息只能均摊到每个消费者中，不能将队列中的消息广播到与之有关联的消费者中，而交换器可以实现广播的功能。</p><p>这里就需要使用：<strong>“fanout”类型的交换器</strong>了。</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511165948.png" alt></p><p>（1）生产者</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Productor</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明交换机,fanout类型的交换器，持久化</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span><span class="token string">"fanout_exchange"</span><span class="token punctuation">,</span> <span class="token string">"fanout"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String message <span class="token operator">=</span> <span class="token string">"fanout_message"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//fanout类型的交换机，不需要指定routingKey，因为是广播的方式。</span>        channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">"fanout_exchange"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发出消息："</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（2）消费者1</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"fanout_queue01"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//绑定交换机与队列，不需要指定路由键！！！</span>        <span class="token comment" spellcheck="true">//将fanout_queue01队列 与 fanout_exchange交换器 绑定到了一起。</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span><span class="token string">"fanout_queue01"</span><span class="token punctuation">,</span> <span class="token string">"fanout_exchange"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//自动应答，false，不会自动应答，即不会自动消除消息。</span>            Boolean autoAck <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"fanout_queue01"</span><span class="token punctuation">,</span> autoAck<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"fanout_queue01_接受到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//确认应对，如果不确认消息的话，队列里面的消息是不会消除的！！！</span>                    channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（3）消费者2</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer02</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"fanout_queue02"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//绑定交换机与队列，不需要指定路由键！！！</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span><span class="token string">"fanout_queue02"</span><span class="token punctuation">,</span> <span class="token string">"fanout_exchange"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//自动应答，false，不会自动应答，即不会自动消除消息。</span>            Boolean autoAck <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"fanout_queue02"</span><span class="token punctuation">,</span> autoAck<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"fanout_queue02_接受到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//确认应对，如果不确认消息的话，队列里面的消息是不会消除的！！！</span>                    channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（4）测试：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511164905.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511164940.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511164955.png" alt></p><p>能看到，两个队列中都收到了 “fanout_message” 这条消息。</p><p>总结：</p><p>1）发送消息到 fanout类型的交换器时，不需要指定路由键。</p><p>2）绑定队列到 fanout类型的交换器时，不需要指定绑定键。</p><p>3）fanout类型的交换器，实现了交换器级别的广播，将消息发送到所有与之绑定的队列中。</p><h3 id="路由模型"><a href="#路由模型" class="headerlink" title="路由模型"></a>路由模型</h3><p>路由模型是使用：<strong>direct类型的交换器</strong>来实现的，路由键必须与绑定键完全匹配才行。</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511170212.png" alt></p><p>（1）生产者</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Productor</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         *  使用交换机的模式：direct。         *  direc：一个交换机的一个routingKey匹配一个队列，是一对一的关系。         *  注意交换机还是可以绑定多个队列的，只是通过routingKey匹配唯一的队列而已。         *         *  生产者只需声明交换机即可，消费者那里声明队列，然后设置routingKye来匹配队列。         *         *  生产者发送消息时，需要指定routingKey。发送的消息经过交换机后，会转发消息到与         *  routingKey匹配的队列中         *         *  发送消息时，使用不同的routingKey就可以发送消息到不同的队列中。         */</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明交换机</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span><span class="token string">"direct_exchange"</span><span class="token punctuation">,</span> <span class="token string">"direct"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String message <span class="token operator">=</span> <span class="token string">"gakki_message"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//发送消息，指定 交换机 和 路由键。</span>        channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">"direct_exchange"</span><span class="token punctuation">,</span> <span class="token string">"gakki"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送消息："</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（2）消费者1</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"gakki_queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//绑定交换机与队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span><span class="token string">"gakki_queue"</span><span class="token punctuation">,</span> <span class="token string">"direct_exchange"</span><span class="token punctuation">,</span> <span class="token string">"gakki"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Boolean autoAck <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"gakki_queue"</span><span class="token punctuation">,</span> autoAck<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"gakki_queue队列接受到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//确认应对，如果不确认消息的话，队列里面的消息是不会消除的！！！</span>                    channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（3）消费者2</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer02</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"liuzhuo_queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//绑定交换机与队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span><span class="token string">"liuzhuo_queue"</span><span class="token punctuation">,</span> <span class="token string">"direct_exchange"</span><span class="token punctuation">,</span> <span class="token string">"liuzhuo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//自动应答，false，不会自动应答，即不会自动消除消息。</span>            Boolean autoAck <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"liuzhuo_queue"</span><span class="token punctuation">,</span> autoAck<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"liuzhuo_queue队列接受到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//确认应对，如果不确认消息的话，队列里面的消息是不会消除的！！！</span>                    channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（4）测试：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511171334.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511171523.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511171637.png" alt></p><hr><p>修改生产者的代码：</p><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">//声明交换机</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span><span class="token string">"direct_exchange"</span><span class="token punctuation">,</span> <span class="token string">"direct"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String message <span class="token operator">=</span> <span class="token string">"liuzhuo_message"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//发送消息，指定 交换机 和 路由键。</span>        channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">"direct_exchange"</span><span class="token punctuation">,</span> <span class="token string">"liuzhuo"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送消息："</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511171822.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511172034.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511172105.png" alt></p><hr><p>总结：</p><p>1）direct类型的交换器，需要路由键与绑定键完全匹配才行。</p><p>2）direct类型的交换器，可以连接多个队列，指定不同的绑定键即可。</p><h3 id="主题模型"><a href="#主题模型" class="headerlink" title="主题模型"></a>主题模型</h3><p>前面讲到direct类型的Exchange路由规则是完全匹配binding key与routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同，它约定：</p><ul><li><p>routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”</p></li><li><p>binding key与routing key一样也是句点号“. ”分隔的字符串</p></li><li><p>binding key中可以存在两种特殊字符“*”与“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）</p></li></ul><p>主题模型就是使用 <strong>topic类型的交换器</strong>，如下所示：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190508160433.png" alt></p><p>（1）生产者</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Productor</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建topic类型的交换机</span>         channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span><span class="token string">"topic_exchange"</span><span class="token punctuation">,</span> <span class="token string">"topic"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建消息</span>        String message <span class="token operator">=</span> <span class="token string">"news.liuzhuo.djtopic"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//发送消息,需要路由键</span>        channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">"topic_exchange"</span><span class="token punctuation">,</span> <span class="token string">"news.liuzhuo.djtopic"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送的消息为："</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（2）消费者1</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"topic_queue01"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//绑定交换机与队列，需要指定路由键，路由键可以设置通配符: *.liuzhuo.*</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span><span class="token string">"topic_queue01"</span><span class="token punctuation">,</span> <span class="token string">"topic_exchange"</span><span class="token punctuation">,</span> <span class="token string">"*.liuzhuo.*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//自动应答，false，不会自动应答，即不会自动消除消息。</span>            Boolean autoAck <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"topic_queue01"</span><span class="token punctuation">,</span> autoAck<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"topic_queue01:接受到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//确认应对，如果不确认消息的话，队列里面的消息是不会消除的！！！</span>                    channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（3）消费者2</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer02</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"topic_queue02"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//绑定交换机与队列，需要指定路由键</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span><span class="token string">"topic_queue02"</span><span class="token punctuation">,</span> <span class="token string">"topic_exchange"</span><span class="token punctuation">,</span> <span class="token string">"*.*.client"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span><span class="token string">"topic_queue02"</span><span class="token punctuation">,</span> <span class="token string">"topic_exchange"</span><span class="token punctuation">,</span> <span class="token string">"com.#"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//自动应答，false，不会自动应答，即不会自动消除消息。</span>            Boolean isAsk <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"topic_queue02"</span><span class="token punctuation">,</span> isAsk<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"topic_queue02:接受到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//确认应对，如果不确认消息的话，队列里面的消息是不会消除的！！！</span>                    channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（4）测试：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511174027.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511174135.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511174159.png" alt></p><hr><p>修改生产者代码：</p><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">//创建消息</span>        String message <span class="token operator">=</span> <span class="token string">"news.liuzhuo.client"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//发送消息,需要路由键</span>        channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">"topic_exchange"</span><span class="token punctuation">,</span> <span class="token string">"news.liuzhuo.client"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行测试：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511174606.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511174632.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511174646.png" alt></p><hr><p>修改生产者代码：</p><pre class=" language-java"><code class="language-java">String message <span class="token operator">=</span> <span class="token string">"news.gakki.client"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//发送消息,需要路由键</span>        channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">"topic_exchange"</span><span class="token punctuation">,</span> <span class="token string">"news.gakki.client"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行测试：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511174826.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511174852.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511174907.png" alt></p><hr><p>修改生产者代码：</p><pre class=" language-java"><code class="language-java">String message <span class="token operator">=</span> <span class="token string">"com.xxxx"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//发送消息,需要路由键</span>channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">"topic_exchange"</span><span class="token punctuation">,</span> <span class="token string">"com.xxxx"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行测试：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511175320.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511175351.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511175405.png" alt></p><hr><p>topic类型的交换器，我就演示到这里了，大家可以自行测试~~~</p><h3 id="RPC模型"><a href="#RPC模型" class="headerlink" title="RPC模型"></a>RPC模型</h3><p>Remote procedure call (RPC)：<strong>远程过程调用</strong>。</p><p>MQ本身是基于异步的消息处理，前面的示例中所有的生产者（P）将消息发送到RabbitMQ后不会知道消费者（C）处理成功或者失败（甚至连有没有消费者来处理这条消息都不知道）。</p><p>但实际的应用场景中，我们很可能需要一些同步处理，需要同步等待服务端将我的消息处理完成后再进行下一步处理。这相当于RPC（Remote Procedure Call，远程过程调用）。在RabbitMQ中也支持RPC。</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511175828.png" alt></p><p>RabbitMQ中实现RPC的机制是：</p><ul><li>客户端发送请求（消息）时，在消息的属性（MessageProperties，在AMQP协议中定义了14种properties，这些属性会随着消息一起发送）中设置两个值 <strong>replyTo</strong>（一个Queue名称，用于告诉服务器处理完成后将通知我的消息发送到这个Queue中）和 <strong>correlationId</strong>（此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个id了解哪条请求被成功执行了或执行失败）</li><li>服务器端收到消息并处理</li><li>服务器端处理完消息后，将生成一条应答消息到 replyTo 指定的 Queue，同时带上correlationId属性</li><li>客户端之前已订阅 replyTo指定的 Queue，从中收到服务器的应答消息后，根据其中的 correlationId属性分析哪条请求被执行了，根据执行结果进行后续业务处理。</li></ul><p>服务器：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Connection connection <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//声明队列</span>            channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"rpc_queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"rpc_queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"rpc_queue中接收到的信息:"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送应答信息之前："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ReplyTo:"</span> <span class="token operator">+</span> properties<span class="token punctuation">.</span><span class="token function">getReplyTo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"CorrelationId:"</span> <span class="token operator">+</span> properties<span class="token punctuation">.</span><span class="token function">getCorrelationId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//发送应答的信息</span>                    AMQP<span class="token punctuation">.</span>BasicProperties props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">correlationId</span><span class="token punctuation">(</span>properties<span class="token punctuation">.</span><span class="token function">getCorrelationId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    String replytoMessage <span class="token operator">=</span> <span class="token string">"服务端消费完消息后，向客户端发送自己的应答信息！！！"</span><span class="token punctuation">;</span>                    channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> properties<span class="token punctuation">.</span><span class="token function">getReplyTo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> props<span class="token punctuation">,</span> replytoMessage<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送应答信息之后："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//连接不关闭，一直处于打开状态!</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>客户端：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Productor</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Connection connection <span class="token operator">=</span> null<span class="token punctuation">;</span>        Channel channel <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//声明反馈队列</span>            channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"replyTo_queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//UUID</span>            String uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String message <span class="token operator">=</span> <span class="token string">"rpc_message"</span><span class="token punctuation">;</span>            AMQP<span class="token punctuation">.</span>BasicProperties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                    <span class="token function">replyTo</span><span class="token punctuation">(</span><span class="token string">"replyTo_queue"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>                    <span class="token function">correlationId</span><span class="token punctuation">(</span>uuid<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"rpc_queue"</span><span class="token punctuation">,</span> properties<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发出消息："</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//接收应答信息</span>            channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"replyTo_queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>properties<span class="token punctuation">.</span><span class="token function">getCorrelationId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>uuid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"correlationId:"</span> <span class="token operator">+</span> properties<span class="token punctuation">.</span><span class="token function">getCorrelationId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"correlationId不是我声明的!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>30000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TimeoutException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>先运行服务器端，再运行客户端：</p><p>最开始的服务器端：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511194018.png" alt></p><p>客户端：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511194132.png" alt></p><p>再看服务器端：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190511194202.png" alt></p><hr><p>在我们的客户端中：</p><p><code>handleDelivery</code> 函数中使用了 死循环来同步，如果没有接收到 我们一开始发送的 correlationId的话，就会一直死循环，不会进行其他操作了，只要返回回来的correlationId和当初设置的correlationId相等的话，就会跳出死循环，进行下一步操作，强行让异步的消息中间件变成了同步的处理流程。</p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ的基础实战</title>
      <link href="/2019/05/10/rabbitmq-de-ji-chu-shi-zhan/"/>
      <url>/2019/05/10/rabbitmq-de-ji-chu-shi-zhan/</url>
      
        <content type="html"><![CDATA[<p>通过前面几篇博客的介绍，大家应该对RabbitMQ有了基础的认识了，现在开始带着大家进入RabbitMQ的基础实战，让大家体验一把RabbitMQ消息中间件的基础操作。</p><h3 id="连接RabbitMQ"><a href="#连接RabbitMQ" class="headerlink" title="连接RabbitMQ"></a>连接RabbitMQ</h3><h4 id="指定各种参数"><a href="#指定各种参数" class="headerlink" title="指定各种参数"></a>指定各种参数</h4><p>使用下面的代码来连接RabbitMQ，通过指定各种参数（IP地址、端口号、用户名、密码等）</p><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">//创建连接工厂</span>        ConnectionFactory connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置用户名和密码</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span>USERNAME<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//默认值：guest</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>PASSWORD<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//默认值：guest</span>        <span class="token comment" spellcheck="true">//设置ip地址</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span>IPADDRESS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置端口号</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span>PORT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//默认值：5672</span>        <span class="token comment" spellcheck="true">//设置虚拟主机</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span>VHOST<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//默认值：/</span>        <span class="token comment" spellcheck="true">//根据连接工厂创建连接</span>        Connection connection <span class="token operator">=</span> connectionFactory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="使用URI的方式"><a href="#使用URI的方式" class="headerlink" title="使用URI的方式"></a>使用URI的方式</h4><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">//创建连接工厂</span>        ConnectionFactory connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setUri</span><span class="token punctuation">(</span><span class="token string">"amqp://USERNAME:PASSWORD@IPADDRESS:PORT/VHOST"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Connection connection <span class="token operator">=</span> connectionFactory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </code></pre><h3 id="创建信道"><a href="#创建信道" class="headerlink" title="创建信道"></a>创建信道</h3><pre class=" language-java"><code class="language-java">        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在创建之后， Channel 可以用来发送或者接收消息了。</p><font color="red">注意事项：</font><p>Connection 可以用来创建多个 Channel 实例，但是 Channel 实例不能在线程间共享，应用程序应该为每一个线程新开辟一个 Channel 。某些情况下 Channel 的操作可以并发运行，但是在其他情况下会导致在网络上出现错误的通信帧交错，同时也会影响<strong>发送方确认( publisher confirm)机制</strong>的运行，所以多线程问共享 Channel 实例是非线程安全的。</p><h3 id="交换器与队列"><a href="#交换器与队列" class="headerlink" title="交换器与队列"></a>交换器与队列</h3><p>交换器和队列是 AMQP 中 high-level 层面的构建模块，应用程序需确保在使用它们的时候就已经存在了，在使用之前需要<strong>先声明 declare 它们</strong>。</p><p>我们再一次看一下AMQP协议的架构模型：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190510150917.png" alt></p><h4 id="交换器属性"><a href="#交换器属性" class="headerlink" title="交换器属性"></a>交换器属性</h4><p>1）Name：交换器名称</p><p>2）Type：交换器类型：direct、fanout、topic、headers</p><p>3）Durability：是否需要持久化，true为持久化</p><p>4）Auto Delete：当最后一个绑定到Exchange上的队列删除后，自动删除该Exchange</p><p>5）Internal：当前Exchange是否用于Rabbitmq内部使用，默认是false，我们基本上不使用这个属性，都设置为false</p><p>6）Arguments：扩展参数，用于扩展AMQP协议自定化使用</p><p>生产者和消费者都可以声明一个交换器或者队列。如果尝试声明一个已经存在的交换器或者队列 ，只要声明的参数完全匹配现存的交换器或者队列， RabbitMQ 就可以什么都不做 ，并成功返回 。如果声明的参数不匹配则会抛出异常。</p><h4 id="exchangeDeclare-方法详解"><a href="#exchangeDeclare-方法详解" class="headerlink" title="exchangeDeclare 方法详解"></a>exchangeDeclare 方法详解</h4><p>exchangeDeclare 有多个重载方法，这些重载方法都是由下面这个方法中缺省的某些参数构成的。</p><pre class=" language-java"><code class="language-java">Exchange<span class="token punctuation">.</span>DeclareOk <span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>String exchange<span class="token punctuation">,</span>             String type <span class="token punctuation">,</span> <span class="token keyword">boolean</span> durable <span class="token punctuation">,</span>             <span class="token keyword">boolean</span> autoDelete <span class="token punctuation">,</span> <span class="token keyword">boolean</span> internal<span class="token punctuation">,</span>             Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> arguments<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不常用，不阻塞的方法，有风险！</span><span class="token keyword">void</span> <span class="token function">exchangeDeclareNoWait</span><span class="token punctuation">(</span>String exchange<span class="token punctuation">,</span>             String type <span class="token punctuation">,</span> <span class="token keyword">boolean</span> durable <span class="token punctuation">,</span>             <span class="token keyword">boolean</span> autoDelete <span class="token punctuation">,</span> <span class="token keyword">boolean</span> internal<span class="token punctuation">,</span>             Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> arguments<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span></code></pre><p> 各个参数的含义，上面我已经解释了，这里就不再解释了，不过重点的参数还是再说一遍：</p><ul><li>durable：设置是否持久化。true：表示持久化，反之是非持久化。持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息。</li><li>autoDelete：设置是否自动删除。autoDelete 设置为 true ，则表示自动删除。自动删除的前提是至少有 一个队列或者交换器 与 该交换器绑定之后，然后所有与这个交换器绑定的队列或者交换器都与 其解绑了，才会自动删除。<strong>注意</strong>：不能错误地 把这个参数理解为 “当与此交换器连接的客户端都断开时 ，RabbitMQ会自动 删除本交换器 “ 。</li><li>internal：设置是否为内置的。如果设置为 true，则表示是内置的交换器，客户端程序无法直接发送消息到这个交换器中，只能通过交换器 路由 到这个交换器中。</li><li>arguments：其他一些结构化参数，比如 alternate-exchange。</li></ul><h4 id="队列属性"><a href="#队列属性" class="headerlink" title="队列属性"></a>队列属性</h4><p>1）Name：队列的名字</p><p>2）durable：是否持久化，true：持久化，反之非持久化</p><p>3）exclusive：是否排他，true：排他队列，只能在同一个连接下才能使用</p><p>4）autoDelete：是否自动删除，true：自动删除</p><p>5）arguments：其他一些参数</p><h4 id="queueDeclare-方法详解"><a href="#queueDeclare-方法详解" class="headerlink" title="queueDeclare 方法详解"></a>queueDeclare 方法详解</h4><p>queueDeclare 相对于 exchangeDeclare 方法而言，重载方法的个数就少很多 ，它只有两个重载方法:</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> Queue<span class="token punctuation">.</span>DeclareOk <span class="token function">queueDec1are</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token function">IOException</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> Queue<span class="token punctuation">.</span>DeclareOk <span class="token function">queueDec1are</span><span class="token punctuation">(</span>String queue <span class="token punctuation">,</span> <span class="token keyword">boolean</span> durable <span class="token punctuation">,</span> <span class="token keyword">boolean</span> exclusive <span class="token punctuation">,</span> <span class="token keyword">boolean</span> autoDelete <span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String Object<span class="token operator">></span> arguments<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不常用</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">queueDec1areNoWait</span><span class="token punctuation">(</span>String queue <span class="token punctuation">,</span> <span class="token keyword">boolean</span> durable <span class="token punctuation">,</span> <span class="token keyword">boolean</span> exclusive <span class="token punctuation">,</span> <span class="token keyword">boolean</span> autoDelete <span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String Object<span class="token operator">></span> arguments<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span></code></pre><p>参数详解：</p><ul><li>queue：队列的名字</li><li>durable：设置是否持久化。为 true 则设置队列为持久化。持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息。</li><li>exclusive：设置是否排他。为 true 则设置队列为排他的。如果一个队列被声明为排队列，该队列仅对首次声明它的连接可见，<strong>并在连接断开时自动删除</strong>。<font color="red">这里需要注意三点</font>: 排他队列是基于连接( Connection) 可见的，同一个连接的不同信道 (Channel)也是可以同时访问排他队列的；首次是指如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；即使该队列是持久化的，一旦连接关闭或客户端退出，该排他队列都会被自动删除，这种队列适用于一个客户端同时发送和接收消息的应用场景。</li><li>autoDelete：设置是否自动删除。为 true 则设置队列为自动删除。自动删除的前提是: <strong>至少有一个</strong>消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。不能把这个参数错误地理解为: “当连接到此队列的所有客户端断开时，这个队列自动删除 “，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列。</li><li>arguments：设置队列的其他一些参数，如 ：x-message-ttl 、 x-expires 、x-max-length 、x-max-length-bytes 、x-dead-letter-exchange 、x-dead-letter-routing-key 、x-max-priority 等。</li></ul><font color="red"><strong>注意要点：</strong></font><p>生产者和消费者都能够使用 queueDeclare 来声明一个队列，但是如果消费者在同一个信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，然后将信道直为”传输”模式，之后才能声明队列。</p><h4 id="queueBind-方法详解"><a href="#queueBind-方法详解" class="headerlink" title="queueBind 方法详解"></a>queueBind 方法详解</h4><p>将队列和交换器绑定 方法如下 ，可以与前两节中的方法定义进行类比</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> Queue<span class="token punctuation">.</span>BindOk <span class="token function">queueBind</span><span class="token punctuation">(</span>String queue <span class="token punctuation">,</span> String exchange <span class="token punctuation">,</span> String routingKey<span class="token punctuation">)</span><span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> Queue<span class="token punctuation">.</span>BindOk <span class="token function">queueBind</span><span class="token punctuation">(</span>String queue <span class="token punctuation">,</span> String exchange <span class="token punctuation">,</span> String routingKey<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> arguments<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不常用</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">queueBindNoWait</span><span class="token punctuation">(</span>String queue <span class="token punctuation">,</span> String exchange <span class="token punctuation">,</span> String routingKey<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> arguments<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span></code></pre><p>方法中涉及的参数详解：</p><ul><li>queue：队列的名称</li><li>exchange：交换器的名称</li><li>routingKey：用来绑定队列和交换器的路由键（也是BindingKey：绑定键！！！）</li><li>arguments：定义绑定的一些参数</li></ul><p>不仅可以将队列和交换器绑定起来，也可以将已经被绑定的队列和交换器进行解绑。</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> Queue<span class="token punctuation">.</span>UnbindOk <span class="token function">queueUnbind</span> <span class="token punctuation">(</span>String queue <span class="token punctuation">,</span> String exchange <span class="token punctuation">,</span> String routingKey<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> Queue<span class="token punctuation">.</span>UnbindOk <span class="token function">queueUnbind</span> <span class="token punctuation">(</span>String queue <span class="token punctuation">,</span> String exchange <span class="token punctuation">,</span> String routingKey<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String <span class="token punctuation">,</span> Object<span class="token operator">></span> arguments<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span></code></pre><h4 id="exchangeBind-方法详解"><a href="#exchangeBind-方法详解" class="headerlink" title="exchangeBind 方法详解"></a>exchangeBind 方法详解</h4><p>我们不仅可以将交换器与队列绑定，也可以<strong>将交换器与交换器绑定</strong>，后者和前者的用法如出一辙，相应的方法如下:</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> Exchange<span class="token punctuation">.</span>BindOk <span class="token function">exchangeBind</span><span class="token punctuation">(</span>String destination <span class="token punctuation">,</span> String source <span class="token punctuation">,</span> String routingKey<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> Exchange<span class="token punctuation">.</span>BindOk <span class="token function">exchangeBind</span><span class="token punctuation">(</span>String destination<span class="token punctuation">,</span> String source <span class="token punctuation">,</span> String routingKey<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String <span class="token punctuation">,</span> Object<span class="token operator">></span> arguments<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不常用</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">exchangeBindNoWait</span><span class="token punctuation">(</span>String destination<span class="token punctuation">,</span> String sour ce <span class="token punctuation">,</span> String routingKey<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> arguments<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span></code></pre><p>交换器与交换器绑定之后 ，消息由 source交换器 转发到 destination交换器中，某种程度上来 destination交换器可以 看作是一个队列 。示例代码如下：</p><pre class=" language-java"><code class="language-java">channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span> <span class="token string">"source"</span> <span class="token punctuation">,</span> <span class="token string">"direct"</span> <span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span> channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span> <span class="token string">"destination"</span> <span class="token punctuation">,</span> <span class="token string">"fanout"</span> <span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span> channel<span class="token punctuation">.</span><span class="token function">exchangeBind</span><span class="token punctuation">(</span> <span class="token string">"destination"</span> <span class="token punctuation">,</span> <span class="token string">"source"</span> <span class="token punctuation">,</span> <span class="token string">"exKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span> <span class="token string">"queue"</span> <span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span> channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span> <span class="token string">"queue"</span> <span class="token punctuation">,</span> <span class="token string">"destination"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span> <span class="token string">"source"</span> <span class="token punctuation">,</span> <span class="token string">"exKey"</span> <span class="token punctuation">,</span> null <span class="token punctuation">,</span> <span class="token string">"exToExDemo"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>生产者发送消息至交换器 source 中，交换器 source 根据 路由键：”exkey” 找到与其匹配 另一个交换器destination 井把消息转发到 destination中，进而存储到与destination 进行绑定的队列 “queue” 中。参考如下：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190510163729.png" alt></p><p>这里声明了 fanout 和 direct 的两个交换器，一个队列，direct 是完全匹配的路由规则，fanout是广播的路由规则，这里大家简单看看，后面会陆续讲解交换器的类型的。</p><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>如果要发送一条消息，可以使用 Channel 类的 <strong>basicPublish</strong> 方法，比如发送一条内容为：”Hello World! “ 消息</p><pre class=" language-java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> messageBodyBytes <span class="token operator">=</span> <span class="token string">"Hello,world!"</span><span class="token punctuation">.</span> <span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>exchangeName <span class="token punctuation">,</span> routingKey <span class="token punctuation">,</span> null <span class="token punctuation">,</span> messageBodyBytes<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>为了更好地控制发送，可以使用 <strong>mandatory</strong> 这个参数 或者 可以发送一些特定属性的信息:</p><pre class=" language-java"><code class="language-java">channe1<span class="token punctuation">.</span><span class="token function">basicPub1ish</span><span class="token punctuation">(</span>exchangeName <span class="token punctuation">,</span> routingKey <span class="token punctuation">,</span> mandatory<span class="token punctuation">,</span>                     MessageProperties<span class="token punctuation">.</span>PERSISTENT_TEXT_PLAIN <span class="token punctuation">,</span>                     messageBodyBytes <span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre><p> MessageProperties.PERSISTENT_TEXT_PLAIN：这个属性的意思是，这条消息的投递模式 （delivery mode） 设置为2 ，即消息会被持久化(即存入磁盘)在服务器中。同时这条消息的优先级（ priority ) 设置为 1，content-type设置为 “text/plain” 。和下面自定义设置属性一模一样：</p><pre class=" language-java"><code class="language-java">channe1<span class="token punctuation">.</span><span class="token function">basicPub1ish</span><span class="token punctuation">(</span>exchangeName <span class="token punctuation">,</span> routingKey <span class="token punctuation">,</span>             <span class="token keyword">new</span> <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span><span class="token string">"text/plain"</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">deliveryMode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">priority</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">userId</span><span class="token punctuation">(</span><span class="token string">"hidden"</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>             messageBodyBytes<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>也可以发送 一条带有 headers 的消息：</p><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String <span class="token punctuation">,</span> Object<span class="token operator">></span> headers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> headers<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span> <span class="token string">"localtion"</span> <span class="token punctuation">,</span> <span class="token string">"here"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> headers<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span> <span class="token string">"time"</span> <span class="token punctuation">,</span> <span class="token string">"today"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>exchangeName，routingKey，            <span class="token keyword">new</span> <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">headers</span><span class="token punctuation">(</span>headers<span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            messageBodyBytes<span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre><p>还可以发送一条带有过期时间 ( expiration ）的消息：</p><pre class=" language-java"><code class="language-java">channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>exchangeName <span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span>             <span class="token keyword">new</span> <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">expiration</span><span class="token punctuation">(</span> <span class="token string">"60000"</span> <span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>             messageBodyBytes<span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre><p>以上只是举例，由于篇幅关系，这里就不一一列举所有的可能情形了。对于 basicPublish 而言，有几个重载方法</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">basicPublish</span> <span class="token punctuation">(</span>String exchange <span class="token punctuation">,</span> String routingKey<span class="token punctuation">,</span> BasicProperties props<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">basicPublish</span><span class="token punctuation">(</span>String exchange，String routingKey<span class="token punctuation">,</span> <span class="token keyword">boolean</span> mandatory<span class="token punctuation">,</span>BasicProperties props<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">basicPublish</span><span class="token punctuation">(</span>String exchange <span class="token punctuation">,</span> String routingKey<span class="token punctuation">,</span> <span class="token keyword">boolean</span> mandatory<span class="token punctuation">,</span> <span class="token keyword">boolean</span> immediate <span class="token punctuation">,</span> BasicProperties props<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span></code></pre><p>对应的具体参数解释如下所述：</p><ul><li><p>exchange：交换器的名称，指明消息需要发送到哪个交换器中 ，如果设置为<strong>空字符串</strong>，则消息会被发送到 RabbitMQ 默认的交换器中。</p></li><li><p>routingKey：路由键，交换器根据路由键将消息存储到相应的队列之中。</p></li><li><p>props：消息的基本属性集，其包含 14 个属性成员，分别有 contentType、<br>contentEncoding 、headers (Map<string object\>)、 deliveryMode 、priority 、correlationld 、replyTo、 expiration 、messageld 、timestamp、 type 、userld、 appld 、clusterId 。其中常用的几种都在上面的示例中进行了演示。</string></p></li><li><p>body：消息体 （payload） ，真正需要发送的消息。</p></li><li><p>mandatory 和  immediate 会在后面的高级操作中讲到。</p></li></ul><h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><p>RabbitMQ的消费模式分两种：推（Push）模式 和 拉（Pull）模式。推模式采用：<strong>Basic.Consume</strong> 进行消费，而拉模式：则是调用 <strong>Basic.Get</strong> 进行消费。</p><h4 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h4><p>在推模式中，可以通过持续订阅的方式来消费消息，使用到的相关类有：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Consumer<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>DefaultConsumer<span class="token punctuation">;</span></code></pre><p>接收消息一般通过实现 Consumer 接口 或者 继承 DefaultConsumer 类来实现。</p><p>当调用与Consumer相关的API方法时，不同的订阅采用不同的消费者标签 (consumerTag) 来区分彼此 ，在同一个 Channel 中的消费者 也需要通过唯一的消费者标签以作区分，关键消费代码如下：</p><pre class=" language-java"><code class="language-java">            Boolean autoAck <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"queueName"</span><span class="token punctuation">,</span> autoAck<span class="token punctuation">,</span> <span class="token string">"myConsumerTag"</span> <span class="token punctuation">,</span>                  <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span>                                            Envelope envelope<span class="token punctuation">,</span>                                            AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span>                                            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span>                     <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"consumerTag: "</span> <span class="token operator">+</span> consumerTag<span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"envelope: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"exchange: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"routingKey: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getRoutingKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"deliveryTag: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接受到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>注意，上面代码中显示地设置 autoAck 为 false，然后在接收到消息之后进行显示 ack操作（channel.basicAck），对于消费者来说这个设置是非常必要的，可以防止消息不必要地丢失。</p><p>Channel 类中 basicConsume 方法如下几种形式：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> String <span class="token function">basicConsume</span><span class="token punctuation">(</span>String queue <span class="token punctuation">,</span> Consumer callback<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> String <span class="token function">basicConsume</span><span class="token punctuation">(</span>String queue <span class="token punctuation">,</span> <span class="token keyword">boolean</span> autoAck<span class="token punctuation">,</span> Consumer callback<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> String <span class="token function">basicConsume</span><span class="token punctuation">(</span>String queue <span class="token punctuation">,</span> <span class="token keyword">boolean</span> autoAck<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> arguments<span class="token punctuation">,</span> Consumer callback<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> String <span class="token function">basicConsume</span><span class="token punctuation">(</span>String queue <span class="token punctuation">,</span> <span class="token keyword">boolean</span> autoAck<span class="token punctuation">,</span> String consumerTag<span class="token punctuation">,</span> Consumer callback<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> String <span class="token function">basicConsume</span><span class="token punctuation">(</span>String queue <span class="token punctuation">,</span> <span class="token keyword">boolean</span> autoAck<span class="token punctuation">,</span> String consumerTag<span class="token punctuation">,</span> <span class="token keyword">boolean</span> noLocal <span class="token punctuation">,</span> <span class="token keyword">boolean</span> exclusive <span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String <span class="token punctuation">,</span> Object<span class="token operator">></span> arguments<span class="token punctuation">,</span> Consumer callback<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span></code></pre><p>其对应的参数说明如下所述：</p><ul><li>queue：队列的名称</li><li>autoAck：设置是否自动确认。建议设成false，即不自动确认</li><li>consumerTag：消费者标签，用来区分多个消费者</li><li>noLocal：设置为 true 则表示不能将同一个 Connection 中生产者发送的消息传送给<br>这个 Connection 中的消费者:</li><li>exclusive：设置是否排他</li><li>arguments：设置消费者的其他参数</li><li>callback：设置消费者的回调函数。用来处理 RabbitMQ 推送过来的消息，比如<br>DefaultConsumer 使用时需要客户端重写 (override) 其中的方法。</li></ul><p>每个 Channel 都拥有自己独立的线程。最常用的做法是一 个Channel 对应一个消费者，也就是意味着消费者彼此之间没有任何关联。当然也可以在一个 Channel 中维持多个消费者，但是要注意一个问题，如果 Channel 中的 一个消费者一直在运行，那么其他消费者的 callback 会被 “耽搁” 。</p><h4 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h4><p>这里讲一下拉模式的消费方式。通过 channel.basicGet 方法可以<strong>单条地获取消息</strong>，其返回值是 GetRespone。Channel 类的 basicGet 方法没有其他重载方法，只有：</p><pre class=" language-java"><code class="language-java">GetResponse <span class="token function">basicGet</span><span class="token punctuation">(</span>String queue <span class="token punctuation">,</span> <span class="token keyword">boolean</span> autoAck<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span></code></pre><p>其中 queue 代表队列的名称，如果设置 autoAck 为 false ，那么同样需要调用 channel.basicAck 来确认消息己被成功接收。</p><p>拉模式的关键代码为：</p><pre class=" language-java"><code class="language-java">GetResponse response <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">basicGet</span><span class="token punctuation">(</span>QUEUE_NAME <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">getEnvelope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><font color="red"><strong>注意要点：</strong></font><p>Basic.Consume 将信道 (Channel) 设置为接收模式，直到取消队列的订阅为止。在接收模式期间， RabbitMQ 会不断地推送消息给消费者，当然推送消息的个数还是会受到 Basic.Qos的限制。如果只想从队列获得单条消息而不是持续订阅，建议还是使用 Basic.Get 进行消费。但是不能将 Basic.Get 放在一个循环里来代替 Basic.Consume ，这样做会严重影响 RabbitMQ 的性能。如果要实现高吞吐量，消费者理应使用 Basic.Consume 方法。</p><h3 id="消费端的确认与拒绝"><a href="#消费端的确认与拒绝" class="headerlink" title="消费端的确认与拒绝"></a>消费端的确认与拒绝</h3><h4 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h4><p>为了保证消息从队列可靠地达到消费者， RabbitMQ 提供了<strong>消息确认机制</strong>( message acknowledgement)， 消费者在订阅队列时，可以指定 autoAck 参数，当 autoAck 等于 false 时， RabbitMQ 会等待消费者显式地回复确认信号后才从内存(或者磁盘)中移去消息(实质上是先打上删除标记，之后再删除) 。当 autoAck 等于 true 时， RabbitMQ 会自动把发送出去的消息设置为确认，然后从内存(或者磁盘)中删除，而不管消费者是否真正地消费到了这些消息。</p><p>采用消息确认机制后，只要设置 <strong>autoAck 参数为 false</strong> ，消费者就有足够的时间来处理消息(任务) ，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题 ，因为 RabbitMQ 会一直等待持有消息直到消费者显式调Basic.Ack 命令为止。</p><p>当 autoAck 参数置为 false ，对于 RabbitMQ 服务端而言，队列中的消息分成了两个部分：一部分是等待投递给消费者的消息；一部分是己经投递给消费者，但是还没有收到消费者确认信号的消息。 如果 RabbitMQ 一直没有收到消费者的确认信号，并且消费此消息的消费者己经断开连接，则 RabbitMQ 会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。</p><p>RabbitMQ 不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的依据是消费该消息的消费者连接是否己经断开，这么设计的原因是 RabbitMQ 允许消费者消费这条消息的时间可以很久很久。</p><p>RabbtiMQ Web 管理平台上可以看到当前队列中的 <strong>“Ready” 状态</strong> 和 <strong>“Unacknowledged” 状态</strong> 的消息数，分别对应上文中的等待投递给消费者的消息数 和 己经投递给消费者但是未收到确认信号的消息数。</p><h4 id="消息拒绝"><a href="#消息拒绝" class="headerlink" title="消息拒绝"></a>消息拒绝</h4><p>在消费者接收到消息后，如果想明确拒绝当前的消息而不是确认，那么应该怎么做呢? RabbitMQ在 2.0.0 版本开始引入了 <strong>Basic.Reject</strong> 这个命令，消费者客户端可以调用与其对应的 <strong>channel.basicReject</strong> 方法来告RabbitMQ 拒绝这个消息。</p><p>Channel 类中的 basicReject 方法定义如下:</p><p><code>void basicReject(long deliveryTag, boolean requeue) throws IOException;</code></p><p>其中 deliveryTag 可以看作消息的编号 ，它是 一个 64 位的长整型值，最大值是9223372036854775807 。如果 requeue 参数设置为 true ，则 RabbitMQ 会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者；如果 requeue 参数设置为 false ，则 RabbitMQ立即会把消息从队列中移除，而不会把它发送给新的消费者。</p><p>Basic.Reject 命令一次只能拒绝一条消息 ，如果想要批量拒绝消息 ，则可以使用<br>Basic.Nack 这个命令 。消费者客户端可以调用 <strong>channel.basicNack</strong> 方法来实现，方法定义如下:</p><p><code>void basicNack(long deliveryTag , boolean multiple , boolean requeue) throws IOException;</code></p><p>其中 deliveryTag  和 requeue 的含义可以参考 basicReject 方法。 <strong>multiple 参数</strong> 设置为 false 则表示拒绝编号为 deliveryTag 的这一条消息，这时候 basicNack 和 basicReject 方法一样；multiple 参数设置为 true 则表示拒绝 deliveryTag 编号之前所有未被当前消费者确认的消息。</p><hr><p>对于 requeue， AMQP 中还有一个命令 Basic.Recover 具备可入队列的特性 。其对应的客户端方法为:</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> Basic<span class="token punctuation">.</span>RecoverOk <span class="token function">basicRecover</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> Basic<span class="token punctuation">.</span>RecoverOk <span class="token function">basicRecover</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> requeue<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span></code></pre><p>这个 channel.basicRecover 方法用来请求 RabbitMQ 重新发送还未被确认的消息。如果 requeue 参数设置为 true ，则未被确认的消息会被重新加入到队列中，这样对于同一条消息来说，可能会被分配给与之前不同的消费者。如果 requeue 参数设置为 false ，那么同一条消息会被分配给与之前相同的消费者。默认情况下，如果不设置 requeue 这个参数，相当于channel.basicRecover(true) ，即 requeue 默认为 true。</p><h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>在应用程序使用完之后，需要关闭连接，释放资源:</p><pre class=" language-java"><code class="language-java">channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre><p>显式地关闭 Channel 是个好习惯，但这不是必须的，在 Connection 关闭的时候，Channel 也会自动关闭。</p><p>AMQP 协议中的 Connection  和 Channel 采用同样的方式来管理：网络失败、内部错误 和 显式地关闭连接。 Connection 和 Channel 所具备的生命周期如下所述。</p><ul><li>Open：开启状态，代表当前对象可以使用。</li><li>Closing：正在关闭状态。当前对象被显式地通知调用关闭方法( shutdown) ，这样<br>就产生了一个关闭请求让其内部对象进行相应的操作， 并等待这些关闭操作的完成。</li><li>Closed：已经关闭状态。当前对象己经接收到其所有的内部对象己完成关闭动作的通知，<br>并且其也关闭了自身。</li></ul><p>Connection 和 Channel 最终都是会成为 Closed 的状态，不论是程序正常调用的关闭方法，或者是客户端的异常，再或者是发生了网络异常。</p><p>在 Connection 和 Channel 中，与关闭相关的方法有 ：<strong>addShutdownListener(ShutdownListener listener)</strong> 和 <strong>removeShutdownListener (ShutdownListner listener)</strong> 。当 Connection 或者 Channel 的状态转变为 Closed 的时候会调用ShutdownListener 。而且如果将一个 ShutdownListener 注册到一个己经处于Closed状态的对象(这里特指 Connection Channel 对象) 时，会立刻调用 ShutdownListener。</p><p>getCloseReason 方法可以让你知道对象关闭的原因 ；isOpen 方法检测对象当前是否处于开启状态；close(int closeCode , String closeMessage ) 方法 显式地通知当前对象执行关闭操作。</p><hr><p>有关 ShutdownListener 的使用可以参考代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>ShutdownSignalException<span class="token punctuation">;</span> <span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>ShutdownListener<span class="token punctuation">;</span>connection<span class="token punctuation">.</span><span class="token function">addShutdownListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ShutdownListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdownCompleted</span> <span class="token punctuation">(</span>ShutdownSignalException cause<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当触发 ShutdownListener 的时候，就可以获取到 ShutdownSignalException，这个 ShutdownSignalException 包含了关闭 原因 ，这里原因 也可以通过调用前面所提及的 getCloseReason 方法获取。</p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ的简单入门</title>
      <link href="/2019/05/08/rabbitmq-de-jian-dan-ru-men/"/>
      <url>/2019/05/08/rabbitmq-de-jian-dan-ru-men/</url>
      
        <content type="html"><![CDATA[<p>在上篇博客中，我们知道了RabbitMQ的相关概念，再进行RabbitMQ的实操之前，我们还需要了解一下AMQP协议，毕竟RabbitMQ是基于AMQP协议用Erlang语言开发的。</p><h3 id="AMQP协议模型"><a href="#AMQP协议模型" class="headerlink" title="AMQP协议模型"></a>AMQP协议模型</h3><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190508211111.png" alt="AMQP协议模型"></p><p>从上述的AMQP协议模型中，我们可以看出该协议主要是通过 生产者（Publisher）发送消息到 Server中（RabbitMQ 服务节点），具体是发送到某个虚拟主机中（Virtual host）中，一个Server中会有多个虚拟主机，每个虚拟主机都是隔离的，相互是不受影响的。在虚拟主机中，会存在多个交换器（Exchange）和 队列（Queue），生产者发送消息到某个虚拟主机中的交换器中，是与交换器打交道，不是直接与队列打交道。而消费者是与队列进行通信，不与交换器交流。即重点就在于 交换器 怎么与队列进行绑定。</p><h3 id="AMQP核心概念"><a href="#AMQP核心概念" class="headerlink" title="AMQP核心概念"></a>AMQP核心概念</h3><p><strong>Server</strong>：又称为 Broker，接受客户端的连接，实现AMQP实体服务。</p><p><strong>Connection</strong>：连接，应用程序与Broker的网络连接</p><p><strong>Channel</strong>：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道。客户端可建立多个Channel，每个Channel代表一个会话任务。</p><p><strong>Messages</strong>：消息。服务器和应用程序之间传递的数据，由 Properties 和 Body组成。Properties  可以对消息进行设置，比如消息的优先级、延迟等高级特性；Body则就是消息体内容。</p><p><strong>Virtual host</strong>：虚拟主机，用于进行逻辑隔离，最上层的消息路由。一个Virtual host里面有若干个Exchange和Queue，同一个Virtual host里面不能有相同名称的Exchange和Queue。</p><p><strong>Exchange</strong>：交换机，接受消息，根据路由键转发消息到绑定的队列中。</p><p><strong>Binding</strong>：Exchange和Queue之间的虚拟连接，binding中可以包含routing key。</p><p><strong>RoutingKey</strong>：一个路由规则，虚拟主机用它来确定如何路由一个特定信息。</p><p><strong>Queue</strong>：也称为 Messages Queue，消息队列，保存消息并将它们转发给消费者。</p><h3 id="命令行与管控台"><a href="#命令行与管控台" class="headerlink" title="命令行与管控台"></a>命令行与管控台</h3><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><p><strong>rabbitmq-server start &amp;</strong> ： 服务启动</p><p><strong>rabbitmqctl start_app</strong> : 启动应用</p><p><strong>rabbitmqctl stop_app</strong> ：关闭应用</p><p><strong>rabbitmqctl status</strong> ：节点状态</p><p><strong>rabbitmqctl add_user username password</strong> ：添加用户</p><p><strong>rabbitmqctl list_users</strong> ：列出所有用户</p><p><strong>rabbitmqctl delete_user username</strong> ：删除用户</p><p><strong>rabbitmqctl set_user_tags {username} {tag}</strong> ：设置用户角色，tag可以为administrator, monitoring, management</p><p><strong>rabbitmqctl clear_permissions -p vhostpath username</strong> ：清除用户的权限（某个虚拟主机中的）</p><p><strong>rabbitmqctl list_user_permissions username</strong> ：列出用户权限</p><p><strong>rabbitmqctl change_password username newpassword</strong> ：修改密码</p><p><strong>rabbitmqctl set_permissions -p vhostpath username “.*“ “.*“ “.*“</strong> ：设置用户权限</p><pre class=" language-java"><code class="language-java">权限设置：rabbitmqctl set_permissions <span class="token punctuation">[</span><span class="token operator">-</span>p vhostpath<span class="token punctuation">]</span> <span class="token punctuation">{</span>user<span class="token punctuation">}</span> <span class="token punctuation">{</span>conf<span class="token punctuation">}</span> <span class="token punctuation">{</span>write<span class="token punctuation">}</span> <span class="token punctuation">{</span>read<span class="token punctuation">}</span>    conf<span class="token operator">:</span>一个正则表达式match哪些配置资源能够被该用户访问。    write<span class="token operator">:</span>一个正则表达式match哪些配置资源能够被该用户读。    read<span class="token operator">:</span>一个正则表达式match哪些配置资源能够被该用户访问。<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 举例：rabbitmqctl set_permissions <span class="token operator">-</span>p <span class="token operator">/</span> root “<span class="token punctuation">.</span>*” “<span class="token punctuation">.</span>*” “<span class="token punctuation">.</span>*”</code></pre><p><strong>rabbitmqctl add_vhost vhostpath</strong> ：创建虚拟主机</p><p><strong>rabbitmqctl list_vhost</strong> ：列出所有虚拟主机</p><p><strong>rabbitmqctl list_permissions -p vhostpath</strong> ：列出虚拟主机上所有权限</p><p><strong>rabbitmqctl delete_vhost vhostpath</strong> ：删除虚拟主机</p><p><strong>rabbitmqctl list_queues</strong> ：查看所有队列信息</p><p><strong>rabbitmqctl -p vhostpath purge_queue blue</strong> ：清除队列里的消息</p><h4 id="获取服务器状态信息"><a href="#获取服务器状态信息" class="headerlink" title="获取服务器状态信息"></a><strong>获取服务器状态信息</strong></h4><pre class=" language-java"><code class="language-java">服务器状态：rabbitmqctl status队列信息： rabbitmqctl list_queues <span class="token punctuation">[</span><span class="token operator">-</span>p vhostpath<span class="token punctuation">]</span> <span class="token punctuation">[</span>queueinfoitem …<span class="token punctuation">]</span>queueinfoitem可以为： name<span class="token punctuation">,</span> durable<span class="token punctuation">,</span> auto_delete<span class="token punctuation">,</span> arguments<span class="token punctuation">,</span> messages_ready<span class="token punctuation">,</span> messages_unacknowled<span class="token punctuation">,</span> messages<span class="token punctuation">,</span> consumers<span class="token punctuation">,</span> memory<span class="token punctuation">.</span>Exchange信息： rabbitmqctl list_exchanges <span class="token punctuation">[</span><span class="token operator">-</span>p vhostpath<span class="token punctuation">]</span> <span class="token punctuation">[</span>exchangeinfoitem …<span class="token punctuation">]</span>exchangeinfoitem有：name<span class="token punctuation">,</span> type<span class="token punctuation">,</span> durable<span class="token punctuation">,</span> auto_delete<span class="token punctuation">,</span> internal<span class="token punctuation">,</span> arguments<span class="token punctuation">.</span>Binding信息：rabbitmqctl list_bindings <span class="token punctuation">[</span><span class="token operator">-</span>p vhostpath<span class="token punctuation">]</span> <span class="token punctuation">[</span>bindinginfoitem …<span class="token punctuation">]</span>bindinginfoitem有：source_name<span class="token punctuation">,</span> source_kind<span class="token punctuation">,</span> destination_name<span class="token punctuation">,</span> destination_kind<span class="token punctuation">,</span> routing_key<span class="token punctuation">,</span> arguments<span class="token punctuation">.</span>等connection信息：rabbitmqctl list_connections <span class="token punctuation">[</span>connectioninfoitem …<span class="token punctuation">]</span>connectioninfoitem有：recv_oct，recv_cnt，send_oct，send_cnt，send_pend等。channel信息：rabbitmqctl list_channels <span class="token punctuation">[</span>channelinfoitem …<span class="token punctuation">]</span>channelinfoitem有<span class="token operator">:</span>consumer_count，messages_unacknowledged，messages_uncommitted，acks_uncommitted，messages_unconfirmed，prefetch_count，client_flow_blocked举例：rabbitmqctl list_queues name messages_ready pid slave_pids<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> </code></pre><h4 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h4><p><strong>rabbitmqctl reset</strong> ：移除所有数据，要在rabbitmqctl stop_app 之后使用</p><p><strong>rabbitmqctl force_reset</strong>：作用和 rabbitmqctl reset一样，区别是无条件重置节点</p><p><strong>rabbitmqctl join_cluster &lt;clusternode> [--ram]</strong> ：组成集群命令, <code>--ram</code>: 内存节点，<code>--disc</code>：磁盘节点</p><p><strong>rabbitmqctl cluster_status</strong> ：查看集群状态</p><p><strong>rabbitmqctl change_cluster_node_type disc | ram</strong> ：修改集群节点的存储形式</p><p><strong>rabbitmqctl forget_cluster_node [--offline]</strong> ：忘记节点（摘除节点）</p><p><strong>rabbitmqctl rename_cluster_node oldnode1 newnode1 [oldnode2] [newnode2 …]</strong> ：修改节点名称</p><pre class=" language-java"><code class="language-java">镜像队列的设置<span class="token operator">:</span>镜像队列的配置通过添加policy完成，policy添加的命令为：rabbitmqctl set_policy <span class="token punctuation">[</span><span class="token operator">-</span>p Vhost<span class="token punctuation">]</span> Name Pattern Definition <span class="token punctuation">[</span>Priority<span class="token punctuation">]</span><span class="token operator">-</span>p Vhost<span class="token operator">:</span> 可选参数，针对指定vhost下的queue进行设置Name<span class="token operator">:</span> policy的名称Pattern<span class="token operator">:</span> queue的匹配模式（正则表达式）Definition<span class="token operator">:</span> 镜像定义，包括三个部分 ha<span class="token operator">-</span>mode，ha<span class="token operator">-</span>params，ha<span class="token operator">-</span>sync<span class="token operator">-</span>mode    ha<span class="token operator">-</span>mode<span class="token operator">:</span> 指明镜像队列的模式，有效值为 all<span class="token operator">/</span>exactly<span class="token operator">/</span>nodes            all表示在集群所有的节点上进行镜像            exactly表示在指定个数的节点上进行镜像，节点的个数由ha<span class="token operator">-</span>params指定            nodes表示在指定的节点上进行镜像，节点名称通过ha<span class="token operator">-</span>params指定    ha<span class="token operator">-</span>params<span class="token operator">:</span> ha<span class="token operator">-</span>mode模式需要用到的参数    ha<span class="token operator">-</span>sync<span class="token operator">-</span>mode<span class="token operator">:</span> 镜像队列中消息的同步方式，有效值为automatic，manuallyPriority<span class="token operator">:</span> 可选参数， policy的优先级例如，对队列名称以hello开头的所有队列进行镜像，并在集群的两个节点上完成镜像，policy的设置命令为：rabbitmqctl  set_policy  hello<span class="token operator">-</span>ha  <span class="token string">"^hello"</span>  <span class="token string">'{"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"}'</span></code></pre><h4 id="实战演习"><a href="#实战演习" class="headerlink" title="实战演习"></a>实战演习</h4><p>rabbitmqctl status ：查看状态</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509135251.png" alt="rabbitmqctl status"></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509135525.png" alt="查询各种信息"></p><p>rabbitmqctl add_user gakkij gakkij  : 添加用户名 gakkij，密码：gakkij</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509140020.png" alt="添加新用户"></p><p>rabbitmqctl set_user_tags username &lt;tag_name> ：设置用户的标签</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509140353.png" alt="设置用户的标签"></p><p>其他的命令行操作，大家可以执行操作实验，就不一一列举了。</p><h4 id="管控台"><a href="#管控台" class="headerlink" title="管控台"></a>管控台</h4><p>在浏览器中输入：<code>http://192.168.69.200:15672/</code> 其中的ip地址是你的虚拟机的ip地址</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509140639.png" alt="管控台"></p><p>输入我们新增的用户：gakkij</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509140937.png" alt="管控台"></p><p>管控台添加用户：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509141117.png" alt="添加用户"></p><p>管控台添加交换器：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509141332.png" alt="添加交换器"></p><p>管控台添加队列：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509141441.png" alt="添加队列"></p><p>其他的管控台操作，请大家自行学习，操作。</p><hr><p>一个扩展知识点：在overview中的最下端，有着：Import 和 Export</p><p><strong>Export</strong>：将我们的Rabbitmq信息导出，这样当我迁移Rabbitmq时，就不再需要我们又重新定义虚拟主机、交换器、队列的。</p><p><strong>Import</strong> ：将我们导出的Rabbitmq信息，导入到我们的新的Rabbitmq服务器中。</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509142011.png" alt="Rabbitmq迁移"></p><h3 id="急速入门-消息生产与消息"><a href="#急速入门-消息生产与消息" class="headerlink" title="急速入门-消息生产与消息"></a>急速入门-消息生产与消息</h3><p>1）ConnectionFactory：获取连接工厂</p><p>2）Connection：一个连接（TCP连接）</p><p>3）Channel：数据通信信道，可发送和接收消息（TCP的复用）</p><p>4）Queue：具体的消息存储队列</p><p>5）Producer &amp; Consumer：生产者和消费者</p><hr><p>我使用的是IDEA的编辑器，大家使用Eclipse也行，编辑器无伤大雅。</p><p>使用IDEA创建一个普通的maven工程：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509150824.png" alt></p><p>这里，大家注意一下，我这里是已经实操过一遍了，所以会多出了很多包名和代码，大家自行忽略即可。</p><p>添加：rabbitmq的java客户端依赖：</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span>project xmlns<span class="token operator">=</span><span class="token string">"http://maven.apache.org/POM/4.0.0"</span>         xmlns<span class="token operator">:</span>xsi<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/XMLSchema-instance"</span>         xsi<span class="token operator">:</span>schemaLocation<span class="token operator">=</span><span class="token string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>modelVersion<span class="token operator">></span><span class="token number">4.0</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token operator">&lt;</span><span class="token operator">/</span>modelVersion<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>com<span class="token punctuation">.</span>liuzhuo<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>rabbitmq<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">1.0</span><span class="token operator">-</span>SNAPSHOT<span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>    <span class="token operator">&lt;</span>dependencies<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>rabbitmq的jave客户端<span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>com<span class="token punctuation">.</span>rabbitmq<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>amqp<span class="token operator">-</span>client<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">5.6</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>dependencies<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>project<span class="token operator">></span></code></pre><p>获取Connection：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConnectionUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String USERNAME <span class="token operator">=</span> <span class="token string">"gakkij"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用户名</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String PASSWORD <span class="token operator">=</span> <span class="token string">"gakkij"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//密码</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String IPADDRESS <span class="token operator">=</span> <span class="token string">"192.168.69.200"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//虚拟机的地址</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> PORT <span class="token operator">=</span> <span class="token number">5672</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//端口号</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String VHOST <span class="token operator">=</span> <span class="token string">"/"</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//虚拟主机path</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Connection <span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建连接工厂</span>        ConnectionFactory connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置相关的属性值</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span>USERNAME<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>PASSWORD<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置ip地址</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span>IPADDRESS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置端口号</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span>PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置虚拟主机</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span>VHOST<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//根据连接工厂创建连接</span>        Connection connection <span class="token operator">=</span> connectionFactory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> connection<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>自己编写的获取Connection的工具类，放在了util包下，方便后续的生产者和消费者直接调用。</p><p>producer:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Productor</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 注意，这里是最简单的消息队列的使用，没有使用交换机的例子。         * 生产者直接把消息发送到队列中，发送消息时的routingKey必须与队列的名字queue相同才行。         */</span>        Connection connection <span class="token operator">=</span> null<span class="token punctuation">;</span>        Channel channel <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取信道</span>        connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//消息</span>        String message <span class="token operator">=</span> <span class="token string">"hello,world!"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//发送消息到队列中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//1.交换器，2.路由键，3.参数，4.要发送的消息体（字节数组）</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"simple_queue"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送消息完毕！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭信道</span>        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭连接</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Consumer：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        Connection connection <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"simple_queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//1.队列的名字，2.是否自动应答，3.消费者</span>            channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"simple_queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//重写处理消息的方法</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span> AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=========================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"consumerTag: "</span> <span class="token operator">+</span> consumerTag<span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"envelope: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"exchange: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"routingKey: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getRoutingKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"deliveryTag: "</span> <span class="token operator">+</span> envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接受到的消息为："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在没有运行生产者和消费者程序之前，观看管控台的信息：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509152944.png" alt></p><p>首先运行消费者：因为队列是在消费者中声明的，先运行生产者的话，因为没有队列所以会将消息丢失！</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509153237.png" alt></p><p>如果出现连接超时的情况，请看一下你的虚拟机中的centos的防火墙，是否开启了5672的端口号，没有的话，请开启5672的端口号：</p><pre class=" language-java"><code class="language-java">firewall<span class="token operator">-</span>cmd <span class="token operator">--</span>zone<span class="token operator">=</span><span class="token keyword">public</span> <span class="token operator">--</span>add<span class="token operator">-</span>port<span class="token operator">=</span><span class="token number">5672</span><span class="token operator">/</span>tcp <span class="token operator">--</span>permanentfirewall<span class="token operator">-</span>cmd <span class="token operator">--</span>reload </code></pre><p>再次查看管控台的信息：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509154857.png" alt></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509154939.png" alt></p><p>运行生产者：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509155039.png" alt></p><p>看到，生产者的控制台，输出了：发送消息完毕！</p><p>再看，消费者的控制台：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509155139.png" alt></p><p>看到，我们消费了五条消息。</p><hr><p>以上就是简单的入门案例，大家应该有了一个初步的操作印象了。</p><p>因为，该案例中，我们的消费者是自动ack，所以，只要从队列中发送消息给消费者的话，都会从队列中删除消息，不管消费者是否已经处理好消息。</p><p>现在，我们关闭消费者的程序，再运行生产者的程序，在管控台看到：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509155619.png" alt></p><font color="red"><strong>注意，重点：</strong></font><p>在之前的篇章中，我们知道在AMQP协议的模型中，生产者发送消息是不能直接发送消息到队列中的，需要发送到交换器中，让交换器将我们的消息路由到相应的队列中，消费者从队列中消费消息。</p><p>但是，在这里，我是直接发送队列中的，不知道大家有没有这么的疑惑？</p><p><code>channel.basicPublish(&quot;&quot;, &quot;simple_queue&quot;, null, message.getBytes());</code></p><p>交换器，我们输入的是空字符串：””，路由键发送的是：”simple_queue”。</p><p>为啥在simple_queue队列中，会接收到我们发送的数据呢？</p><p>其实，当我们不指定交换器时（即：交换器输入空字符串时），Rabbitmq会使用一个默认的交换器，如下：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509160430.png" alt></p><p>点击该交换器：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190509160625.png" alt></p><p>即：该默认的交换器，会匹配所有的队列，只要当路由键和队列的名字完全匹配时，就会将该消息转发到该队列中，如果没有与路由键相匹配的队列，就会丢弃该消息，或者返回给生产者（需要设置相关的配置和回调函数）。</p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ的概念介绍</title>
      <link href="/2019/05/07/rabbitmq-de-gai-nian-jie-shao/"/>
      <url>/2019/05/07/rabbitmq-de-gai-nian-jie-shao/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章，主要讲述了消息中间件的基本概念，消息中间件的作用、功能，以及各种消息中间件的对比，接下来会主要讲述RabbitMQ消息队列。</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>RabbitMQ整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想像成：当你将一个包裹送到邮局，邮局会使用邮箱来暂存包裹并最终将包裹通过邮递员送到收件人的手上，RabbitMQ就好比由<strong>邮局、邮箱 和 邮递员</strong>组成的一个系统。从计算机术语层面来说，RabbitMQ模型更像是一种交换机模型。</p><p>RabbitMQ模型如下：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190507204209.png" alt="RabbitMQ模型架构图"></p><h4 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h4><p><strong>Producer</strong>：生产者，就是投递消息的一方。</p><p>生产者创建消息，然后发布到RabbitMQ中。消息一般可以包含2个部分：消息体和标签（Label）。消息体也可以称之为：payload，在实际应用中，消息体一般是一个带有业务逻辑结构的数据，比如一个Json字符串。当然可以进一步对这个消息体进行序列化操作。消息的标签用来描述这条消息，比如这个消息要投递哪个交换器和投递时的路由键。生产者把消息交由给RabbitMQ，RabbitMQ之后会根据标签把消息发送到相应的队列中，然后由消费者来消费消息。</p><p><strong>Consumer</strong>：消费者，就是接收消息的一方。</p><p>消费者连接到RabbitMQ服务器，并订阅到队列上。当消费者消费一条消息时，只是消费消息的消息体（payload）。在消息路由的过程中，消息的标签会丢弃，存入到队列中的消息只有消息体，消费者也只会消费到消息体，也就不知道消息的生产者是谁，当然消费者也不需要知道消息的生产者是谁。</p><p><strong>Broker</strong>：消息中间件的服务节点。</p><p>对于RabbitMQ来说，一个RabbitMQ Broker可以简单地看作是一个RabbitMQ服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个RabbitMQ Broker看作是一台RabbitMQ服务器。</p><p>下图展示了一个完整的消息运转过程：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190507211857.png" alt="消息队列的运转过程"></p><p>首先生产者将业务方数据进行可能的包装，之后封装成消息，发送（AMQP协议里这个动作对应的命令为Basic.Publish）到Broker中。消费者订阅并接收消息（AMQP协议里这个动作对应的命令为Basic.Consume或者Basic.Get），经过可能的解包处理得到原始的数据，之后再进行业务处理逻辑。这个业务处理逻辑并不一定需要和接收消息的逻辑使用同一个线程。消费者进程可以使用一个线程去接收消息，存入到内存中，比如使用Java中的BlockingQueue。业务处理逻辑使用另一个线程从内存中读取数据，这样可以将应用进一步解耦，提高整个应用的处理效率。</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><strong>Queue</strong>：队列，是 RabbitMQ的内部对象，用于存储消息。如下所示：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190507213351.png" alt="队列"></p><p>RabbitMQ中的消息都只能存储在队列中，这一点和Kafka这种消息中间件相反。Kafka将消息存储在topic（主题）这个逻辑层面，而相对应的队列逻辑只是topic实际存储文件中的位移标识。RabbitMQ的生产者生产消息并最终投递到队列中，消费者可以从队列中获取信息并消费。</p><p>多个消费者可以订阅同一个队列，这时队列中的消息会被<font color="red"><strong>平均分摊（Round-Robin，即轮询）</strong></font>给多个消费者进行处理，<strong>而不是每个消费者都收到所有的消息并处理</strong>，意思就是说：队列中的某条消息，只能被一个消费者消费，而不是队列中的一条消息同时给多个消费者消费。如下所示：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190508134003.png" alt="队列轮询消费"></p><p>一个队列可以连接多个消费者，但是队列中的消息只能被一个消费者消费，即5这条消费有可能被Consumer1消费，也有可能被Consumer2消费，但是5这条消息不会同时被Consumer1和Consumer2消费。</p><p>RabbitMQ不支持队列层面的广播消费，如果需要广播消费，需要在其上进行二次开发，处理逻辑会变得异常复杂，同时也不建议这么做。可以使用交换器（Exchange）来广播消息到多个队列中来完成相应的功能。</p><h4 id="交换器、路由键、绑定"><a href="#交换器、路由键、绑定" class="headerlink" title="交换器、路由键、绑定"></a>交换器、路由键、绑定</h4><p><strong>Exchange：</strong>交换器。在介绍消息中间件的队列时，我们暂时可以理解成生产者将消息投递到队列中，实际上这个在RabbitMQ中不会发生。真实的情况是，生产者将消息发送到 Exchange中，由交换器将消息路由到一个或者多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃。默认情况下，如果没有指定交换器的话，直接发送消息到队列中时，系统会使用一个默认的交换器帮我们转换到队列中，匹配规则是：路由键要和队列名完全匹配。</p><p>交换器的具体示意图如下：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190508140016.png" alt="交换器示意图"></p><p><strong>RoutingKey：</strong>路由键。生产者将消息发给交换器的时候，一般需要指定一个RoutingKey（路由键），用来</p><p>指定这个消息的路由规则，而这个RoutingKey需要与交换器类型和绑定键（BindingKey）联合使用才能最终生效。</p><p>在交换器类型和绑定键固定的情况下，生产者可以在发送消息给交换器时，通过指定RoutingKey来决定消息流向</p><p>哪个队列或哪些队列。</p><p><strong>Binding：</strong>绑定。RabbitMQ中通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键（BindingKey），这样RabbitMQ就知道如何正确地将消息路由到队列中了，如下所示：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190508140931.png" alt="绑定队列示意图"></p><p>生产者将消息发送给交换器时，需要一个RoutingKey，当BindingKey和RoutingKey相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的BindingKey。BindingKey并不是在所有的情况下都生效，它依赖于交换器的类型，比如：fanout类型的交换器就会无视BindingKey，而是将消息路由到所有绑定到该交换器的队列中。</p><p>有经验的读者可能会发现，在某些情况下，RoutingKey与BindingKey可以看做是同一个东西。</p><p>简单看一个例子：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//声明交换器</span>channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span><span class="token string">"direct"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//声明队列</span>channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//绑定队列与交换器，使用BindingKey，可以看出RoutingKey与BindingKey是同一个东西！！！</span>channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span>EXCHANGE_NAME<span class="token punctuation">,</span>ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//要发送的消息内容</span>String message <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//发送消息</span>channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span>ROUTING_KEY<span class="token punctuation">,</span>null<span class="token punctuation">,</span>message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>以上代码声明了一个 “direct”类型的交换器，然后将交换器和队列绑定起来。注意这里使用的字样是 “ROUTING_KEY”，在本该使用BindingKey的地方却使用了RoutingKey，java客户端这样做的潜台词就是：这里的RoutingKey和BindingKey是同一个东西。在direct交换器类型下，RoutingKey和BindingKey需要完全匹配才能使用，所以上面代码中采用了此种写法会显得方便许多。</p><p>为了避免混淆，可以这么理解：</p><ul><li><p>在使用绑定的时候，其中需要的路由键是BindingKey。</p></li><li><p>在发送消息的时候，其中需要的路由键是RoutingKey。</p></li></ul><p>由于某些历史的原因，包括现存能搜集到的资料显示：大多数情况下习惯性地将BindingKey写成RoutingKey，尤其是在使用direct类型的交换器的时候。本文后面的篇幅中也会将两者合称为路由键，读者需要注意区分其中的不同，可以根据上面的辨别方法进行有效的区分。</p><h4 id="交换器类型"><a href="#交换器类型" class="headerlink" title="交换器类型"></a>交换器类型</h4><p>RabbitMQ中常用的交换器类型有：fanout、direct、topic、headers 这四种。AMQP协议里还提到另外两种类型：System和自定义，这里不予描述。</p><p><strong>fanout</strong></p><p>它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。（即路由键没什么作用）</p><p><strong>direct</strong></p><p>direct类型的交换器路由规则也很简单，它会把消息路由到那些 BindingKey 和 RoutingKey完全匹配的队列中。</p><p>以下图所示，交换器类型为：direct，如果我们发送一条消息，并在发送消息的时候设置路由键为 “warning”，则</p><p>消息会路由到 Queue1 和 Queue2中。</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190508154120.png" alt="direct类型的交换器"></p><p>如果在发送消息的时候设置路由键为 “info” 或者 “debug”，消息只会路由到 Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。</p><p><strong>topic</strong></p><p>前面讲到 direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic类型的交换器在匹配规则上进行了扩展，它与direct类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：</p><ul><li>RoutingKey 为一个点号 “.” 分隔的字符串（被点号 “.” 分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client” 、”com.hidden.client”</li><li>BindingKey 和 RoutingKey 一样也是点号 “.” 分隔的字符串</li><li>BindingKey 中可以存在两种特殊字符串 “*“ 和 “#” ，用于做模糊匹配，其中 “*“ 用于匹配一个单词， “#” 用于匹配多个单词（可以是零个）。</li></ul><p>以下图所示的配置中：</p><ul><li>路由键为 “com.liuzhuo.client” 的消息会同时路由到 Queue1 和 Queue 2</li><li>路由键为 “com.gakki.client” 的消息只会路由到 Queue2中</li><li>路由键为 “com.gakki.demo” 的消息只会路由到 Queue2中</li><li>路由键为 “java.liuzhuo.demo” 的消息只会路由到 Queue1中</li><li>路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置mandatory参数），因为它没有匹配任何路由键。</li></ul><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190508160433.png" alt="direct类型的交换器"></p><p><strong>headers</strong></p><p>headers类型的交换器不依赖与路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</p><h4 id="RabbitMQ运转流程"><a href="#RabbitMQ运转流程" class="headerlink" title="RabbitMQ运转流程"></a>RabbitMQ运转流程</h4><p>了解了以上的RabbitMQ架构模型及相关术语，再来回顾整个消息队列的使用过程。在最初状态下：</p><p><strong>生产者发送消息的时候：</strong></p><p>（1）生产者连接到 <strong>RabbitMQ Broker</strong> 建立一个连接 ( Connection ) ，开启 一个信道  ( Channel )</p><p>（2）生产者声明一个交换器 ，并设置相关属性，比如：交换机类型、是否持久化等</p><p>（3）生产者声明 一个队列，井设置相关属性，比如：是否排他、是否持久化、是否自动删除等</p><p>（4）生产者通过路由键 (BindingKey) 将交换器和队列绑定起来</p><p>（5）生产者发送消息至 RabbitMQ Broker ，其中包含 路由键 (RoutingKey)、交换器 等信息</p><p>（6）相应的交换器根据接收到的路由键查找相匹配的队列</p><p>（7）如果找到 ，则将从生产者发送过来的消息存入相应的队列中</p><p>（8）如果没有找到 ，则根据生产者配置的属性选择丢弃还是回退给生产者</p><p>（9）关闭信道</p><p>（10）关闭连接</p><p><strong>消费者接收消息的过程:</strong></p><p>（1）消费者连接到 RabbitMQ Broker ，建立一个连接(Connection ) ，开启 一个信道 (Channel)</p><p>（2）消费者向 RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，<br>以及做 一些准备工作</p><p>（3）等待 RabbitMQ Broker 回应并投递相应队列中的消息给消费者， 消费者接收消息</p><p>（4）消费者消费消息 并 发送确认 应答(ack) 给 RabbitMQ Broker （可以自动应答或手动应答）</p><p>（5）RabbitMQ 将收到应答的消息从队列中删除</p><p>（6）关闭信道</p><p>（7）关闭连接</p><hr><p>如下图所示，我们又引入了两个新的概念: Connection  和 Channel 。我们知道无论是生产者还是消费者，都需要和 RabbitMQ Broker 建立连接，这个连接就是一条 TCP 连接，也就是Connection 。一旦TCP 连接建立起来，客户端紧接着可以创建一个 AMQP 信道 (Channel) ，每个信道都会被指派 一个唯一的ID 。信道是建立在Connection 之上的虚拟连接， RabbitMQ 处理的每条 AMQP 指令都是通过信道完成的。</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190508162857.png" alt="Connection与Channel"></p><p>我们完全可以直接使用 Connection 就能完成信道的工作，为什么还要引入信道呢? 试想这样一个场景， 一个应用程序中有很多个线程需要从 RabbitMQ 中消费消息，或者生产消息，那么必然需要建立很多个 Connection ，也就是许多个 TCP 连接。然而对于操作系统而言，建立和销毁 TCP 连接是非常昂贵的开销，如果遇到使用高峰，性能瓶颈也随之显现。 RabbitMQ 采用类似 NIO’ (Non-blocking 1/0) 的做法，选择 TCP 连接复用，不仅可以减少性能开销，同时也便于管理。</p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件的介绍</title>
      <link href="/2019/05/07/xiao-xi-zhong-jian-jian-de-jie-shao/"/>
      <url>/2019/05/07/xiao-xi-zhong-jian-jian-de-jie-shao/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是消息中间件"><a href="#什么是消息中间件" class="headerlink" title="什么是消息中间件"></a>什么是消息中间件</h3><p>消息（Messages）是指应用间传递的数据。消息可以非常简单，比如：文本字符串、Json数据等，也可以很复杂，比如内嵌对象。</p><p>消息队列中间件（Message Queue Middleware，简称为MQ）是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。</p><p>消息队列中间件，也可以称为消息队列或消息中间件。它一般有两种传递模式：（1）点对点（P2P，Point-to-Point）模式 和 （2）发布/订阅（Pub/Sub）模式。点对点模式是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接受消息，队列的存在使得消息的异步传输成为可能。发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题（topic），主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息。主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布/订阅模式在消息的一对多广播时采用。</p><h3 id="为何要使用消息中间件"><a href="#为何要使用消息中间件" class="headerlink" title="为何要使用消息中间件"></a>为何要使用消息中间件</h3><p>从上一节的描述中可以看出，消息中间件是一种系统间相互协作的通信机制。那么什么时候需要使用消息队列呢？</p><p>（1）异步</p><p>举个例子。某天产品经理说：“系统需要增加一个用户注册功能，注册成功后用户能收到邮件通知”。</p><p>在实际场景中这种需要很常见，开发人员觉得这个很简单，就是提供一个注册页面，点击按钮提交之后保存用户的注册信息，然后发送邮件，最后返回用户注册成功，如下所示：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190507164035.png" alt="需求分析"></p><p>该功能上线运行了一段时间后，产品人员说：“点击注册按钮之后的响应时间有点长，很多用户表示反感，能不能优化一下？”。开发人员首先想到的优化方案就是将 <strong>保存注册信息</strong> 与 <strong>发送邮件</strong> 分开执行，怎么分呢？可以单独启动线程来发做发送邮件的事情，如下所示：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190507164935.png" alt="需求分析"></p><p>没过多久，产品人员又说：“现在注册操作的响应是快了，但有用户反映没收到注册成功的邮件，能不能在发送邮件的时候先保存所发送邮件的内容，如果没有发送成功则进行补发呢？”。</p><p>看着开发人员愁眉苦脸的样子，产品人员说：“在邮件发送这个模块，平台部门已经做好了方案，你直接调用他们提供的服务就行。”。开发人员一听，赶紧和平台部门沟通，对方的答复是：“我们提供了一个类似于邮局信箱的东西，你可以直接往里面写上发送邮件的地址、邮件的标题和内容即可。我们会从信箱里面取出信息，向你填写的邮件地址发送响应邮件”。</p><p>这个故事讲的就是使用：消息队列的典型场景——异步处理。消息队列还可用于解决解耦、流量消峰、日志收集、事务最终一致性等问题。</p><p>（2）解耦</p><p>某天产品经理说：“为了方便与网站用户之间进行交流、共享信息、解决网站中遇到的各种问题，网站要增加一个论坛功能，在这个论坛中用户可以发布帖子，其他用户可以在这个帖子下评论和回复。” 开发人员一听，觉得这个需求很简单，不难实现，就是常见的网上论坛。于是，没过几天就完成了功能开发并转测上线了。</p><p>过了一段时间，用户量增加了，对帖子发布功能的使用越来越频繁。产品人员说：“信息质量部门期望在发帖子的时候能检查所发布的内容是不是合规”。没多久，产品人员又说：“大数据部门希望能根据帖子的内容提供用户相关信息来丰富用户的画像”。又过了几天，产品人员说：“营销部门最近在做活动，如果用户发布的是与营销活动相关的帖子，则能给该用户增加积分”。</p><p>经验少的开发人员遇到这种情况，一般是来一个需要叠加一段业务逻辑代码。这当然可以尽快交付上线，但仔细分析需求发现，<strong>发布帖子应该作为一个独立的功能</strong>，并且这个功能并不需要关心后面不断增加的那些功能，更不需要关心后面功能的执行结果，只需要<strong>通知</strong>其他相应模块执行就行了。</p><p>在大型系统的开发过程中会经常碰到此类情况，随着需求的叠加，各模块之间逐渐变成了互相调用的关系，这种模块间紧密关联的关系就是紧耦合。紧耦合带来的问题是对一个模块的功能变更将导致其关联模块发生变化，因此各个模块难以独立演化。</p><p>要解决这个问题，可以在模块之间调用时增加一个中间层来实现解耦，这也方便了以后的扩展。所谓解耦，简单的理解就是一个模块只关心自己的核心流程，而依赖该模块执行结果的其他模块如果做的不是很重要的事情，有通知即可，无须等待结果。换句话说，基于消息队列的模型，<strong>关心的是通知，而非处理</strong>。</p><font color="red">例子：</font><p>看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃……</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190507172445.png" alt="需求分析"></p><p>在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！</p><p>如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190507172755.png" alt="需求分析"></p><p><strong>总结</strong>：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</p><p><strong>面试技巧</strong>：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。在简历中体现出来这块东西，用 MQ 作解耦。</p><p>（3）削峰</p><p>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。</p><p>一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。</p><p>但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190507173238.png" alt="需求分析"></p><p>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ截图20190507173401.png" alt="需求分析"></p><p>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</p><h3 id="消息队列有什么优缺点"><a href="#消息队列有什么优缺点" class="headerlink" title="消息队列有什么优缺点"></a>消息队列有什么优缺点</h3><p>优点上面已经说了，就是<strong>在特殊场景下有其对应的好处</strong>，<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p><p>缺点有以下几个：</p><ul><li><p>系统可用性降低<br>系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人家 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？如何保证消息队列的高可用性呢？</p></li><li><p>系统复杂度提高<br>硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</p></li><li><p>一致性问题<br>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</p></li></ul><p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</p><h3 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h3><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><p>综上，各种对比之后，有如下建议：</p><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p><p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p><p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p><p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rabbitmq的安装与入门</title>
      <link href="/2019/04/28/rabbitmq-de-an-zhuang-yu-ru-men/"/>
      <url>/2019/04/28/rabbitmq-de-an-zhuang-yu-ru-men/</url>
      
        <content type="html"><![CDATA[<p>今天，我们来学习Rabbitmq的安装与入门。</p><hr><p>一般情况下，Rabbitmq都是安装在linux系统中，所以，这里我也是以linux系统为主来讲解。</p><p>如果，大家想安装在windows上面，可以查看Rabbitmq的官网。</p><h3 id="Rabbitmq的下载"><a href="#Rabbitmq的下载" class="headerlink" title="Rabbitmq的下载"></a>Rabbitmq的下载</h3><p>主要分为：以下四个步骤</p><p>1）查看Rabbitmq的官网信息</p><p>2）提前准备：安装Linux必要依赖包</p><p>3）下载Rabbitmq必须的安装包</p><p>4）修改配置文件</p><hr><p>学习一门技术之前，我们首先需要到官网上面，来查看官方的信息：<a href="http://www.rabbitmq.com" target="_blank" rel="noopener">www.rabbitmq.com</a></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/20190428150300.png"></p><p>我们能看到，目前Rabbitmq的最新版本为：3.7.14</p><p>也能发现Rabbitmq版本的更新很快，但是，我们一般不用最新的Rabbitmq版本，使用<strong>Rabbitmq 3.6.x</strong>即可。</p><p>Rabbitmq 3.6.x 是目前最稳定的版本，互联网大厂一般也是用这个版本，所以，大家目前就使用这个版本就行。</p><hr><p>这里，我使用的是3.6.5的版本：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428151551.png"></p><p>点击：<strong>downloads page</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428151752.png"></p><p>能看到Rabbitmq支持多个操作系统，我这里主要使用Linux系统来演示。</p><p>Rabbitmq的安装包，分为：rpm和zip的两种方式，rpm的安装方式会自动帮我们安装好一切，也会帮我们默认配置一些信息，而zip压缩包的安装方式，需要我们手动来设置配置文件，对于新手来说使用rpm方式比较好，当你们熟练掌握Rabbitmq后，zip的方式也就水到渠成了。</p><hr><p>选择好安装方式后，我们还需要注意到，Rabbitmq由于是Erlang语言开发的，所以安装Rabbitmq的前提是需要先安装Erlang的依赖，而对于不同版本的Rabbitmq需要哪个版本的Erlang呢？</p><p>这里，我们点击右边的<strong> Erlang Version</strong>：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428152532.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428152836.png"></p><p>这里，我们就需要Erlang语言版本的：R16Bo3 版本。</p><hr><p>现在，我们的前提知识点都疏通了，打开我们的虚拟机，我的虚拟机使用的是：CentOS7版本。</p><p>当前目录为：usr/local/soft</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428153200.png"></p><p>如果你的CentOS7是精简版的话，还需要提前安装必要的Linux依赖包：</p><pre><code>yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz</code></pre><p>下载：Erlang 和 Rabbitmq</p><pre><code>wget www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpmwget http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpmwget www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm</code></pre><p>下载完毕后：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428153609.png"></p><h3 id="Rabbitmq的安装"><a href="#Rabbitmq的安装" class="headerlink" title="Rabbitmq的安装"></a>Rabbitmq的安装</h3><p>上述步骤中，我们已经下载好了所有的安装包。现在，开始我们的安装流程。</p><p>首先，要告诉大家的是：三个rpm安装包的安装顺序，Erlang必须是在Rabbitmq安装之前的安装。</p><p>1）首先安装 Erlang</p><p><strong>rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428154158.png"></p><p>Erlang安装成功。</p><p>现在是先安装socat还是Rabbitmq呢？我们尝试一下就好了。</p><p>先尝试安装Rabbitmq：</p><p><strong>rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428154503.png"></p><p>所以，需要先安装：socat依赖</p><p>2）安装socat依赖</p><p><strong>rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm</strong></p><p>3）安装Rabbitmq</p><p><strong>rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428154835.png"></p><h3 id="Rabbitmq的配置"><a href="#Rabbitmq的配置" class="headerlink" title="Rabbitmq的配置"></a>Rabbitmq的配置</h3><p><strong>vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app</strong></p><p>这个rabbit.app是核心配置文件，这里就简单的说明一下，以后会重点介绍的，比如修改密码、配置等等。</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428160302.png"></p><p>这里，我们主要修改一下，我们需要访问的用户：</p><p><strong>loopback_users 中的 &lt;&lt;”guest”&gt;&gt; , 只保留guest。即：{loopback_users，[guest]}</strong></p><p>不做这样的修改的话，我们是不能直接访问Rabbitmq的。</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428160535.png"></p><h3 id="Rabbitmq服务的启动"><a href="#Rabbitmq服务的启动" class="headerlink" title="Rabbitmq服务的启动"></a>Rabbitmq服务的启动</h3><p>1）服务的启动：</p><p><strong>rabbitmq-server start &amp;</strong></p><p>后台启动rabbitmq服务</p><p>2）服务的停止：</p><p><strong>rabbitmqctl stop_app</strong></p><p>3）管理插件</p><p><strong>rabbitmq-plugins enable rabbitmq_management</strong></p><p>4）访问地址：</p><p><strong><a href="http://ip地址:15672" target="_blank" rel="noopener">http://ip地址:15672</a></strong></p><hr><p>在我们的终端中输入：rabbitmq然后敲Tab键</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428161208.png"></p><p>Linux系统帮我们补全了：rabbitmq的命令，主要使用三个脚本命令。</p><p>1）rabbitmqctl：一系列rabbitmq的操作命令，我们大多时候会使用这个命令，这个脚本命令比较全</p><p>2）rabbitmq-plugins：rabbitmq的插件命令，比如rabbitmq的界面管理插件等</p><p>3）rabbitmq-server：主要用于rabbitmq服务的启动，停止。</p><hr><p>使用 <strong>rabbtitmq-server start &amp;</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428161928.png"></p><p>这个，有个细节，就是日志文件是以：rabbit开头，@作为分界符，加你的主机名来命名的，我们的主机名要使用英文，不要使用中文的命名。</p><p>怎么印证我们的rabbitmq已经启动成功了呢？首先：ctrl+C退出当前的运行。</p><p>输入：<strong>lsof -i:5672</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428162434.png"></p><hr><p>使用：<strong>rabbitmqctl stop_app</strong> 停止rabbitmq服务：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428162826.png"></p><hr><p>使用rabbitmq的插件，来提供一个rabbitmq的界面管理工具，方便我们的管理。</p><p><strong>rabbitmq-plugins list</strong> 列出所有的插件</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428163414.png"></p><hr><p><strong>rabbitmq-plugins enable rabbitmq_management</strong> 启动rabbitmq管控台插件</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428163716.png"></p><p>再次，启动我们的rabbitmq应用：<strong>rabbitmqctl start_app</strong></p><p>此时我们的rabbitmq服务是启动的，只是停止了rabbitmq的应用，启动应用使用：rabbitmqctl start_app，而不是：rabbitmq-server start &amp;</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428164323.png"></p><p>再次启动：rabbitmq的插件：<strong>rabbitmq-plugins enable rabbitmq_management</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428164830.png"></p><p>现在来印证我们的rabbitmq-management是否启动成功：</p><p>在我们的虚拟机中的浏览器中输入：<strong>localhost:15672</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428170712.png"></p><p>我们能看到，rabbitmq的管控台了，成功了一半。</p><p>在我们的宿主机中输入：<strong><a href="http://192.168.69.200:15672/" target="_blank" rel="noopener">http://192.168.69.200:15672/</a></strong></p><p>其中的ip地址是我的虚拟机的ip地址。</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428170910.png"></p><p>为啥，我们的宿主机访问失败呢？那是因为在我们的虚拟机中linux系统设置了防火墙，需要修改防火墙的设置。</p><pre><code>firewall-cmd --zone=public --add-port=15672/tcp --permanentfirewall-cmd --reload </code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428171424.png"></p><p>刷新我们的宿主机的浏览器：</p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428171518.png"></p><p>输入默认的账号和密码：<strong>guest</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/rabbitmq/QQ%E6%88%AA%E5%9B%BE20190428171630.png"></p><p>登入成功，这里我们能看到图形化的信息，连接数，信道数，交换机，队列，用户管理等。</p>]]></content>
      
      
      <categories>
          
          <category> Rabbitmq </category>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
            <tag> Rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解Annotation的浅析</title>
      <link href="/2019/03/22/zhu-jie-annotation-de-qian-xi/"/>
      <url>/2019/03/22/zhu-jie-annotation-de-qian-xi/</url>
      
        <content type="html"><![CDATA[<p>在我们使用Spring的时候，会使用很多注解，但是对于注解是什么，却还是一知半解，今天就带大家来学习一下java中的元注解。</p><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><p>对于很多初次接触的开发者来说应该都会有这个疑惑？<code>annotation</code> 是java5开始引入的新特征，中文名称叫做注解。</p><p>它提供了一种安全的类似注解的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加上更直观更名了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。</p><p><code>Annotation</code> 像一个修饰符一样，应用于包、类、构造方法、成员方法、成员变量、参数以及本地变量的声明语句中。</p><p>Java注解是附加在代码中的一些元信息。用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在<code>java.lang.annotation</code>包中。</p><h3 id="注解的用处"><a href="#注解的用处" class="headerlink" title="注解的用处"></a>注解的用处</h3><p>1、生成文档。这是最常见的，也是java最早提供的注解。常用的用<code>@Param @return</code>等</p><p>2、跟踪代码依赖性，实现替代配置文件功能。比如Dagger 2 依赖注入，未来java 开发，将大量注解配置，具有很大用处。</p><p>3、在编译时进行格式检查。如<code>@override</code> 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。</p><h3 id="注解的原理"><a href="#注解的原理" class="headerlink" title="注解的原理"></a>注解的原理</h3><p>注解本质是一个继承了<code>Annotation 的特殊接口</code>，其具体实现类是Java 运行时生成的动态代理类。而我们通过<code>反射</code>获取注解时，返回的是Java 运行时生成的动态代理对象<code>$Proxy1</code>。通过代理对象调用自定义注解（接口）的方法，会最终调用<code>AnnotationInvocationHandler</code> 的<code>invoke方法</code>。该方法会从<code>memberValues</code> 这个Map 中索引出对应的值。而<code>memberValues</code>的来源是Java 常量池。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p><code>java.lang.annotation</code>:提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：</p><p><code>@Documented</code> 注解是否将包含在JavaDoc中</p><p><code>@Retention</code> 什么时候使用该注解</p><p><code>@Target</code> 注解用于什么地方</p><p><code>@Inherited</code> 是否允许子类继承该注解</p><hr><h4 id="Retention"><a href="#Retention" class="headerlink" title="Retention"></a>Retention</h4><p>表示什么时候使用该注解，可用 RetentionPolicy 参数包括。</p><p><code>RetentionPolicy.SOURCE</code>: 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings 都属于这类注解。</p><p><code>RetentionPolicy.CLASS</code>: 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式。</p><p><code>RetentionPolicy.RUNTIME</code>：始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</p><hr><h4 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h4><p>表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用 ElementType 参数包括。</p><p><code>ElementType.PACKAGE</code>: 用于描述包</p><p><code>ElementType.TYPE</code>: 用于描述类、接口(包括注解类型) 或enum声明</p><p><code>ElementType.CONSTRUCTOR</code>: 用于描述构造器</p><p><code>ElementType.FIELD</code> : 成员变量、对象、属性（包括enum实例）</p><p><code>ElementType.METHOD</code> : 用于描述方法</p><p><code>ElementType.PARAMETER</code>: 用于描述参数</p><p><code>ElementType.LOCAL_VARIABLE</code> : 用于描述局部变量</p><hr><h4 id="Documented"><a href="#Documented" class="headerlink" title="Documented"></a>Documented</h4><p>一个简单的Annotations 标记注解，表示是否将注解信息添加在java 文档中。</p><hr><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="Inherited"></a>Inherited</h4><p>定义该注释和子类的关系。</p><p><code>@Inherited</code> 元注解是一个标记注解，<code>@Inherited</code> 阐述了某个被标注的类型是被继承的。如果一个使用了<code>@Inherited</code> 修饰的 <code>annotation</code> 类型被用于一个<code>class</code>，则这个<code>annotation</code> 将被用于该<strong><code>class 的子类</code></strong>。</p><hr><h3 id="常见标准的Annotation"><a href="#常见标准的Annotation" class="headerlink" title="常见标准的Annotation"></a>常见标准的Annotation</h3><ol><li>Override</li></ol><p><code>java.lang.Override</code>是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java 编译器将以一个编译错误来警示。</p><ol start="2"><li>Deprecated</li></ol><p><code>Deprecated</code> 也是一种标记类型注解。当一个类型或者类型成员使用<code>@Deprecated</code> 修饰的话，编译器将不鼓励使用这个被标注的程序元素。所以使用这种修饰具有一定的“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为<code>@Deprecated</code>，但编译器仍然要报警。</p><ol start="3"><li>SuppressWarnings</li></ol><p><code>SuppressWarning</code> 不是一个标记类型注解。它有一个类型为String[] 的成员，这个成员的值为被禁止的警告名。对于javac 编译器来讲，被-Xlint 选项有效的警告名也同样对<code>@SuppressWarings</code> 有效，同时编译器忽略掉无法识别的警告名。</p><p><code>@SuppressWarnings(&quot;unchecked&quot;)</code></p><hr><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>自定义注解类编写的一些规则:</p><p>Annotation 型定义为<code>@interface</code>, 所有的<code>Annotation</code> 会自动继承<code>java.lang.Annotation</code>这一接口,并且不能再去继承别的类或是接口.</p><p>参数成员只能用public 或默认(default) 这两个访问权修饰.</p><p>参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组.</p><p>要获取类方法和字段的注解信息，必须通过<font color="red">Java的反射技术</font>来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法.</p><p>注解也可以没有定义成员，不过这样注解就没啥用了.</p><hr><h3 id="自定义注解实例"><a href="#自定义注解实例" class="headerlink" title="自定义注解实例"></a>自定义注解实例</h3><p><code>FruitName.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Documented<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 水果名称注解 */</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>FIELD<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">FruitName</span> <span class="token punctuation">{</span>    String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>FruitColor.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Documented<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 水果颜色注解 */</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>FIELD<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">FruitColor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 颜色枚举     */</span>    <span class="token keyword">public</span> <span class="token keyword">enum</span> Color<span class="token punctuation">{</span> BLUE<span class="token punctuation">,</span>RED<span class="token punctuation">,</span>GREEN<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 颜色属性     */</span>    Color <span class="token function">fruitColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> Color<span class="token punctuation">.</span>GREEN<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>FruitProvider.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Documented<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 水果供应者注解 */</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>FIELD<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">FruitProvider</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 供应商编号     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 供应商名称     */</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 供应商地址     */</span>    <span class="token keyword">public</span> String <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>FruitInfoUtil.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Field<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 注解处理器 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FruitInfoUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getFruitInfo</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz<span class="token punctuation">)</span><span class="token punctuation">{</span>        String strFruitName<span class="token operator">=</span><span class="token string">" 水果名称："</span><span class="token punctuation">;</span>        String strFruitColor<span class="token operator">=</span><span class="token string">" 水果颜色："</span><span class="token punctuation">;</span>        String strFruitProvicer<span class="token operator">=</span><span class="token string">"供应商信息："</span><span class="token punctuation">;</span>        Field<span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Field field <span class="token operator">:</span>fields<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>FruitName<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                FruitName fruitName <span class="token operator">=</span> <span class="token punctuation">(</span>FruitName<span class="token punctuation">)</span> field<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>FruitName<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                strFruitName<span class="token operator">=</span>strFruitName<span class="token operator">+</span>fruitName<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>strFruitName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>FruitColor<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                FruitColor fruitColor<span class="token operator">=</span> <span class="token punctuation">(</span>FruitColor<span class="token punctuation">)</span> field<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>FruitColor<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                strFruitColor<span class="token operator">=</span>strFruitColor<span class="token operator">+</span>fruitColor<span class="token punctuation">.</span><span class="token function">fruitColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>strFruitColor<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>FruitProvider<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                FruitProvider fruitProvider<span class="token operator">=</span> <span class="token punctuation">(</span>FruitProvider<span class="token punctuation">)</span> field<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>FruitProvider<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                strFruitProvicer<span class="token operator">=</span><span class="token string">" 供应商编号："</span><span class="token operator">+</span>fruitProvider<span class="token punctuation">.</span><span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" 供应商名称："</span><span class="token operator">+</span>fruitProvider<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" 供应商地址："</span><span class="token operator">+</span>fruitProvider<span class="token punctuation">.</span><span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>strFruitProvicer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Apple.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> test<span class="token punctuation">.</span>FruitColor<span class="token punctuation">.</span>Color<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 注解使用 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@FruitName</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String appleName<span class="token punctuation">;</span>    <span class="token annotation punctuation">@FruitColor</span><span class="token punctuation">(</span>fruitColor<span class="token operator">=</span>Color<span class="token punctuation">.</span>RED<span class="token punctuation">)</span>    <span class="token keyword">private</span> String appleColor<span class="token punctuation">;</span>    <span class="token annotation punctuation">@FruitProvider</span><span class="token punctuation">(</span>id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">"陕西红富士集团"</span><span class="token punctuation">,</span>address<span class="token operator">=</span><span class="token string">"陕西省西安市延安路89号红富士大厦"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String appleProvider<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAppleColor</span><span class="token punctuation">(</span>String appleColor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>appleColor <span class="token operator">=</span> appleColor<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getAppleColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> appleColor<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAppleName</span><span class="token punctuation">(</span>String appleName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>appleName <span class="token operator">=</span> appleName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getAppleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> appleName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAppleProvider</span><span class="token punctuation">(</span>String appleProvider<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>appleProvider <span class="token operator">=</span> appleProvider<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getAppleProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> appleProvider<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">displayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"水果的名字是：苹果"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>FruitRun.java</code></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 输出结果 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FruitRun</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        FruitInfoUtil<span class="token punctuation">.</span><span class="token function">getFruitInfo</span><span class="token punctuation">(</span>Apple<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><p>水果名称：Apple<br>水果颜色：RED<br>供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延安路89号红富士大厦</p>]]></content>
      
      
      <categories>
          
          <category> 注解 </category>
          
          <category> annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注解 </tag>
            
            <tag> annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis代码生成器</title>
      <link href="/2019/03/17/mybatis-dai-ma-sheng-cheng-qi/"/>
      <url>/2019/03/17/mybatis-dai-ma-sheng-cheng-qi/</url>
      
        <content type="html"><![CDATA[<p>MyBatis Generator：代码生成器，帮助我们自动生成基本的增、删、改、查的代码，方便我们开发，减少不必要的体力活动。</p><p>当数据库表的字段比较少的时候，写起来还能接受，一旦字段过多或者需要在很多表中写这些基本方法时，就会很麻烦，不仅需要很大的代码量，而且字段过多时很容易出现错误。</p><p>作为一个优秀的程序员，”懒”是很重要的优点。我们不仅要会写代码，还要会利用工具生成代码。Mybatis的开发团队提供了一个很强大的代码生成器——MyBatis Generator，后文中使用缩写MBG来代替。</p><p>MBG通过丰富的配置可以生成不同类型的代码，代码包含了数据库表对应的实体类、Mapper接口类、MapperXML文件和Example对象等，这些代码文件中几乎包含了全部的单表操作方法，使用MBG可以极大程度上方便我们使用MyBatis，还可以减少很多重复操作。</p><p>官方文档：<a href="http://www.mybatis.org/generator/" target="_blank" rel="noopener">http://www.mybatis.org/generator/</a></p><hr><h3 id="非图形化方式"><a href="#非图形化方式" class="headerlink" title="非图形化方式"></a>非图形化方式</h3><p>首先，我讲解官方推出的方式，<a href="https://github.com/mybatis/generator" target="_blank" rel="noopener">mybatis-generator</a>有三种用法：命令行、eclipse插件、maven插件。个人觉得maven插件最方便，可以在eclipse/intellij idea等ide上可以通用。</p><p>不管哪种方式，都需要学会MBG的xml配置文件，下面，我们来学习一下吧~~~</p><h4 id="XML配置详解"><a href="#XML配置详解" class="headerlink" title="XML配置详解"></a>XML配置详解</h4><p>首先按照MBG的要求添加XML的文件头：</p><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;!DOCTYPE generatorConfiguration          PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;          &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</code></pre><p>在文件头之后，需要加上XML文件的根节点：<code>generatorConfiguration</code></p><pre><code>&lt;generatorConfiguration&gt;    &lt;!--其他配置内容--&gt;&lt;/generatorConfiguration&gt;</code></pre><p>以上两部分内容是MBG必备的基本信息，后面是MBG中的自定义配置部分。下面介绍 generatorConfiguration 标签下的 3 个子级标签</p><p>分别是：<code>properties</code>、<code>classPathEntry</code> 和 <code>context</code>。在配置这三个标签时，注意它们的顺序，必须和这里列举的顺序一致才行！！！</p><hr><p>第一个是properties标签。这个标签用来指定外部的属性元素，最多可以配置一个，也可以不配置。</p><p>properties标签用于指定一个需要在配置中解析使用的外部属性文件，引入属性文件后，可以在配置中使用 <code>${property}</code> 这种形式的引用，通过这种方式引用属性文件中的属性值，对于后面需要配置的JDBC信息会很有用。</p><p>properties标签包括 resource 和 url 两个属性，只能使用其中一个属性来指定，同时出现则会报错。</p><ul><li><p>resource：指定classpath下的属性文件，类似：com/liuzhuo/mybatis/generatorConfig.properties 这样的属性值。</p></li><li><p>url：指定文件系统上的特定位置，例如：file:///E:/myfolder/generatorConfig.properties</p></li></ul><hr><p>第二个是 classPathEntry 标签。这个标签可以配置多个，也可以不配置。</p><p>classPathEntry标签最常见的用法是通过属性 location指定驱动的路径，代码如下：</p><p><code>&lt;classPathEntry location=&quot;E:\mysql\mysql-connector-java-5.1.29.jar&quot;/&gt;</code></p><hr><p>第三个是 context 标签。这个标签是要重点讲解的，该标签至少配置一个，可以配置多个。</p><p>context标签用于指定生成一组对象的环境。例如指定要连接的数据库，要生成对象的类型和要处理的数据库中的表。运行MBG的时候还可以指定要运行的context。</p><p>context标签只有一个必选属性id，用来唯一确定该标签，该id属性可以运行MBG时使用。此外还有几个可选属性：</p><ul><li>defaultModelType：这个属性很重要，定义了MBG如何生成实体类。该属性可选值有：</li></ul><p>（1）conditional：默认值，和下面的 hierarchical 类似，如果一个表的主键只有一个字段，那么不会为该字段生成单独的实体类，而是会将该字段合并到基本实体类中。</p><p>（2）flat：该模型只为每张表生成一个实体类。这个实体类包含表中的所有字段。这种模型最简单，推荐使用。</p><p>（3）hierarchical：如果表有主键，那么该模型会产生一个单独的主键实体类，如果表还有BLOB字段，则会为表生成一个包含所有BLOB字段的单独的实体类，然后为所有其他的字段另外生成一个单独的实体类。MBG会在所有生成的实体类之间维护一个继承关系。</p><ul><li>targetRuntime：此属性用于指定生成的代码的运行环境，支持以下可选值</li></ul><p>（1）MyBatis3：默认值</p><p>（2）MyBatis3Simple：这种情况不会生成与Example相关的方法。</p><ul><li>introspecedColumnImpl：该参数可以指定扩展 org.mybatis.generator.api.Introspected Column类的实现类。</li></ul><hr><p>一般情况下，使用如下配置即可。</p><p><code>&lt;context id=&quot;Mysql&quot; defaultModeType=&quot;flat&quot;&gt;</code></p><hr><p>MBG配置中的其他几个标签基本上都是 context的子标签，这些子标签（有严格的配置顺序）包括以下几个：</p><ul><li><p>property（0个或多个）</p></li><li><p>plugin（0个或多个）</p></li><li><p>commentGenerator（0个或多个）</p></li><li><p>jdbcConnection（1个）</p></li><li><p>javaTypeResolver（0个或多个）</p></li><li><p>javaModelGenerator（1个）</p></li><li><p>sqlMapGenerator（0个或多个）</p></li><li><p>javaClientGenerator（0个或多个）</p></li><li><p>table（1个或多个）</p></li></ul><p>下面逐条介绍这些重要的标签。</p><hr><h5 id="property标签"><a href="#property标签" class="headerlink" title="property标签"></a>property标签</h5><p>在介绍property标签之前，先来了解一下数据库中的<strong>分隔符</strong>。</p><p>举一个简单的例子，假设数据库中有一个表，名为 <code>user info</code> ，注意这个名字，user 和 info 中间存在一个空格。如果直接写如下查询，在数据库执行这个查询时会报错。</p><p><code>select * from user info</code></p><p>可能会提示 <code>user</code> 表不存在或者user附件有语法错误，这种情况下该怎么写 <code>user info</code>表呢？</p><p>这时，就会用到<strong>分隔符</strong>了，在MySQL中可以使用反单引号 “ ` “ 作为分隔符，例如：</p><pre><code>`user info`</code></pre><p>在SQL Server中则是 [user info]。通过分隔符可以将其中的内容作为一个整体的字符串进行处理，当SQL中有数据库关键字时，使用反单引号括住关键字，可以避免数据库产生错误。</p><p>之所以先介绍分隔符，就是因为property标签中包含以下3个和分隔符相关的属性。</p><ul><li><p>autoDelimitKeywords</p></li><li><p>beginningDelimiter</p></li><li><p>endingDelimiter</p></li></ul><p>从名字可以看出，第一个是自动给关键字添加分隔符的属性。MBG中维护了一个关键字列表，当数据库中的字段或表与这些关键字一样时，MBG会自动给这些字段或表添加分隔符。关键字列表可以查看MBG中的 org.mybatis.generator.internal.db.SqlReservedWords类。</p><p>后面两个属性很简单，一个是配置前置分隔符的属性，一个是配置后置分隔符的属性。在MySQL中，两个分隔符都是 “ ` “，在SQL Server中分别为 “ [ “ 和 “ ] “。</p><p>MySQL中的property配置写法如下：</p><pre><code>&lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt;   &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;true&quot;/&gt;   &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;   &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;   &lt;!--其他配置--&gt;&lt;/context&gt;</code></pre><p>除了上面3个和分隔符相关的属性外，还有以下3个属性。</p><ul><li><p>javaFileEncoding</p></li><li><p>javaFormatter</p></li><li><p>xmlFormatter</p></li></ul><p>属性 javaFileEncoding 设置要使用的Java文件的编码，例如 GBK 或 UTF-8。默认使用当前运行环境的编码。后面的不常用，就不介绍了。</p><hr><h5 id="plugin标签"><a href="#plugin标签" class="headerlink" title="plugin标签"></a>plugin标签</h5><p>plugin标签可以配置0个或多个，个数不受限制。</p><p>plugin标签用来定义一个插件，用于扩展或修改通过MBG生成的代码。该插件将按照在配置中的顺序执行。MBG插件使用的情况并不多，如果对开发插件有兴趣，可以参考MBG文档，或者参考下面要介绍的缓存插件的例子，这个例子包含在MBG插件中。</p><p>下面要介绍的缓存插件的全限定名称为： org.mybatis.generator.plugins.CachePlugin。</p><p>这个插件可以在生成的SQL XML映射文件中增加一个 cache 标签。只有当targetRuntime 为 MyBatis3时，该插件才有效。</p><p>该插件接受下列可选属性。</p><ul><li><p>cache_eviction</p></li><li><p>cache_flushInterval</p></li><li><p>cache_readOnly</p></li><li><p>cache_size</p></li><li><p>cache_type</p></li></ul><p>配置方法如下：</p><pre><code>&lt;plugin type=&quot;org.mybatis.generator.plugins.CachePlugin&quot;&gt;   &lt;property name=&quot;cache_eviction&quot; value=&quot;LRU&quot;/&gt;   &lt;property name=&quot;cache_size&quot; value=&quot;1024&quot;/&gt;&lt;/plugin&gt;</code></pre><p>添加这个配置后，生成的Mapper.xml文件中会增加如下的缓存相关配置。</p><pre><code>&lt;cache eviction=&quot;LRU&quot; size=&quot;1024&quot;&gt;&lt;/cache&gt;</code></pre><hr><h5 id="commentGenerator标签"><a href="#commentGenerator标签" class="headerlink" title="commentGenerator标签"></a>commentGenerator标签</h5><p>该标签用来配置如何生成注释信息，最多可以配置1个。</p><p>该标签有一个可选属性 type，可以指定用户的实现类，该类需要实现 org.mybatis.generator.api.CommentGenerator接口，而且必有一个默认空的构造方法。</p><p>type属性接收默认的特殊值：DEFAULT，使用默认的实现类 org.mybatis.generator.internal.DefaultCommentGenerator。</p><p>默认的实现类中提供了三个可选属性，需要通过property属性进行配置。</p><ul><li><p>suppressAllComments：阻止生成注释，默认为false。</p></li><li><p>suppressDate：阻止生成的注解包含时间戳，默认为false。</p></li><li><p>addRemarkComments：注释是否添加数据库表的备注信息，默认为false。</p></li></ul><p>一般情况下，由于MBG生成的注解信息没有任何价值，而且时间戳的情况下每次生成的注释都不一样，使用版本控制的时候每次都会提交，因而一般情况下都会屏蔽注释信息，可以如下配置：</p><pre><code>&lt;commentGenerator&gt;   &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;   &lt;property name=&quot;addRemarkComments&quot; value=&quot;true&quot;/&gt;&lt;/commentGenerator&gt;</code></pre><h5 id="jdbcConnection标签"><a href="#jdbcConnection标签" class="headerlink" title="jdbcConnection标签"></a>jdbcConnection标签</h5><p>jdbcConnection标签用于指定MBG要连接的数据库信息，该标签必选，并且只能有一个。</p><p>配置该标签需要注意，如果JDBC驱动不在classpath下，就要通过 classPathEntry 标签引入 jar 包，这里推荐将jar包放到classpath下，或者参考前面classPathEntry配置的JDBC驱动的方法。</p><p>该标签有两个必选属性。</p><ul><li><p>driverClass：访问数据库的JDBC驱动程序的完全限定类名。</p></li><li><p>connectionURL：访问数据库的JDBC连接URL。</p></li></ul><p>该标签还有两个可选属性。</p><ul><li><p>userId：访问数据库的用户ID。</p></li><li><p>password：访问数据库的密码。</p></li></ul><p>此外，该标签还可以接受多个property子标签，这里配置的property属性都会添加到JDBC驱动的属性中（使用property标签的name属性反射赋值）。</p><p>这个标签配置起来非常容易，基本配置如下：</p><pre><code>&lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot;                userId=&quot;root&quot;                password=&quot;&quot;&gt;&lt;/jdbcConnection&gt;</code></pre><p>Oracle的配置：</p><pre><code>&lt;jdbcConnection driverClass=&quot;oracle.jdbc.driver.OracleDriver&quot;                connectionURL=&quot;jdbc:oracle:thin:@//localhost:1521/oracle&quot;                userId=&quot;mybatis&quot;                password=&quot;mybatis&quot;&gt;    &lt;property name=&quot;remarksReporting&quot; value=&quot;true&quot;/&gt;&lt;/jdbcConnection&gt;</code></pre><h5 id="javaTypeResolver标签"><a href="#javaTypeResolver标签" class="headerlink" title="javaTypeResolver标签"></a>javaTypeResolver标签</h5><p>该标签的配置用来指定 <code>JDBC类型</code> 和 <code>Java类型</code> 如何转换，最多可以配置一个。</p><p>该标签提供了一个可选的属性type。另外，和commentGenerator类似，该标签提供了默认的实现 DEFAULT ，一般情况下使用默认即可，需要特殊处理的情况可以通过其他标签配置来解决，不建议修改该属性。</p><p>该属性还有一个可以配置的property标签，可以配置的属性为：<code>forceBigDecimals</code>，该属性可以控制是否强制将 DECIMAL 和 NUMERIC 类型的JDBC 字段转换为JAVA类型的java.math.BigDecimal，默认值为false，一般不需要配置。</p><p>默认情况下的转换规则如下：</p><ul><li><p>如果精度 &gt; 0 或者 长度 &gt; 18 ，就使用 java.math.BigDecimal。</p></li><li><p>如果精度 = 0 并且 10&lt;=长度&lt;=18，就使用 java.lang.Long。</p></li><li><p>如果精度 = 0 并且 5&lt;=长度&lt;=9，就使用 java.lang.Integer。</p></li><li><p>如果精度 = 0 并且 长度&lt;5，就使用 java.lang.Short。</p></li></ul><p>如果将 forceBigDecimals 设置为 true，那么一定会使用 java.math.BigDecimal类型。</p><pre><code>&lt;javaTyepResolver&gt;   &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;&lt;/javaTyepResolver&gt;</code></pre><h5 id="javaModelGenerator标签"><a href="#javaModelGenerator标签" class="headerlink" title="javaModelGenerator标签"></a>javaModelGenerator标签</h5><p>该标签用来控制生成的实体类，根据context标签中配置的 defaultModelType属性值的不同，一个表可能会对应生成多个不同的实体类。一个表对应多个类时使用并不方便，所以前面推荐使用 flat，保证一个表对应一个实体类。该标签必须配置一个，并且最多配置一个。</p><p>该标签只有两个必选属性。</p><ul><li><p>targetPackage：生成实体类存放的包名。一般就是放在该包下，实际还会受到其他配置的影响。</p></li><li><p>targetProject：指定目标项目路径，可以使用相对路径或绝对路径。</p></li></ul><p>该标签还支持以下几个property子标签属性。</p><ul><li><p>constructorBased：该属性只对 <code>MyBatis3</code> 有效，如果为 true就会使用构造方法入参，如果为 false就会使用setter方式。默认为false。</p></li><li><p>enableSubPackages：如果为true，MBG会根据 catalog 和 schema 来生成子包。如果为 false 就会直接使用 targetPackage属性。默认为false。</p></li><li><p>immutable：用来配置实体类属性是否可变。如果设置为 true，那么constructorBased不管设置成什么，都会使用构成方法入参，并且不会生成setter方法。如果false，实体类属性就可以改变。默认为false。</p></li><li><p>rootClass：设置所有实体类的基类。如果设置，则需要使用类的全限定名称。并且，如果MBG能够加载 rootClass（可以通过classPathEntry引入jar包，或者classpath方式），那么MBG不会覆盖和父类中完全匹配的属性。匹配规则如下：</p></li></ul><p>（1）属性名完全相同</p><p>（2）属性类型相同</p><p>（3）属性有getter方法</p><p>（4）属性有setter方法</p><ul><li>trimStrings：判断是否对数据库查询结果进行trim操作，默认值为false。如果设置为 true就会生成如下代码：<pre><code>public void setUsername(String username){  this.username = username == null ? null : username.trim();}</code></pre></li></ul><p>javaModelGenerator配置如下：</p><pre><code>&lt;javaModelGenerator targetPackage=&quot;com.liuzhuo.model&quot;                    targetProject=&quot;src\main\java&quot; &gt;  &lt;!--相对路径--&gt;     &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;     &lt;property name=&quot;trimStrings&quot; values=&quot;false&quot; /&gt;&lt;/javaModelGenerator&gt;</code></pre><h5 id="sqlMapGenerator标签"><a href="#sqlMapGenerator标签" class="headerlink" title="sqlMapGenerator标签"></a>sqlMapGenerator标签</h5><p>该标签用于配置SQL映射生成器（Mapper.xml文件）的属性，该标签可选，最多配置一个。</p><p>如果targetRuntime设置为MyBatis3，则只有当javaClientGenerator配置需要XML时，该标签才必须配置一个。如果没有配置：javaClientGenerator，则使用以下规则。</p><ul><li><p>如果指定了一个sqlMapGenerator，那么MBG将只生成XML的SQL映射文件和实体类。</p></li><li><p>如果没有指定sqlMapGenerator，那么MBG将只生成实体类。</p></li></ul><p>该标签只有两个必选属性。</p><ul><li><p>targetPackage：生成SQL映射文件（XML文件）存放的包名。一般就是放在该包下，实际还会受到其他配置的影响。</p></li><li><p>targetProject：指定目标项目路径，可以使用相对路径或绝对路径。</p></li></ul><p>该标签还有一个可选的property子标签属性：enableSubPackages，如果为true，MBG会根据catalog和schema来生成子包。如果为false就会直接用targetPackage属性，默认为false。</p><p>sqlMapGenerator配置如下：</p><pre><code>&lt;sqlMapGenerator targetPackage=&quot;com.liuzhuo.mapper&quot;                 targetProject=&quot;E:\Myproject\src\main\resources&quot;&gt;  &lt;!--绝对路径--&gt;      &lt;property name=&quot;enableSubPackages&quot; values=&quot;false&quot; /&gt;&lt;/sqlMapGenerator&gt;</code></pre><h5 id="javaClientGenerator标签"><a href="#javaClientGenerator标签" class="headerlink" title="javaClientGenerator标签"></a>javaClientGenerator标签</h5><p>该标签用于配置Java客户端生成器（Mapper接口）的属性，该标签可选，最多配置一个。如果不配置该标签，就不会生成Mapper接口。</p><p>该标签有以下3个必选属性。</p><ul><li>type：用于选择客户端代码（Mapper接口）的属性，用户可以自定义实现，需要继承 org.mybatis.generator.codegen.AbstractJavaClientGenerator类，必须有一个默认空的构造方法。该属性提供了以下预设的代码生成器，首先根据context的targetRuntime分成两类（不考虑iBATIS）。</li></ul><p>（1）MyBatis3</p><pre><code>ANNOTATEDMAPPER: 基于注解的Mapper接口，不会有对应的XML映射文件。MIXEDMAPPER：    XML和注解的混合模式，上面这种情况中的SQL Provider注解方法会被XML方式替代。XMLMAPPER：      所有方法都在XML中，接口调用依赖XML文件。</code></pre><p>（2）MyBatis3Simple</p><pre><code>ANNOTATEDMAPPER: 基于注解的Mapper接口，不会有对应的XML映射文件。XMLMAPPER：      所有方法都在XML中，接口调用依赖XML文件。</code></pre><ul><li><p>targePackage：生成Mapper接口存放的包名。一般就是放在该包下，实际还会受到其他配置的影响。</p></li><li><p>targetProject：指定目标项目路径，可以使用相对路径或绝对路径。</p></li></ul><p>javaClientGenerator标签配置：</p><pre><code>&lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.liuzhuo.mapper&quot;                     targetProject=&quot;src\main\java&quot; /&gt;    &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;&lt;/javaClientGenerator&gt;</code></pre><h5 id="table标签"><a href="#table标签" class="headerlink" title="table标签"></a>table标签</h5><p>table标签是最重要的一个标签，该标签用于配置需要通过内省数据库的表，只有在table中配置过的表，才能经过上述其他配置生成最终的代码，该标签至少要配置一个，可以配置多个。</p><p>table标签有一个必选属性 <code>tableName</code> ，该属性指定要生成的表名，可以使用SQL通配符匹配多个表。</p><p>例如要生成全部的表，可以配置如下：</p><p><code>&lt;table tableName=&quot;%&quot; /&gt;</code></p><p>table标签包含多个可选属性。</p><ul><li><p>schema：数据库的schema，可以使用SQL通配符匹配。如果设置了该值，生成SQL的表名会变成如 schema.tableName的形式。</p></li><li><p>catalog：数据库的catalog，如果设置了该值，生成SQL的表名会变成如：catalog.tableName的形式。</p></li><li><p>alias：如果指定，这个值会用在生成的 select 查询SQL表的别名和列名上，例如 alias_actualColumnName（别名_实际列名）。</p></li><li><p>domainObjectName：生成对象的基本名称。如果没有指定，MBG会自动根据表名来生成名称。</p></li><li><p>enableXXX：XXX代表多种SQL方法，该属性用来指定是否生成对应的XXX语句。</p></li><li><p>selectByPrimaryKeyQueryId：DBA跟踪工具中会用到，具体请参考详细文档。</p></li><li><p>selectByExampleQueryid：DBA跟踪工具中会用到，具体请参考详细文档。</p></li><li><p>modelType：和context的defaultModelType含义一样，这里可以针对表进行配置，胡覆盖defaultModelType的配置。</p></li><li><p>escapeWildcards：表示查询列是否对 schema和表名中的SQL通配符（ _ 和 % ）进行转义。对于某些驱动，当 schema或表名中包含SQL通配符时，转义是必须的。有一些驱动则需要将下画线进行转义，例如：MY_TABLE。默认值是 false。</p></li><li><p>delimitidentifiers：是否给标识符增加分隔符。默认是false。当 catalog、schema、tableName中包含空白时，默认为true。</p></li><li><p>delimitAllColumns：是否对所有列添加分隔符。默认为 false。</p></li></ul><hr><p>除了 property 子标签外， table 还包含以下子标签。</p><ul><li><p>generatedKey （0个或 多个）</p></li><li><p>columnRenamingRule（0 个或 多个）</p></li><li><p>columnOverride （0个或多个）</p></li><li><p>ignoreColumn （0个或多个）</p></li></ul><hr><p>generatedKey：该标签用来指定自动生成主键的属性。</p><p>该标签包含以下两个必选属性。</p><ul><li><p>column：生成列的列名</p></li><li><p>sqlStatement：返回新值的SQL语句。如果这是一个identity列，则可以使用其中一个预定义的特殊值，预定义值如下：</p></li></ul><p>（1） Cloudscape </p><p>（2）DB2</p><p>（3）DB2_MF</p><p>（4）Derby </p><p>（5）HSQLDB</p><p>（6）Informix</p><p>（7）MySQL</p><p>（8）SQL Server</p><p>（9）SYBASE</p><p>（10）JDBC：使用该值时，Mybatis会使用JDBC标准接口来获取值，这是一个独立于数据库获取标识列中的值的方法。</p><p>该标签还包含两个可选属性。</p><ul><li><p>identity：当设置为 true 时，该列会被标记为 identity 井且 selectKey标签会被插入在 insert后面；当设置为 false时，selectKey标签会被插入在 insert前面面。</p></li><li><p>type： type = post 且 identity=true 时，生成的 selectKey 中 order=AFTER；当type=pre时，identity只能为false，生成selectKey中的 order=BEFORE。</p></li></ul><hr><p>table的示例：</p><pre><code>&lt;table tableName=&quot;user login info&quot; domainObjectName= &quot;UserLogininfo&quot;&gt;       &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; /&gt;&lt;/table&gt; </code></pre><p>改配置生成的对应的insert方法如下：</p><pre><code>&lt;insert id=&quot;insert&quot; parameterType=&quot;com.liuzhuo.model.UserLogininfo&quot;&gt;    &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;            SELECT LAST INSERT ID ()     &lt;/selectKey&gt;     insert into `user login info` (Id, username , logindate , loginip)     values (#{id,jdbcType=INTEGER} , #{username , jdbcType=VARCHAR} ,             #{logindate,jdbcType=TIMESTAMP}            #{loginip,jdbcType=VARCHAR}) &lt;/ insert&gt; </code></pre><hr><h4 id="完整的配置"><a href="#完整的配置" class="headerlink" title="完整的配置"></a>完整的配置</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;classPathEntry            location=&quot;D:\mysql-connect-jar\mysql-connector-java-5.1.39.jar&quot;/&gt;    &lt;context id=&quot;mySqlContext&quot; targetRuntime=&quot;MyBatis3&quot;              defaultModelType=&quot;flat&quot;&gt;        &lt;property name=&quot;begnningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;commentGenerator&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot;                        userId=&quot;root&quot;                        password=&quot;&quot;/&gt;        &lt;javaModelGenerator targetPackage=&quot;com.liuzhuo.entity&quot;                            targetProject=&quot;src\main\java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.liuzhuo.mapper&quot;                         targetProject=&quot;src\main\resources&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;javaClientGenerator targetPackage=&quot;com.liuzhuo.mapper&quot;                             targetProject=&quot;src\main\java&quot;                             type=&quot;MIXEDMAPPER&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/javaClientGenerator&gt;        &lt;!--&lt;table tableName=&quot;T_FEE_AGTBILL&quot; domainObjectName=&quot;FeeAgentBill&quot;               enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;               enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;               selectByExampleQueryId=&quot;false&quot;/&gt;--&gt;        &lt;table tableName=&quot;student&quot; domainObjectName=&quot;Student&quot;&gt;              &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot;/&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p>有关配置有几点重要说明。</p><p>（1）context属性 targetRuntime 设置为 MyBatis3Simple，可以避免生成与Example相关的代码和方法，如果需要Example相关的代码，则设置为：MyBatis3.</p><p>（2）context属性 defaultModelType 设置为 flat，目的是使每个表只生成一个实体类，当没有复杂的类继承时，使用起来更方便。</p><p>（3）因为此处使用的数据库为MySQL，所以前后分隔符都设置为 “ ` “。</p><hr><h4 id="运行MyBatis-Generator"><a href="#运行MyBatis-Generator" class="headerlink" title="运行MyBatis Generator"></a>运行MyBatis Generator</h4><p>MBG提供了很多种运行方式，常用的有以下几种：</p><ul><li><p>使用java编写代码运行</p></li><li><p>从命令提示符运行</p></li><li><p>使用 Maven Plugin运行</p></li><li><p>使用 Eclipse插件运行</p></li></ul><hr><h5 id="使用java编写方式"><a href="#使用java编写方式" class="headerlink" title="使用java编写方式"></a>使用java编写方式</h5><p>在写代码之前，需要先把MBG的jar包添加到项目当中。</p><p>第一种方式是，从地址：<a href="https://github.com/mybatis/generator/releases" target="_blank" rel="noopener">https://github.com/mybatis/generator/releases</a> 下载jar包。</p><p>第二种方式是，使用Maven方式直接引入依赖，在pom.xml中添加如下依赖：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-generator&lt;/artifactId&gt;    &lt;version&gt;1.3.7&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>在MyBatis项目中添加 <code>com.mybatis.generator</code>包，创建Generator.java类。</p><pre><code>public class Generator {   public static void main(String[] args) throws Exception{    //MBG执行过程中的警告信息    List&lt;String&gt; warning = new ArrayList&lt;String&gt;();    //当生成的代码重复时，覆盖原代码    boolean overwrite = true;    //读取MBG配置文件    InputStream is = Generator.class.getResourceAsStream(&quot;/generator/generatorConfig.xml&quot;);    ConfigurationParser cp = new ConfigurationParser(warnings);    Configuration config = cp.parseConfiguration(is);    is.close();    DefaultShellCallback callback =  new DefaultShellCallback(overwrite);   //创建MBG   MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,callback,warnings);   //执行生成代码   myBatisGenerator.generate(null);   //输出警告信息   for(Strng warning : warnings) {        System.out.println(warning);      }  }}</code></pre><p>使用Java编码方式运行的好处是，generatorConfig.xml配置的一些特殊的类（如commentGenerator 标签中 type 属性配置的 MyCommentGenerator 类）只要在当前项目中，或者在当前项目的 classpath 中， 就可以直接使用。使用其他方式时都需要特别配置才能在MBG执行过程中找到 MyCommentGenerator 类并实例化，否则都会由于找不到这个类而抛出异常。</p><h5 id="从命令提示符运行"><a href="#从命令提示符运行" class="headerlink" title="从命令提示符运行"></a>从命令提示符运行</h5><p>从命令提示符运行就必须使用 jar包，将这个jar包与generatorConfig.xml文件放在一起。从这里就可以体会到为什么说这种配置方式不方便了，因为需要修改generatorConfig.xml配置文件。</p><p>将 MySQL JDBC 驱动 （如 mysql-connector java-5.1.38.jar ）放到当前目录中，然后在配置文件中添加classPathEntry：</p><pre><code>&lt;generatorConfiguration&gt;&lt;classPathEntry location=&quot;mysql-connector java-5.1.38.jar&quot;/&gt;&lt;context id=&quot;MySqlContext&quot; defaultModelTyp=&quot;flat&quot;&gt;  &lt;!--其他原有配置--&gt;&lt;/context&gt;&lt;/generatorConfiguration&gt; </code></pre><p>除此之外，在当前目录中添加src文件夹，在src中再添加 main文件夹，main文件夹中添加 java 和 resources文件夹。<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190317175506.png" style="width:50%"></p><p>下面介绍一下MBG命令行可以接受的几个参数：</p><ul><li><p>-configfile fileName ：指定配置文件的名称。</p></li><li><p>-overwrite(可选)：指定了该参数后，如果生成的java文件已经存在同名的文件，新生成的文件则会覆盖原有的文件。否则，会新生成一个唯一的名字。</p></li><li><p>-verbose（可选）：指定该参数，执行过程中会输出到控制台。</p></li><li><p>-forceJavaLogging（可选）：指定该参数，MBG将会使用Java日志记录而不会使用Log4J，即使Log4J在运行时的类路径中。</p></li><li><p>contextids context1,context2,···(可选)：指定该参数，逗号隔开这些的context会被执行。</p></li><li><p>tables table1,table2,···(可选)：指定该参数，逗号隔开的这些表会被运行。</p></li></ul><hr><pre><code>java -jar mybatis-generator-core-1.3.3.jar -configfile generatorConfig.xmljava -Dfile.encoding=UTF-8 -jar mybatis-generator-core-1.3.3.jar -configfile generatorConfig.xml -overwrite</code></pre><hr><h5 id="使用Maven-Plugin运行"><a href="#使用Maven-Plugin运行" class="headerlink" title="使用Maven Plugin运行"></a>使用Maven Plugin运行</h5><p>使用 Maven Plugin 插件方式和 java编码方式类似，都是和项目绑定在一起的，当需要引用其他类时，需要给 Maven插件添加依赖，否则找不到类。</p><p>在pom.xml文件中添加插件配置：</p><pre><code>    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;            &lt;groupid&gt;org.mybatis.generator&lt;/groupid&gt;             &lt;artifactid&gt;mybatis-generator-maven-plugin&lt;/artifactid&gt;             &lt;version&gt;l.3.3&lt;/version&gt;             &lt;configuration&gt;                  &lt;configurationFile&gt;                           ${basedir}/src/main/resources/generator/generatorConfig.xml                  &lt;/configurationFile&gt;                  &lt;overwrite&gt;true&lt;/overwrite&gt;                 &lt;verbose&gt;true&lt;/verbose&gt;             &lt;/configuration&gt;             &lt;dependencies&gt;                  &lt;dependency&gt;                      &lt;groupid&gt;mysql&lt;/groupid&gt;                      &lt;artifactid&gt;mysql-connector-java&lt;/artifactid&gt;                      &lt;version&gt;5.l.38&lt;/version&gt;                  &lt;/dependency&gt;                  &lt;dependency&gt;                      &lt;groupid&gt;com.liuzhuo&lt;/groupid&gt;                      &lt;artifactid&gt;mybatis&lt;/artifactid&gt;                      &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;                   &lt;/dependency&gt;             &lt;/dependencies&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;    &lt;/build&gt;</code></pre><p>这里<code>&lt;configuration&gt;</code>就和命令行的参数一样，不用讲了，特殊之处在于插件中的<code>&lt;dependencies&gt;</code>，在generatorConfig.xml配置文件中，没有通过classPathEntry方式配置 JDBC驱动了，这里通过添加依赖将 JDBC驱动添加到了MBG的classpath中，另外还添加了当前项目的依赖。</p><p><strong>需要特别注意的是：</strong>当前项目必须执行 mvn install（通过Maven命令将当前项目安装到本地仓库），否则会找不到当前项目的依赖。</p><p>配置好插件后，可以执行：</p><p><code>mvn mybatis-generator:generate</code></p><hr><h5 id="Eclipse插件方式"><a href="#Eclipse插件方式" class="headerlink" title="Eclipse插件方式"></a>Eclipse插件方式</h5><p>（1）安装Eclipse插件：</p><p>从MBG的发布页面 <a href="https://github.com/mybatis/generator/releases" target="_blank" rel="noopener">https://github.com/mybatis/generator/releases</a> 中下载插件：</p><p><code>org.mybatis.generator.eclipse.site-1.3.7.201807042148.zip</code><br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190317182045.png"></p><p>下载好插件后，在Eclipse中选中菜单 Help 中的 Install New Software：</p><p>点击Add按钮，在弹出的窗口中选择 Archive，选择下载完成的 MBG 插件，输入 Name MBG后，点击OK。</p><p>从下拉列表中选择全部的 MyBatis Generator，点击Next，一步步完成安装，安装完成后重启Eclipse。</p><p>（2）使用Eclipse插件</p><p>Eclipse 插件的运行方式有点特殊， JDBC 驱动需要通过 classPathEntry 进行配置，其他定制类只要在当前项目或当前项目classpath中即可使用。</p><pre><code>&lt;generatorConfiguration&gt;    &lt;classPathEntry            location=&quot;D:\mysql-connect-jar\mysql-connector-java-5.1.39.jar&quot;/&gt;    &lt;context id=&quot;mySqlContext&quot; targetRuntime=&quot;MyBatis3&quot;              defaultModelType=&quot;flat&quot;&gt;        &lt;property name=&quot;begnningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;!--其他配置--&gt;&lt;/generatorConfiguration&gt;</code></pre><p>(3) 运行</p><p>完成上述修改后，在配置文件中单击鼠标右键，选择：<code>Generate MyBatis/iBATIS Artifacts</code></p><p>点击 Generate MyBatis 后就会自动生成代码。</p><hr><h5 id="使用IDEA的方式"><a href="#使用IDEA的方式" class="headerlink" title="使用IDEA的方式"></a>使用IDEA的方式</h5><p>我自己使用的是IDEA的方式。</p><p>随便创建一个 Springboot的web项目：</p><p>我填写的是：<br>groupId：com.generator<br>artifactId：mybatis</p><p>项目结构：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190317183413.png"></p><p>pom.xml文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.generator&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;name&gt;mybatis&lt;/name&gt;    &lt;description&gt;generator-mybatis&lt;/description&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;1.5.6.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;1.3.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;/configuration&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;mysql&lt;/groupId&gt;                        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                        &lt;version&gt;5.1.39&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>在resources中，添加：generator.properties 文件：</p><pre><code>jdbc.driverClass=com.mysql.jdbc.Driverjdbc.connectionURL=jdbc:mysql://localhost:3306/mybatisjdbc.userId=rootjdbc.password=123456jdbc.database=mybatis</code></pre><p>generatorConfig.xml文件中：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!--导入属性配置 --&gt;    &lt;properties resource=&quot;generator.properties&quot;&gt;&lt;/properties&gt;    &lt;!--指定特定数据库的jdbc驱动jar包的位置 --&gt;    &lt;!--&lt;classPathEntry location=&quot;${jdbc.driverLocation}&quot;/&gt;--&gt;    &lt;context id=&quot;default&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt;        &lt;commentGenerator&gt;            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;!--jdbc的数据库连接 --&gt;        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;        &lt;jdbcConnection                driverClass=&quot;${jdbc.driverClass}&quot;                connectionURL=&quot;${jdbc.connectionURL}&quot;                userId=&quot;${jdbc.userId}&quot;                password=&quot;${jdbc.password}&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类            targetPackage     指定生成的model生成所在的包名            targetProject     指定在该项目下所在的路径        --&gt;        &lt;javaModelGenerator targetPackage=&quot;com.liuzhuo.model.student&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;!-- 是否对model添加 构造函数 --&gt;            &lt;property name=&quot;constructorBased&quot; value=&quot;true&quot;/&gt;            &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;            &lt;!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 --&gt;            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;            &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.liuzhuo.mapper.student&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码                type=&quot;ANNOTATEDMAPPER&quot;,生成Java Model 和 基于注解的Mapper对象                type=&quot;MIXEDMAPPER&quot;,生成基于注解的Java Model 和相应的Mapper对象                type=&quot;XMLMAPPER&quot;,生成SQLMap XML文件和独立的Mapper接口        --&gt;        &lt;javaClientGenerator targetPackage=&quot;com.liuzhuo.mapper.student&quot; targetProject=&quot;src/main/java&quot;                             type=&quot;MIXEDMAPPER&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;!--                    定义Maper.java 源代码中的ByExample() 方法的可视性，可选的值有：                    public;                    private;                    protected;                    default                    注意：如果 targetRuntime=&quot;MyBatis3&quot;,此参数被忽略             --&gt;            &lt;property name=&quot;exampleMethodVisibility&quot; value=&quot;public&quot;/&gt;            &lt;!--              方法名计数器              Important note: this property is ignored if the target runtime is MyBatis3.            &lt;property name=&quot;methodNameCalculator&quot; value=&quot;&quot;/&gt;             --&gt;            &lt;!--                  为生成的接口添加父接口            &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;            --&gt;        &lt;/javaClientGenerator&gt;        &lt;!--tableName:表名            schema:数据库名            domainObjectName:实体类的名字        --&gt;        &lt;!--详细的表--&gt;        &lt;!--       &lt;table tableName=&quot;tbl_file_permission_map&quot; schema=&quot;${jdbc.database}&quot;               domainObjectName=&quot;FilePermissionMap&quot;               enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;               enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;               selectByExampleQueryId=&quot;false&quot;&gt;               optional , only for mybatis3 runtime               自动生成的键值（identity,或者序列值）               如果指定此元素，MBG将会生成&lt;selectKey&gt;元素，然后将此元素插入到SQL Map的&lt;insert&gt; 元素之中               sqlStatement 的语句将会返回新的值               如果是一个自增主键的话，你可以使用预定义的语句,或者添加自定义的SQL语句. 预定义的值如下:                  Cloudscape    This will translate to: VALUES IDENTITY_VAL_LOCAL()                  DB2:      VALUES IDENTITY_VAL_LOCAL()                  DB2_MF:       SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1                  Derby:        VALUES IDENTITY_VAL_LOCAL()                  HSQLDB:   CALL IDENTITY()                  Informix:     select dbinfo(&#39;sqlca.sqlerrd1&#39;) from systables where tabid=1                  MySql:        SELECT LAST_INSERT_ID()                  SqlServer:    SELECT SCOPE_IDENTITY()                  SYBASE:   SELECT @@IDENTITY                  JDBC:     This will configure MBG to generate code for MyBatis3 suport of JDBC standard generated keys. This is a database independent method of obtaining the value from identity columns.                  identity: 自增主键  If true, then the column is flagged as an identity column and the generated &lt;selectKey&gt; element will be placed after the insert (for an identity column). If false, then the generated &lt;selectKey&gt; will be placed before the insert (typically for a sequence).            &lt;generatedKey column=&quot;&quot; sqlStatement=&quot;&quot; identity=&quot;&quot; type=&quot;&quot;/&gt;            optional.                     列的命名规则：                     MBG使用 &lt;columnRenamingRule&gt; 元素在计算列名的对应 名称之前，先对列名进行重命名，                     作用：一般需要对BUSI_CLIENT_NO 前的BUSI_进行过滤                     支持正在表达式                     searchString 表示要被换掉的字符串                     replaceString 则是要换成的字符串，默认情况下为空字符串，可选            &lt;columnRenamingRule searchString=&quot;&quot; replaceString=&quot;&quot;/&gt;            optional.告诉 MBG 忽略某一列                    column，需要忽略的列                    delimitedColumnName:true ,匹配column的值和数据库列的名称 大小写完全匹配，false 忽略大小写匹配                    是否限定表的列名，即固定表列在Model中的名称            &lt;ignoreColumn column=&quot;&quot; delimitedColumnName=&quot;&quot;/&gt;            optional.覆盖MBG对Model 的生成规则                 column: 数据库的列名                 javaType: 对应的Java数据类型的完全限定名                 在必要的时候可以覆盖由JavaTypeResolver计算得到的java数据类型. For some databases, this is necessary to handle &quot;odd&quot; database types (e.g. MySql&#39;s unsigned bigint type should be mapped to java.lang.Object).                 jdbcType:该列的JDBC数据类型(INTEGER, DECIMAL, NUMERIC, VARCHAR, etc.)，该列可以覆盖由JavaTypeResolver计算得到的Jdbc类型，对某些数据库而言，对于处理特定的JDBC 驱动癖好 很有必要(e.g. DB2&#39;s LONGVARCHAR type should be mapped to VARCHAR for iBATIS).                 typeHandler:            &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; jdbcType=&quot;&quot; typeHandler=&quot;&quot; delimitedColumnName=&quot;&quot;/&gt;        &lt;/table&gt;        --&gt;        &lt;!--其他表的简单配置--&gt;        &lt;table tableName=&quot;student&quot; domainObjectName=&quot;Student&quot;               enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;               enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;               selectByExampleQueryId=&quot;false&quot;&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p>resources目录结构：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190317190500.png"></p><hr><p>使用 Maven 插件运行：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190317190650.png" style="width:50%"></p><p>运行后的结果：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190317190809.png"></p><hr><h3 id="图像化方式"><a href="#图像化方式" class="headerlink" title="图像化方式"></a>图像化方式</h3><p>mybatis-generator-gui是基于mybatis generator开发一款界面工具, 本工具可以使你非常容易及快速生成Mybatis的Java POJO文件及数据库Mapping文件。</p><p>地址是：<a href="https://github.com/zouzg/mybatis-generator-gui" target="_blank" rel="noopener">https://github.com/zouzg/mybatis-generator-gui</a></p><p>要求：本工具由于使用了Java 8的众多特性，所以要求JDK 1.8.0.60以上版本，另外JDK 1.9暂时还不支持。</p><hr><h4 id="方式一下载软件"><a href="#方式一下载软件" class="headerlink" title="方式一下载软件"></a>方式一下载软件</h4><p>直接下载软件： <a href="http://tools.mingzhi.ink" target="_blank" rel="noopener">http://tools.mingzhi.ink</a></p><p>（1）下载完成后，直接运行该软件（前提，你的本机的java环境变量要配置为：JDK 1.8.0.60以上版本）。<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190317215847.png"></p><p>（2）点击保存后：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190317220231.png"></p><p>（3）点击代码生成：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190317220414.png"></p><h4 id="方式二下载源码启动"><a href="#方式二下载源码启动" class="headerlink" title="方式二下载源码启动"></a>方式二下载源码启动</h4><h5 id="两种方式下载源码"><a href="#两种方式下载源码" class="headerlink" title="两种方式下载源码"></a>两种方式下载源码</h5><ul><li><p>直接下载源码：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190318092300.png"></p></li><li><p>使用git工具：<code>git clone https://github.com/zouzg/mybatis-generator-gui</code></p></li></ul><h5 id="两种方式启动"><a href="#两种方式启动" class="headerlink" title="两种方式启动"></a>两种方式启动</h5><ul><li>直接进入下载好的源码目录</li></ul><p>直接下载的目录为：<code>mybatis-generator-gui-master</code> ，git后的目录为：<code>mybatis-generator-gui</code></p><p>(1)在根目录下，启动 <code>cmd</code></p><p>然后输入：<code>mvn jfx:jar</code><br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190318092931.png"></p><p>注意：你的本机要先安装好 maven，并配置好相关的环境变量。</p><p>输入命令后，会开始下载相关的jar包：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190318093145.png"></p><p>(2) 进入target/jfx/app/目录下</p><p>输入：<code>cd target/jfx/app/</code></p><p>然后输入：<code>java -jar mybatis-generator-gui.jar</code><br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190318093422.png"></p><p>回车后，就会弹出界面系统：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190318093506.png"></p><hr><ul><li>使用Eclipse或IDEA启动下载好的源代码</li></ul><p>要求，你的IDE配置的JDK必须大于：1.8.0.40。</p><p>在 com.zzg.mybatis.generator下，找到：<code>MainUI</code> 主类：</p><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190318093945.png"></p><p>运行主类即可：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190318094150.png"></p><hr><font color="red"><br><strong>注意事项</strong><br><br>(1) 本自动生成代码工具只适合生成单表的增删改查，对于需要做数据库联合查询的，请自行写新的XML与Mapper；<br><br>(2) 部分系统在中文输入方法时输入框中无法输入文字，请切换成英文输入法；<br><br>(3) 如果不明白对应字段或选项是什么意思的时候，把光标放在对应字段或Label上停留一会然后如果有解释会出现解释；<br><br></font><hr><p>还有一款图形化生成器：<a href="https://github.com/spawpaw/mybatis-generator-gui-extension" target="_blank" rel="noopener">https://github.com/spawpaw/mybatis-generator-gui-extension</a></p><p>大家可以自行尝试，运行。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中的动态SQL</title>
      <link href="/2019/03/16/mybatis-zhong-de-dong-tai-sql/"/>
      <url>/2019/03/16/mybatis-zhong-de-dong-tai-sql/</url>
      
        <content type="html"><![CDATA[<p>Mybatis的强大特性之一便是它的动态SQL。使用过JDBC或其他类似的框架的人都会知道，根据不同条件拼接SQL语句时不仅不能忘记必要的空格，还有注意省略掉列名列表最后的逗号，处理方式麻烦且凌乱。Mybatis的动态SQL则能帮我们摆脱这种痛苦。</p><p>在Mybatis 3 之前的版本中，使用动态SQL需要学习和了解非常多的标签，现在Mybatis采用功能强大的 OGNL 表达式语言消除了许多其他标签，以下是Mybatis的动态SQL在XML中支持的几种标签：</p><ul><li><p>if：判断语句，单条件分支判断</p></li><li><p>choose(when、otherwise)：相当于java中的switch语句，多条件分支判断</p></li><li><p>trim(where、set)：辅助元素，用于处理一些SQL拼装问题</p></li><li><p>foreach：循环语句，在in语句等列举条件中常用</p></li><li><p>bind：绑定元素，就像一个变量一样，提前定义，后面使用</p></li></ul><hr><h3 id="if用法"><a href="#if用法" class="headerlink" title="if用法"></a>if用法</h3><p>if元素是我们最常用的判断语句，相当于Java中的if语句，它常常与 <code>test</code> 属性联合使用。</p><p>if标签通常用于where语句中，通过判断参数值来决定是否使用某个查询条件，它也经常用于update语句中判断是否更新某一个字段，还可以在insert语句中用来判断是否插入某一个字段的值。</p><h4 id="在where条件中使用if"><a href="#在where条件中使用if" class="headerlink" title="在where条件中使用if"></a>在where条件中使用if</h4><p>假设，现在我们要根据 学生id 和 学生的姓名 来查询学生的信息：</p><pre><code>    &lt;select id=&quot;selectByStu&quot; resultType=&quot;student&quot;&gt;        select        s.id,        s.stu_name as &#39;stuName&#39; ,        s.stu_sex as &#39;stuSex&#39;,        s.stu_id as &#39;stuId&#39;        from student as s        where         s.id = #{id}        and         s.stu_name like concat(&#39;%&#39;,#{stuName},&#39;%&#39;)    &lt;/select&gt;</code></pre><p>当同时输入 <code>id</code> 和 <code>stuName</code> 这两个条件时，能查出正确的结果，但是当只提供id参数时，stuName默认是null，就会导致stuName = null 也成为查询条件，因此查不到正确的结果。这时可以使用 if标签 来解决这个问题。</p><pre><code>    &lt;select id=&quot;selectByStu&quot; resultType=&quot;student&quot;&gt;        select        s.id,        s.stu_name as &#39;stuName&#39; ,        s.stu_sex as &#39;stuSex&#39;,        s.stu_id as &#39;stuId&#39;        from student as s        where         1 = 1        &lt;if test=&quot;id != null&quot;&gt;        and s.id = #{id}        &lt;/if&gt;        &lt;if test=&quot;stuName != null and stuName != &#39;&#39;&quot;&gt;        and s.stu_name like concat(&#39;%&#39;,#{stuName},&#39;%&#39;)        &lt;/if&gt;    &lt;/select&gt;</code></pre><p>if标签有一个必填的属性：<code>test</code> ，test属性值是一个符合OGNL要求的表达式，表达式的结果可以是 true 或 false，除此之外所有的非0值都为 true，只有0为：false。为了方便理解，在表达式中，建议只有：true 或 false 作为结果。OGNL的详细用法，后面会提及到。</p><ul><li><p>判断条件 <code>property != null 或 property == null</code>：适用于任何类型的字段，用于判断属性值是否为空。</p></li><li><p>判断条件 <code>property != &#39;&#39; 或 property == &#39;&#39;</code>：仅适合于String类型的字段，用于判断是否为空字符串。</p></li><li><p>and 和 or：当有多个判断条件时，使用 and 或 or 进行连接，嵌套的判断可以使用小括号分组，and相当于java中的&amp;&amp;，or相当于||</p></li></ul><hr><p>上面的条件属性类型有的是String，对字符串的判断和Java中的判断类似，首先需要判断字段是否为 null，然后再去判断是否为空（在OGNL表达式中，这两个判断的顺序不会影响到结果，也不会有空指针异常）。</p><p>虽然上面可以完成需求，但是在XML中仍然需要注意两个地方：</p><ul><li>注意SQL中where关键字后面的条件</li></ul><p><code>where 1=1</code></p><p>由于两个条件都是动态的，所以如果没有 1=1 这个默认的条件，当两个if判断都不满足时，最后生成的SQL语句就会以 <code>where 结束</code>，这样不符合SQL语句规范，因此会报错。加上 1=1 这个条件，就可以避免SQL语句错误导致的异常。这种写法并不完美，后面我们会使用更好的方式来替代这个写法。</p><ul><li>注意条件中的 and（or）</li></ul><p><code>and id =#{id}</code></p><p>这里的 and（或 or）需要手动添加，当这部分条件拼接到 where 1=1 后面时任然是合法的SQL。因为有默认的 1 = 1 这个条件，我们不需要判断第一个动态条件是否需要加上 and（或 or），因为这种情况下 and（or）是必须有的。</p><hr><h4 id="在update更新列中使用if"><a href="#在update更新列中使用if" class="headerlink" title="在update更新列中使用if"></a>在update更新列中使用if</h4><p>现在，需要实现这样一个功能：只更新有变化的字段，需要注意的是，更新的时候不能将原来有值但没有发生变化的字段更新为 空 或 null。</p><pre><code>&lt;update id=&quot;updateByIdSelective&quot;&gt;    update student    set        &lt;if test=&quot;stuName !=null and stuName !=&#39;&#39;&quot;&gt;        stu_name = #{stuName},        &lt;/if&gt;        &lt;if test=&quot;stuSex !=null&quot;&gt;        stu_sex = #{stuSex},        &lt;/if&gt;        &lt;if test=&quot;stuNumber != null and stuNumber != &#39;&#39;&quot;&gt;        stu_number = #{stuNumber},        &lt;/if&gt;        id = #{id}    where    id = #{id}&lt;/update&gt;</code></pre><p>需要注意的两个点：</p><p>第一个是：每个if元素里面的SQL语句后面都有逗号</p><p>第二个是：where关键字前面的 id = #{id} 这个条件。</p><hr><ul><li>当全部条件都是 null 或者 空。</li></ul><p>如果有 id = #{id} 这个条件，最终的SQL语句：</p><p><code>update student set id = #{id} where id = #{id}</code></p><p>如果没有 id = #{id} 这个条件，最终的SQL语句：</p><p><code>update student set where id = #{id}</code></p><p>这个SQL很明显是错误的，set 关键字后面没有内容，直接是where关键字，不符合SQL语句规范。</p><ul><li>查询条件只有一个不是null也不是空（假设是stu_name）</li></ul><p>如果有 id =#{id}这个条件，最终的SQL语句：</p><p><code>update student set stu_name =#{stuName}, id = #{id} where id = #{id}</code></p><p>如果没有 id = #{id} 这个条件，最终的SQL语句：</p><p><code>update student set stu_name =#{stuName}, where id = #{id}</code></p><p>where关键字前面直接就是一个逗号，这个SQL语句也是错误的。</p><p>从上面两种情况来看，id = #{id} 这个条件可以最大限度保证方法不出错。除了使用这种方式外，还可以结合业务层的逻辑判断调整XML文件中的SQL来确保最终的SQL语句的正确性，也可以通过 where 和 set 标签来解决这个问题。</p><hr><h4 id="在insert动态插入列中使用if"><a href="#在insert动态插入列中使用if" class="headerlink" title="在insert动态插入列中使用if"></a>在insert动态插入列中使用if</h4><p>在数据库表中插入数据的时候，如果某一列的参数值不为空，就使用传入的值，如果传入参数为空，就使用数据库中的默认值（通常是空），而不使用传入的空值。使用if就可以实现这种动态插入列的功能。</p><pre><code>&lt;insert id =&quot;insertStu&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;    insert into student(    &lt;if test=&quot;stuName != null and stuName != &#39;&#39;&quot;&gt;    stu_name,    &lt;/if&gt;    stu_sex,    stu_number)    values(    &lt;if test=&quot;stuName != null and stuName != &#39;&#39;&quot;&gt;    #{stuName},    &lt;/if&gt;    #{stuSex},    #{stuNumber})&lt;/insert&gt;</code></pre><p>需要注意的是，若在列的部分增加了 if条件，则在values的部分也要增加相同的 if条件，必须保证上下可以互相对应，完全匹配。</p><hr><h3 id="choose用法"><a href="#choose用法" class="headerlink" title="choose用法"></a>choose用法</h3><p>上一节的 if标签 提供了基本的条件判断，但是它无法实现 if···else、if···else···的逻辑，要想实现这样的逻辑，就需要用到 choose when otherwise 标签。choose标签：包含 when 和 otherwise 两个标签，一个 choose中至少有一个when，有0个或者1个otherwise。在已知的student表中，除了主键id外，我们认为stu_name（学生名）也是唯一的，所有的用户名都不可以重复。</p><p>现在，进行如下查询：当参数 id 有值的时候，优先使用 id查询，当id没有值时就去判断用户名是否有值，如果有值就用用户名查询，如果用户名也没有值，就使用SQL查询无结果。</p><pre><code>&lt;select id=&quot;selectByStu&quot; resultType=&quot;student&quot;&gt;    select    s.id,    s.stu_name as &#39;stuName&#39; ,    s.stu_sex as &#39;stuSex&#39;,    s.stu_id as &#39;stuId&#39;    from student as s    where 1 = 1    &lt;choose&gt;      &lt;when test=&quot;id != null&quot;&gt;         and s.id = #{id}      &lt;/when&gt;      &lt;when test=&quot;stuName != null and stuName != &#39;&#39;&quot;&gt;         and s.stu_name like concat(&#39;%&#39;,#{stuName},&#39;%&#39;)      &lt;/when&gt;      &lt;otherwise&gt;         and 1 = 2      &lt;/otherwise&gt;    &lt;/choose&gt;&lt;/select&gt;</code></pre><p>使用choose when otherwise 的时候逻辑要严密，避免由于某些值出现问题导致SQL出错。</p><font color="red"><br>提示：上述查询中，如果没有 otherwise的话，所有用户都会查询出来，因为我们在对应的接口方法中使用了Student作为返回值，所以当实际查询结果是多个就会报错。<br></font><hr><h3 id="trim、where、set用法"><a href="#trim、where、set用法" class="headerlink" title="trim、where、set用法"></a>trim、where、set用法</h3><p>这个三个标签解决类似的问题，并且where 和 set 都属于 trim的一种具体用法。</p><h4 id="where用法"><a href="#where用法" class="headerlink" title="where用法"></a>where用法</h4><p>where标签的作用：如果该标签包含的元素中有返回值，就插入一个where；如果where后面的字符串是以 and 和 or 开头的，就将它们剔除。</p><pre><code>    &lt;select id=&quot;selectByStu&quot; resultType=&quot;student&quot;&gt;        select        s.id,        s.stu_name as &#39;stuName&#39; ,        s.stu_sex as &#39;stuSex&#39;,        s.stu_id as &#39;stuId&#39;        from student as s        &lt;where&gt;            &lt;if test=&quot;id != null&quot;&gt;              and s.id = #{id}           &lt;/if&gt;           &lt;if test=&quot;stuName != null and stuName != &#39;&#39;&quot;&gt;              and s.stu_name like concat(&#39;%&#39;,#{stuName},&#39;%&#39;)           &lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre><p>看到，我去掉了 1 = 1 这个条件，当 if条件都不满足的时候，where元素中没有内容，所以在SQL中不会出现 where；也就不存在 之前在 if动态用法中的问题。</p><p>如果 if条件满足，where元素的内容就是以：and 开头的条件，where会自动去掉开头的 and，这也保证了where条件正确。</p><h4 id="set用法"><a href="#set用法" class="headerlink" title="set用法"></a>set用法</h4><p>set标签的作用：如果该标签包含的元素中有返回值，就插入一个set；如果set后面的字符串是以逗号结尾的，就将这个逗号剔除。</p><pre><code>&lt;update id=&quot;updateByIdSelective&quot;&gt;    update student    &lt;set&gt;        &lt;if test=&quot;stuName !=null and stuName !=&#39;&#39;&quot;&gt;        stu_name = #{stuName},        &lt;/if&gt;        &lt;if test=&quot;stuSex !=null&quot;&gt;        stu_sex = #{stuSex},        &lt;/if&gt;        &lt;if test=&quot;stuNumber != null and stuNumber != &#39;&#39;&quot;&gt;        stu_number = #{stuNumber},        &lt;/if&gt;        id = #{id},    &lt;/set&gt;    where    id = #{id}&lt;/update&gt;</code></pre><p>在set标签的用法中，SQL后面的逗号没有问题了，但是如果set元素中没有内容，照样会出现SQL错误，所以为了避免错误产生，类似 id = #{id} 这样必然存在的赋值仍然有保留的必要。从这个点看，set标签并没有解决全部的问题，使用时仍然需要注意。</p><hr><h4 id="trim用法"><a href="#trim用法" class="headerlink" title="trim用法"></a>trim用法</h4><p>where 和 set 标签的功能都可以使用 trim 标签来实现，并且在底层就是通过 <code>TrimSqlNode</code>实现的。</p><p>where标签对应的 trim的实现如下：</p><pre><code>&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt;···&lt;/trim&gt;</code></pre><font color="red"><br>提示：这里的AND 和 OR后面的空格不能省略，为了避免匹配到 andes、orders等单词。<br><br>实际上prefixOverrides 包含 “AND”、”OR”、”AND\n”、”OR\n”、”AND\r”、”OR\r”、”AND\t”、”OR\t”，不仅仅是上面提到的两个带空格的前缀。<br></font><hr><p>set标签对应的trim实现如下：</p><pre><code>&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;···&lt;/trim&gt;</code></pre><hr><p>trim标签有如下属性：</p><ul><li><p>prefix：当trim元素内包含内容时，会给内容增加prefix指定的前缀。</p></li><li><p>prefixOverrs：当trim元素内包含内容时，会把内容中匹配的前缀字符串去掉。</p></li><li><p>suffix：当trim元素内包含内容时，会给内容增加suffix指定的后缀。</p></li><li><p>suffixOverrs：当trim元素内包含内容时，会把内容中匹配的后缀字符串去掉。</p></li></ul><hr><h3 id="foreach用法"><a href="#foreach用法" class="headerlink" title="foreach用法"></a>foreach用法</h3><p>SQL语句中有时会使用 <code>IN</code> 关键字，例如 id in（1,2,3）。可以使用 <code>${ids}</code> 方式直接获取值，但这种写法不能防止SQL注入，想避免SQL注入就需要要 <code>#{}</code>的方式，这时就要配合使用 <code>foreach</code> 标签来满足需求。</p><p>foreach 可以对数组、Map或实现了 Iterable接口（如 List、Set）的对象进行遍历。数组在处理时会转换为List对象，因此foreach遍历的对象可以分为两大类：<code>Iterable类型</code> 和 <code>Map类型</code>。</p><hr><h4 id="foreach实现-in-集合"><a href="#foreach实现-in-集合" class="headerlink" title="foreach实现 in 集合"></a>foreach实现 in 集合</h4><p>foreach实现 in 集合（或数组）是最简单和最常用的一种情况，下面介绍如何根据传入的学生id集合查询出所有的学生。</p><pre><code>List&lt;Student&gt; selectByIdList(List&lt;Long&gt; idList);</code></pre><pre><code>&lt;select id=&quot;selectByStu&quot; resultType=&quot;student&quot;&gt;    select    s.id,    s.stu_name as &#39;stuName&#39; ,    s.stu_sex as &#39;stuSex&#39;,    s.stu_id as &#39;stuId&#39;    from student as s    where     id in    &lt;foreach collection=&quot;list&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; item=&quot;id&quot; index=&quot;i&quot;&gt;    #{id}    &lt;/foreach&gt;&lt;/select&gt;</code></pre><p>foreach 包含以下属性：</p><ul><li><p>collection：必填，值为要迭代循环的属性名，这个属性值的情况很多。</p></li><li><p>item：变量名，值为从迭代对象中取出的每一个值。</p></li><li><p>index：索引的属性名，在集合数组情况下，值为当前索引的值，当迭代循环对象是Map类型时，这个值为Map的 Key（键值）。</p></li><li><p>open：整个循环内容开头的字符串</p></li><li><p>close：整个循环内容结尾的字符串</p></li><li><p>separator：每次循环的分隔符</p></li></ul><hr><p>collection的属性要如何设置呢？来看一下Mybatis是如何处理这种类型的参数的。</p><p>（1）只有一个数组参数或集合参数</p><p>以下代码是 DefaultSqlSession中的方法，也是默认情况下的处理逻辑：</p><pre><code>  private Object wrapCollection(final Object object) {    if (object instanceof Collection) {      StrictMap&lt;Object&gt; map = new StrictMap&lt;Object&gt;();      map.put(&quot;collection&quot;, object);      if (object instanceof List) {        map.put(&quot;list&quot;, object);      }      return map;    } else if (object != null &amp;&amp; object.getClass().isArray()) {      StrictMap&lt;Object&gt; map = new StrictMap&lt;Object&gt;();      map.put(&quot;array&quot;, object);      return map;    }    return object;  }</code></pre><p>当参数类型为集合的时候，默认会转换为Map类型，并添加一个key为 “collection” 的值，如果参数类型是List集合，那么会继续添加一个key为 “list”的值，这样，当collection = “list” 时，就能得到这个集合，并对它进行循环操作。</p><p>当参数类型为数组的时候，也会转换为Map类型，默认的key为 “array”。当采用如下方法使用数组时，就需要把foreach标签中的collection属性值设置为：array。</p><pre><code>List&lt;Student&gt; selectByIdList(Long[] idArray);</code></pre><p>（2）有多个参数</p><p>之前的博客讲过，当有多个参数的时候，要使用<code>@param注解</code>给每个参数指定一个名字，否则在SQL中使用参数时就会不方便，因此将collection设置为<code>@param注解</code>指定的名字即可。</p><p>（3）参数是Map类型</p><p>使用Map和使用@param注解方式类似，将collection指定为对应的Map中的key即可。如果要循环所传入的Map，推荐使用@param注解指定名字，此时可将collection设置为指定的名字，如果不想指定名字，就使用默认值<code>_parameter</code>。</p><p>（4）参数是一个对象</p><p>这个情况下指定为对象的属性名即可。当使用对象内多层嵌套的对象时，使用 <code>属性.属性（集合和数组可以使用下标）</code>的方式可以指定深层的属性值。</p><hr><h4 id="foreach实现批量插入"><a href="#foreach实现批量插入" class="headerlink" title="foreach实现批量插入"></a>foreach实现批量插入</h4><p>如果数据库支持批量插入，就可以通过foreach来实现。批量插入是SQL-92新增的特性，目前支持的数据库有DB2、SQL Server2008及以上版本、PostgreSQL8.2及以上版本、MySQL、SQLite3.7.11及以上版本、H2。批量插入的语法如下：</p><pre><code>INSERT INTO tablename (column-a,[column-b,···])VALUES (&#39;value-1a&#39;,[&#39;value-1b&#39;,···]),       (&#39;value-2a&#39;,[&#39;value-2b&#39;,···]),       ···</code></pre><p>从待处理部分可以看出，后面是一个值的循环，因此可以通过foreach实现循环插入。</p><pre><code>int insertList(List&lt;Student&gt; userList);&lt;insert id =&quot;insertList&quot;&gt;    insert into student(       stu_name,stu_sex,stu_number)    values    &lt;foreach collection=&quot;list&quot; item=&quot;stu&quot; separator=&quot;,&quot;&gt;      (        #{stu.stuName},#{stu.stuSex},#{stu.stuNumber}      )    &lt;/foreach&gt;&lt;/insert&gt;</code></pre><font color="red"><br>注意：通过item指定了循环变量名后，在引用值的时候使用的是 “属性.属性” 的方式，如：stu.stuName。<br></font><p>从Mybatis 3.3.1版本开始，Mybatis开始支持批量新增回写主键值的功能，这个功能首先要求数据库主键值为自增类型，同时还要求该数据库提供的JDBC驱动可以支持返回批量插入的主键值（JDBC提供了接口，但并不是所有数据库都完美实现了该接口），因此到目前为止，<font color="red"><strong>可以完美支持该功能的仅有MySQL数据库。</strong></font></p><p>如果要在MySQL中实现批量插入返回自增主键值，只需要在原来代码基础上进行如下修改：</p><pre><code>&lt;insert id =&quot;insertList&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</code></pre><p>和单表一样，此处增加了 useGeneratedKeys 和 keyProperty 两个属性。</p><hr><h4 id="foreach实现动态update"><a href="#foreach实现动态update" class="headerlink" title="foreach实现动态update"></a>foreach实现动态update</h4><pre><code>&lt;update id=&quot;updateByMap&quot;&gt;    update student      set      &lt;foreach collection=&quot;_parameter&quot; index=&quot;key&quot; item=&quot;val&quot; separator=&quot;,&quot;&gt;        ${key} = #{val}      &lt;/foreach&gt;      where id = #{id}&lt;/update&gt;</code></pre><p>这里的Key作为列名，对应的值作为该列的值，通过foreach将需要更新的字段拼接在SQL语句中。</p><pre><code>int updateByMap(Map&lt;String,Object&gt; map);</code></pre><p>这里没有通过@param注解指定参数名，因而Mybatis在内部的上下文中使用了默认 <code>_parameter</code>作为该参数的key，所以在XML中也使用了<code>_parameter</code>。</p><hr><h3 id="bind用法"><a href="#bind用法" class="headerlink" title="bind用法"></a>bind用法</h3><p>bind元素的作用是通过OGNL表达式去自定义一个上下文变量，这样更方便我们使用。在我们进行模糊查询的时候，如果是MySQL数据库，我们常常用到的是一个concat用”%” 和 参数相连接。然而在Oracle数据库则是用连接符合 “||”，这样SQL就需要提供两种形式去实现了。但是有了bind元素，我们就完全不必使用数据库的语言，只要使用Mybatis的语言即可与所需参数相连。</p><p>比如我们要按角色名称进行模糊查询，我们可以把映射文件写成如下：</p><pre><code>&lt;select id=&quot;findStudent&quot; resultTpe=&quot;student&quot;&gt;    &lt;bind name=&quot;pattern&quot; value=&quot;&#39;%&#39; + stuName + &#39;%&#39;&quot; /&gt;    select id , stu_name, stu_sex, stu_number    from student    where id =#{id} and stu_name like #{pattern}&lt;/select&gt;</code></pre><p>这里的 <code>stuName</code> 代表的就是传递进来的参数，它和通配符连接后，赋给了pattern，我们就可以在select语句中使用这个变量进行模糊查询了，不管是MySQL数据库还是Oracle数据库都可以使用这样的语句，提高了其可移植性。</p><hr><p>我们传递的参数往往不止一个，我们可以传递多个参数。</p><pre><code>public List&lt;Student&gt; findStu(@Param(&quot;stuName&quot;) String stuName,@Param(&quot;note&quot;) String note);&lt;select id=&quot;findStudent&quot; resultTpe=&quot;student&quot;&gt;    &lt;bind name=&quot;stuNameLike&quot; value=&quot;&#39;%&#39; + stuName + &#39;%&#39;&quot; /&gt;    &lt;bind name=&quot;noteLike&quot; value=&quot;&#39;%&#39; + note + &#39;%&#39;&quot; /&gt;    select id , stu_name, stu_sex, stu_number,note    from student    where id =#{id} and stu_name like #{stuNameLike} and note like #{noteLike}&lt;/select&gt;</code></pre><h3 id="OGNL用法"><a href="#OGNL用法" class="headerlink" title="OGNL用法"></a>OGNL用法</h3><p>在Mybatis的动态SQL和 ${} 形式的参数中都用到了OGNL表达式，所以我们有必要了解一下OGNL的简单用法。</p><p>（1）e1 <code>or</code> e2</p><p>（2）e1 <code>and</code> e2</p><p>（3）e1 <code>==</code> e2 或 e1 <code>eq</code> e2</p><p>（4）e1 <code>!=</code> e2 或 e1 <code>neq</code> e2</p><p>（5）e1 <code>lt</code> e2：小于</p><p>（6）e1 <code>lte</code> e2：小于等于，其他表示为：<code>gt</code>（大于）、<code>gte</code>（大于等于）</p><p>（7）e1 + e2、e1 * e2、e1/e2、e1-e2、e1%e2</p><p>（8）!e 或 not e：非，取反</p><p>（9）e.method(args)：调用方法</p><p>（10）e.property：对象属性值</p><p>（11）e1[e2]：按索引取值（List、数组和Map）</p><p>（12）@class@method(args)：调用类的静态方法</p><p>（13）@class@field：调用类的静态字段值</p><hr><p>Mybatis使用XML时，不可避免会使用到一些对XML来说是特殊的字符，比如：&lt;：小于号，当你使用时，在XML中它也标签的符合，所以为了区别，该怎么解决呢？</p><p>方法一：</p><p>使用转义字符</p><pre><code>&lt;：&amp;lt;&gt;: &amp;gt;&amp;：&amp;amp;&#39;(单引号）：&amp;apos;&quot;(双引号)：&amp;quot;</code></pre><hr><p>方法二：</p><p>使用 CDATA 部件</p><pre><code>   &lt;![CDATA[···]]&gt;其中的：···部分，使用特殊符号时，不起作用。</code></pre>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中的缓存</title>
      <link href="/2019/03/15/mybatis-zhong-de-huan-cun/"/>
      <url>/2019/03/15/mybatis-zhong-de-huan-cun/</url>
      
        <content type="html"><![CDATA[<p>使用缓存可以使应用更快地获取数据，避免频繁的与数据库交互 ，尤其是在查询越多 、缓存命中率越高的情况下，使用缓存的作用就越明显。MyBatis 作为持久化框架提供了非常强大的查询缓存特性，可以非常方便地配置和定制使用。</p><p>一般提到Mybatis的缓存都是指二级缓存。一级缓存（也叫本地缓存）默认会启动，并且不能控制，因此很少会提到。首先，我会简单的介绍一下Mybatis的一级缓存，了解Mybatis的一级缓存可以避免产生一些难以发现的错误。其次，我会全面介绍Mybatis的二级缓存，包括二级缓存的基本配置用法，还有一些常用的缓存框架和缓存数据库的结合。</p><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><h4 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h4><p>我们来看一个简单的例子：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSelectStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        SqlSession sqlSession <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StudentMapper studentMapper <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>StudentMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Student student <span class="token operator">=</span> studentMapper<span class="token punctuation">.</span><span class="token function">findStudentById</span><span class="token punctuation">(</span>1L<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用同一个SqlSession再执行一次同样的方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Student student2 <span class="token operator">=</span> studentMapper<span class="token punctuation">.</span><span class="token function">findStudentById</span><span class="token punctuation">(</span>1L<span class="token punctuation">)</span><span class="token punctuation">;</span>        sqlSession<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//开启一个新的SqlSession</span>        SqlSession sqlSession2 <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StudentMapper studentMapper2 <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>StudentMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开启一个新的SqlSession再执行一次："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Student student3 <span class="token operator">=</span> studentMapper<span class="token punctuation">.</span><span class="token function">findStudentById</span><span class="token punctuation">(</span>1L<span class="token punctuation">)</span><span class="token punctuation">;</span>        sqlSession2<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//不要忘记关闭SqlSession</span>            sqlSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sqlSession2<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>注意：这里要调用：sqlSession.commit()，才会启动缓存。</p><p>运行结果如下：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190315154304.png"></p><p>发现，Mybatis的一级缓存存在于：<font color="red">SqlSession的生命周期中</font>，在同一个SqlSession中查询时，Mybatis会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个Map对象中。如果同一个SqlSession中执行的方法和参数完全一致，那么通过算法会生成相同的键值，当Map缓存对象中已经存在了该键值时，则会返回缓存中的对象。</p><hr><h4 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h4><p>再看一个例子：</p><pre><code>    public void testSelectStudent() {        SqlSession sqlSession = sqlSessionFactory.openSession();        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);        Student student = studentMapper.findStudentById(1L);        System.out.println(student);        //修改student中的Name属性        student.setStuName(&quot;dj&quot;);        System.out.println(&quot;使用同一个SqlSession再执行一次同样的方法&quot;);        Student student2 = studentMapper.findStudentById(1L);        System.out.println(student2);        sqlSession.commit();        //开启一个新的SqlSession        SqlSession sqlSession2 = sqlSessionFactory.openSession();        StudentMapper studentMapper2 = sqlSession.getMapper(StudentMapper.class);        System.out.println(&quot;开启一个新的SqlSession再执行一次：&quot;);        Student student3 = studentMapper.findStudentById(1L);        System.out.println(student3);        sqlSession2.commit();        try {        } finally {            //不要忘记关闭SqlSession            sqlSession.close();            sqlSession2.close();        }    }</code></pre><p>运行结果：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190315155617.png"></p><p>我们可以看到的是，当我获取 <code>id=1</code> 的 student学生后，修改它的姓名，然后再次调用同样的方法，获取 <code>id=1</code> 的学生，它的姓名也跟着发生了改变。说明此时，student2 和 student 是同一个对象，都是从缓存中获取的，所以会发生上面的问题。开启一个新的SqlSession后，获取 <code>id=1</code> 的学生，又会从数据库中重新获取了。</p><hr><p>如果不想让该方法使用一级缓存的话，可以添加：<code>flushCache=true</code> ，表示，每次调用该方法，都会重新发送SQL语句，从数据库中获取最新的数据。</p><pre><code>    &lt;select id=&quot;findStudentById&quot;  flushCache=&quot;true&quot; resultMap=&quot;studentMap&quot;&gt;         select * from student where id = #{id}     &lt;/select&gt;</code></pre><p><code>flushCache=true</code> ，这个属性配置为：true后，会在查询数据前清空当前的一级缓存，因此该方法每次都会重新从数据库中查询数据，此时的student和student2就会变成两个不同的实例，可以避免上面的问题。</p><p>但是由于这个方法清空了一级缓存，<strong><code>会影响到当前SqlSession中所有的缓存的查询</code></strong>，因此在需要反复查询获取只读数据的情况下，会增加数据库的查询次数，所以要避免这么使用。</p><font color="red">注意：调用 flushCache=true 的方法后，一级缓存会被清空，即之前的所有方法的调用缓存都会被清空，不仅仅是指：flushCache=true 的方法</font><hr><h4 id="第三个例子"><a href="#第三个例子" class="headerlink" title="第三个例子"></a>第三个例子</h4><pre><code>    public void testSelectStudent() {        SqlSession sqlSession = sqlSessionFactory.openSession();        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);        System.out.println(&quot;第一次调用&quot;);        Student student = studentMapper.findStudentById(1L);        System.out.println(&quot;第二次调用&quot;);        Student student2 = studentMapper.findStudentById(1L);        System.out.println(&quot;两个对象是否相等：&quot; + (student == student2));        sqlSession.commit();        System.out.println(&quot;====================================&quot;);        //开启一个新的SqlSession        SqlSession sqlSession2 = sqlSessionFactory.openSession();        StudentMapper studentMapper2 = sqlSession.getMapper(StudentMapper.class);        System.out.println(&quot;开启一个新的SqlSession再执行一次：&quot;);        Student student3 = studentMapper.findStudentById(1L);        //执行删除操作        studentMapper2.deleteById(3L);        System.out.println(&quot;执行删除操作后，再调用一次&quot;);        Student student4 = studentMapper.findStudentById(1L);        sqlSession2.commit();        try {        } finally {            //不要忘记关闭SqlSession            sqlSession.close();            sqlSession2.close();        }    }</code></pre><p>前提：删除 findStudentById 方法：<code>flushCache=true</code>。</p><p>执行之后的结果如下：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190315162557.png"></p><p>发现，在同一个SqlSession的情况下，只要执行了：insert、update、delete操作，都会清空一级缓存，所以查询 student4 时由于缓存不存在，就会再次发送SQL语句去执行数据库的查询操作。</p><hr><p>以上就是Mybatis中的一级缓存的各种情况了，由于一级缓存是在默默地工作，因此要避免在使用的过程中由于不了解而发生察觉不到的错误。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>Mybatis的二级缓存非常强大，它不同于一级缓存只存在于SqlSession的生命周期中，而是可以理解为存在于：SqlSessionFactory的生命周期中。虽然目前还没有接触过同时存在多个SqlSessionFactory的情况，但可以知道，当存在多个SqlSessionFactory时，它们的缓存都是绑定在各自对象上的，缓存数据在一般情况下是不相通的。只有在使用如Redis这样的缓存数据库时，才可以共享缓存。</p><h4 id="配置二级缓存"><a href="#配置二级缓存" class="headerlink" title="配置二级缓存"></a>配置二级缓存</h4><p>在Mybatis的全局配置settings中有一个参数为：<code>cacheEnabled</code>，这个参数是二级缓存的全局开关。默认值是：true，所以不必配置，如果想要配置，可以在：mybatis-config.xml中添加：</p><pre><code>    &lt;settings&gt;        &lt;!--其他setting配置--&gt;        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;    &lt;/settings&gt;</code></pre><p>二级缓存是和命名空间绑定的，即二级缓存需要配置在<code>Mapper.xml</code>映射文件中，或者配置在Mapper.java接口中。在映射文件中，命名空间就是XML根节点mapper的namespace属性。在Mapper接口中，命名空间就是接口的全限定名。</p><h5 id="Mapper-xml中配置二级缓存"><a href="#Mapper-xml中配置二级缓存" class="headerlink" title="Mapper.xml中配置二级缓存"></a>Mapper.xml中配置二级缓存</h5><p>在保证二级缓存的全局配置开启的情况下，给 <code>StudentMapper.xml</code> 开启二级缓存只需要添加：<code>&lt;cache/&gt;</code> 标签即可：</p><pre><code>&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentMapper&quot;&gt;    &lt;cache/&gt;    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot;/&gt;    &lt;/resultMap&gt;    &lt;!--其他配置--&gt;&lt;/mapper&gt;</code></pre><p>默认的二级缓存会有如下效果：</p><ul><li><p>映射语句文件中的所有select语句将会被缓存。</p></li><li><p>映射语句文件中的所有insert、update、delete语句会刷新缓存。</p></li><li><p>缓存会使用 LRU（最近最少使用）算法来回收。</p></li><li><p>根据时间表，比如 No Flush Interval（没有刷新间隔），缓存不会以任何时间顺序来刷新。</p></li><li><p>缓存会存储集合或对象的1024个引用</p></li><li><p>缓存会被视为 read/write（可读/可写）的，意味着对象检索不是共享的，而且可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</p></li></ul><hr><p>所有的这些属性都可以通过缓存元素的属性来修改：</p><pre><code>    &lt;cache        eviction=&quot;FIFO&quot;        flushInterval=&quot;60000&quot;        size=&quot;512&quot;        readOnly=&quot;true&quot;/&gt;</code></pre><p>这个更高级的配置，创建了一个FIFO缓存，并每隔60秒刷新一次，存储集合或对象的512个引用，而且返回的对象被认为是只读的，因此在不同线程中的调用者之间修改它们会导致冲突。</p><p>cache可以配置的属性如下：</p><ul><li>eviction（回收策略）</li></ul><p>（1）LRU（最近最少使用）：移除最长时间不被使用的对象，这是默认值。</p><p>（2）FIFO（先进先出）：按对象进入缓存的顺序来移除它们。</p><p>（3）SOFT（软引用）：移除基于垃圾回收器状态和软引用规则的对象。</p><p>（4）WEAK（弱引用）：更积极地移除基于垃圾回收器状态和弱引用规则的对象。</p><ul><li><p>flushInterval（刷新间隔）：可以被设置为任意的正整数，而且它们代表一个合理的毫秒形式的时间段。默认情况不设置，即没有刷新间隔，缓存仅仅在调用语句时刷新。</p></li><li><p>size（引用数目）：可以被设置为任意的正整数，要记住缓存的对象数目和运行环境的可用内存资源数目。默认值是：1024.</p></li><li><p>readOnly（只读）：属性可以被设置为：true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，这提供了很重要的性能优势。默认值是：false，允许修改。</p></li></ul><h5 id="Mapper接口中设置二级缓存"><a href="#Mapper接口中设置二级缓存" class="headerlink" title="Mapper接口中设置二级缓存"></a>Mapper接口中设置二级缓存</h5><p>在使用注解方式时，如果想对注解方法启用二级缓存，还需要在Mapper接口中进行配置，如果Mapper接口也存在对应的XML映射文件，两者同时开启缓存时，还需要特殊配置。</p><p>(1)当只使用注解方式配置二级缓存时，如果在 <code>StudentMapper</code>接口中，则需要增加如下配置。</p><pre><code>@CacheNamespacepublic interface StudentMapper {    //接口方法}</code></pre><p>只需增加该注解即可，该注解还可以配置各项属性：</p><pre><code>@CacheNamespace(        eviction = FifoCache.class,        flushInterval = 600000,        size = 512,        readWrite = true)public interface StudentMapper {    //接口方法}</code></pre><hr><p>(2)当同时使用注解方式和XML映射文件时，如果同时配置了上述的二级缓存，就会抛出如下异常：</p><pre><code>Caches collection already contains value for com.liuzhuo.mapper.StudentMapper</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190315171320.png"></p><p>这是因为Mapper接口和对应的XML文件是相同的命名空间，想使用二级缓存，两者必须同时配置（如果接口不存在使用注解方式的方法，可以只在XML中配置），因此按照上面的方式进行配置就会出错，这个时候应该使用参数缓存。在Mapper接口中，参照缓存配置如下：</p><pre><code>@CacheNamespaceRef(StudentMapper.class)public interface StudentMapper {}</code></pre><p>注意使用的注解是：<code>@CacheNamespaceRef</code> 多了Ref的后缀！！！</p><p>因为想让StudentMapper接口中的注解方法和XML中的方法使用相同的缓存，因此使用参数缓存配置 StudentMapper.class，这样就会使用命名空间 com.liuzhuo.mapper.StudentMapper的缓存配置，即：StudentMapper.xml中配置的缓存。</p><p>Mapper接口可以通过注解引用XML映射文件或者其他接口的缓存，在XML中也可以配置参数缓存，如在 StudentMapper.xml中：</p><pre><code>&lt;cache-ref namespace=&quot;com.liuzhuo.mapper.StudentMapper&quot;/&gt;</code></pre><p>这样配置后，XML就会引用Mapper接口中配置的二级缓存，同样可以避免同时配置二级缓存导致的冲突。</p><hr><p>Mybatis中很少会同时使用Mapper接口注解方式和XML映射文件，所以参照缓存并不是为了解决这个问题而设计的。参照缓存除了能够通过引用其他缓存减少配置外，主要的作用是解决脏读。</p><p>为了保持后续测试一致，对 StudentMapper 接口和XML映射文件进行如下配置。</p><pre><code>@CacheNamespaceRef(StudentMapper.class)public interface StudentMapper {}&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentMapper&quot;&gt;    &lt;cache        eviction=&quot;FIFO&quot;        flushInterval=&quot;60000&quot;        size=&quot;512&quot;        readOnly=&quot;false&quot;/&gt;&lt;/mapper&gt;</code></pre><hr><h4 id="使用二级缓存"><a href="#使用二级缓存" class="headerlink" title="使用二级缓存"></a>使用二级缓存</h4><p>上面讲到了二级缓存的配置，现在开始讲解二级缓存的使用，当调用 StudentMapper的所有select查询方法时，二级缓存就已经开始起作用了。需要注意的是，由于配置的是可读写的缓存，而Mybatis使用 <code>SerializedCache</code> 序列化缓存来实现可读写缓存类，并通过序列化和反序列化来保证通过缓存获取数据时，得到的是一个新的实例。因此，如果配置为只读缓存时，Mybatis就会使用Map来存储缓存值，这种情况下，从缓存中获取的对象就是同一个实例。</p><p>因为使用可读写缓存，可以使用  <code>SerializedCache</code> 序列化缓存。这个缓存类要求所有被序列化的对象必须实现 <code>Serializable</code> 接口，所以还需要修改Student对象。</p><pre><code>public class Student implements Serializable {    private static final long serializableUID = 7483479274923474792L;    //其他属性和set、get方法}</code></pre><hr><p>编写测试方法：</p><pre><code>    public void testSelectStudent() {        SqlSession sqlSession = sqlSessionFactory.openSession();        Student student = null;        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            System.out.println(&quot;第一次调用&quot;);            student = studentMapper.findStudentById(1L);            System.out.println(student);            student.setStuName(&quot;dj&quot;);            System.out.println(&quot;第二次调用&quot;);            Student student2 = studentMapper.findStudentById(1L);            System.out.println(student2);            System.out.println(&quot;两个对象是否相等：&quot; + (student == student2));        } finally {            sqlSession.close();        }        System.out.println(&quot;开启新的Sqlsession~~~~&quot;);        //开启一个新的SqlSession        sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper2 = sqlSession.getMapper(StudentMapper.class);            System.out.println(&quot;开启一个新的SqlSession后，执行第一次：&quot;);            Student student3 = studentMapper2.findStudentById(1L);            System.out.println(student3);            System.out.println(&quot;开启一个新的SqlSession后，执行第二次：&quot;);            Student student4 = studentMapper2.findStudentById(1L);            System.out.println(student4);            System.out.println(&quot;两个对象是否相等：&quot; + (student3 == student4));            sqlSession.commit();        } finally {            //不要忘记关闭SqlSession            sqlSession.close();        }    }</code></pre><p>运行结果：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190315180036.png"></p><p>日志中：出现的以：<code>Cache Hit Ratio</code> 开头的语句，这行语句后面输出的值为当前执行方法的缓存命中率（二级缓存的，不包括一级缓存）。</p><p>在测试第一部分中，第一次查询student时由于没有缓存，所以执行了数据库查询，在第二次查询获取student2时，student和student2是完全相同的实例，这里是使用了一级缓存，所以返回的是同一个实例，此时的命中率还是：0。</p><p>当调用SqlSession.close（）后，SqlSession才会保存查询数据到二级缓存中。在这之后二级缓存才有了缓存数据。所以可以看到在第一部分的两次查询时，命中率都是：0。</p><p>在第二部分测试代码中，再次获取student3对象时，日志中并没有输出数据库查询，而是输出了命中率，这时的命中率是：0.33333333333。这是第三次查询，并且得到了二级缓存中的数据，因此该方法一共被请求了3次，有一次命中，所以命中率就是三分之。后面再获取student4时，就是4次请求，2次命中，命中率为：0.5。并且因为是读写缓存的缘故，student3 和student4 都是反序列化得到的结果，所以它们不是相同的实例。在这一部分，这两个实例是读写安全的，其属性不会互相影响。</p><hr><font color="red"><strong>提示：</strong></font><p>在这个例子中并没有实现真正的读写安全，为啥？</p><p>因为这个测试中加入了一段不该有的代码，即：<code>student.setStuName(&quot;dj&quot;);</code> 这里修改了：student的属性后，按照常理应该更新数据到数据库中，更新后会清空一级、二级缓存，这样第二部分代码中就不出现查询结果的 stuName 都是 <code>&#39;dj&#39;</code> 的情况了。所以想要安全使用，需要避免毫无意义的修改，这样可以避免人为产生的脏数据，避免缓存和数据库的数据不一致的情况。</p><hr><p>Mybatis默认提供的缓存实现都是基于Map实现的内存缓存，已经可以满足基本的应用。但是当需要缓存大量的数据时，不能仅仅通过提高内存来使用Mybatis的二级缓存，还可以选择一些类似 <code>EhCache</code>的缓存框架或 <code>Redis</code>缓存数据库等工具来保存Mybatis的二级缓存数据。</p><hr><h3 id="集成EhCache缓存"><a href="#集成EhCache缓存" class="headerlink" title="集成EhCache缓存"></a>集成EhCache缓存</h3><p>EhCache是一个纯粹的Java进程内的缓存框架，具有快速、精干等特点。具体来说，EhCache主要的特性如下。</p><ul><li><p>快速</p></li><li><p>简单</p></li><li><p>多种缓存策略</p></li><li><p>缓存数据有内存和磁盘两级，无须担心容量问题</p></li><li><p>缓存数据会在虚拟机重启的过程中写入磁盘</p></li><li><p>可以通过RMI、可插入API等方式进行分布式缓存</p></li><li><p>具体缓存和缓存管理器的侦听接口</p></li></ul><p>因为以上诸多优点，Mybatis项目开发者最早提供了EhCache的Mybatis二级缓存实现，该项目名为 <code>ehcache-cache</code></p><p>地址是：<a href="https://github.com/mybatis/ehcache-cache" target="_blank" rel="noopener">https://github.com/mybatis/ehcache-cache</a></p><hr><p>（1）添加项目依赖</p><p>在pom.xml中添加如下的依赖：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>（2）配置EhCache</p><p>在 src/main/resources 目录下新增 <code>ehcache.xml</code>文件。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt;    &lt;!-- 磁盘缓存位置 --&gt;    &lt;diskStore path=&quot;E:\DEV_ENV\ehcache&quot;/&gt;    &lt;!-- 默认缓存 --&gt;    &lt;defaultCache            maxEntriesLocalHeap=&quot;10000&quot;            eternal=&quot;false&quot;            copyOnRead=&quot;true&quot;            copyOnWrite=&quot;true&quot;            timeToIdleSeconds=&quot;120&quot;            timeToLiveSeconds=&quot;120&quot;            maxEntriesLocalDisk=&quot;10000000&quot;            diskExpiryThreadIntervalSeconds=&quot;120&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;        &lt;persistence strategy=&quot;localTempSwap&quot;/&gt;    &lt;/defaultCache&gt;&lt;/ehcache&gt;</code></pre><p>有关EhCache的详细配置可以参考地址：<a href="http://www.ehcache.org/ehcache.xml" target="_blank" rel="noopener">http://www.ehcache.org/ehcache.xml</a></p><p>在上面的配置中重点要看两个属性，<code>copyOnRead</code> 和 <code>copyOnWrite</code> 属性。这两个属性的配置会对后面使用二级缓存产生很大影响。</p><p><code>copyOnRead的含义：</code> 判断从缓存中读取数据时是返回对象的引用还是复制一个对象返回。默认情况下是false，即返回数据的引用，这种情况下返回的都是相同的对象，和Mybatis默认缓存中的只读对象是相同的。如果设置为：true，那就是可读写缓存，每次读取缓存时都会复制一个新的实例。</p><p><code>copyOnWrite的含义：</code> 判断写入缓存时是直接缓存对象的引用还是复制一个对象，然后缓存，默认也是false。如果想使用可读写缓存，就需要将这两个属性配置为true，如果使用只读缓存，可以不配置这两个属性，使用默认值false即可。</p><hr><p>（3）修改StudentMapper.xml中的缓存配置</p><p>ehcache-cache提供了如下2个可选的缓存实现。</p><ul><li><p>org.mybatis.caches.ehcache.EhcacheCache</p></li><li><p>org.mybatis.caches.ehcache.LoggingEhcache</p></li></ul><p>这两个缓存中，第二个是带日志的缓存，由于Mybatis初始化缓存时，如果Cache不是继承自LoggingEhcache(org.mybatis.caches.ehcache.LoggingEhcache)，Mybatis便会使用Logging Ehcache 装饰代理缓存，所以上面两个缓存使用时并没有区别，都会输出缓存命中率的日志。</p><p>修改 StudentMapper.xml 中的配置：</p><pre><code>&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentMapper&quot;&gt;    &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;    &lt;!--其他配置--&gt;&lt;/mapper&gt;</code></pre><p>只通过设置type属性就可以使用EhCache缓存了，这时cache的其他属性都不会起到任何作用，针对缓存的配置都在ehcache.xml中进行。在ehcache.xml配置文件中，只有一个默认的缓存配置，所以配置使用EhCache缓存的Mapper映射文件都会有一个以映射文件命名空间命名的缓存。如果想针对某一个命名空间进行配置，需要在ehcache.xml中添加一个和映射文件命名空间一致的缓存配置，例如针对：StudentMapper，可以进行如下配置：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt;    &lt;!-- 磁盘缓存位置 --&gt;    &lt;diskStore path=&quot;E:\DEV_ENV\ehcache&quot;/&gt;    &lt;!-- 默认缓存 --&gt;    &lt;defaultCache            maxEntriesLocalHeap=&quot;10000&quot;            eternal=&quot;false&quot;            copyOnRead=&quot;true&quot;            copyOnWrite=&quot;true&quot;            timeToIdleSeconds=&quot;120&quot;            timeToLiveSeconds=&quot;120&quot;            maxEntriesLocalDisk=&quot;10000000&quot;            diskExpiryThreadIntervalSeconds=&quot;120&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;        &lt;persistence strategy=&quot;localTempSwap&quot;/&gt;    &lt;/defaultCache&gt;    &lt;!-- StudentMapper缓存 --&gt;    &lt;cache            name=&quot;com.liuzhuo.mapper.StudentMapper&quot;            maxElementsInMemory=&quot;1000&quot;            eternal=&quot;false&quot;            copyOnRead=&quot;true&quot;            copyOnWrite=&quot;true&quot;            timeToIdleSeconds=&quot;5000&quot;            timeToLiveSeconds=&quot;5000&quot;            diskPersistent=&quot;true&quot;            overflowToDisk=&quot;false&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;&lt;/ehcache&gt;</code></pre><hr><p>执行之前的测试方法，会发现：<code>E:\DEV_ENV\ehcache</code>目录下会多出几个文件：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190315201938.png"></p><hr><h3 id="集成Redis缓存"><a href="#集成Redis缓存" class="headerlink" title="集成Redis缓存"></a>集成Redis缓存</h3><p>Redis是一个高性能的 key-value 数据库，之前的博客中有一系列的Redis讲解，大家可以去看看，回顾一下。</p><p>Mybatis项目开发者提供了Redis的Mybatis二级缓存实现，该项目名为：<code>redis-cache</code>，目前只有beta版，项目地址是：</p><p><a href="https://github.com/mybatis/redis-cache" target="_blank" rel="noopener">https://github.com/mybatis/redis-cache</a></p><hr><p>（1）添加项目依赖</p><p>在pom.xml文件中添加如下依赖：</p><pre><code>  &lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-redis&lt;/artifactId&gt;    &lt;version&gt;1.0.0-beta2&lt;/version&gt;  &lt;/dependency&gt;</code></pre><p>mybatis-redis 目前只有beta版本。</p><p>（2）配置Redis</p><p>使用Redis前，必须有一个Redis服务，有关Redis安装启动的相关内容，请看我之前的博客。</p><p>参考地址：<a href="https://redis.io/topics/quickstart" target="_blank" rel="noopener">https://redis.io/topics/quickstart</a></p><p>Redis服务启动后，在 src/main/resources 目录下新增redis.properties文件。</p><pre><code>host=localhostport=6379connectionTimeout=5000soTimeout=5000password=database=0clientName=</code></pre><p>上面这几项是redis-cache项目提供的可以配置的参数，这里配置了服务器地址、端口号和超时时间。</p><p>（3）修改StudentMapper.xml中的缓存配置</p><p>redis-cache 提供了1个 MyBatis 缓存实现， <code>org.mybatis.caches.redis.RedisCache</code>。</p><pre><code>&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentMapper&quot;&gt;    &lt;cache type=&quot;org.mybatis.caches.redis.RedisCache&quot;/&gt;    &lt;!--其他配置--&gt;&lt;/mapper&gt;</code></pre><p>配置很简单，RedisCache在保存缓存数据和获取缓存数据时，使用了Java的序列化和反序列化，因此还需要保证被缓存的对象必须实现Serializable接口。</p><p>Redis缓存并不会因为应用的关闭而失效。</p><hr><p>当需要分布式部署应用时，如果使用Mybatis自带缓存或基础的EhCache缓存，分布式应用会各自拥有自己的缓存，它们之间不会共享缓存，这种方式会消耗更多的服务器资源。如果使用类似Redis的缓存服务，就可以将分布式应用连接到同一个缓存服务器，实现分布式应用间的缓存共享。</p><hr><h3 id="二级缓存适用场景"><a href="#二级缓存适用场景" class="headerlink" title="二级缓存适用场景"></a>二级缓存适用场景</h3><p>二级缓存虽然好处很多，但并不是什么时候都可以使用。在以下场景中，推荐使用二级缓存。</p><ul><li><p>以查询为主的应用中，只有尽可能少的增、删、改操作。</p></li><li><p>绝大多数以单表操作存在时，由于很少存在互相关联的情况，因此不会出现脏数据。</p></li><li><p>可以按业务划分对表进行分组时，如关联的表比较少时，可以通过参照缓存进行配置。</p></li></ul><p>除了推荐使用的情况，如果脏读对系统没有影响，也可以考虑使用。在无法保证数据不出现脏读的情况下，建议在业务层使用可控制的缓存代替二级缓存。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中的高级查询</title>
      <link href="/2019/03/13/mybatis-zhong-de-gao-ji-cha-xun/"/>
      <url>/2019/03/13/mybatis-zhong-de-gao-ji-cha-xun/</url>
      
        <content type="html"><![CDATA[<p>通过前面几篇博客的学习，我们已经了解了 MyBatis 中最常用的部分。基本的增、删、改、查操作己经可以满足我们大部分的需求，今天将会对除上述内容之外的知识点进行详细介绍。</p><p>本篇博客主要包含的内容为MyBatis的高级结果映射，主要处理数据库一对一、一对多的查询，另外就是在 MyBtis 中使用存储过程的方法，处理存储过程的入参和出参方法。</p><hr><h3 id="高级映射"><a href="#高级映射" class="headerlink" title="高级映射"></a>高级映射</h3><p>在关系型数据库中，我们经常要处理 一对一、一对多 的关系 例如， 一辆汽车需要有引擎，这是一对一的关系。 一辆汽车有4个或更多个轮子，这是一对多的关系。</p><p>在Mybatis中使用3种方式来操作级联：</p><ul><li><p>association，代表一对一的关系，比如中国公民和身份证是一对一的关系。</p></li><li><p>collection，代表一对多的关系，比如班级和学生是一对多的关系，一个班级有多个学生。</p></li><li><p>discriminator，是鉴别器，它可以根据实际情况，选择采用哪个类作为实例，允许你根据特定的条件去关联不同的结果集。</p></li></ul><hr><p>为了方便讲解，我们来创建一系列的数据库表，它们的模型关系，如下所示：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313130557.png"></p><p>学生表为核心，学生表与学生证表是一对一的关系；学生表与课程成绩表是一对多的关系，一个学生有多门课；课程表与课程成绩表也是一对多的关系。</p><p>学生有男生与女生，所以健康项目不一样，这里我就列举了一个不同点，简化一下。根据学生的性别不同来决定使用哪个表，而鉴别性别就需要使用鉴别器了。</p><hr><p>这里，大家可能会想到，数据库中不是还有多对多的关系嘛？为啥这里没有体现呢？</p><p>这是因为在实际中，多对多的关系应用不多，因为它比较复杂，会增加理解和关联的复杂性，推荐的方法是，使用一对多的关系把它分解为双向关系，以降低关系的复杂度，简化程序。</p><hr><p>根据上述的数据库表的描述，生成相应的表，然后创建新的maven工程。</p><p>（1）生成Mybatis数据库：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313131616.png"></p><p>（2）创建相关的表：</p><pre><code>use mybatis;drop table if exists student;drop table if exists student_selfcard;drop table if exists lecture;drop table if exists student_lecture;drop table if exists student_female_health;drop table if exists student_male_health;create table student( id  INT(20) not null auto_increment COMMENT &#39;学生编号&#39;, stu_name VARCHAR(60) not null comment &#39;学生姓名&#39;, stu_sex TINYINT(4) not null comment &#39;性别&#39;, stu_id int(20) not NULL COMMENT &#39;学生证号&#39;, PRIMARY key(id));create table student_selfcard( id INT(20) not null auto_increment COMMENT &#39;编号&#39;, stu_number int(20) not null COMMENT &#39;学生证号&#39;, stu_birthplace VARCHAR(60) COMMENT &#39;籍贯&#39;, stu_start_time date COMMENT &#39;发证日期&#39;, stu_end_time date COMMENT &#39;结束日期&#39;, primary key(id));create table lecture( id int(20) not null comment &#39;编号&#39;, lecture_name varchar(60) not null comment &#39;课程名称&#39;, primary key(id));create table student_lecture( id int(20) not null auto_increment comment &#39;编号&#39;, stu_id int(20) not null comment &#39;学生编号&#39;, lecture_id int(20) not null comment &#39;课程编号&#39;, grade DECIMAL(16,2) not null comment &#39;课程成绩&#39;, primary key(id));create table student_female_health( id int(20) not null auto_increment comment &#39;编号&#39;, stu_id int(20) not null comment &#39;学生编号&#39;, check_date date not null comment &#39;检查日期&#39;, heart varchar(60) not null comment &#39;心&#39;, uterus varchar(60) not null comment &#39;子宫&#39;, primary key(id));create table student_male_health( id int(20) not null auto_increment comment &#39;编号&#39;, stu_id int(20) not null comment &#39;学生编号&#39;, check_date date not null comment &#39;检查日期&#39;, heart varchar(60) not null comment &#39;心&#39;, prostate varchar(60) not null comment &#39;前列腺&#39;, primary key(id));</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313135537.png"></p><p>(3) 创建新的maven工程</p><p>项目的整体结构：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313145410.png"></p><p>entities：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313145502.png"></p><p>mappers：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313145550.png"></p><p>typeHanler：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313145813.png"></p><p>pom.xml:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.liuzhuo&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.13&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;        &lt;!--配置即使xml不在resources中，也能读取到xml文件--&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;        &lt;/resources&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>jdbc.properties：</p><pre><code>jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8jdbc.username=rootjdbc.password=123456</code></pre><p>log4j.properties:</p><pre><code>#全局配置log4j.rootLogger=ERROR,stdout#MyBatis日志配置log4j.logger.com.liuzhuo=TRACE#控制台输出配置log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[%5p] [%t] - %m %x %n</code></pre><p>mybatis-config.xml:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;properties resource=&quot;jdbc.properties&quot;&gt;    &lt;/properties&gt;    &lt;settings&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;    &lt;/settings&gt;    &lt;!--别名--&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.liuzhuo.entities&quot;/&gt;    &lt;/typeAliases&gt;    &lt;typeHandlers&gt;        &lt;typeHandler handler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot; javaType=&quot;com.liuzhuo.enums.Sex&quot;/&gt;    &lt;/typeHandlers&gt;    &lt;!--定义数据库信息，默认使用development数据库构建环境--&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!--采用JDBC事务管理--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;            &lt;/transactionManager&gt;            &lt;!--配置数据源的信息--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;package name=&quot;com.liuzhuo.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>entities中的POJO，我就不列出来了，大家自行解决。</p><p>Sex:</p><pre><code>public enum Sex {    MALE(1, &quot;男&quot;), FEMALE(2, &quot;女&quot;);    private int id;    private String name;    private Sex(int id, String name) {        this.id = id;        this.name = name;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public static Sex getSex(int id) {        if (id == 1) {            return MALE;        } else if (id == 2) {            return FEMALE;        }        return null;    }}</code></pre><p>SexEnumTypeHandler:</p><pre><code>public class SexEnumTypeHandler extends BaseTypeHandler&lt;Sex&gt; {    @Override    public void setNonNullParameter(PreparedStatement ps, int i, Sex parameter, JdbcType jdbcType) throws SQLException {        System.out.println(&quot;自定义的枚举类型，set&quot;);        ps.setInt(i, parameter.getId());    }    @Override    public Sex getNullableResult(ResultSet rs, String columnName) throws SQLException {        System.out.println(&quot;自定义的枚举类型，get&quot;);        int id = rs.getInt(columnName);        return Sex.getSex(id);    }    @Override    public Sex getNullableResult(ResultSet rs, int columnIndex) throws SQLException {        System.out.println(&quot;自定义的枚举类型，get&quot;);        int id = rs.getInt(columnIndex);        return Sex.getSex(id);    }    @Override    public Sex getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {        System.out.println(&quot;自定义的枚举类型，get&quot;);        int id = cs.getInt(columnIndex);        return Sex.getSex(id);    }}</code></pre><p>StudentMapper.xml:</p><pre><code>&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentMapper&quot;&gt;    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;!--新添加的字段--&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;findStudentById&quot; resultMap=&quot;studentMap&quot;&gt;         select * from student where id = #{id}     &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>test:</p><pre><code>public class MainTest {    private static SqlSessionFactory sqlSessionFactory;    @BeforeClass    public static void init() {        try {            String mybatisConfig = &quot;mybatis-config.xml&quot;;            InputStream inputStream = Resources.getResourceAsStream(mybatisConfig);            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);            inputStream.close();        } catch (IOException e) {            e.printStackTrace();        }    }    @Test    public void testSelectStudent() {        SqlSession sqlSession = sqlSessionFactory.openSession();            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            Student student = studentMapper.findStudentById(1L);            System.out.println(student);            try {        } finally {            //不要忘记关闭SqlSession            sqlSession.close();        }    }}</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313150007.png"></p><hr><p>运行测试：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313150123.png"></p><p><strong>数据库中的数据，自己随意添加呀，没有要求的。</strong></p><p>以上就是我们的新的项目工程，现在已经能够运行了，下面，我们开始讲解Mybatis中的高级映射功能。</p><h3 id="一对一映射"><a href="#一对一映射" class="headerlink" title="一对一映射"></a>一对一映射</h3><p>一个学生对应一个学生证，属于一对一映射。</p><h4 id="使用自动映射处理一对一映射"><a href="#使用自动映射处理一对一映射" class="headerlink" title="使用自动映射处理一对一映射"></a>使用自动映射处理一对一映射</h4><p>添加新的POJO对象：StudentAndSelfcard类：</p><pre><code>public class StudentAndSelfcard extends Student {    private StudentSelfcard studentSelfcard;    public StudentSelfcard getStudentSelfcard() {        return studentSelfcard;    }    public void setStudentSelfcard(StudentSelfcard studentSelfcard) {        this.studentSelfcard = studentSelfcard;    }    @Override    public String toString() {        return super.toString() +                &quot; + StudentAndSelfcard{ &quot; +                &quot;studentSelfcard=&quot; + studentSelfcard +                &#39;}&#39;;    }}</code></pre><p>该类就是一个Student类中添加一个StudentSelfcard属性。</p><p>修改：StudentMapper.xml</p><p>添加一个新的<code>selectStudentAndSelfcardById</code> select 标签：</p><pre><code>    &lt;select id=&quot;selectStudentAndSelfcardById&quot; resultType=&quot;studentAndSelfcard&quot;&gt;        select        s.id,        s.stu_name as &#39;stuName&#39; ,        s.stu_sex as &#39;stuSex&#39;,        s.stu_id as &#39;stuId&#39; ,        ss.id as &#39;studentSelfcard.id&#39;,        ss.stu_number as &#39;studentSelfcard.stuNumber&#39;,        ss.stu_birthplace as &#39;studentSelfcard.stuBirthplace&#39;,        ss.stu_start_time as &#39;studentSelfcard.stuStartTime&#39;,        ss.stu_end_time as &#39;studentSelfcard.stuEndTime&#39;        from student as s        JOIN student_selfcard as ss on s.stu_id = ss.stu_number        where s.id = #{id}    &lt;/select&gt;</code></pre><p>注意上面，因为使用的是Mybatis的自动映射，所以，从student_selfcard表中获取的数据，在使用别名时，都加上了<code>studentSelfcard</code>前缀，通过这种方式将student_selfcard表中的数据映射到StudentAndSelfcard类中的studentSelfcard属性中。</p><hr><p>在StudentMapper中添加新的方法：<code>selectStudentAndSelfcardById</code></p><pre><code>public interface StudentMapper {    public Student findStudentById(Long id);    public StudentAndSelfcard selectStudentAndSelfcardById(Long id);}</code></pre><hr><p>在MainTest中添加新的测试方法：</p><pre><code>    @Test    public void testSelectStudentAndSelfcardById() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            StudentAndSelfcard studentAndSelfcard = studentMapper.selectStudentAndSelfcardById(1L);            //student不为空            Assert.assertNotNull(studentAndSelfcard);            //studentSelfcard不为空            Assert.assertNotNull(studentAndSelfcard.getStudentSelfcard());            System.out.println(studentAndSelfcard);        } finally {            sqlSession.close();        }    }</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313154824.png"></p><p>可以看到映射成功，通过 SQL 日志可以看到已经查询出的一条数据， Mybatis 将这条数据映射到了两个类中。</p><p>像这样通过一次查询，将结果映射到不同对象的方式，称之为：<strong><font color="red">关联的嵌套结果映射。</font></strong></p><p>关联 嵌套结果 映射 ，需要关联多张表，将所有需要的值一次性查询出来。这种方式的好处是减少数据库查询次数 ，减轻数据库的压力， 缺点是要写很复杂的 SQL，并且当嵌套结果更复杂时， 不容易一次写正确 ，由于要在应用服务器上将结果映射到不同的类上。 因此 ，会增加应用服务器的压力。当一定要使用 嵌套结果 并且整个复杂的 SQL 执行速度很快时 ，建议使用关联的嵌套结果映射。</p><hr><h4 id="resultMap处理一对一映射"><a href="#resultMap处理一对一映射" class="headerlink" title="resultMap处理一对一映射"></a>resultMap处理一对一映射</h4><p>除了使用Mybatis的自动映射来处理一对一嵌套外，还可以在XML映射文件中配置结果映射。</p><p>使用resultMap来实现与上一节相同的效果。</p><p>在 <code>StudentMapper.xml</code> 文件中：</p><p>添加新的resultMap：</p><pre><code>    &lt;resultMap id=&quot;studentSelfcardMap&quot; type=&quot;studentAndSelfcard&quot;&gt;        &lt;!--student的映射--&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;        &lt;!--studentselfcard的映射--&gt;        &lt;result column=&quot;studentSelfcard_id&quot; property=&quot;studentSelfcard.id&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_number&quot; property=&quot;studentSelfcard.stuNumber&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_birthplace&quot; property=&quot;studentSelfcard.stuBirthplace&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_start_time&quot; property=&quot;studentSelfcard.stuStartTime&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_end_time&quot; property=&quot;studentSelfcard.stuEndTime&quot;/&gt;    &lt;/resultMap&gt;</code></pre><p>在映射studentSelfcard表时，列名我都加上了 <code>studentSelfcard_</code> 的前缀了，为了防止与student中有相同的列名。</p><p>添加新的select：</p><pre><code>    &lt;select id=&quot;selectStudentAndSelfcardById02&quot; resultMap=&quot;studentSelfcardMap&quot;&gt;        select        s.id,        s.stu_name,        s.stu_sex,        s.stu_id,        ss.id as &#39;studentSelfcard_id&#39;,        ss.stu_number as &#39;studentSelfcard_stu_number&#39;,        ss.stu_birthplace as &#39;studentSelfcard_stu_birthplace&#39;,        ss.stu_start_time as &#39;studentSelfcard_stu_start_time&#39;,        ss.stu_end_time as &#39;studentSelfcard_stu_end_time&#39;        from student as s        JOIN student_selfcard as ss on s.stu_id = ss.stu_number        where s.id = #{id}    &lt;/select&gt;</code></pre><p>看到，查询student时，我们都没有使用别名，因为此时，我们在resultMap中配置了，此时查询出来的列名要与resultMap中的<code>column</code>同名才行。</p><p>所以，查询student_selfcard表时，我们都使用了<code>studentSelfcard_</code>前缀的别名，来与resultMap中的<code>column</code>同名。</p><font color="red">此时，是不是已经看出了与自动映射的区别了，在自动映射中，列名的别名是对应着POJO的属性名，而使用resultMap的话，select中查询出来的列名的别名，要与resultMap中的column的属性值一模一样！！！</font><p><strong>此时在select标签中，使用的是resultMap元素，而不是resultType元素了。select标签中的resultMap元素等于resultMap标签中的id元素值。</strong></p><hr><p>在StudentMapper接口中添加:<code>selectStudentAndSelfcardById02</code></p><pre><code>public interface StudentMapper {    public Student findStudentById(Long id);    public StudentAndSelfcard selectStudentAndSelfcardById(Long id);    public StudentAndSelfcard selectStudentAndSelfcardById02(Long id);}</code></pre><hr><p>在MainTest中添加新的测试方法：</p><pre><code>    @Test    public void testSelectStudentAndSelfcardById02() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            StudentAndSelfcard studentAndSelfcard = studentMapper.selectStudentAndSelfcardById02(1L);            //student不为空            Assert.assertNotNull(studentAndSelfcard);            //studentSelfcard不为空            Assert.assertNotNull(studentAndSelfcard.getStudentSelfcard());            System.out.println(studentAndSelfcard);        } finally {            sqlSession.close();        }    }</code></pre><p>运行结果：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313162728.png"></p><p>结果和使用自动映射的效果一模一样，但是，大家肯定会觉得这样岂不是更加麻烦了，还多写了一个resultMap标签来映射，不仅没有方便开发，还增加了工作量。</p><p>下面就使用resultMap的继承功能：</p><h5 id="resultMap的继承功能"><a href="#resultMap的继承功能" class="headerlink" title="resultMap的继承功能"></a>resultMap的继承功能</h5><p>在我们的 xxxMapper.xml中都会有一个基本的xxxtMap的resultMap映射，这个映射可以使用 <strong><code>MyBatis的代码生成器生成</code></strong>，所以可以省略手动工作。</p><p>关于MyBatis的代码生成器生成，后面我会讲到，大家不要急，现在只需要知道就行。</p><hr><p>在我们的 StudentMapper.xml 中的基类resultMap为：</p><pre><code>    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;    &lt;/resultMap&gt;</code></pre><p>只映射了student的属性。</p><p>添加新的resultMap标签：（studentSelfcardMap02）</p><pre><code>    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;    &lt;/resultMap&gt;    &lt;resultMap id=&quot;studentSelfcardMap02&quot; type=&quot;studentAndSelfcard&quot; extends=&quot;studentMap&quot;&gt;        &lt;!--studentselfcard的映射--&gt;        &lt;result column=&quot;studentSelfcard_id&quot; property=&quot;studentSelfcard.id&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_number&quot; property=&quot;studentSelfcard.stuNumber&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_birthplace&quot; property=&quot;studentSelfcard.stuBirthplace&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_start_time&quot; property=&quot;studentSelfcard.stuStartTime&quot;/&gt;        &lt;result column=&quot;studentSelfcard_stu_end_time&quot; property=&quot;studentSelfcard.stuEndTime&quot;/&gt;    &lt;/resultMap&gt;</code></pre><p>可以看到新的<code>studentSelfcardMap02</code> 中使用 <code>extends</code>关键字继承了 <code>studentMap</code>。</p><p>此时只需要书写：studentSelfcard的相关属性即可，简化了我们的书写。</p><p>而且如果要修改：student表的话，我们只需要修改：studentMap一次即可，不需要修改多个resultMap。</p><p>将 <code>select id=selectStudentAndSelfcardById02</code>的 <strong><code>resultMap</code></strong> 改为：<code>selectStudentAndSelfcardById02</code>,然后运行<code>testSelectStudentAndSelfcardById02</code></p><p>发现运行还是成功的。</p><hr><h4 id="使用resultMap的association"><a href="#使用resultMap的association" class="headerlink" title="使用resultMap的association"></a>使用resultMap的association</h4><p>添加新的resultMap标签：</p><pre><code>    &lt;resultMap id=&quot;studentSelfcardMap03&quot; type=&quot;studentAndSelfcard&quot; extends=&quot;studentMap&quot;&gt;        &lt;!--studentselfcard的映射--&gt;        &lt;association property=&quot;studentSelfcard&quot; columnPrefix=&quot;studentSelfcard_&quot; javaType=&quot;studentSelfcard&quot;&gt;            &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;            &lt;result property=&quot;stuNumber&quot; column=&quot;stu_number&quot;/&gt;            &lt;result property=&quot;stuBirthplace&quot; column=&quot;stu_stu_birthplace&quot;/&gt;            &lt;result property=&quot;stuStartTime&quot; column=&quot;stu_start_time&quot;/&gt;            &lt;result property=&quot;stuEndTime&quot; column=&quot;stu_end_time&quot;/&gt;        &lt;/association&gt;    &lt;/resultMap&gt;</code></pre><p>association标签包含以下属性：</p><ul><li><p>property：对应POJO中的属性名，必须填</p></li><li><p>javaType：属性对应的Java类型（可以使用别名）</p></li><li><p>resultMap：可以直接使用现有的resultMap，然后就不要在这里配置了。</p></li><li><p>columnPrefix：查询列的前缀，在子标签配置result的column时可以省略前缀。</p></li></ul><p>还有其他的属性，此处不做过多的介绍了。</p><p>然后运行，结果会是一样的，这里就不演示了。</p><hr><p>使用association配置时，还可以使用resultMap配置一个已经存在的resultMap映射，一般情况下，如果使用了Mybatis代码生成器，都会生成每个表对应实体的resultMap配置，也可以手动写一个resultMap。</p><pre><code>    &lt;resultMap id=&quot;studentSelfcardBaseMap&quot; type=&quot;studentSelfcard&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_number&quot; property=&quot;stuNumber&quot;/&gt;        &lt;result column=&quot;stu_birthplace&quot; property=&quot;stuBirthplace&quot;/&gt;        &lt;result column=&quot;stu_start_time&quot; property=&quot;stuStartTime&quot;/&gt;        &lt;result column=&quot;stu_end_time&quot; property=&quot;stuEndTime&quot;/&gt;    &lt;/resultMap&gt;</code></pre><p>添加新的resultMap：</p><pre><code>    &lt;resultMap id=&quot;studentSelfcardMap04&quot; type=&quot;studentAndSelfcard&quot; extends=&quot;studentMap&quot;&gt;        &lt;association property=&quot;studentSelfcard&quot; columnPrefix=&quot;studentSelfcard_&quot;  resultMap=&quot;studentSelfcardBaseMap&quot;/&gt;    &lt;/resultMap&gt;</code></pre><p>此时，就很简单了，看起来很清爽了。</p><p>需要注意的是，<code>studentSelfcardBaseMap</code>：现在是写在：<code>StudentMapper.xml</code>中的，但是实际开发中，<code>studentSelfcardBaseMap</code>应该在<code>StudentSelfcardMapper.xml</code>文件中，此时，<code>studentSelfcardMap04</code>就不能简单的直接使用: <code>resultMap=studentSelfcardBaseMap</code>了，必须要加上 namespace命名空间。</p><p>如下：</p><pre><code>    &lt;resultMap id=&quot;studentSelfcardMap04&quot; type=&quot;studentAndSelfcard&quot; extends=&quot;studentMap&quot;&gt;        &lt;association property=&quot;studentSelfcard&quot; columnPrefix=&quot;studentSelfcard_&quot;  resultMap=&quot;com.liuzhuo.mapper.StudentSelfcardMapper.studentSelfcardBaseMap&quot;/&gt;    &lt;/resultMap&gt;</code></pre><hr><h4 id="association标签的嵌套查询"><a href="#association标签的嵌套查询" class="headerlink" title="association标签的嵌套查询"></a>association标签的嵌套查询</h4><p>除了前面3种通过复杂的SQL查询获取结果外，还可以利用简单的SQL通过多次查询转换为我们需要的结果，这种方式与根据业务逻辑手动执行多次SQL的方式相像，最后将结果组合成一个对象。</p><p>association标签的嵌套查询常用的属性：</p><ul><li><p>select：另一个映射查询的id，Mybatis会额外执行这个查询获取嵌套对象的结果。</p></li><li><p>column：列名（或别名），将主查询中列的结果作为嵌套查询的参数，配置方式如：<code>column={prop1=col1,prop2=col2}</code>,其中prop1和prop2将作为嵌套查询的参数，就像#{prop1}一样，col1和col2就是主查询出来的列名。</p></li><li><p>fetchType：数据加载方式，可选值为：<code>lazy</code> 和 <code>eager</code>，分别为延迟加载和积极加载，这个配置会覆盖全局的lazyLoadingEnabled配置。</p></li></ul><hr><p>使用嵌套查询的方式配置一个和前面功能一样的方法，首先在 <code>StudentMapper.xml</code> 中：</p><pre><code>    &lt;resultMap id=&quot;studentSelfcardMap05&quot; type=&quot;studentAndSelfcard&quot; extends=&quot;studentMap&quot;&gt;        &lt;association property=&quot;studentSelfcard&quot; column=&quot;stuNumber=stu_id&quot;                     select=&quot;com.liuzhuo.mapper.StudentSelfcardMapper.selectStudentSelfcardBystuNumber&quot;&gt;        &lt;/association&gt;    &lt;/resultMap&gt;</code></pre><p>然后创建一个select标签：</p><pre><code>    &lt;select id=&quot;selectStudentAndSelfcardById03&quot; resultMap=&quot;studentSelfcardMap05&quot;&gt;        select        s.id,        s.stu_name,        s.stu_sex,        s.stu_id,        from student as s        where s.id = #{id}    &lt;/select&gt;</code></pre><p>注意关联中已经没有了 <code>studentSelfcard</code>了 ，因为我们不再是通过一个SQL语句来获取全部的信息了，学生证表的信息是通过配置的<code>select=&quot;com.liuzhuo.mapper.StudentSelfcardMapper.selectStudentSelfcardBystuNumber&quot;</code> 来查询的，这个方法写在 <code>StudentSelfcardMapper.xml</code>中。</p><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313173138.png"></p><pre><code>&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentSelfcardMapper&quot;&gt;    &lt;resultMap id=&quot;studentSelfcard&quot; type=&quot;studentSelfcard&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_number&quot; property=&quot;stuNumber&quot;/&gt;        &lt;result column=&quot;stu_birthplace&quot; property=&quot;stuBirthplace&quot;/&gt;        &lt;result column=&quot;stu_start_time&quot; property=&quot;stuStartTime&quot;/&gt;        &lt;result column=&quot;stu_end_time&quot; property=&quot;stuEndTime&quot;/&gt;    &lt;/resultMap&gt;   &lt;select id=&quot;selectStudentSelfcardBystuNumber&quot; resultMap=&quot;studentSelfcard&quot;&gt;        select        ss.id,        ss.stu_number as &#39;stuNumber&#39;,        ss.stu_birthplace as &#39;stuBirthplace&#39;,        ss.stu_start_time as &#39;stuStartTime&#39;,        ss.stu_end_time as &#39;stuEndTime&#39;        from student_selfcard as ss        where ss.stu_number = #{stuNumber}   &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>注意，可用的参数是通过上面的 <code>column=&quot;{stuNumber=stu_id}&quot;</code>进行配置的，因此在嵌套的SQL中只能使用#{stuNumber}参数，当需要多个参数的时候，可用配置多个，使用逗号隔开即可，例如：</p><p> <code>column=&quot;{id = id,stuNumber=stu_id}&quot;</code>。</p><hr><p>针对上面的方法，在MainTest中编写测试的方法：</p><pre><code>    @Test    public void testSelectStudentAndSelfcardById03() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            StudentAndSelfcard studentAndSelfcard = studentMapper.selectStudentAndSelfcardById03(1L);            //student不为空            Assert.assertNotNull(studentAndSelfcard);            //studentSelfcard不为空            Assert.assertNotNull(studentAndSelfcard.getStudentSelfcard());            System.out.println(studentAndSelfcard);        } finally {            sqlSession.close();        }    }</code></pre><p>运行：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313174148.png"></p><p>结果和我们想的一致，因为第一条SQL语句的查询结果只有一条，所以根据这一条数据的 <code>stu_id</code> 来关联另一个查询，因此执行了两次SQL。</p><p>这种配置方式符合开始预期的结果，但是由于嵌套查询会执行多条SQL语句，所以还要考虑更多的情况。在这个例子中，是否一定会用到<code>StudentSelfcard</code>呢？</p><p>如果查询出来并没有使用，那不就是白白浪费了一次查询吗？如果查询的不是1条数据，而是N条数据，那就会出现 N+1 的问题，主SQL会查询一次，查询出N条结果，这N条结果，那就需要进行N此查询。如何解决这个问题呢？</p><p>在上面在介绍：association标签的属性时，介绍了<code>fetchType</code>数据加载方式，这个方式可以帮我们实现延迟加载，解决 N+1 的问题。</p><p>按照上面的介绍，需要把 <code>fetchType</code> 设置为：lazy，这样设置后，只有当调用：<code>studentAndSelfcard.getStudentSelfcard()</code>方法获取：StudentSelfcard的时候，Mybatis才会执行嵌套查询去获取数据。</p><p>首先修改：<code>studentSelfcardMap05</code></p><pre><code>    &lt;resultMap id=&quot;studentSelfcardMap05&quot; type=&quot;studentAndSelfcard&quot; extends=&quot;studentMap&quot;&gt;        &lt;association property=&quot;studentSelfcard&quot; column=&quot;stuNumber=stu_id&quot;                     select=&quot;com.liuzhuo.mapper.StudentSelfcardMapper.selectStudentSelfcardBystuNumber&quot;                     fetchType=&quot;lazy&quot;&gt;        &lt;/association&gt;    &lt;/resultMap&gt;</code></pre><p>添加了：<code>fetchType=&quot;lazy&quot;</code></p><p>然后修改测试方法，在调用<code>studentAndSelfcard.getStudentSelfcard()</code>方法之前增加一行输出：</p><pre><code>    //student不为空    Assert.assertNotNull(studentAndSelfcard);    System.out.println(&quot;调用studentAndSelfcard.getStudentSelfcard()&quot;);    //studentSelfcard不为空    Assert.assertNotNull(studentAndSelfcard.getStudentSelfcard());</code></pre><p>再运行测试方法：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313175722.png"></p><p>发现，现在是按需加载了。</p><p>现在将 <code>Assert.assertNotNull(studentAndSelfcard.getStudentSelfcard());</code> 注释掉，再测试：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313175940.png"></p><hr><p>我们在把 <code>fetchType</code> 去掉后，再测试：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313180224.png"></p><hr><p>现在最新的Mybatis中，只需要把 <code>fetchType=lazy</code> 就可以实现按需执行SQL语句了。</p><p>如果你的不是最新的Mybatis的话，还需要配置一个全局的参数 <code>aggressiveLazyLoading</code>。</p><p>这个参数的含义是，当参数设置为：true时，对任意延迟属性的调用，会使带有延迟加载属性的对象<strong><code>完整加载</code></strong>，反之，每种属性都将按需加载。</p><p>以前版本默认是：true。所以即使你配置了：<code>fetchType=lazy</code>，也会全部加载！！！</p><p>需要在mybatis-config.xml中配置：</p><pre><code>    &lt;settings&gt;        &lt;!--其他配置--&gt;        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;    &lt;/settings&gt;</code></pre><p>增加这个配合后，再次执行测试，就会和新版的一样了。</p><hr><font color="red"><br>注意：<br><br>许多对延迟加载原理不太熟悉的朋友会经常遇到一些莫名其妙的问题：有些时候延迟加载可以得到数据，有些时候延迟加载就会报错，为什么会出现这种情况呢？<br><br>Mybatis延迟加载是通过动态代理实现的，当调用配置为延迟加载的属性方法时，动态代理的操作会被触发，这些额外的操作就是通过Mybatis的SqlSession去执行嵌套SQl的。<br><br>由于在和某些框架集成的时候，SqlSession的生命周期交给了框架管理，因为当对象超出SqlSession生命周期调用时，会由于链接关闭等问题而抛出异常。在和Spring集成时，要确保只能在Service层延迟加载属性。当结果从Service层返回至Controller层时，如果获取延迟加载的属性值时，会因为SqlSession已经关闭而抛出异常。<br></font><hr><h3 id="一对多映射"><a href="#一对多映射" class="headerlink" title="一对多映射"></a>一对多映射</h3><p>在上一节中，我们使用了4种方式实现了一对一映射。这一节中，<font color="red"><strong>一对多映射只有两种配置方式，都是使用collection标签进行的</strong></font>，下面来看看具体的介绍。</p><h4 id="collection集合的嵌套结果映射"><a href="#collection集合的嵌套结果映射" class="headerlink" title="collection集合的嵌套结果映射"></a>collection集合的嵌套结果映射</h4><p>和association类似，集合的嵌套结果映射就是指通过一次SQl语句，查询出所有的结果，然后通过配置的结果映射，将数据映射到不同的对象中。在一对多的关系中，主表的一条数据会对应关联表中的多条数据，因此一般查询时会查询出多个结果，按照一对多的数据结构存储数据的时候，最终的结果数会小于等于查询的总记录数。</p><hr><p>在我们的数据库中，有两个级联关系，一个是学生和课程成绩的级联，这是一对多的关系，另一个是课程成绩与课程的级联，这是一对一的关系。</p><p>现在我们首先来看一对多的关系，学生与课程成绩的关系。</p><p>创建一个新的POJO对象：StudentBean</p><pre><code>public class StudentBean extends Student {    List&lt;StudentLecture&gt; studentLectureList;    public List&lt;StudentLecture&gt; getStudentLectureList() {        return studentLectureList;    }    public void setStudentLectureList(List&lt;StudentLecture&gt; studentLectureList) {        this.studentLectureList = studentLectureList;    }}</code></pre><p>使用List集合来对应：一对多中的多的一方。在这里就是<code>List&lt;StudentLecture&gt;</code>。</p><hr><p>打开：StudentMapper.xml，添加新的resultMap：</p><pre><code>    &lt;resultMap id=&quot;studentBeanMap&quot; type=&quot;studentBean&quot;&gt;        &lt;!--student的基本信息--&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;        &lt;!--studentLecture--&gt;        &lt;collection property=&quot;studentLectureList&quot; columnPrefix=&quot;studentLecture_&quot; ofType=&quot;studentLecture&quot;&gt;            &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;            &lt;result property=&quot;stuId&quot; column=&quot;stu_id&quot;/&gt;            &lt;result property=&quot;lectureId&quot; column=&quot;lecture_id&quot;/&gt;            &lt;result property=&quot;grade&quot; column=&quot;grade&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;</code></pre><font color="red"><strong>注意：在collection中，ofType：为List中的java类型，此时不是使用javaType，javaType是在association中使用的，注意差别！！！</strong></font><hr><p>select标签：</p><pre><code>    &lt;select id=&quot;selectStudentBeanById&quot; resultMap=&quot;studentBeanMap&quot;&gt;        select        s.id,        s.stu_name,        s.stu_sex,        s.stu_id,        sl.id as &#39;studentLecture_id&#39;,        sl.stu_id as &#39;studentLecture_stu_id&#39;,        sl.lecture_id as &#39;studentLecture_lecture_id&#39;,        sl.grade as &#39;studentLecture_grade&#39;        from student as s join student_lecture as sl on s.stu_id = sl.stu_id        where s.id = #{id}    &lt;/select&gt;</code></pre><hr><p>StudentMapper接口：</p><pre><code>public interface StudentMapper {    public Student findStudentById(Long id);    public StudentAndSelfcard selectStudentAndSelfcardById(Long id);    public StudentAndSelfcard selectStudentAndSelfcardById02(Long id);    public StudentAndSelfcard selectStudentAndSelfcardById03(Long id);    //增加的新的方法    public StudentBean selectStudentBeanById(Long id);}</code></pre><hr><p>MainTest：</p><pre><code>    @Test    public void testSelectStudentBeanById() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            StudentBean studentBean = studentMapper.selectStudentBeanById(1L);            Assert.assertNotNull(studentBean);            List&lt;StudentLecture&gt; studentLectureList = studentBean.getStudentLectureList();            System.out.println(studentBean.getStuName() + &quot; : 选修了：&quot; + studentLectureList.size() + &quot; 门功课!&quot;);            for (StudentLecture studentLecture : studentLectureList) {                System.out.println(studentLecture);            }        } finally {            sqlSession.close();        }    }</code></pre><hr><p>运行结果：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190314160845.png"></p><p>一条SQL语句，查询出所有的结果，然后Mybatis帮我们组合起来。</p><hr><p>然后，我们还能简化，在collection中，还可以使用已存在的resultMap。</p><p>在 StudentLectureMapper.xml中：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentLectureMapper&quot;&gt;    &lt;resultMap id=&quot;studentLectureMap&quot; type=&quot;studentLecture&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;lecture_id&quot; property=&quot;lectureId&quot;/&gt;        &lt;result column=&quot;grade&quot; property=&quot;grade&quot;/&gt;    &lt;/resultMap&gt;&lt;/mapper&gt;</code></pre><p>有一个基本的 <code>studentLectureMap</code> 映射配置</p><hr><p>在 StudentMapper.xml中：</p><pre><code>    &lt;resultMap id=&quot;studentBeanMap02&quot; type=&quot;studentBean&quot; extends=&quot;studentMap&quot;&gt;        &lt;collection property=&quot;studentLectureList&quot; columnPrefix=&quot;studentLecture_&quot; resultMap=&quot;com.liuzhuo.mapper.StudentLectureMapper.studentLectureMap&quot;&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;</code></pre><p>首先，第一个resultMap，使用 extends 继承了 studentMap 了，所以此时student的映射就不需要写了。</p><p>然后，在collection中，使用resultMap等于StudentLectureMapper.xml中的studentLectureMap，来映射studentLecture，此时ofType就不需要写了！！！</p><hr><p>现在测试，发现结果也是好使的。</p><hr><p>现在，我们往数据库中，添加一些新的数据：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190314162837.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190314162915.png"></p><p>能看到，jack有三条课程成绩数据，gakki有两条课程成绩数据，应该会有五条记录。</p><p>在 StudentMapper.xml中添加新的select标签：</p><pre><code>    &lt;select id=&quot;selectStudentBeanAll&quot; resultMap=&quot;studentBeanMap02&quot;&gt;        select        s.id,        s.stu_name,        s.stu_sex,        s.stu_id,        sl.id as &#39;studentLecture_id&#39;,        sl.stu_id as &#39;studentLecture_stu_id&#39;,        sl.lecture_id as &#39;studentLecture_lecture_id&#39;,        sl.grade as &#39;studentLecture_grade&#39;        from student as s join student_lecture as sl on s.stu_id = sl.stu_id    &lt;/select&gt;</code></pre><hr><p>在StudentMapper接口添加新的接口：</p><pre><code>public List&lt;StudentBean&gt; selectStudentBeanAll();</code></pre><p>在MainTest中：</p><pre><code>    @Test    public void testSelectStudentBeanAll() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            List&lt;StudentBean&gt; studentBeanList = studentMapper.selectStudentBeanAll();            System.out.println(&quot;有:&quot; + studentBeanList.size() + &quot;个学生&quot;);            for (StudentBean studentBean : studentBeanList) {                System.out.println(&quot;学生名：&quot; + studentBean.getStuName());                for (StudentLecture studentLecture : studentBean.getStudentLectureList()) {                    System.out.println(&quot;课程Id：&quot; + studentLecture.getLectureId());                }            }        } finally {            sqlSession.close();        }    }</code></pre><p>执行测试方法，验证一下：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190314164045.png"></p><hr><p>通过日志可以清楚地看出，SQL执行的结果数有5条，后面输出的学生数是2，也就说本来查询出来的5条结果经过Mybatis对collection数据的处理后，变成了两条。</p><p>我们都知道，因为第一个学生有三门课程，所以转换为一对多的数据结构后就变成了三条结果。那么Mybatis是怎么知道将5条数据中的哪三条给第一个学生呢？</p><p>理解Mybatis处理的规则对使用一对多配置是非常重要的，如果只是一知半解，很容易就会遇到各种莫名其妙的问题，所以针对Mybatis处理中的要点，下面进行一个详细的阐述。</p><p>Mybatis在处理结果的时候，会判断结果是否相同，如果是相同的的结果，则只会保留第一结果，所以这个问题的关键点就是Mybatis如何判断结果是否相同。</p><p>Mybatis判断是否相同时，最简单的情况就是在映射配置中至少有一个id标签，在studentMap中配置如下：</p><pre><code>&lt;id property=&#39;id&#39; column=&#39;id&#39;/&gt;</code></pre><p>我们对id（构造方法中为idArg）的理解一般是，它配置的字段为表的主键（联合主键时可以配置多个id标签），因为Mybatis的resultMap只用于配置结果如何映射，并不知道这个表具体如何。<font color="red">id的唯一作用就是嵌套的映射配置时判断数据是否相同</font>，当配置id标签时，Mybatis只需要比较所有数据中id标签配置字段值是否相同即可。在配置嵌套结果查询时，配置id标签可以提高处理效率。</p><p>这样一来，上面的查询就不难理解了。因为前三条数据的studentMap部分的id相同，所以它们属于同一个学生，因此这条数据会合并到同一个学生中。</p><p>为了让大家更清楚的理解id的作用，可以临时对studentMap的映射进行如下的修改：</p><pre><code>    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;!--&lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;--&gt;        &lt;id column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;!--&lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;--&gt;    &lt;/resultMap&gt;</code></pre><p>将stu_sex 设置为id元素，然后将数据库中的两个学生的stu_sex字段设置为相同的值。</p><p>然后执行测试：</p><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190314171115.png"></p><hr><p>我们能看到，变成了一个学生！！！学生信息保留的是第一个学生的信息，因此学生姓名为jack。</p><p>大家通过这个简单的例子应该明白id的作用了。需要注意的是，很有可能会出现一种没有配置id的情况。没有配置id时，Mybatis就会把resultMap中配置的所有字段进行比较，如果所有字段的值都相同就合并，只要有一个字段值不同，就不合并。</p><font color="red"><strong>提示：在嵌套结果配置时id属性时，如果查询语句中没有查询id属性配置的列，就会导致id对应的值为null。这种情况下，所有值的id都相同，因此会使嵌套的集合中只有一条数据。所以在配置id列时，查询语句中必须包含该列。</strong></font><hr><p>可以对studentMap再次修改，将id标签改为result：</p><pre><code>    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;!--&lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;--&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;!--&lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;--&gt;    &lt;/resultMap&gt;</code></pre><p>此时，已经不存id标签了，执行测试方法：</p><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190314172153.png"></p><p>发现此时的结果，与配置id标签时的结果相同。因为学生在studentMap这部分配置的属性都相同，因此合并。</p><p>虽然结果相同，但是由于Mybatis要对所有字段进行比较，因此字段数为M时，如果查询结果又N条，就需要进行M * N 次比较，相比配置id时的N次比较，效率相差更多，所以要尽可能配置id标签！！！</p><p>在studentMap比较完毕后，会接着比较studentLecture，如果不多，就会增加一个studentLecture对象，如果两个studentLecture相同就保留一个。假设studentLecture还有下一级，仍然按照该规则去比较。</p><hr><p>上面就是学生与课程成绩的一对多的映射配置，我们还有一个课程表与课程成绩表是一对一的映射，现在我们将这个映射也加上。</p><p>添加的POJO类：StudentLectureBean</p><pre><code>public class StudentLectureBean extends StudentLecture {    private Lecture lecture;    public Lecture getLecture() {        return lecture;    }    public void setLecture(Lecture lecture) {        this.lecture = lecture;    }}</code></pre><p>修改：StudentBean</p><pre><code>public class StudentBean extends Student {    //将List中类型修改为我们添加的POJO对象    List&lt;StudentLectureBean&gt; studentLectureList;    public List&lt;StudentLectureBean&gt; getStudentLectureList() {        return studentLectureList;    }    public void setStudentLectureList(List&lt;StudentLectureBean&gt; studentLectureList) {        this.studentLectureList = studentLectureList;    }}</code></pre><p>添加：LectureMapper.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.liuzhuo.mapper.LectureMapper&quot;&gt;    &lt;resultMap id=&quot;lectureMap&quot; type=&quot;lecture&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;lecture_name&quot; property=&quot;lectureName&quot;/&gt;    &lt;/resultMap&gt;&lt;/mapper&gt;</code></pre><p>在：StudentLectureMapper.xml 添加新的映射配置：</p><pre><code>    &lt;resultMap id=&quot;studentLectureMap02&quot; type=&quot;studentLectureBean&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;lecture_id&quot; property=&quot;lectureId&quot;/&gt;        &lt;result column=&quot;grade&quot; property=&quot;grade&quot;/&gt;        &lt;association property=&quot;lecture&quot; columnPrefix=&quot;lecture_&quot;                     resultMap=&quot;com.liuzhuo.mapper.LectureMapper.lectureMap&quot;/&gt;    &lt;/resultMap&gt;</code></pre><p>在 StudentMapper.xml 中修改：</p><pre><code>    &lt;resultMap id=&quot;studentBeanMap02&quot; type=&quot;studentBean&quot; extends=&quot;studentMap&quot;&gt;        &lt;!--student的基本信息--&gt;        &lt;!--studentLecture--&gt;        &lt;collection property=&quot;studentLectureList&quot; columnPrefix=&quot;studentLecture_&quot;                    resultMap=&quot;com.liuzhuo.mapper.StudentLectureMapper.studentLectureMap02&quot;&gt; &lt;!--修改为02了--&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;</code></pre><p>修改测试方法：</p><pre><code>    public void testSelectStudentBeanAll() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            List&lt;StudentBean&gt; studentBeanList = studentMapper.selectStudentBeanAll();            System.out.println(&quot;有:&quot; + studentBeanList.size() + &quot;个学生&quot;);            for (StudentBean studentBean : studentBeanList) {                System.out.println(&quot;学生名：&quot; + studentBean.getStuName());                for (StudentLectureBean studentLecture : studentBean.getStudentLectureList()) {                    System.out.println(&quot;课程Id：&quot; + studentLecture.getLectureId());                    System.out.println(&quot;课程的名字: &quot; + studentLecture.getLecture().getLectureName());                }            }        } finally {            sqlSession.close();        }    }</code></pre><p>运行结果：</p><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190314180033.png"></p><hr><p>虽然association和collection标签是分开介绍的，但是这两者可以组合使用或者互相嵌套使用，也可以使用符合自己需要的任何数据结构，不需要局限于数据库表之间的关系联系。</p><hr><h4 id="collection集合的嵌套查询"><a href="#collection集合的嵌套查询" class="headerlink" title="collection集合的嵌套查询"></a>collection集合的嵌套查询</h4><p>接着上一节的内容，我们来将上诉的collection嵌套结果映射改为嵌套查询。</p><p>StudentMapper接口：</p><pre><code>public List&lt;StudentBean&gt; selectStudentBeanAll02();</code></pre><p>StudentMapper.xml：</p><pre><code>    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;    &lt;/resultMap&gt;    &lt;resultMap id=&quot;studentBeanMap03&quot; type=&quot;studentBean&quot; extends=&quot;studentMap&quot;&gt;        &lt;collection property=&quot;studentLectureList&quot; fetchType=&quot;lazy&quot; column=&quot;{stuId = stu_id}&quot;                    select=&quot;com.liuzhuo.mapper.StudentLectureMapper.selectStudentLectureByStuId&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectStudentBeanAll02&quot; resultMap=&quot;studentBeanMap03&quot;&gt;        select        s.id,        s.stu_name,        s.stu_sex,        s.stu_id        from        student as s    &lt;/select&gt;</code></pre><p>StudentLectureMapper.xml:</p><pre><code>    &lt;resultMap id=&quot;studentLectureMap03&quot; type=&quot;studentLectureBean&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;lecture_id&quot; property=&quot;lectureId&quot;/&gt;        &lt;result column=&quot;grade&quot; property=&quot;grade&quot;/&gt;        &lt;association property=&quot;lecture&quot; fetchType=&quot;lazy&quot; column=&quot;{lectureId = lecture_id}&quot;                     select=&quot;com.liuzhuo.mapper.LectureMapper.selectLectureById&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectStudentLectureByStuId&quot; resultMap=&quot;studentLectureMap03&quot;&gt;         SELECT id , stu_id , lecture_id , grade from student_lecture where stu_id = #{stuId}    &lt;/select&gt;</code></pre><p>LectureMapper.xml:</p><pre><code>    &lt;resultMap id=&quot;lectureMap&quot; type=&quot;lecture&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;lecture_name&quot; property=&quot;lectureName&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectLectureById&quot; resultMap=&quot;lectureMap&quot;&gt;        SELECT id , lecture_name FROM lecture WHERE id = #{lectureId}    &lt;/select&gt;</code></pre><p>testSelectStudentBeanAll02测试方法：</p><pre><code>    public void testSelectStudentBeanAll02() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            List&lt;StudentBean&gt; studentBeanList = studentMapper.selectStudentBeanAll02();            System.out.println(&quot;有:&quot; + studentBeanList.size() + &quot;个学生&quot;);            for (StudentBean studentBean : studentBeanList) {                System.out.println(&quot;学生名：&quot; + studentBean.getStuName());                for (StudentLectureBean studentLecture : studentBean.getStudentLectureList()) {                    System.out.println(&quot;课程Id：&quot; + studentLecture.getLectureId());                    System.out.println(&quot;课程的名字: &quot; + studentLecture.getLecture().getLectureName());                }            }        } finally {            sqlSession.close();        }    }</code></pre><hr><p>运行测试结果：</p><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190314191100.png"><br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190314191130.png"><br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190314191147.png"></p><p>从结果可以看出，是按需发送SQL语句，然后获取数据的。</p><p>首先只是获取了学生的基本信息。</p><p>然后获取学生的课程成绩时，会发送第二条SQL语句，获取课程的id。</p><p>最后获取学生课程的名称时，会发送第三条SQL语句，获取课程的名称。</p><p>我们也可以发现，当获取第二个学生的时候，只是获取它的课程信息时发送了SQL语句，后面的课程名称没有发送SQL语句，因为在第一个学生那里已经发送过了，Mybatis会自动帮我们缓存，这个缓存的知识点，我们后面会讲到，大家不要急~~~</p><hr><h3 id="discriminator鉴别器"><a href="#discriminator鉴别器" class="headerlink" title="discriminator鉴别器"></a>discriminator鉴别器</h3><p>鉴别器级联是在特定的条件下去使用不同的POJO。比如本例中要了解学生的健康情况，如果是男生总不能去了解他的女性生理指标吧，这样就会闹出笑话了，同样女生也不能去了解男性的生理指标。这个时候就需要使用到鉴别器了。</p><hr><p>我们可以根据学生信息中的性别属性进行判断去关联男性的健康指标或者女性的健康指标，然后进行关联即可，在Mybatis中我们采用的是鉴别器discriminator，由它来处理这些需要鉴别的场景，它相当于Java语言中的switch语句。让我们来看看它是如何实现的。</p><p><code>discriminator</code>标签常用的两个属性如下：</p><ul><li><p>column：该属性用于设置要进行鉴别比较值的列。</p></li><li><p>javaType：该属性用于指定列的类型，保证使用相同的java类型来比较值。</p></li></ul><p><code>discriminator</code> 标签可以有1个或多个<code>case标签</code>，case标签包含以下三个属性：</p><ul><li><p>value：该值为discriminator指定column用来匹配的值。</p></li><li><p>resultMap：当column的值和value的值匹配时，可以配置使用resultMap指定的映射，resultMap优先级高于resulType。</p></li><li><p>resultType：当column的值和value的值匹配时，用于配置使用resultType指定的映射。</p></li></ul><p>case标签下面可以包含的标签和resultMap中一样，用法也一样。</p><hr><p>Student类：</p><pre><code>public class Student {    private Long id;  //学生编号    private String stuName; //学生姓名    private Integer stuSex;//性别    private Long stuId;//学生证号    ····省略get、set方法}</code></pre><hr><p>StudentBean类：</p><pre><code>public class StudentBean extends Student {    private List&lt;StudentLectureBean&gt; studentLectureList;    ····省略get、set方法}</code></pre><hr><p>StudentMaleHealth类：</p><pre><code>public class StudentMaleHealth {    private Long id;    private Long stuId;    private Date checkDate;    private String heart;    private String prostate;    ····省略get、set方法}</code></pre><hr><p>StudentFemaleHealth类：</p><pre><code>public class StudentFemaleHealth {    private Long id;    private Long stuId;    private Date checkDate;    private String heart;    private String uterus;    ····省略get、set方法}</code></pre><p><strong>上面的都是之前创建的POJO，现在开始创建新的POJO类：</strong></p><hr><p>MaleStudentBean类：</p><pre><code>public class MaleStudentBean extends StudentBean {    private StudentMaleHealth studentMaleHealth;    ····省略get、set方法}</code></pre><hr><p>FemaleStudentBean类：</p><pre><code>public class FemaleStudentBean extends StudentBean {    private StudentFemaleHealth studentFemaleHealth;    ····省略get、set方法}</code></pre><hr><p>StudentMapper.xml文件：</p><pre><code>    &lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_name&quot; property=&quot;stuName&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;stu_sex&quot; property=&quot;stuSex&quot;/&gt;    &lt;/resultMap&gt;    &lt;resultMap id=&quot;studentBeanMap04&quot; type=&quot;studentBean&quot; extends=&quot;studentMap&quot;&gt;        &lt;collection property=&quot;studentLectureList&quot; fetchType=&quot;lazy&quot; column=&quot;{stuId = stu_id}&quot;                    select=&quot;com.liuzhuo.mapper.StudentLectureMapper.selectStudentLectureByStuId&quot;/&gt;        &lt;discriminator javaType=&quot;int&quot; column=&quot;stu_sex&quot;&gt;            &lt;case value=&quot;1&quot; resultMap=&quot;maleStudentMap&quot;/&gt;            &lt;case value=&quot;2&quot; resultMap=&quot;femaleStudentMap&quot;/&gt;        &lt;/discriminator&gt;    &lt;/resultMap&gt;    &lt;resultMap id=&quot;maleStudentMap&quot; type=&quot;maleStudentBean&quot; extends=&quot;studentMap&quot;&gt;        &lt;association property=&quot;studentMaleHealth&quot; fetchType=&quot;lazy&quot; column=&quot;{stuId = stu_id}&quot;                     select=&quot;com.liuzhuo.mapper.StudentMaleHealthMapper.selectStudentMaleHealthByStuId&quot;/&gt;        &lt;collection property=&quot;studentLectureList&quot; fetchType=&quot;lazy&quot; column=&quot;{stuId = stu_id}&quot;                    select=&quot;com.liuzhuo.mapper.StudentLectureMapper.selectStudentLectureByStuId&quot;/&gt;    &lt;/resultMap&gt;    &lt;resultMap id=&quot;femaleStudentMap&quot; type=&quot;femaleStudentBean&quot; extends=&quot;studentMap&quot;&gt;        &lt;association property=&quot;studentFemaleHealth&quot; fetchType=&quot;lazy&quot; column=&quot;{stuId = stu_id}&quot;                     select=&quot;com.liuzhuo.mapper.StudentFemaleHealthMapper.selectStudentFemaleHealthByStuId&quot;/&gt;        &lt;collection property=&quot;studentLectureList&quot; fetchType=&quot;lazy&quot; column=&quot;{stuId = stu_id}&quot;                    select=&quot;com.liuzhuo.mapper.StudentLectureMapper.selectStudentLectureByStuId&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectStudentBeanAll03&quot; resultMap=&quot;studentBeanMap04&quot;&gt;        select        s.id,        s.stu_name,        s.stu_sex,        s.stu_id        from        student as s    &lt;/select&gt;</code></pre><hr><p>StudentMaleHealthMapper.xml文件：</p><pre><code>&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentMaleHealthMapper&quot;&gt;    &lt;resultMap id=&quot;studentMaleHealthMap&quot; type=&quot;studentMaleHealth&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;check_date&quot; property=&quot;checkDate&quot;/&gt;        &lt;result column=&quot;heart&quot; property=&quot;heart&quot;/&gt;        &lt;result column=&quot;prostate&quot; property=&quot;prostate&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectStudentMaleHealthByStuId&quot; resultMap=&quot;studentMaleHealthMap&quot;&gt;        SELECT id , stu_id ,check_date,heart,prostate FROM student_male_health WHERE stu_id = #{stuId}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><hr><p>StudentFemaleHealthMapper.xml文件：</p><pre><code>&lt;mapper namespace=&quot;com.liuzhuo.mapper.StudentFemaleHealthMapper&quot;&gt;    &lt;resultMap id=&quot;studentFemaleHealthMap&quot; type=&quot;studentFemaleHealth&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;stu_id&quot; property=&quot;stuId&quot;/&gt;        &lt;result column=&quot;check_date&quot; property=&quot;checkDate&quot;/&gt;        &lt;result column=&quot;heart&quot; property=&quot;heart&quot;/&gt;        &lt;result column=&quot;uterus&quot; property=&quot;uterus&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectStudentFemaleHealthByStuId&quot; resultMap=&quot;studentFemaleHealthMap&quot;&gt;        SELECT id , stu_id ,check_date,heart,uterus FROM student_female_health WHERE stu_id = #{stuId}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><hr><p>StudentMapper接口：</p><pre><code>public List&lt;StudentBean&gt; selectStudentBeanAll03();</code></pre><p>这里返回的是<code>StudentBean</code>类型，因为 MaleStudentBean、FemaleStudentBean都是它的子类。</p><hr><p>MainTest类：</p><pre><code>    public void testSelectStudentBeanAll03() {        SqlSession sqlSession = sqlSessionFactory.openSession();        try {            StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);            List&lt;StudentBean&gt; studentBeanList = studentMapper.selectStudentBeanAll03();            System.out.println(&quot;有:&quot; + studentBeanList.size() + &quot;个学生&quot;);            for (StudentBean studentBean : studentBeanList) {                System.out.println(&quot;学生名：&quot; + studentBean.getStuName());                System.out.println(&quot;学生的性别：&quot; + studentBean.getStuSex());                //判断是哪个类型的学生类型                if (studentBean instanceof MaleStudentBean) {                    MaleStudentBean maleStudentBean = (MaleStudentBean) studentBean;                    System.out.println(maleStudentBean.getStudentMaleHealth().getHeart());                    System.out.println(maleStudentBean.getStudentMaleHealth().getProstate());                } else if (studentBean instanceof FemaleStudentBean) {                    FemaleStudentBean femaleStudentBean = (FemaleStudentBean) studentBean;                    System.out.println(femaleStudentBean.getStudentFemaleHealth().getHeart());                    System.out.println(femaleStudentBean.getStudentFemaleHealth().getUterus());                } else {                    System.out.println(&quot;没有映射成功!!!&quot;);                }                for (StudentLectureBean studentLecture : studentBean.getStudentLectureList()) {                    System.out.println(&quot;课程Id：&quot; + studentLecture.getLectureId());                    System.out.println(&quot;课程的名字: &quot; + studentLecture.getLecture().getLectureName());                }            }        } finally {            sqlSession.close();        }    }</code></pre><p>上面通过：<code>studentBean instanceof MaleStudentBean</code> 来判断Mybatis帮我们返回的具体类型是哪个。</p><hr><p>测试结果：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190315110511.png"></p><p>当判断具体是哪个类型时，再发生SQL语句，查询具体的信息：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190315110619.png"></p><p>当要获取学生的课程成绩时，再发生SQL语句：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190315110738.png"></p><p>当要获取学生的课程名是，再发生SQL语句：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190315110819.png"></p><p>接下来就是类似的操作了：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190315110934.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190315110953.png"></p><hr><font color="red">鉴别器是一种很少使用的方式，在使用之前一定要完全掌握，没有把握的情况下尽可能避免使用。</font>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中的resultMap</title>
      <link href="/2019/03/13/mybatis-zhong-de-resultmap/"/>
      <url>/2019/03/13/mybatis-zhong-de-resultmap/</url>
      
        <content type="html"><![CDATA[<p>resultMap是Mybatis里面最为复杂的元素，所以单独来讲解。</p><p>resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来, 并在一些情形下允许你做一些 JDBC 不支持的事情。 实际上，在对复杂语句进行联合映射的时候，它很可能可以代替数千行的同等功能的代码。 ResultMap 的设计思想是，简单的语句不需要明确的结果映射，而复杂一点的语句只需要描述它们的关系就行了。</p><hr><h3 id="resultMap元素构成"><a href="#resultMap元素构成" class="headerlink" title="resultMap元素构成"></a>resultMap元素构成</h3><p>resultMap元素里面还有以下的元素：</p><pre><code>&lt;resultMap&gt;    &lt;constructor&gt;    &lt;idArg/&gt;    &lt;arg/&gt;    &lt;/constructor&gt;    &lt;id/&gt;    &lt;result/&gt;    &lt;association/&gt;    &lt;collection/&gt;    &lt;discriminator&gt;        &lt;case/&gt;    &lt;/discriminator&gt;&lt;/resultMap&gt;</code></pre><p>resultMap元素的属性：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313100156.png"></p><p>下一部分将详细说明每个元素。</p><hr><p> constructor</p><p>其中 constructor 元素用于配置构造方法。</p><p><strong><code>一个POJO可能不存在没有参数的构造方法，这个时候我们就需要使用 constructor 进行配置。</code></strong></p><p>假设角色类RoleBean不存在没有参数的构成方法，它的构造方法声明为 <code>public RoleBean(Integer id,String roleName)</code></p><p>那么，我们需要配置如下的 resultMap：</p><pre><code>&lt;resultMap&gt;    &lt;constructor&gt;        &lt;idArg column = &quot;id&quot; javaType=&quot;int&quot;/&gt;        &lt;arg column=&quot;role_name&quot; javaType=&quot;string&quot;/&gt;    &lt;/constructor&gt;&lt;/resultMap&gt;</code></pre><p>这样Mybatis就知道需要使用这个构造方法来构造POJO了。</p><p><code>idArg</code>: 表示哪个列是主键，<code>arg</code>：表示普通列表元素。</p><hr><h4 id="id和result"><a href="#id和result" class="headerlink" title="id和result"></a>id和result</h4><p><code>id</code>元素是表示哪个列是主键，允许有多个主键，多个主键则称为联合主键。</p><p><code>result</code>元素是配置其他的SQL列名到POJO的映射关系。</p><p>两者的一些属性：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190313095715.png"></p><hr><p>此外的 <code>&lt;association/&gt;、&lt;collection/&gt;、&lt;discriminator&gt;</code> 这些元素，我们在级联那里详细介绍。</p><hr><h3 id="使用map存储结果集"><a href="#使用map存储结果集" class="headerlink" title="使用map存储结果集"></a>使用map存储结果集</h3><p>一般而言，任何的select语句都可以使用map存储，如下：</p><pre><code>&lt;select id=&quot;findColorByNote&quot; parameterType=&quot;string&quot; reslutMap=&quot;map&quot;&gt;     select id ,color,note from t_color where note like concat(&#39;%&#39;,#{note},&#39;%&#39;)&lt;/select&gt;</code></pre><p>使用map原则上是可以匹配所有结果集的，但是使用map接口就意味着可读性下降，所以这不是一种推荐的方式。更多的时候我们使用的是POJO的方式。</p><hr><h3 id="使用POJO存储结果集"><a href="#使用POJO存储结果集" class="headerlink" title="使用POJO存储结果集"></a>使用POJO存储结果集</h3><p>POJO是我们常用的方式，也是我们推荐的方式。</p><p>一方面我们可以使用自动映射，正如 select 语句里论述的一样。</p><p>另一方面，我们还可以使用 select 语句的属性 resultMap配置映射集合，只是使用前需要配置类似的resultMap。</p><pre><code>&lt;resultMap id=&quot;roleResultMap&quot; type=&quot;role&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt;&lt;/resultMap&gt;</code></pre><p>resultMap元素的属性 id 代表这个 resultMap的标识，type代表着你需要映射的POJO（可以使用定义好的别名）。</p><p>映射关系中，id 元素：表示这个对象的主键，property代表着POJO的属性名称，column表示数据库SQL的列名，于是POJO就和数据库SQL的结果一一对应起来了。</p><p>接着在 select元素 里面使用即可：</p><pre><code>&lt;select id=&quot;getRole&quot; parameterType=&quot;long&quot; reslutMap=&quot;roleResultMap&quot;&gt;     select id , role_name , note from t_role where id = #{id}&lt;/select&gt;</code></pre><p>我们可以发现<code>SQL语句的列名</code> 和 <code>roleResultMap的column</code> 是一一对应的。</p><p>使用XML配置的结果集，还可以配置 typeHandler、javaType、jdbcType。</p><font color="red">但是这条语句配置了resultMap，就不要配置resultType。</font>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中的Mapper映射器</title>
      <link href="/2019/03/11/mybatis-zhong-de-mapper-ying-she-qi/"/>
      <url>/2019/03/11/mybatis-zhong-de-mapper-ying-she-qi/</url>
      
        <content type="html"><![CDATA[<p>映射器是Mybatis最强大的工具，也是我们使用Mybatis时用得最多的工具，因此熟练掌握它十分必要。</p><p>MyBatis 的真正强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 就是针对 SQL 构建的，并且比普通的方法做的更好。</p><p>SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）：</p><ul><li><p>cache – 给定命名空间的缓存配置。</p></li><li><p>cache-ref – 其他命名空间缓存配置的引用。</p></li><li><p>resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</p></li><li><p>parameterMap – 已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。</p></li><li><p>sql – 可被其他语句引用的可重用语句块。</p></li><li><p>insert – 映射插入语句</p></li><li><p>update – 映射更新语句</p></li><li><p>delete – 映射删除语句</p></li><li><p>select – 映射查询语句</p></li></ul><p>下一部分将从语句本身开始来描述每个元素的细节。</p><hr><h3 id="select元素"><a href="#select元素" class="headerlink" title="select元素"></a>select元素</h3><p>查询语句是 MyBatis 中最常用的元素之一，光能把数据存到数据库中价值并不大，如果还能重新取出来才有用，多数应用也都是查询比修改要频繁。对每个插入、更新或删除操作，通常对应多个查询操作。这是 MyBatis 的基本原则之一，也是将焦点和努力放到查询和结果映射的原因。简单查询的 select 元素是非常简单的。比如：</p><pre><code>&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt;  SELECT * FROM PERSON WHERE ID = #{id}&lt;/select&gt;</code></pre><p>这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p><p>注意参数符号：<br><code>#{id}</code></p><p>这就告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p><pre><code>// Similar JDBC code, NOT MyBatis…String selectPerson = &quot;SELECT * FROM PERSON WHERE ID=?&quot;;PreparedStatement ps = conn.prepareStatement(selectPerson);ps.setInt(1,id);</code></pre><p>当然，这需要很多单独的 JDBC 的代码来提取结果并将它们映射到对象实例中，这就是 MyBatis 节省你时间的地方。我们需要深入了解参数和结果映射，细节部分我们下面来了解。</p><p>select 元素有很多属性允许你配置，来决定每条语句的作用细节。</p><pre><code>&lt;select  id=&quot;selectPerson&quot;  parameterType=&quot;int&quot;  parameterMap=&quot;deprecated&quot;  resultType=&quot;hashmap&quot;  resultMap=&quot;personResultMap&quot;  flushCache=&quot;false&quot;  useCache=&quot;true&quot;  timeout=&quot;10000&quot;  fetchSize=&quot;256&quot;  statementType=&quot;PREPARED&quot;  resultSetType=&quot;FORWARD_ONLY&quot;&gt;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190311135926.png"></p><h4 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h4><p>在简单的场景下，MyBatis可以替你自动映射查询结果。如果遇到复杂的场景，你需要构建一个resultMap，resultMap之后介绍。</p><p>有这样一个参数autoMappingBehavior，当它不设置为NONE的时候，只要返回的SQL列名和POJO对象的属性名一致（忽略大小写），Mybatis就会帮助我们回填这些字段而无需任何配置，它可以在很大程度上简化我们的配置工作。</p><p>在实际工作中，大部分数据库规范都是要求大写单词命名，单词间用下划线分隔，而java则是使用驼峰命名法，于是可以使用列的别名来使得Mybatis自动映射，或者直接在配置文件中开启驼峰命名方式。</p><p>让我们来看一个简单的例子，体验一下自动映射的好处。</p><p>javaBean:</p><pre><code>public class Role{   private Long id;   private String roleName;   private String note;   ···set、get、toString方法}</code></pre><p>数据库表（T_ROLE）</p><pre><code>字段        类型ID          INT(20)ROLE_NAME   VACHAR(60)NOTE        VARCHAR(1024)</code></pre><p>让我们编写Mapper的映射语句：</p><pre><code>&lt;select id=&quot;getRole&quot; parameterType=&quot;long&quot; resultType=&quot;role&quot;&gt;     select id, role_name as roleName, note from t_role where id = #{id}&lt;/select&gt;</code></pre><p>RoleMapper接口：</p><pre><code>public Role getRole(Long id);</code></pre><p>虽然数据中的列名和javaBean的属性名不是一一对应，但是我们在查询语句中使用了 <code>as</code> 别名，让它们一致了，所以Mybatis会自动帮我们映射。</p><hr><p>自动映射可以在 <code>settings元素</code> 中配置 autoMapperBehavior属性值来设置其策略，它含有三个值：</p><ul><li><p>NONE，取消自动映射。仅设置手动映射属性。</p></li><li><p>PARTIAL，只会自动映射，没有定义嵌套结果映射的结果集</p></li><li><p>FULL，会自动映射任意复杂的结果集（无论是否嵌套）</p></li></ul><p><strong>默认值是PARTIAL</strong>，当使用FULL时，自动映射会在处理join结果时执行，并且join取得若干相同行的不同实体数据，因此这可能导致非预期的映射。</p><p>下面的例子将展示这种风险：</p><pre><code>&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;  select    B.id,    B.title,    A.username,  from Blog B left outer join Author A on B.author_id = A.id  where B.id = #{id}&lt;/select&gt;</code></pre><pre><code>&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;  &lt;association property=&quot;author&quot; resultMap=&quot;authorResult&quot;/&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt;  &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;&lt;/resultMap&gt;</code></pre><p>在结果中Blog和Author均将自动映射。但是注意Author有一个id属性，在ResultSet中有一个列名为id， 所以Author的id将被填充为Blog的id，这不是你所期待的。所以需要谨慎使用FULL。</p><p>通过添加autoMapping属性可以忽略自动映射等级配置，你可以启用或者禁用自动映射指定的ResultMap。</p><pre><code>&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot; autoMapping=&quot;false&quot;&gt;  &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt;&lt;/resultMap&gt;</code></pre><hr><p>如果你的数据库是规范命名的，即每个单词之间用下划线隔开，javaBean采用驼峰命名法，那么你可以使用设置 <code>mapUnderscoreToCamelCase = true</code>,这样不用使用 <code>as</code>来重新命名列名 , Mybatis也会帮我们自动映射的。</p><h4 id="传递多个参数"><a href="#传递多个参数" class="headerlink" title="传递多个参数"></a>传递多个参数</h4><p>之前的例子，我们都是传递一个参数，但是，更多的时候我们需要传递多个参数给映射器。</p><h5 id="使用Map传递多个参数"><a href="#使用Map传递多个参数" class="headerlink" title="使用Map传递多个参数"></a>使用Map传递多个参数</h5><pre><code>    &lt;select id=&quot;selectByMap&quot; parameterType=&quot;map&quot; resultMap=&quot;userMap&quot;&gt;        select userId,user_age ,user_name ,user_sex  from user where userId = #{id} and user_age=#{userAge}    &lt;/select&gt;</code></pre><p>这里，parameterType = “map”，说明参数是Map类型的。</p><pre><code>public interface UserMapper {    User selectByMap(Map&lt;String,String&gt; map);}</code></pre><pre><code>    sqlSession = SqlSessionFactoryUtil.openSqlSession();    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    Map&lt;String ,String &gt; userMap = new HashMap&lt;&gt;();    userMap.put(&quot;id&quot;,&quot;1&quot;);    userMap.put(&quot;userAge&quot;,&quot;18&quot;);    User user = userMapper.selectByMap(userMap);    System.out.println(user);</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190311144413.png"></p><p>使用Map来传递多个参数的话，<font color="red">Map中的键名，必须和SQL语句中的：#{XXX}中的XXX一致才行。</font></p><p>这里就是 id 和 userAge，现在我们修改一下，传递给Map的键名，将 userAge 变成 user_age.<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190311144942.png"></p><hr><p>使用Map传递多个参数的缺点：因为参数是封装在Map中的，由于业务关联性不强，你需要深入到程序中看代码，造成可读性下降。</p><h5 id="使用注解的方式"><a href="#使用注解的方式" class="headerlink" title="使用注解的方式"></a>使用注解的方式</h5><p>我们需要使用Mybatis的参数注解@Param(org.apache.ibatis.annotations.Param)来实现想要的功能。</p><pre><code>User selectByAnnotation(@Param(&quot;id&quot;) String userId, @Param(&quot;userAge&quot;) long useAge);</code></pre><pre><code>&lt;select id=&quot;selectByMap&quot; parameterType=&quot;map&quot; resultMap=&quot;userMap&quot;&gt;    select userId,user_age ,user_name ,user_sex  from user     where userId = #{id} and user_age = #{userAge}&lt;/select&gt;</code></pre><p>这样，Mybatis会把 @Param(“xxx”) 代表的值，传递给 SQL语句中的 #{xxx}.</p><p>这样可读性性增强了，但是当需要传递的参数过多的时候，那么我们会写很多的@Param注解，麻烦。</p><h5 id="使用javaBean的方式"><a href="#使用javaBean的方式" class="headerlink" title="使用javaBean的方式"></a>使用javaBean的方式</h5><p>当参数过多的时候，Mybatis允许组织一个JavaBean，通过简单的 setter 和 getter 方法设置参数，这样就可以提高我们的可读性。</p><p>首先定义一个javaBean对象：</p><pre><code>public class User {    private String userId;    private Long userAge;    private String userName;    private Sex userSex;    ····set、get方法}</code></pre><pre><code>&lt;select id=&quot;selectByMap&quot; parameterType=&quot;com.liuzhuo.entities.User&quot; resultMap=&quot;userMap&quot;&gt;    select userId,user_age ,user_name ,user_sex  from user     where userId = #{id} and user_age = #{userAge}&lt;/select&gt;</code></pre><p>这里，parameterType为javaBean的全限定名，如果你配置了别名的话，就直接使用别名也行，更方便。</p><pre><code>public User selectByUser(User user);</code></pre><hr><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><p>使用Map传递参数。因为Map导致业务可读性差，从而导致后续扩展和维护的困难，我们应该在实际开发中废弃这样的方式</p></li><li><p>使用@Param注解，这个方式适合于参数不多的情况下（参数&lt;=5）</p></li><li><p>javaB的方式，适合于参数过多的情况</p></li></ul><hr><h4 id="resultMap映射结果集"><a href="#resultMap映射结果集" class="headerlink" title="resultMap映射结果集"></a>resultMap映射结果集</h4><p>在自动映射章节，我们使用的是 <code>resultType=javaBean的全限定名</code> 来完成自动映射的，但是某些时候，我们需要处理更多复杂的映射。</p><p>resultMap为我们提供了这样的模式，使用resultMap之前，我们需要首先定义它：</p><pre><code>    &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt;        &lt;id column=&quot;userId&quot; property=&quot;userId&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;        &lt;result column=&quot;user_age&quot; property=&quot;userAge&quot;/&gt;        &lt;!--定义结果类型转化器标识，才能使用类型转换器--&gt;        &lt;result column=&quot;user_name&quot; property=&quot;userName&quot; typeHandler=&quot;com.liuzhuo.typehandler.MyStringTypehandler&quot;/&gt;        &lt;!--新添加的字段--&gt;        &lt;result column=&quot;user_sex&quot; property=&quot;userSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectById&quot; parameterType=&quot;string&quot; resultMap=&quot;userMap&quot;&gt;        select userId,user_age ,user_name ,user_sex  from user where userId = #{id}    &lt;/select&gt;</code></pre><p><strong><code>使用&lt;resultMap&gt;标签来定义，然后在&lt;select&gt;标签中使用 resultMap = 在&lt;resultMap&gt;中定义的id 即可</code>。</strong></p><p>解释一下resultMap的配置：</p><ul><li><p>id是resultMap的唯一标识，用type属性去定义它对应的是哪个javaBean（可以使用别名）</p></li><li><p>通过<code>&lt;id&gt;元素</code>定义这个对象的主键，column：列名，property：属性名</p></li><li><p>通过<code>&lt;result&gt;元素</code>定义普通列的映射关系，column：列名，property：属性名</p></li><li><p>这样select语句就不再需要使用自动映射规则了，直接使用resultMap属性指定的userMap即可，这样Mybatis就会使用这个自定义的映射规则了。</p></li></ul><p>javaType，jdbcType，typeHandler是用来指定TypeHandler的，之前我们就讲过，现在应该有点感觉了吧~~~</p><p>resultMap是映射器中最为复杂的元素，它一般用于复杂、级联这些关联的配置，后面会单独来讲解，这样就简单了解一下。</p><hr><h3 id="insert元素"><a href="#insert元素" class="headerlink" title="insert元素"></a>insert元素</h3><p>insert元素，相对于select元素而言简单许多了。Mybatis执行insert后会返回一个整数，代表插入到数据库的行数。<br>update、delete类似。</p><pre><code>&lt;insert  id=&quot;insertAuthor&quot;  parameterType=&quot;domain.blog.Author&quot;  flushCache=&quot;true&quot;  statementType=&quot;PREPARED&quot;  keyProperty=&quot;&quot;  keyColumn=&quot;&quot;  useGeneratedKeys=&quot;&quot;  timeout=&quot;20&quot;&gt;&lt;update  id=&quot;updateAuthor&quot;  parameterType=&quot;domain.blog.Author&quot;  flushCache=&quot;true&quot;  statementType=&quot;PREPARED&quot;  timeout=&quot;20&quot;&gt;&lt;delete  id=&quot;deleteAuthor&quot;  parameterType=&quot;domain.blog.Author&quot;  flushCache=&quot;true&quot;  statementType=&quot;PREPARED&quot;  timeout=&quot;20&quot;&gt;</code></pre><p>详细介绍：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190311153037.png"></p><font color="red">注意：keyProperty 和 keyColumn不能同时使用，keyProperty表示以哪个列名作为属性的主键，keyColumn是表示哪一列，接受的是整数！！</font><hr><p>简单使用：</p><pre><code>    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;user&quot;&gt;        INSERT INTO user(userId,user_age,user_name,user_sex)        VALUES (#{userId},#{userAge},#{userName},#{userSex,typeHandler=com.liuzhuo.typehandler.SexEnumTypeHandler})    &lt;/insert&gt;</code></pre><hr><h4 id="主键回填和自定义"><a href="#主键回填和自定义" class="headerlink" title="主键回填和自定义"></a>主键回填和自定义</h4><p>现实中有许多我们需要处理的问题，例如，主键自增字段；MySql里面的主键需要根据一些特殊的规则去生成，在插入后我们往往需要获取到这个主键，以便未来的操作，而Mybatis提供了实现的方法。</p><p>首先，我们可以使用 keyProperty 属性指定哪个是主键字段，同时使用 useGeneratedKeys属性告诉Mybatis这个主键是否使用数据库内置策略生成。</p><pre><code>    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;user&quot;            useGeneratedKeys=&quot;true&quot; keyColumn=&quot;userId&quot;&gt;        INSERT INTO user(user_age,user_name,user_sex)        VALUES (#{userAge},#{userName},#{userSex,typeHandler=com.liuzhuo.typehandler.SexEnumTypeHandler})    &lt;/insert&gt;</code></pre><p>这样，我们传入的user对象，就不需要设置userId的值了，Mybatis会用数据库的设置进行处理。这样做的好处是在Mybatis插入的时候，它会回填javaBean的id值。</p><p><strong>以上成功的前提是数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server）</strong></p><hr><p>对于不支持自动生成类型的数据库或可能不支持自动生成主键的 JDBC 驱动，MyBatis 有另外一种方法来生成主键。</p><p>这里有一个简单示例，表中没有记录 id就为 1，否则为最大的 id + 2：</p><pre><code>&lt;insert id=&quot;inserUser&quot; parameterType=&quot;user&quot; keyColumn=&quot;userId&quot;&gt;  &lt;selectKey keyProperty=&quot;userId&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;    select if( max(user_id) is null , 1 , max(user_id) + 2 ) as newId from user  &lt;/selectKey&gt;  insert into user    (user_id, user_name, user_age,user_sex)  values    (#{userId}, #{userName}, #{userAge}, #{userSex})&lt;/insert&gt;</code></pre><p>在上面的示例中，selectKey 元素将会首先运行，User 的 userId 会被设值，然后插入语句会被调用。这给你了一个和数据库中来处理自动生成的主键类似的行为，避免了使 Java 代码变得复杂。</p><hr><p>selectKey 元素描述如下：</p><pre><code>&lt;selectKey  keyProperty=&quot;id&quot;  resultType=&quot;int&quot;  order=&quot;BEFORE&quot;  statementType=&quot;PREPARED&quot;&gt;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190311155900.png"></p><hr><h3 id="update-delete"><a href="#update-delete" class="headerlink" title="update/delete"></a>update/delete</h3><p>这个两个元素比较简单，所以放在一起讨论，和insert元素一样，Mybatis执行update、delete元素后会返回一个整数，标出执行后影响的记录条数。</p><pre><code>&lt;update id=&quot;updateUser&quot;&gt;  update user set    user_name = #{userName},    user_age = #{userAge},  where id = #{id}&lt;/update&gt;&lt;delete id=&quot;deleteUser&quot;&gt;  delete from user where user_id = #{userId}&lt;/delete&gt;</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>正如你所见，我们可以传入一个简单的参数，比如int、double等，也可以传入javaBean，这些我们都讨论过了，有时候我们需要处理一个特殊的情况，我们可以指定特定的类型，以确定使用哪个typeHandler处理它们，以便我们进行特殊的处理。</p><pre><code>#{ age, javaType=int , jdbcType = NUMERIC }</code></pre><p>当然，我们还可以指定用哪个typeHandler去处理参数</p><pre><code>#{ age, javaType=int , jdbcType = NUMERIC , typeHandler = MyTypeHandler}</code></pre><p>此外，我们还可以对一些数值型的参数设置其保存的精度</p><pre><code>#{ price , javaType= double , jdbcType = NUMERIC , numericScale = 2}</code></pre><p>可见Mybatis映射器可以通过EL的功能帮助完成我们所需要的多种的功能，使用还是很方便的。</p><hr><h4 id="特殊字符串处理-和"><a href="#特殊字符串处理-和" class="headerlink" title="特殊字符串处理(#和$)"></a>特殊字符串处理(#和$)</h4><p>在Mybatis中，我们常常传递字符串，我们设置的参数 #{name} 在大部分的情况下Mybatis会用创建<strong>预编译的语句</strong>，然后Mybatis为它设值，而有时候我们需要的是传递SQL语句本身，而不是SQL所需要的参数。</p><p>例如，在一些动态表格中，我们需要传递SQL的列名，根据某些列进行排序，或者传递列名给SQL都是比较常见的场景，当然Mybatis也对这样的场景进行了支持，这些是Hibernate难以做到的。</p><p>例如，在程序中传递变量 columns = “ col1 , col2 , col3 …” 给SQL，让其组装成为SQL语句。我们当然不想被Mybatis像处理普通参数一样把它设为” col1.col2,col3…”，那么我们就可以写成如下语句。</p><pre><code> select ${columns} from t tablename</code></pre><p>这样Mybatis就不会帮我们转译 columns，而变为 <strong>直出</strong> ，而不是作为SQL的参数进行设置了。只是这样是对SQL而言是不安全的，Mybatis给了你灵活性的同时，也需要你自己去控制参数以保证SQL运转的正确性和安全性。</p><h3 id="sql元素"><a href="#sql元素" class="headerlink" title="sql元素"></a>sql元素</h3><p>这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。它可以被静态地(在加载参数) 参数化. 不同的属性值通过包含的实例变化. 比如：</p><pre><code>&lt;sql id=&quot;userColumns&quot;&gt; ${alias}.id , ${alias}.username , ${alias}.password &lt;/sql&gt;</code></pre><p>这个 SQL 片段可以被包含在其他语句中，例如：</p><pre><code>&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;  select    &lt;include refid=&quot;userColumns&quot;&gt;            &lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;    &lt;/include&gt;,    &lt;include refid=&quot;userColumns&quot;&gt;            &lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt;    &lt;/include&gt;  from some_table t1 cross join some_table t2&lt;/select&gt;</code></pre><p>属性值也可以被用在 include 元素的 refid 属性里（</p><p><code>&lt;include refid=&quot;${include_target}&quot;/&gt;</code> )</p><p>或者 include 内部语句中（</p><p><code>${prefix}Table</code> )</p><p>例如：</p><pre><code>&lt;sql id=&quot;sometable&quot;&gt;  ${prefix}Table&lt;/sql&gt;&lt;sql id=&quot;someinclude&quot;&gt;  from    &lt;include refid=&quot;${include_target}&quot;/&gt;&lt;/sql&gt;&lt;select id=&quot;select&quot; resultType=&quot;map&quot;&gt;  select    field1, field2, field3  &lt;include refid=&quot;someinclude&quot;&gt;    &lt;property name=&quot;prefix&quot; value=&quot;Some&quot;/&gt;    &lt;property name=&quot;include_target&quot; value=&quot;sometable&quot;/&gt;  &lt;/include&gt;&lt;/select&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中的主配置文件02</title>
      <link href="/2019/03/10/mybatis-zhong-de-zhu-pei-zhi-wen-jian-02/"/>
      <url>/2019/03/10/mybatis-zhong-de-zhu-pei-zhi-wen-jian-02/</url>
      
        <content type="html"><![CDATA[<p>此篇博客，接着上篇博客的内容，继续讲解Mybatis-config.xml配置文件</p><h3 id="environments-配置环境"><a href="#environments-配置环境" class="headerlink" title="environments(配置环境)"></a>environments(配置环境)</h3><p>配置环境可以注册多个数据源（dataSource），每个一个数据源又可以分为两大部分：一个是数据库源的配置，另外一个是数据库事务（transactionManager）的配置。</p><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者共享相同 Schema 的多个生产数据库， 想使用相同的 SQL 映射。许多类似的用例。</p><p><strong>不过要记住：尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一。</strong></p><p>所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单：</p><p><strong>每个数据库对应一个 SqlSessionFactory 实例</strong></p><p>为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：</p><pre><code>SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);</code></pre><p>如果忽略了环境参数，那么默认环境将会被加载，如下所示：</p><pre><code>SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties);</code></pre><p>环境元素定义了如何配置环境。</p><pre><code>&lt;environments default=&quot;development&quot;&gt;  &lt;environment id=&quot;development&quot;&gt;    &lt;transactionManager type=&quot;JDBC&quot;&gt;      &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;    &lt;/transactionManager&gt;    &lt;dataSource type=&quot;POOLED&quot;&gt;      &lt;property name=&quot;driver&quot;   value=&quot;${driver}&quot;/&gt;      &lt;property name=&quot;url&quot;      value=&quot;${url}&quot;/&gt;      &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;      &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;    &lt;/dataSource&gt;  &lt;/environment&gt;&lt;/environments&gt;</code></pre><p>注意这里的关键点：</p><ul><li><p>environments中的属性default，表明了在缺省的情况下，我们将启动哪个数据源配置</p></li><li><p>environment元素是配置一个数据源的开始，属性id是设置这个数据源的标志，以便Mybatis在上下文中使用它</p></li><li><p>transactionManager 配置的是数据库事务</p></li><li><p>dataSource 是配置数据源连接的信息</p></li></ul><h4 id="事务管理器-transactionManager"><a href="#事务管理器-transactionManager" class="headerlink" title="事务管理器(transactionManager)"></a>事务管理器(transactionManager)</h4><p>在 MyBatis 中有两种类型的事务管理器（也就是 type= “ [JDBC|MANAGED] “）：</p><ul><li><p>JDBC，采用的是JDBC方式的管理，直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。</p></li><li><p>MANAGED，采用是容器方式管理事务，在JNDI数据源中常用</p></li></ul><p>MANAGED – 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。例如:</p><pre><code>&lt;transactionManager type=&quot;MANAGED&quot;&gt;  &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;&lt;/transactionManager&gt;</code></pre><p>property元素则是可以配置数据源的各类属性，比如配置不自动提交：</p><pre><code>&lt;transactionManager type=&quot;JDBC&quot;&gt;  &lt;property name=&quot;autoCommit&quot; value=&quot;false&quot;/&gt;&lt;/transactionManager&gt;</code></pre><hr><p>这两种事务管理器类型都不需要任何属性。它们不过是类型别名，换句话说，你可以使用 TransactionFactory 接口的实现类的完全限定名或类型别名代替它们。</p><pre><code>public interface TransactionFactory {  void setProperties(Properties props);    Transaction newTransaction(Connection conn);  Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);  }</code></pre><p>任何在 XML 中配置的属性在实例化之后将会被传递给 setProperties() 方法。你也需要创建一个 Transaction 接口的实现类，这个接口也很简单：</p><pre><code>public interface Transaction {  Connection getConnection() throws SQLException;  void commit() throws SQLException;  void rollback() throws SQLException;  void close() throws SQLException;  Integer getTimeout() throws SQLException;}</code></pre><p>使用这两个接口，你可以完全自定义 MyBatis 对事务的处理。</p><hr><font color="red">提示，如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用<strong>自带的管理器</strong>来覆盖前面的配置。</font><h4 id="数据源-dataSource"><a href="#数据源-dataSource" class="headerlink" title="数据源(dataSource)"></a>数据源(dataSource)</h4><p>数据库事务 Mybatis是交给 SqlSession 去控制的，我们可以通过SqlSession 提交（commit）或者 回滚（rollback）。</p><p>Mybatis内部为我们提供了3种数据源的实现方式</p><ul><li>UNPOOLED，非连接池。</li></ul><p>这个数据源的实现只是每次被请求时打开和关闭连接。虽然有点慢，但对于在数据库连接可用性方面没有太高要求的简单应用程序来说，是一个很好的选择。 不同的数据库在性能方面的表现也是不一样的，对于某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性：</p><pre><code>driver – 这是 JDBC 驱动的 Java 类的完全限定名（并不是 JDBC 驱动中可能包含的数据源类）。url – 这是数据库的 JDBC URL 地址。username – 登录数据库的用户名。password – 登录数据库的密码。defaultTransactionIsolationLevel – 默认的连接事务隔离级别。</code></pre><p>作为可选项，你也可以传递属性给数据库驱动。要这样做，属性的前缀为“driver.”，例如：</p><p><code>driver.encoding=UTF8</code></p><p>这将通过 DriverManager.getConnection(url,driverProperties) 方法传递值为 UTF8 的 encoding 属性给数据库驱动。</p><ul><li>POOLED，连接池。</li></ul><p>这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p><p>除了上述提到 UNPOOLED 下的属性外，还有更多属性用来配置 POOLED 的数据源：</p><pre><code>poolMaximumActiveConnections – 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10poolMaximumIdleConnections – 任意时间可能存在的空闲连接数。poolMaximumCheckoutTime – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）poolTimeToWait – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败），默认值：20000 毫秒（即 20 秒）。poolMaximumLocalBadConnectionTolerance – 这是一个关于坏连接容忍度的底层设置， 作用于每一个尝试从缓存池获取连接的线程. 如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 poolMaximumIdleConnections 与 poolMaximumLocalBadConnectionTolerance 之和。 默认值：3 (新增于 3.4.5)poolPingQuery – 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动失败时带有一个恰当的错误消息。poolPingEnabled – 是否启用侦测查询。若开启，需要设置 poolPingQuery 属性为一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语句），默认值：false。poolPingConnectionsNotUsedFor – 配置 poolPingQuery 的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。</code></pre><ul><li>JNDI</li></ul><p>这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。这种数据源配置只需要两个属性：</p><pre><code>initial_context – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么 data_source 属性将会直接从 InitialContext 中寻找。data_source – 这是引用数据源实例位置的上下文的路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。</code></pre><p>和其他数据源配置类似，可以通过添加前缀“env.”直接把属性传递给初始上下文。比如：</p><p><code>env.encoding=UTF8</code></p><p>这就会在初始上下文（InitialContext）实例化时往它的构造方法传递值为 UTF8 的 encoding 属性。</p><hr><p>你可以通过实现接口 org.apache.ibatis.datasource.DataSourceFactory 来使用<strong>第三方数据源：</strong></p><pre><code>public interface DataSourceFactory {  void setProperties(Properties props);  DataSource getDataSource();}</code></pre><p>org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory 可被用作父类来构建新的数据源适配器，比如下面这段插入 C3P0 数据源所必需的代码：</p><pre><code>import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;import com.mchange.v2.c3p0.ComboPooledDataSource;public class C3P0DataSourceFactory extends UnpooledDataSourceFactory {  public C3P0DataSourceFactory() {    this.dataSource = new ComboPooledDataSource();  }}</code></pre><p>为了令其工作，记得为每个希望 MyBatis 调用的 setter 方法在配置文件中增加对应的属性。下面是一个可以连接至 PostgreSQL 数据库的例子：</p><pre><code>&lt;dataSource type=&quot;org.myproject.C3P0DataSourceFactory&quot;&gt;  &lt;property name=&quot;driver&quot; value=&quot;org.postgresql.Driver&quot;/&gt;  &lt;property name=&quot;url&quot; value=&quot;jdbc:postgresql:mydb&quot;/&gt;  &lt;property name=&quot;username&quot; value=&quot;postgres&quot;/&gt;  &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/dataSource&gt;</code></pre><hr><h3 id="databaseIdProvider"><a href="#databaseIdProvider" class="headerlink" title="databaseIdProvider"></a>databaseIdProvider</h3><p>MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。 MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库 databaseId 属性的所有语句。 如果同时找到带有 databaseId 和不带 databaseId 的相同语句，则后者会被舍弃。 为支持多厂商特性只要像下面这样在 mybatis-config.xml 文件中加入 databaseIdProvider 即可：</p><pre><code>&lt;databaseIdProvider type=&quot;DB_VENDOR&quot; /&gt;</code></pre><p>这里的 DB_VENDOR 会通过 DatabaseMetaData#getDatabaseProductName() 返回的字符串进行设置。 由于通常情况下这个字符串都非常长而且相同产品的不同版本会返回不同的值，所以最好通过设置属性别名来使其变短，如下：</p><pre><code>&lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt;  &lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&gt;  &lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt;     &lt;property name=&quot;DB2&quot; value=&quot;db2&quot;/&gt;          &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot; /&gt;&lt;/databaseIdProvider&gt;</code></pre><p>在提供了属性别名时，DB_VENDOR databaseIdProvider 将被设置为第一个能匹配数据库产品名称的属性键对应的值，如果没有匹配的属性将会设置为 “null”。 在这个例子中，如果 getDatabaseProductName() 返回“Oracle (DataDirect)”，databaseId 将被设置为“oracle”。</p><p>我们也可以指定SQL在哪个数据库厂商执行，我们把Mapper的XML配置修改一下，如下：</p><pre><code>    &lt;select id=&quot;selectById&quot; parameterType=&quot;string&quot; resultMap=&quot;userMap&quot; databaseId=&quot;mysql&quot;&gt;        select userId,user_age ,user_name ,user_sex  from user where userId = #{id}    &lt;/select&gt;</code></pre><p>在多一个databaseId属性的情况下，Mybatis将提供如下规则。</p><ul><li><p>如果没有配置databaseIdProvider标签，那么databaseId就会返回null。</p></li><li><p>如果配置了databaseIdProvider标签，Mybatis就会用配置的name值去匹配数据库信息，如果匹配得上就会设置databaseId，否则为null。</p></li><li><p>如果Configuration的databaseId不为空，则它只会找到配置databaseId的SQL语句。</p></li><li><p>Mybatis会加载不带databaseId属性和带有匹配当前数据库databaseId属性的所有语句。如果同时找到带有databaseId和不带databaseId的相同语句，则后者会被舍弃。</p></li></ul><hr><p>Mybatis也提供了规则允许自定义，我们只要实现DatabaseIdProvider接口，并且实现配置即可</p><pre><code>public class MydatabaseIdProvider implements DatabaseIdProvider {    private Properties properties = null;    @Override    public void setProperties(Properties p) {        this.properties = p;    }    @Override    public String getDatabaseId(DataSource dataSource) throws SQLException {        String dbName = dataSource.getConnection().getMetaData().getDatabaseProductName();        String dbId = (String) this.properties.get(dbName);        return dbId;    }}</code></pre><p>其次，注册这个类到Mybatis上下文环境中，我们这样配置databaseIdProvider标签，如下所示：</p><pre><code>&lt;databaseIdProvider type=&quot;com.liuzhuo.databaseIdProvider.MydatabaseIdProvider&quot;&gt;  &lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&gt;  &lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt;     &lt;property name=&quot;DB2&quot; value=&quot;db2&quot;/&gt;          &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot; /&gt;&lt;/databaseIdProvider&gt;</code></pre><p>我们把type修改为我们自己实现的类，类里面setProperties方法的参数传递进去的将会是我们在XML配置的信息，我们保存在类的变量properties里，方便以后读出。在方法getDatabaseId中，传递的参数是数据库数据源，我们获取其名称，然后通过properties的键值找到对应的databaseId。</p><hr><h3 id="mapper-映射器"><a href="#mapper-映射器" class="headerlink" title="mapper(映射器)"></a>mapper(映射器)</h3><p>映射器是Mybatis最复杂、最核心的组件。此处只是讨论如何引入映射器，其他的特性放在后面的博客中讲解。</p><p>引入映射器有4中方法：</p><p>（1）用文件路径引入映射器</p><pre><code>&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt;  &lt;mapper resource=&quot;org/mybatis/builder/authorMapper.xml&quot;/&gt;  &lt;mapper resource=&quot;org/mybatis/builder/blogMapper.xml&quot;/&gt;  &lt;mapper resource=&quot;org/mybatis/builder/postMapper.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><p>(2) 用完全限定资源定位(url)</p><pre><code>&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt;  &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;  &lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&gt;  &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><p>(3) 用包名引入映射器</p><pre><code>&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt;  &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt;</code></pre><p>(4) 用类注册引入映射器</p><pre><code>&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt;  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;  &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt;  &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;&lt;/mappers&gt;</code></pre><font color="red">注意：（1）和（2）是xml的方式，所以填写的是XML的路径，（3）和 （4）是注解的方式，填写的是mapper接口的路径</font><p>（1）和（2）我就不演示了，大家都清楚。</p><p>看看（3）和（4）。</p><p>首先，我们的UserMapper在：com.liuzhuo.dao包下</p><p>然而，我们的userMapper.xml在：com.liuzhuo.mapper包下。<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310220314.png"></p><p>但是，在mybatis-config.xml中必须配置为mapper接口的包路径：</p><pre><code>    &lt;mappers&gt;        &lt;package name=&quot;com.liuzhuo.dao&quot;/&gt;    &lt;/mappers&gt;</code></pre><p><strong>而且，此时只能使用注解的方式，不能使用xml的方式了。</strong></p><p>现在，在我们的UserMapper中，有两个selectById方法，一个是xml的，一个是注解的，我们分别来演示。</p><pre><code>public interface UserMapper {    User selectById(String id);    @Select(&quot;select userId,user_age as useAge,user_name as userName from user where userId = #{id}&quot;)    User selectById02(String id);    int insertUser(User user);}</code></pre><p>在主函数中调用xml的方法（selectById）<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310220747.png"></p><p>发现调用失败！！！！</p><p>在主函数中调用注解的方法（selectById02）<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310220942.png"></p><hr><p><strong>如果想使用非注解的xml配置文件的话，必须将Mapper接口类和xml文件放在同一级目录中，且两种同名！！！</strong></p><p>结构如下：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190311092826.png" style="width:50%"></p><p>再次运行，如果你的还是出错<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190311100400.png"></p><p>是因为使用IDEA创建的Maven项目中，不在resources创建的xml配置文件是不会读取到的，需要修改一下pom.xml文件。</p><pre><code>    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;        &lt;!--配置即使xml不在resources中，也能读取到xml文件--&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;        &lt;/resources&gt;    &lt;/build&gt;</code></pre><p>加入上面的<code>&lt;resources&gt;</code>即可。</p><p>此时再次运行项目，就会成功了：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190311100710.png"></p><p>此时，在target目录下，能看到：com.liuzhuo.dao下的UserMapper.xml文件。<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190311100846.png" style="width:50%"></p><p>没有修改pom.xml文件之前，即使你在src源码目录的:com.liuzhuo.dao中加入UserMapper.xml文件，在target相同的目录下是不会有UserMapper.xml文件。</p><p>这就是出错的原因。</p><p>如果你创建的是web的maven工程，不会出错的，我的这个工程是简单的maven工程才会这样，大家如果出现了同样的问题，可以看看是不是这个原因！！！</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中的主配置文件</title>
      <link href="/2019/03/10/mybatis-zhong-de-zhu-pei-zhi-wen-jian/"/>
      <url>/2019/03/10/mybatis-zhong-de-zhu-pei-zhi-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>今天来讲解Mybatis中的主配置文件，Mybatis的配置文件对整个Mybatis体系产生深远的影响。</p><h3 id="Mybatis配置文件层次结构"><a href="#Mybatis配置文件层次结构" class="headerlink" title="Mybatis配置文件层次结构"></a>Mybatis配置文件层次结构</h3><p>先来看一下MyBatis配置XML文件的层次结构。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!--配置--&gt;    &lt;properties/&gt;&lt;!--属性--&gt;    &lt;settings/&gt;&lt;!--设置--&gt;    &lt;typeAliases/&gt;&lt;!--别名--&gt;    &lt;typeHandlers/&gt;&lt;!--类型处理器--&gt;    &lt;plugins/&gt;&lt;!--插件--&gt;    &lt;environments default=&quot;development&quot;&gt;&lt;!--配置环境--&gt;        &lt;environment id=&quot;development&quot;&gt;&lt;!--环境变量--&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;&lt;!--事务管理器--&gt;            &lt;dataSource type=&quot;POOLED&quot;/&gt;&lt;!--数据源--&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;databaseIdProvider/&gt;&lt;!--数据库厂商标识--&gt;    &lt;mappers/&gt;&lt;!--映射器--&gt;&lt;/configuration&gt;</code></pre><font color="red"><strong>注意，这些层次是不能够颠倒顺序的的，如果颠倒顺序，Mybatis在解析XML文件的时候就会出现异常。</strong></font><h3 id="properties元素"><a href="#properties元素" class="headerlink" title="properties元素"></a>properties元素</h3><p>properties是一个配置属性的元素，让我们能在配置文件的上下文中使用它。</p><p>Mybatis提供3种配置方式：</p><ul><li><p>property子元素</p></li><li><p>properties配置文件</p></li><li><p>程序参数传递</p></li></ul><h4 id="property子元素"><a href="#property子元素" class="headerlink" title="property子元素"></a>property子元素</h4><p>property子元素的配置方式如下：</p><pre><code>    &lt;properties&gt;        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/properties&gt;</code></pre><p>这样我们就可以在上下文中使用已经配置好的属性值了。我们在配置数据库的数据源时就可以按照如下进行配置：</p><pre><code>    &lt;dataSource type=&quot;POOLED&quot;&gt;        &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;    &lt;/dataSource&gt;</code></pre><hr><h4 id="properties配置文件"><a href="#properties配置文件" class="headerlink" title="properties配置文件"></a>properties配置文件</h4><p>更多时候，我们希望使用properties配置文件来配置属性值，以方便我们在多个配置文件中重复使用它们，也方便日后维护和随时修改，这些在Mybatis中是很容易做到的，我们先来看一下 properties文件 ( jdbc.properties )，代码如下：</p><pre><code>#数据库配置文件driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatisusername=rootpassword=123456</code></pre><p>我们把这个properties配置文件放在<strong>源码包</strong>下，只要这样引入这个配置文件即可：</p><p><code>&lt;properties resources=&quot;jdbc.properties&quot;/&gt;</code></p><p>如果想要放在自定义的包下，比如：com.liuzhuo.mybatis中就：</p><p><code>&lt;properties resources=&quot;com/liuzhuo/mybatis/jdbc.properties&quot;/&gt;</code></p><hr><h4 id="程序参数传递"><a href="#程序参数传递" class="headerlink" title="程序参数传递"></a>程序参数传递</h4><p>在实际工作中，我们常常遇到这样的问题：系统是由运维人员去配置的，生产数据库的用户密码对于开发者而言是保密的，而且为了安全，运维人员要求对配置文件中的数据库用户密码进行加密，这样我们的配置文件中往往配置的是加密过后的数据库信息，而无法通过加密的字符串去连接数据库，这个时候可以通过编码的形式来满足我们遇到的场景。</p><p>下面假设jdbc.properties文件中的username和password两个属性使用了加密的字符串，这个时候我们需要在生成SqlSessionFactory之前将它转化为明文，而系统已经提供了解密的方法decode(str)，让我们来看看如何使用代码的方式来完成SqlSessionFactory的创建，如下：</p><pre><code>    InputStream cfgStream = null;    Reader cfgReader = null;    InputStream proStream = null;    Reader proReader = null;    Properties properties = null;    try{       //读取配置文件流       cfgStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);       cfgReader = new InputStreamReader(cfgStream);       //读入属性文件       proStream = Resources.getResourceAsStream(&quot;jdbc.properties&quot;);       proReader = new InputStreamReader(proStream);       properties = new Properties();       properties.load(proReader);       //解密为明文       properties.setProperty(&quot;username&quot;,decode(properties.getProperty(&quot;username&quot;)));       properties.setProperty(&quot;password&quot;,decode(properties.getProperty(&quot;password&quot;)));    }catch(IOException ex){      System.out.println(ex.getMessage());    }    Synchronized(CLASS_LOCK){         if(sqlSessionFactory == null){            //使用属性来创建SqlSessionFactory            SqlSessionFactory = new SqlSessionFactoryBuilder().build(cfgReader,properties);         }    }</code></pre><p>这样我们完全可以在jdbc.properties配合密文了，满足对系统安全的要求了。</p><hr><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>Mybatis支持3种配置方式可能同时出现，并且属性还会重复配置。这3种方式是存在优先级的，Mybatis将按照下面的顺序来加载。</p><ol><li><p>在properties元素体内指定的属性首先被读取（property子元素）</p></li><li><p>根据properties元素中的resources属性读取类路径下的.properties文件，或者根据url属性指定的路径读取属性文件，并覆盖也读取的同名属性</p></li><li><p>读取作为方法参数传递的属性，并覆盖也读取的同名属性</p></li></ol><p><strong>因此，通过<code>方法参数传递的属性具有最高优先级</code>，<code>resources属性中指定的配置文件次之</code>，<code>最低优先级的是properties元素中的指定的属性。</code></strong></p><hr><p>因此，在实际操作中，我们需要注意一下3点：</p><ol><li><p>不要混合使用，这样会导致管理混乱</p></li><li><p>首选的方式是使用properties文件</p></li><li><p>如果需要使用加密或者其他加工处理，不妨按照示例的方法来处理，这样做的好处是使得配置都来自于同一个配置文件，就不容易产生没有必要的歧义。</p></li></ol><hr><p>从MyBatis 3.4.2开始，你可以为占位符指定一个默认值。例如：</p><pre><code>&lt;dataSource type=&quot;POOLED&quot;&gt;  &lt;!-- ... --&gt;  &lt;property name=&quot;username&quot; value=&quot;${username:ut_user}&quot;/&gt; &lt;!-- If &#39;username&#39; property not present, username become &#39;ut_user&#39; --&gt;&lt;/dataSource&gt;</code></pre><p>这个特性默认是关闭的。如果你想为占位符指定一个默认值， 你应该添加一个指定的属性来开启这个特性。例如：</p><pre><code>&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;  &lt;!-- ... --&gt;  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt; &lt;!-- Enable this feature --&gt;&lt;/properties&gt;</code></pre><p><strong><code>提示：你可以使用 &quot;:&quot; 作为属性键(e.g. db:username) 或者你也可以在sql定义中使用 OGNL 表达式的三元运算符(e.g. ${tableName != null ? tableName : &#39;global_constants&#39;})</code></strong></p><p>你也可以通过增加一个指定的属性来改变分隔键和默认值的字符。例如：</p><pre><code>&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;  &lt;!-- ... --&gt;  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.default-value-separator&quot; value=&quot;?:&quot;/&gt; &lt;!-- Change default value of separator --&gt;&lt;/properties&gt;&lt;dataSource type=&quot;POOLED&quot;&gt;  &lt;!-- ... --&gt;  &lt;property name=&quot;username&quot; value=&quot;${db:username?:ut_user}&quot;/&gt;&lt;/dataSource&gt;</code></pre><hr><h3 id="settings设置"><a href="#settings设置" class="headerlink" title="settings设置"></a>settings设置</h3><p>设置（settings）在Mybatis中是最复杂的配置，同时也是最为重要的配置内容之一，它会改变Mybatis运行时的行为。即使不配置settings，Mybatis也可以正常的工作，不过了解settings的配置内容，以及它们的作用仍然十分必要。</p><p>Settings的配置内容如下：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310114235.png"><br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310114509.png"><br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310114547.png"></p><p>一个配置完整的 settings 元素的示例如下：</p><pre><code>&lt;settings&gt;  &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;  &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;  &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;  &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;  &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;  &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;  &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;  &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;  &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;  &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;  &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;  &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;  &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;  &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;&lt;/settings&gt;</code></pre><p>在大部分时候我们不需要去配置它，或者只需要配置少数几项即可。</p><hr><h3 id="typeAliases-别名"><a href="#typeAliases-别名" class="headerlink" title="typeAliases(别名)"></a>typeAliases(别名)</h3><p>别名(typeAliases)是一个指代的名称，因为我们遇到的类的全限定名过长，所以我们希望用一个简短的名称来指代它，而这个名称可以在Mybatis上下文中使用。别名在Mybatis里面分为<strong>系统定义的别名</strong>和<strong>自定义的别名</strong>。注意，在Mybatis中别名是不分大小写的。</p><p>一个typeAliases的实例是在解析配置文件时生成的，然后长期保存在Configuration对象中，当我们使用它时，再把它拿出来，这样就没有必要运行的时候再次生成它的实例了。</p><h4 id="系统别名"><a href="#系统别名" class="headerlink" title="系统别名"></a>系统别名</h4><p>Mybatis系统定义了一些经常使用的类型的别名，比如：数值、字符串、日期和集合等，我们可以在Mybatis中直接使用它们，在使用时不要重复定义把它们给覆盖了。</p><p>如下是系统给我们定义的常用的别名：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310115942.png"><br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310120030.png"><br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310120122.png"></p><p>我们可以通过Mybatis的源码 org.apache.ibatis.type.TypeAliasRegistry 可以看出其自定义注册的信息，如下所示：</p><pre><code>  public TypeAliasRegistry() {    registerAlias(&quot;string&quot;, String.class);    registerAlias(&quot;byte&quot;, Byte.class);    registerAlias(&quot;long&quot;, Long.class);    registerAlias(&quot;short&quot;, Short.class);    registerAlias(&quot;int&quot;, Integer.class);    registerAlias(&quot;integer&quot;, Integer.class);    registerAlias(&quot;double&quot;, Double.class);    registerAlias(&quot;float&quot;, Float.class);    registerAlias(&quot;boolean&quot;, Boolean.class);    ·····}</code></pre><p>这些就是Mybatis系统定义的别名，我们无需重复注册它们。</p><h4 id="自定义别名"><a href="#自定义别名" class="headerlink" title="自定义别名"></a>自定义别名</h4><p>系统所定义的别名往往是不够用的，因为不同的应用有着不同的需要，所以Mybatis允许自定义别名。</p><p>代码如下：</p><pre><code>&lt;typeAliases&gt;  &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt;  &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;  &lt;typeAlias alias=&quot;Comment&quot; type=&quot;domain.blog.Comment&quot;/&gt;  &lt;typeAlias alias=&quot;Post&quot; type=&quot;domain.blog.Post&quot;/&gt;  &lt;typeAlias alias=&quot;Section&quot; type=&quot;domain.blog.Section&quot;/&gt;  &lt;typeAlias alias=&quot;Tag&quot; type=&quot;domain.blog.Tag&quot;/&gt;&lt;/typeAliases&gt;</code></pre><p>当这样配置时，Blog可以用在任何使用domain.blog.Blog的地方。</p><p>如果POJO对象过多的时候，配置也是非常多的。因此允许我们通过包扫描的方式来注册自定义别名，如下：</p><pre><code>&lt;typeAliases&gt;  &lt;package name=&quot;domain.blog&quot;/&gt;&lt;/typeAliases&gt;</code></pre><p>每一个在包 domain.blog 中的 Java Bean，<strong><code>在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。</code></strong></p><p>比如 domain.blog.Author 的别名为 author。</p><p>也可以使用注解的方法，自定义别名，如下：</p><pre><code>@Alias(&quot;author&quot;)public class Author {    ...}</code></pre><p>当配合上面的配置，Mybatis就会自动扫描包，将扫描到的类装载到上下文中，以便将来使用。这样就算是多个POJO也可以通过包扫描的方式装载到Mybatis的上下文中。</p><hr><h3 id="typeHandler-类型处理器"><a href="#typeHandler-类型处理器" class="headerlink" title="typeHandler(类型处理器)"></a>typeHandler(类型处理器)</h3><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</p><p>由于数据库可能来自于不同的厂商，不同的厂商设置的参数可能有所不同，同时数据库也可以自定义数据类型，typeHandler允许根据项目的需要自定义设置Java传递到数据库的参数中，或者从数据库读取数据，我们也需要进行特殊的处理，这些都可以在自定义的typeHandler中处理，尤其是在使用枚举的时候，我们常常需要使用typeHandler进行转换。</p><p>typeHandler和别名一样，分为Mybatis系统定义的和用户自定义两种。一般来说，使用Mybatis系统定义的typeHandler就可以实现大部分的功能，如果使用用户自定义的typeHandler，我们在处理的时候务必要小心谨慎，以避免出现不必要的错误。</p><p>typeHandler常用的配置为Java类型（javaType）、JDBC类型（jdbcType）。typeHandler的作用就是将参数从javaType转化为jdbcType，或者从数据库取出数据时把jdbcType转化为javaType。</p><h4 id="系统定义的typeHandler"><a href="#系统定义的typeHandler" class="headerlink" title="系统定义的typeHandler"></a>系统定义的typeHandler</h4><p>Mybatis系统内部定义了一系列的typeHandler，我们可以看看 org.apache.ibatis.type.TypeHandlerRegistry</p><pre><code>  public TypeHandlerRegistry() {    register(Boolean.class, new BooleanTypeHandler());    register(boolean.class, new BooleanTypeHandler());    register(JdbcType.BOOLEAN, new BooleanTypeHandler());    register(JdbcType.BIT, new BooleanTypeHandler());    register(Byte.class, new ByteTypeHandler());    register(byte.class, new ByteTypeHandler());    register(JdbcType.TINYINT, new ByteTypeHandler());    register(Short.class, new ShortTypeHandler());    register(short.class, new ShortTypeHandler());    register(JdbcType.SMALLINT, new ShortTypeHandler());    ····}</code></pre><p>下表描述了一些默认的类型处理器。<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310123016.png"><br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310123134.png"><br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310123216.png"></p><hr><p>我们需要注意下面几点。</p><ul><li><p>数值类型的精度，数据库 int、double、decimal这些类型 和 java的 精度、长度都是不一样的。</p></li><li><p>时间精度，取数据，精确到日用DateOnlyTypeHandler即可，精确到秒就用SqlTimestampTypeHandler等。</p></li></ul><h4 id="自定义typeHandler"><a href="#自定义typeHandler" class="headerlink" title="自定义typeHandler"></a>自定义typeHandler</h4><p>在我们自定义typeHandler之前，我们先学习一下，Mybatis为我们提供的系统typeHandler，这样我们可以照着标准来自定义我们的typeHandler了。</p><p>我们来看一下最常见的：StringTypeHandler。</p><pre><code>public class StringTypeHandler extends BaseTypeHandler&lt;String&gt; {  @Override  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType)      throws SQLException {    ps.setString(i, parameter);  }  @Override  public String getNullableResult(ResultSet rs, String columnName)      throws SQLException {    return rs.getString(columnName);  }  @Override  public String getNullableResult(ResultSet rs, int columnIndex)      throws SQLException {    return rs.getString(columnIndex);  }  @Override  public String getNullableResult(CallableStatement cs, int columnIndex)      throws SQLException {    return cs.getString(columnIndex);  }}</code></pre><p>简单说明一下上面的代码。</p><p>StringTypeHandler 继承了 BaseTypeHandler。 而 BaseTypeHandler 实现了接口 typeHandler，并且自己定义了4个抽象的方法。所以继承它的时候，正如本例一样需要实现其定义的4个抽象方法，这些方法已经在StringTypeHandler中使用@Override注解注明了。</p><p>setParameter 是 PreparedStatement 对象设置参数，它允许我们自己填写变换的规则。</p><p>getResult 则是ResultSet用列名（columnName）或者使用列下标（columnIndex）来获取结果数据的。其中还包括了用CallableStatement（存储过程）获取结果及数据的方法。</p><hr><p>一般而言，Mybatis系统提供的typeHandler已经能够应付大部分的场景了，但是我们不能排除不够用的情况。首先需要明确两个问题：我们自定义的TypeHandler需要处理什么类型？现有的TypeHandler适合我们使用吗？我们需要特殊的处理java的那些类型（JavaType）和对应处理数据库的那些类型（JdbcType），比如字典项的枚举。</p><p>这里让我们重新覆盖一个字符串参数的TypeHandler，我们首先先配置XML文件，确定我们需要处理什么类型的参数和结果，如下所示：</p><pre><code>&lt;!-- mybatis-config.xml --&gt;&lt;typeHandlers&gt;  &lt;typeHandler handler=&quot;com.liuzhuo.typehandler.MyStringTypehandler&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;&lt;/typeHandlers&gt;</code></pre><p>上面定义的数据库类型为VARCHAR型。当java的参数类型为string的时候，我们就可以使用MyStringTypeHandler来处理了，但是只有这个配置，Mybatis不会自动帮你去使用这个TypeHandler去转化的，你需要更多的配置。</p><p>对于MyStringTypehandler，我们需要实现：</p><p><code>org.apache.ibatis.type.TypeHandler</code> 接口，或者是继承：<code>org.apache.ibatis.type.BaseTypeHandler</code>。</p><p>以上就是实现自定义TypeHandler的两种方式（其实BaseTypeHandler就是实现了TypeHandler接口的类）</p><pre><code>@MappedJdbcTypes(JdbcType.VARCHAR)@MappedTypes({String.class})public class MyStringTypehandler extends BaseTypeHandler&lt;String&gt; {  @Override  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {    System.out.println(&quot;使用了我的TypeHandler&quot;);    ps.setString(i, parameter);  }  @Override  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {    System.out.println(&quot;使用了我的TypeHandler，ResultSet列名获取字符串&quot;);    return rs.getString(columnName);  }  @Override  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {    System.out.println(&quot;使用了我的TypeHandler，ResultSet下标获取字符串&quot;);    return rs.getString(columnIndex);  }  @Override  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {    System.out.println(&quot;使用了我的TypeHandler，CallableStatement下标获取字符串&quot;);    return cs.getString(columnIndex);  }}</code></pre><p>自定义的TypeHandler里，使用了注解 @MappedTypes 和 @MappedJdbcTypes 来配置 javaType 和 jdbcType。</p><ul><li><p>@MappedTypes：定义的是JavaType类型，可以指定哪些java类型被拦截</p></li><li><p>@MappedJdbcTypes：定义的是JdbcType类型，它需要满足枚举类型 org.apache.ibatis.type.JdbcType所列的枚举类型。</p></li></ul><font color="red">要注意 MyBatis 不会窥探数据库元信息来决定使用哪种类型，所以你必须在参数和结果映射中指明那是 VARCHAR 类型的字段， 以使其能够绑定到正确的类型处理器上。 这是因为：MyBatis 直到语句被执行才清楚数据类型。</font><hr><p>通过类型处理器的泛型，MyBatis 可以得知该类型处理器处理的 Java 类型，不过这种行为可以通过两种方法改变：</p><ul><li><p>在类型处理器的配置元素（typeHandler element）上增加一个 javaType 属性（比如：javaType=”String”）；</p></li><li><p>在类型处理器的类上（TypeHandler class）增加一个 @MappedTypes 注解来指定与其关联的 Java 类型列表。 如果在 javaType 属性中也同时指定，则注解方式将被忽略。</p></li></ul><p>可以通过两种方式来指定被关联的 JDBC 类型：</p><ul><li><p>在类型处理器的配置元素上增加一个 jdbcType 属性（比如：jdbcType=”VARCHAR”）；</p></li><li><p>在类型处理器的类上（TypeHandler class）增加一个 @MappedJdbcTypes 注解来指定与其关联的 JDBC 类型列表。 如果在 jdbcType 属性中也同时指定，则注解方式将被忽略。</p></li></ul><p>即优先级是：</p><pre><code>&lt;typeHandler handler=&quot;xxx&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;  中的 javaType 和 jdbcType 大于 @MappedTypes 和 @MappedJdbcTypes</code></pre><hr><p>当决定在ResultMap中使用某一TypeHandler时，此时java类型是已知的（从结果类型中获得），但是JDBC类型是未知的。 </p><p>因此Mybatis使用 javaType=[TheJavaType], jdbcType=null 的组合来选择一个TypeHandler。 </p><p>这意味着使用@MappedJdbcTypes注解可以限制TypeHandler的范围，同时除非显式的设置，否则TypeHandler在ResultMap中将是无效的。 </p><p>如果希望在ResultMap中使用TypeHandler，那么设置@MappedJdbcTypes注解的includeNullJdbcType=true即可。 </p><p>然而从Mybatis 3.4.0开始，如果只有一个注册的TypeHandler来处理Java类型，那么它将是ResultMap使用Java类型时的默认值（即使没有includeNullJdbcType=true）。</p><hr><p>最后，类型处理器也可以和别名一样，使用包扫描的方式，注册多个类型处理器</p><pre><code>&lt;!-- mybatis-config.xml --&gt;&lt;typeHandlers&gt;  &lt;package name=&quot;org.mybatis.example&quot;/&gt;&lt;/typeHandlers&gt;</code></pre><p>注意在使用自动检索（autodiscovery）功能的时候，只能通过注解方式来指定 JDBC 的类型。（@MappedJdbcTypes）</p><hr><p>到现在，我们还是不能测试，因为还需要去标识哪些参数或者结果类型去用我们自定义的TypeHandler去转化，在没有任何标识的情况下，Mybatis是不会启用你定义的TypeHandler进行转化的，所以还需要给予对应的标识，比如配置jdbcType 和 javaType，或者直接使用typeHandler属性指定，因此还需要修改映射器的XML配置。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.liuzhuo.dao.UserMapper&quot;&gt;    &lt;resultMap id=&quot;usermap&quot; type=&quot;user&quot;&gt;&lt;!--因为添加了别名，所以直接使用user--&gt;        &lt;id column=&quot;userId&quot; property=&quot;userId&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;        &lt;result column=&quot;user_age&quot; property=&quot;userAge&quot;/&gt;            &lt;!--定义结果类型转化器标识，才能使用类型转换器--&gt;        &lt;result column=&quot;user_name&quot; property=&quot;userName&quot; typeHandler=&quot;com.liuzhuo.typehandler.MyStringTypehandler&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectById&quot; parameterType=&quot;long&quot; resultMap=&quot;usermap&quot;&gt;        select userId,user_name as userName,user_age as userAge from user where userId = #{id}    &lt;/select&gt;    &lt;select id=&quot;selectById03&quot; parameterType=&quot;string&quot; resultMap=&quot;usermap&quot;&gt;        select userId,user_name as userName,user_age as userAge from user where user_name = #{userName,javaType=&quot;string&quot;,jdbcType=&quot;VARCHAR&quot;}    &lt;/select&gt;    &lt;select id=&quot;selectById02&quot; parameterType=&quot;string&quot; resultMap=&quot;usermap&quot;&gt;        select userId,user_name as userName,user_age as userAge from user where user_name = #{userName,typeHandler=&quot;com.liuzhuo.typehandler.MyStringTypehandler}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>我们这里引入了resultMap，它提供了映射规则，这里给出了3种typeHandler的使用方法。</p><ul><li><p>在配置文件里面配置，在结果集的的id定义：javaType 和 jdbcType。只要定义的javaType 和 jdbcType 与我们定义在配置里面的typeHandler是一致的，Mybatis才会知道用我们自定义的类型转化器进行转换。</p></li><li><p>映射集里面直接定义具体的typeHandler，这样就不需要再在配置里面定义了。</p></li><li><p>在参数中制定typeHandler，这样Mybatis就会用对应的typeHandler进行转换，这样也不需要在配置里面定义了。</p></li></ul><hr><p>配置好后，运行我们的项目的MybatisMain主函数，接着上篇博客来写的：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310151142.png"></p><p>从结果看，程序运行了我们自定义的typeHandler，输出了打印语句。</p><hr><h4 id="处理枚举类型"><a href="#处理枚举类型" class="headerlink" title="处理枚举类型"></a>处理枚举类型</h4><p>在Mybatis中枚举类型的typeHandler有自己特殊的规则，Mybatis内部提供了两个枚举typeHandler：</p><ul><li><p>EnumTypeHandler </p></li><li><p>EnumOrdinalTypeHandler </p></li></ul><p>EnumTypeHandler 和 EnumOrdinalTypeHandler 都是泛型类型处理器（generic TypeHandlers）</p><p>其中，EnumTypeHandler是使用枚举字符串名称来作为参数的，EnumOrdinalTypeHandler是使用整数下标作为参数的。</p><p><strong>注意 EnumTypeHandler 在某种意义上来说是比较特别的，其他的处理器只针对某个特定的类，而它不同，它会处理任意继承了 Enum 的类。</strong></p><p>然而这两个枚举类型应用却不是那么广泛，更多的时候我们希望使用自定义的typeHandler处理它们。所以在这里我们也会谈及自定义的typeHandler实现枚举映射。</p><h5 id="EnumOrdinalTypeHandler"><a href="#EnumOrdinalTypeHandler" class="headerlink" title="EnumOrdinalTypeHandler"></a>EnumOrdinalTypeHandler</h5><p>下面以性别为例，讲述如何实现枚举类。现在我们有一个性别枚举，它定义了字典：男（male），女（female）。</p><p>在com.liuzhuo.enums包下，创建Sex枚举类</p><pre><code>public enum Sex {    MALE(1, &quot;男&quot;), FEMALE(2, &quot;女&quot;);    private int id;    private String name;    private Sex(int id, String name) {        this.id = id;        this.name = name;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public static Sex getSex(int id) {        if (id == 1) {            return MALE;        } else if (id == 2) {            return FEMALE;        }        return null;    }}</code></pre><p>在没有配置的时候，EnumOrdinalTypeHandler是Mybatis的默认枚举类型的处理器，为了让EnumOrdinalTypeHandler能够处理它，我们在Mybatis中做如下配置：</p><pre><code>    &lt;typeHandlers&gt;        ···        &lt;typeHandler handler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot; javaType=&quot;com.liuzhuo.enums.Sex&quot;/&gt;    &lt;/typeHandlers&gt;</code></pre><p>这样当Mybatis遇到这个枚举类时就可以识别这个枚举了，然后修改userMapper.xml文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.liuzhuo.dao.UserMapper&quot;&gt;    &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt;&lt;!--因为添加了别名，所以直接使用user--&gt;        &lt;id column=&quot;userId&quot; property=&quot;userId&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;        &lt;result column=&quot;user_age&quot; property=&quot;userAge&quot;/&gt;        &lt;!--定义结果类型转化器标识，才能使用类型转换器--&gt;        &lt;result column=&quot;user_name&quot; property=&quot;userName&quot; typeHandler=&quot;com.liuzhuo.typehandler.MyStringTypehandler&quot;/&gt;        &lt;!--新添加的字段--&gt;        &lt;result column=&quot;user_sex&quot; property=&quot;userSex&quot; typeHandler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectById&quot; parameterType=&quot;long&quot; resultMap=&quot;userMap&quot;&gt;        select userId,user_name as userName,user_age as userAge ,user_sex as userSex from user where userId = #{id}    &lt;/select&gt;    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;user&quot;&gt;        INSERT INTO user(userId,user_age,user_name,user_sex)        VALUES (#{userId},#{userAge},#{userName},#{userSex,typeHandler=org.apache.ibatis.type.EnumOrdinalTypeHandler})    &lt;/insert&gt;&lt;/mapper&gt;</code></pre><p>主要增加了一个新的字段，userSex 和 一个 insert方法。</p><p>userMapper接口：</p><pre><code>public interface UserMapper {    User selectById(Long id);    @Select(&quot;select userId,user_age as useAge,user_name as userName from user where userId = #{id}&quot;)    User selectById02(Long id);    //新增加的方法    int insertUser(User user);}</code></pre><p>User类：</p><pre><code>public class User {    private String userId;    private Long userAge;    private String userName;    //多的字段    private Sex userSex;      ···省略get、set、toSting方法</code></pre><p>在mysql中，添加新的列，为user_sex<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310155623.png"></p><p>修改我们的MybatisMain类的main方法：</p><pre><code>        SqlSession sqlSession = null;        try {            sqlSession = SqlSessionFactoryUtil.openSqlSession();            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);            User user = new User();            user.setUserId(UUID.randomUUID().toString());            user.setUserName(&quot;dj&quot;);            user.setUserAge(18L);            user.setUserSex(Sex.FEMALE);//插入新增加的枚举类型            userMapper.insertUser(user);            sqlSession.commit();        } catch (Exception e) {            System.out.println(e.getMessage());            //出现异常，回滚            sqlSession.rollback();        } finally {            //关闭sqlSession对象            if (sqlSession != null) {                sqlSession.close();            }        }    }</code></pre><p>执行结果：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310155821.png"><br>打开sql数据库：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310155921.png"></p><p>发现它插入的是枚举类型的下标。</p><hr><p>然后，再次修改MybatisMain类的main方法：</p><pre><code>        SqlSession sqlSession = null;        try {            sqlSession = SqlSessionFactoryUtil.openSqlSession();            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);            //id是数据库的，请填写你的id            User user = userMapper.selectById(&quot;a582c9ec-872b-4f6e-8520-a924e140efd7&quot;);            System.out.println(user);            sqlSession.commit();        } catch (Exception e) {            System.out.println(e.getMessage());            //出现异常，回滚            sqlSession.rollback();        } finally {            //关闭sqlSession对象            if (sqlSession != null) {                sqlSession.close();            }        }</code></pre><p>执行：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310161623.png"></p><p>运行成功，取数据时，根据枚举的下标进行转化，变成了FEMALE。</p><font color="red">注意，执行select后，打印出来的user的有可能有的字段没有值，这是因为当我们的使用resultMap后，select中就不要使用as了，这样会映射不对的！！！</font><p>即：(去掉所有的as)</p><pre><code>    &lt;select id=&quot;selectById&quot; parameterType=&quot;string&quot; resultMap=&quot;userMap&quot;&gt;        select userId,user_age ,user_name ,user_sex  from user where userId = #{id}    &lt;/select&gt;</code></pre><hr><h5 id="EnumTypeHandler"><a href="#EnumTypeHandler" class="headerlink" title="EnumTypeHandler"></a>EnumTypeHandler</h5><p>EnumTypeHandler是使用枚举名称去处理Java枚举类型。EnumTypeHandler对应的是一个字符串，让我们来看看它的用法。</p><p>首先将mysql中的user_sex改为<code>VARCHAR</code>类型，然后修改映射的xml文件。<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310162436.png"></p><p>将typeHandler换成：org.apache.ibatis.type.EnumTypeHandler 即可。</p><p>再次插入数据后：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310162944.png"><br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310163028.png"></p><hr><h5 id="自定义枚举类的typeHandler"><a href="#自定义枚举类的typeHandler" class="headerlink" title="自定义枚举类的typeHandler"></a>自定义枚举类的typeHandler</h5><p>我们也看到了Mybatis系统内部的枚举类的typeHandler不太好，所以，一般情况下，我们都需要自己定义枚举类的typeHandler。</p><p>创建SexEnumTypeHandler：</p><pre><code>public class SexEnumTypeHandler extends BaseTypeHandler&lt;Sex&gt; {    @Override    public void setNonNullParameter(PreparedStatement ps, int i, Sex parameter, JdbcType jdbcType) throws SQLException {        System.out.println(&quot;自定义的枚举类型，set&quot;);        ps.setInt(i, parameter.getId());    }    @Override    public Sex getNullableResult(ResultSet rs, String columnName) throws SQLException {        System.out.println(&quot;自定义的枚举类型，get&quot;);        int id = rs.getInt(columnName);        return Sex.getSex(id);    }    @Override    public Sex getNullableResult(ResultSet rs, int columnIndex) throws SQLException {        System.out.println(&quot;自定义的枚举类型，get&quot;);        int id = rs.getInt(columnIndex);        return Sex.getSex(id);    }    @Override    public Sex getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {        System.out.println(&quot;自定义的枚举类型，get&quot;);        int id = cs.getInt(columnIndex);        return Sex.getSex(id);    }}</code></pre><p>修改mbatis-config.xml配置文件：</p><pre><code>    &lt;typeHandlers&gt;        ···        &lt;typeHandler handler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot; javaType=&quot;com.liuzhuo.enums.Sex&quot;/&gt;    &lt;/typeHandlers&gt;</code></pre><p>修改userMapper.xml文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.liuzhuo.dao.UserMapper&quot;&gt;    &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt;        &lt;id column=&quot;userId&quot; property=&quot;userId&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;        &lt;result column=&quot;user_age&quot; property=&quot;userAge&quot;/&gt;        &lt;!--定义结果类型转化器标识，才能使用类型转换器--&gt;        &lt;result column=&quot;user_name&quot; property=&quot;userName&quot; typeHandler=&quot;com.liuzhuo.typehandler.MyStringTypehandler&quot;/&gt;        &lt;!--新添加的字段--&gt;        &lt;result column=&quot;user_sex&quot; property=&quot;userSex&quot; typeHandler=&quot;com.liuzhuo.typehandler.SexEnumTypeHandler&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectById&quot; parameterType=&quot;string&quot; resultMap=&quot;userMap&quot;&gt;        select userId,user_age ,user_name ,user_sex  from user where userId = #{id}&lt;/select&gt;    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;user&quot;&gt;        INSERT INTO user(userId,user_age,user_name,user_sex)        VALUES (#{userId},#{userAge},#{userName},#{userSex,typeHandler=com.liuzhuo.typehandler.SexEnumTypeHandler})    &lt;/insert&gt;&lt;/mapper&gt;</code></pre><p>修改主函数：</p><pre><code>            sqlSession = SqlSessionFactoryUtil.openSqlSession();            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);            User user = new User();            user.setUserId(UUID.randomUUID().toString());            user.setUserName(&quot;gakkij&quot;);            user.setUserAge(18L);            user.setUserSex(Sex.FEMALE);            userMapper.insertUser(user);            sqlSession.commit();</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310164451.png"><br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310164520.png"></p><hr><p>修改主函数：</p><pre><code>            sqlSession = SqlSessionFactoryUtil.openSqlSession();            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);            User user = userMapper.selectById(&quot;635a61a2-1d0e-450a-bda1-20aa340567db&quot;);            System.out.println(user);            sqlSession.commit();</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310164703.png"></p><hr><h3 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h3><p>当Mybatis在构建一个结果返回的时候，都会使用ObjectFactory（对象工厂）去构建POJO，在Mybatis中可以定制自己的对象工厂。一般来说我们使用默认的ObjectFactory即可，Mybatis中默认的ObjectFactory是由 org.apache.ibatis.reflection.DefaultObjectFactory来提供服务的。在大部分的场景下我们都不用修改，如果要定制特定的工厂则需要进行配置，如下所示：</p><pre><code>&lt;objectFactory type=&quot;com.liuzhuo.objectFactory.MyObjectFactory&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;MyObjectFactory&quot;/&gt;&lt;/objectFactory&gt;</code></pre><p>这里，我们配置了一个对象工厂MyObjectFactory，对它的要求是实现ObjectFactory的接口。实际上DefaultObjectFactory已经实现了ObjectFactory的接口，我们可以通过继承DefaultObjectFactory来简化编程。</p><p>在com.liuzhuo.objectFactory包下，创建MyObjectFactory类：</p><pre><code>public class MyObjectFactory extends DefaultObjectFactory {    private static final long serialVersionUID = -4783947743847934344L;    Logger log = Logger.getLogger(MyObjectFactory.class);    @Override    public void setProperties(Properties properties) {        log.info(&quot;定制属性：&quot; + properties);        super.setProperties(properties);    }    @Override    public &lt;T&gt; T create(Class&lt;T&gt; type) {        log.info(&quot;使用定制对象工厂的create方法构建单个对象&quot;);        return super.create(type);    }    @Override    public &lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) {        log.info(&quot;使用定制对象工厂的create方法构建列表对象&quot;);        return super.create(type, constructorArgTypes, constructorArgs);    }    @Override    public &lt;T&gt; boolean isCollection(Class&lt;T&gt; type) {        return super.isCollection(type);    }}</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310175851.png"></p><p>运行我们的main方法：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190310180429.png"></p><p>从运行的结果可以看出，首先，setProperties方法可以获取到<code>&lt;property name=&quot;name&quot; value=&quot;MyObjectFactory&quot;/&gt;</code>定义的属性值。</p><p>create方法分别是处理单个对象和列表对象。</p><p>注意，大部分情况下，我们不需要使用自己配置的ObjectFactory，使用默认的即可。</p><hr><h3 id="plugins-插件"><a href="#plugins-插件" class="headerlink" title="plugins(插件)"></a>plugins(插件)</h3><p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p><ul><li><p>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</p></li><li><p>ParameterHandler (getParameterObject, setParameters)</p></li><li><p>ResultSetHandler (handleResultSets, handleOutputParameters)</p></li><li><p>StatementHandler (prepare, parameterize, batch, update, query)</p></li></ul><p>这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 <strong>因为如果在试图修改或重写已有方法的行为的时候，你很可能在破坏 MyBatis 的核心模块。 这些都是更低层的类和方法，所以使用插件的时候要特别当心。</strong></p><p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。</p><pre><code>// ExamplePlugin.java@Intercepts({@Signature(  type= Executor.class,  method = &quot;update&quot;,  args = {MappedStatement.class,Object.class})})public class ExamplePlugin implements Interceptor {  public Object intercept(Invocation invocation) throws Throwable {    return invocation.proceed();  }  public Object plugin(Object target) {    return Plugin.wrap(target, this);  }  public void setProperties(Properties properties) {  }}</code></pre><pre><code>&lt;!-- mybatis-config.xml --&gt;&lt;plugins&gt;  &lt;plugin interceptor=&quot;org.mybatis.example.ExamplePlugin&quot;&gt;    &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;  &lt;/plugin&gt;&lt;/plugins&gt;</code></pre><p>上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行低层映射语句的内部对象。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis的第三天作用域</title>
      <link href="/2019/03/09/mybatis-de-di-san-tian-zuo-yong-yu/"/>
      <url>/2019/03/09/mybatis-de-di-san-tian-zuo-yong-yu/</url>
      
        <content type="html"><![CDATA[<p>探讨Mybatis中的各个对象的作用域和生命周期</p><p>今天主要来正确的理解Mybatis中的SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession和Mapper的生命周期。</p><h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><p>SqlSessionFactoryBuilder是利用xml和java编码获取资源来构建SqlSessionFactory的，通过它可以构建多个SqlSessionFactory，它的作用就是一个构建器，一旦我们构建了SqlSessionFactory，它的作用就结束了，失去了存在的意义。因此 SqlSessionFactoryBuilder 实例的最佳作用域是<strong><code>方法作用域（也就是局部方法变量）</code></strong>。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。</p><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>SqlSessionFactory的作用就是创建SqlSession，而SqlSession就是一个会话，相当于JDBC中的Connection对象。每次应用程序访问数据库，我们就需要通过SqlSessionFactory创建的Sqlsession来访问数据库，所以SqlSessionFactory应该在Mybatis项目的整个生命周期中，而如果我们多次创建同一个数据库的SqlSessionFactory，则每次创建都会打开更多的数据库连接（Connection）资源，那么连接资源就会很快消耗殆尽。</p><p>SqlSessionFactory的责任是唯一的，它就是创建SqlSession的，所以我们果断采取<strong>单例模式</strong>。因此 SqlSessionFactory 的最佳作用域是<strong><code>应用作用域</code></strong>。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>SqlSession就是一个会话，相当于JDBC中的Connection对象，它的生命周期应该是在请求数据库处理事务的过程中。<strong>它是一个线程不安全的对象</strong>，在涉及多线程的时候我们需要特别小心，操作数据库需要注意其隔离级别、数据库锁等高级特性。此外每次操作SqlSession完后，需要及时关闭它，它长期存在就会使数据库连接池的活动资源减少，对系统的性能的影响很大。正如前面的博客所说一样，往往通过finally语句块保证我们正确的关闭SqlSession。</p><p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是<strong><code>请求或方法作用域</code></strong>。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理作用域中，比如 Servlet 架构中的 HttpSession。</p><p>如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。下面的示例就是一个确保 SqlSession 关闭的标准模式：</p><pre><code>SqlSession session = sqlSessionFactory.openSession();try {  // do work} finally {  session.close();}</code></pre><h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><p>Mapper是一个接口，而没有任何实现类，它的作用是发送SQL语句，然后返回我们需要的结果，或者执行SQL语句从而修改数据库中的数据，因为它应该存在一个SqlSession事务方法之中，是一个方法级别的东西。它就如同JDBC中的一条SQL语句的执行，它最大的范围和SqlSession同级。尽管我们想一直保存着Mapper，但是你会发现它很难控制，所以尽量在一个SqlSession事务的方法中使用它们，然后废弃掉。所以，最好把映射器放在<strong><code>方法作用域（method scope）</code></strong>内。</p><pre><code>SqlSession session = sqlSessionFactory.openSession();try {  BlogMapper mapper = session.getMapper(BlogMapper.class);  // do work} finally {  session.close();}</code></pre><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有了上面的描述，我们已经清楚了Mybatis组件的生命周期了，如下图所示：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190309202349.png"></p><hr><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>这里简单的做一个实例，它可以帮助我们熟悉Mybatis主要组件的用法。我们需要满足Mybatis各个组件的生命周期。首先SqlSessionFactory是单例，然后让它生成SqlSession，进而拿到映射器来完成我们的业务逻辑。</p><p>使用IDEA创建一个简单的maven项目，项目的整体结构如下：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190309212333.png" style="width:50%"></p><p>java源码中：</p><ul><li><p>com.liuzhuo.entities  =====&gt; 存放POJO对象</p></li><li><p>com.liuzhuo.dao       =======&gt; 存放java接口（Mapper）</p></li><li><p>com.liuzhuo.util      ========&gt; 存放工具类</p></li></ul><p>resources资源中：</p><ul><li>com.liuzhuo.mapper   ======&gt; 存放mapper.xml文件</li></ul><p>log4j.properties文件</p><p>mybatis-config.xml文件</p><hr><p>pom.xml文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.liuzhuo&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.13&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>log4j.properties文件：</p><pre><code>#全局配置log4j.rootLogger=ERROR,stdout#MyBatis日志配置log4j.logger.com.liuzhuo=TRACE#控制台输出配置log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[%5p] [%t] - %m %x %n</code></pre><p>mybatis-config.xml文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--日志采用Log4j--&gt;    &lt;settings&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;    &lt;/settings&gt;    &lt;!--别名--&gt;    &lt;typeAliases&gt;        &lt;typeAlias alias=&quot;user&quot; type=&quot;com.liuzhuo.entities.User&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--定义数据库信息，默认使用development数据库构建环境--&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!--采用JDBC事务管理--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;                &lt;!--取消自动提交--&gt;                &lt;property name=&quot;autoCommit&quot; value=&quot;false&quot;/&gt;            &lt;/transactionManager&gt;            &lt;!--配置数据源的信息--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot;                          value=&quot;jdbc:mysql://localhost:3306/school?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;serverTimezone=GMT%2B8&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/liuzhuo/mapper/userMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>注意：上面取消了事务的自动提交功能！！！（实际开发中，不需要取消，这里只是为了演示组件的生命周期而已）</p><p>SqlSessionFactoryUtil类：</p><pre><code>public class SqlSessionFactoryUtil {    private static SqlSessionFactory sqlSessionFactory = null;    //类锁    private static final Class CLASS_LOCK = SqlSessionFactoryUtil.class;    //私有化构造方法    private SqlSessionFactoryUtil() {    }    /*     *创建sqlSessionFactory     * */    public static SqlSessionFactory initSqlSessionFactory() {        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = null;        try {            inputStream = Resources.getResourceAsStream(resource);        } catch (IOException e) {            e.printStackTrace();        }        //上锁，防止创建多个SqlSessionFactory        synchronized (CLASS_LOCK) {            if (sqlSessionFactory == null) {                sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);            }        }        return sqlSessionFactory;    }    /*     * 打开SqlSession     * */    public static SqlSession openSqlSession() {        if (sqlSessionFactory == null) {            initSqlSessionFactory();        }        return sqlSessionFactory.openSession();    }}</code></pre><p>User类：</p><pre><code>public class User {    private String userId;    private Long userAge;    private String userName;    //省略了set、get、toString方法}</code></pre><p>UserMapper接口：</p><pre><code>public interface UserMapper {    User selectById(Long id);    @Select(&quot;select userId,user_age as useAge,user_name as userName from user where userId = #{id}&quot;)    User selectById02(Long id);}</code></pre><p>userMapper.xml文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.liuzhuo.dao.UserMapper&quot;&gt;    &lt;select id=&quot;selectById&quot; parameterType=&quot;long&quot; resultType=&quot;user&quot;&gt;        select userId,user_name as userName,user_age as userAge from user where userId = #{id}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>注意，接口的方法名与xml映射文件的id保持一致，namespace为接口的全限定名！！！</p><p>MybatisMain类：</p><pre><code>public class MybatisMain {    public static void main(String[] args) {        SqlSession sqlSession = null;        try {            sqlSession = SqlSessionFactoryUtil.openSqlSession();            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);            User user = userMapper.selectById(1L);            System.out.println(user);        } catch (Exception e) {            System.out.println(e.getMessage());            //出现异常，回滚            sqlSession.rollback();        } finally {            //关闭sqlSession对象            if (sqlSession != null) {                sqlSession.close();            }        }    }}</code></pre><p>本地的数据库为school：</p><p>表为user：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190309213806.png"></p><hr><p>运行MybatisMain类中的main方法：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190309213950.png"></p><p>打印出了日志信息，可以看到sql语句的打印信息，获取到了数据库中的数据。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis的第二天简单入门</title>
      <link href="/2019/03/08/mybatis-de-di-er-tian-jian-dan-ru-men/"/>
      <url>/2019/03/08/mybatis-de-di-er-tian-jian-dan-ru-men/</url>
      
        <content type="html"><![CDATA[<p>今天来学习Mybatis的基本用法，带大家入门。</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>学习编程是一门实操的科学，只有一边敲代码一边学习才能有更好的效果，所以需要搭建一个学习的环境才行。</p><h4 id="下载Mybatis"><a href="#下载Mybatis" class="headerlink" title="下载Mybatis"></a>下载Mybatis</h4><p>输入官网：<a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a> 进入官网，我们就可以下载Mybatis，如下图所示：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190308214814.png"></p><p>在这里，我们可以下载到Mybatis所需的jar包和源码包。</p><p>mybatis的jar包下载地址：<a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a></p><p>mybatis和Spring整合jar包下载地址：<a href="https://github.com/mybatis/spring/releases" target="_blank" rel="noopener">https://github.com/mybatis/spring/releases</a></p><hr><p><strong><code>使用Mybatis项目可以参考</code></strong>：<a href="http://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">http://mybatis.org/mybatis-3/zh/index.html</a></p><p><strong><code>使用Mybatis-Spring项目可以参考</code></strong>：<a href="http://mybatis.org/spring/zh/index.html" target="_blank" rel="noopener">http://mybatis.org/spring/zh/index.html</a></p><h3 id="搭建Mybatis的环境"><a href="#搭建Mybatis的环境" class="headerlink" title="搭建Mybatis的环境"></a>搭建Mybatis的环境</h3><p>无论使用哪种java IDE都可以轻松的搭建开发环境。我这里使用IDEA来搭建开发环境，Eclipse也行，都是类似的。</p><p>使用IDEA时，我们可以创建普通的java项目，然后将<strong>下载的Mybatis的jar和lib包</strong>导入到项目中使用Mybatis，但是，我觉得还是使用maven来搭建环境比较好，毕竟大家最后开发都是使用maven来开发项目的，maven大家应该都比较熟悉了，这里就不解释了。</p><p>（1） 使用IDEA创建maven项目：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190308220624.png"></p><p>（2）添加Mybatis的依赖：</p><pre><code>    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190308220907.png"></p><p>至于：Mybatis的版本号，自己到maven的仓库中寻找最新即可，我现在最新的版本是3.4.6</p><p>以上，我们的Mybatis的开发环境就搭建完毕了。</p><hr><h3 id="Mybatis的基本构成"><a href="#Mybatis的基本构成" class="headerlink" title="Mybatis的基本构成"></a>Mybatis的基本构成</h3><ul><li><p>SqlSessionFactoryBuilder(构造器)：它会根据配置信息或者代码来生成SqlSessionFactory（工厂接口）</p></li><li><p>SqlSessionFactory：依靠工厂来生成SqlSession（会话）。</p></li><li><p>SqlSession：是一个既可以发送SQL去执行并返回结果，也可以获取Mapper的接口。</p></li><li><p>SQL Mapper：它是Mybatis新设计的组件，它是由一个java接口和XML文件（或注解）构成的，需要给出对应的SQL和映射规则。它负责发送SQL去执行，并返回结果。</p></li></ul><p>可以用如下的图来表示：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190309094652.png"></p><h4 id="构建SqlSessionFactory"><a href="#构建SqlSessionFactory" class="headerlink" title="构建SqlSessionFactory"></a>构建SqlSessionFactory</h4><p>每个Mybatis应用都是以SqlSessionFactory的实例为中心的。SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获取。但是注意：SqlSessionFactory只是一个接口，它的任务是创建SqlSession。SqlSession类似于一个JDBC的Connection对象。Mybatis提供了两种模式去创建SqlsessionFactory：<strong>一种是使用XML配置的方式</strong>，<strong>另一种是代码的方式</strong>。</p><p>通过SqlSessionFactoryBuilder创建SqlsessionFactory时，需要传入一个XML配置文件，然后构建Configuration对象，类的全限定名是：<code>org.apache.ibatis.session.Configuration</code>，这个对象存在于整个Mybatis应用的生命周期中，以便重复的读取和运用。我们解析一次配置的XML文件保存到Configuration类对象中，方便我们从这个对象中读取配置信息，性能高。</p><p>在Mybatis中提供了两个SqlSessionFactory的实现类，<strong>DefaultSqlSessionFactory</strong> 和 <strong>SqlSessionManager</strong>。 不过目前，SqlSessionManager还没有使用，Mybatis中目前使用的是：DefaulSqlSessionFactory。<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190309100536.png"></p><p>(1)XML构成SqlsessionFactory</p><p>在我们的项目中的resources的根目录中创建：mybatis-config.xml文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--别名--&gt;    &lt;typeAliases&gt;        &lt;typeAlias alias=&quot;user&quot; type=&quot;com.liuzhuo.entity.User&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--定义数据库信息，默认使用development数据库构建环境--&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!--采用JDBC事务管理--&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;!--配置数据源的信息--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/school?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=GMT%2B8&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/liuzhuo/mapper/userMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190309104551.png"></p><p>这里配置信息，看注释即可，以后会专门来讲解这个配置文件。</p><p><strong>这里注意一下，mysql的url的连接配置：</strong></p><p>我这里的驱动版本是：mysql-connector-java-8.0.13</p><p>8.0之前（网上有说6.0.2版本之后改的）<br>com.mysql.jdbc.Driver<br>jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8</p><p>8.0及以后（或者说6.0.2版本之后）<br>com.mysql.cj.jdbc.Driver<br>jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</p><p><code>还有，如果你是配置在xml中时，&amp; 需要使用：&amp;amp; 来代替！！！</code></p><hr><p>配置好mybatis-config.xml文件后，就可以创建SqlsessionFactory：</p><pre><code>        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code></pre><p>Mybatis的解析器程序会把mybatis-config.xml文件配置的信息解析到Configuration类对象里面，然后利用SqlSessionFactoryBuilder读取这个对象为我们创建SqlSessionFactory。</p><p>（2）使用代码来创建SqlSessionFactory</p><pre><code>        //配置数据库连接池        PooledDataSource dataSource = new PooledDataSource();        dataSource.setDriver(&quot;com.mysql.cj.jdbc.Driver&quot;);        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/school?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&quot;);        dataSource.setUsername(&quot;root&quot;);        dataSource.setPassword(&quot;123456&quot;);        //构建数据库事务方式        JdbcTransactionFactory transactionFactory = new JdbcTransactionFactory();        Environment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);        //构建Configuration对象        Configuration configuration = new Configuration(environment);        //注册别名        configuration.getTypeAliasRegistry().registerAlias(&quot;user&quot;, User.class);        //加入映射器        configuration.addMapper(UserMapper.class);        //创建SqlSessionFactory        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);</code></pre><p>显然用代码方式和用XML方式只是换了一个方法实现而已，其本质都是一样的。采用代码方式一般是在需要加入自己特性的时候才会用到。</p><hr><h4 id="创建SqlSession"><a href="#创建SqlSession" class="headerlink" title="创建SqlSession"></a>创建SqlSession</h4><p>SqlSession是一个接口类，它类似于你们公司的美女客服，它扮演着门面的作用，而真正干活的是Executor接口，你可以认为它是公司的工程师。假设我是客户找你们公司干活，我只需要告诉前台的美女客服（SqlSession）我要什么信息（参数），要做什么东西，过段时间，她会将结果给我。在这个过程中，作为用户的我所关心的是：</p><p>（1）要给美女客户（SqlSession）什么信息（功能和参数）。</p><p>（2）美女客服会返回什么结果（ResultSet)。</p><p>在Mybatis中的Sqlsession接口的实现类有两个，分别是DefaultSqlSession 和 SqlSessionManager。这里我们不深入讨论Executor接口以及涉及的其他类，只关心SqlSession的用法就好。</p><p>SqlSession就相当于JDBC中的Connection接口对象，我们需要保证每次调用完后能关闭它，所以正确的做法是把关闭Sqlsession接口的代码写在finally语句中保证每次都会关闭SqlSession，让连接资源归还给数据库。</p><p>伪代码如下：</p><pre><code>SqlSession sqlSession = null;try{    //打开SqlSession会话    sqlSession = sqlSessionFactory.openSession();    //some code    sqlSession.commit();}catch(Exception ex){    System.out.println(ex.getMessage());    sqlSession.rollback();}finally{    //在finally语句中确保资源被顺利关闭    if(sqlSession!=null){        sqlSession.close();    }}</code></pre><p>SqlSession的作用：</p><p>（1）获取映射器Mapper，让映射器通过<code>命名空间</code>和<code>方法名</code>找到对应的SQL，发送给数据库执行后返回结果。</p><p>（2）直接通过命名信息去执行SQL返回结果，这是ibatis版本留下的方式。在SqlSession层可以直接通过update、insert、select、delete等方法，带上SQl的id来操作在XML中配置好的SQL，从而完成我们的工作；与此同时它也支持事务，通过commit、rollback方法提交事务或者回滚事务。</p><hr><h4 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h4><p>映射器是由 <code>java接口</code> 和 <code>XML文件</code>（或注解）共同组成的，它的作用如下：</p><p>（1）定义参数类型<br>（2）描述缓存<br>（3）描述SQL语句<br>（4）定义查询结果和POJO的映射关系。</p><p>一个映射器的实现方式有两种：<code>xml方式</code>，<code>注解方式</code>。</p><p>在mybatis-config.xml中，描述了一个xml文件，在<mapper></mapper>标签中，就是用来配置映射器的xml文件，通过它来生成Mapper文件。</p><p>注解的方式是不用写mapper的xml文件的，只需要在Java的接口方法上面写相应的注解信息即可。</p><p>两种方式，根据自己的项目来选择，xml更加灵活，便于排除，写动态sql语句，可读性好，注解只适合于书写简单的sql语句，方便开发简单的项目，不方便维护。</p><p>（1）xml的方式<br>在resources下，创建com.liuzhuo.mapper包，并在其中创建userMapper.xml文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.liuzhuo.dao.UserMapper&quot;&gt;    &lt;select id=&quot;selectById&quot; parameterType=&quot;long&quot; resultType=&quot;user&quot;&gt;        select userId,user_name as userName,user_age as userAge from user where userId = #{id}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190309115557.png"></p><p>使用XML文件配置是Mybatis实现Mapper的首选方式。它是由一个java接口和一个XML文件组成的。</p><p>java接口文件如下：</p><pre><code>public interface UserMapper {    User selectById(Long id);}</code></pre><p>xml中的namespace必须为java接口类的全限定名，java接口中的方法名必须是xml中的id名，这两则必须一致！！！</p><p>我们看到<code>&lt;select&gt;</code>标签中，有一个resultType=user，这是因为我们在mybatis-config.xml中配置了别名，否则就需要填写User类的全限定名了(com.liuzhuo.entity.User)。</p><p>这里的User类为：</p><pre><code>public class User {    private String userId;    private Long userAge;    private String userName;    //省略了get、set、toString方法}</code></pre><p>再看看SQL语句，我们查询了user的信息，并给查询出来的列重新命名了，使用查询出来的列名和POJO对象的属性名一致了，这么Mybatis才会将从数据库中查询出来的信息，自动帮我们赋值到User对象中。如果数据库中的表的列名与POJO对象一致的话，就不需要别名了。</p><hr><h3 id="项目整体结构"><a href="#项目整体结构" class="headerlink" title="项目整体结构"></a>项目整体结构</h3><p>这个项目的整体结构如下：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190309120612.png"></p><p>在java包下：</p><p>com.liuzhuo.entity:存储POJO类</p><p>com.liuzhuo.dao：存储java接口Mapper类</p><p>在resources包下：</p><p>根目录下，存放mybatis-config.xml的基本xml配置文件。</p><p>com.liuzhuo.mapper:存储mapper的xml文件。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在test下，创建com.liuzhuo.test包，并创建一个测试类：</p><pre><code>public class UserTest {    @Test    public void test01() throws IOException {        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        SqlSession sqlSession = sqlSessionFactory.openSession();        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        User user = userMapper.selectById(1L);        System.out.println(user);    }}</code></pre><p>现在完整的pom文件：</p><pre><code>    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.13&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>运行测试方法test01：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190309121425.png"></p><hr><p>这里简单演示一下注解的使用</p><p>在UserMapper接口中：<br>添加新的方法</p><pre><code>public interface UserMapper {    User selectById(Long id);    @Select(&quot;select userId,user_age as useAge,user_name as userName from user where userId = #{id}&quot;)    User selectById02(Long id);}</code></pre><p>在测试类中，添加新的测试方法：</p><pre><code>    @Test    public void test04() throws IOException {        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        SqlSession sqlSession = sqlSessionFactory.openSession();        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        User user = userMapper.selectById02(1L);        System.out.println(user);    }</code></pre><p>这里我们使用：selectById02方法来执行<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190309122041.png"></p><p>发现也能执行成功，所以xml和注解的方式都是类似的。注解还有update、insert、delete等，大家可以去官网去看看，这里就不详细讲解了。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis的开发的第一天</title>
      <link href="/2019/03/08/mybatis-de-kai-fa-de-di-yi-tian/"/>
      <url>/2019/03/08/mybatis-de-kai-fa-de-di-yi-tian/</url>
      
        <content type="html"><![CDATA[<p> 这是Mybatis的开发的第一天，我将讲述原始的jdbc，与orm的区别。</p><h3 id="jdbc的概述"><a href="#jdbc的概述" class="headerlink" title="jdbc的概述"></a>jdbc的概述</h3><p>  Java程序都是通过JDBC（Java DataBase Connectivity）连接数据库的，这样，我们就能通过SQL对数据库编程了。JDBC是由SUN公司提出的一系列规范，但是它只定义了接口规范，而具体的实现是通过各个数据库厂商来实现的，因为每个数据库都有其特殊性，这些是Java规范没有办法来确定的，所以JDBC就是一种典型的桥接模式。</p><h3 id="jdbc的使用"><a href="#jdbc的使用" class="headerlink" title="jdbc的使用"></a>jdbc的使用</h3><p>  传统的jdbc编程的使用给我们带来了连接数据库的功能，但是也引起了巨大的问题。</p><p>  传统的代码如下：<br>  我使用的的编辑器是：idea<br>  打开idea，创建java普通项目即可：</p><p>  <img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190308135115.png"></p><p>  创建com.liuzhuo.jdbc包<br>  然后，创建jdbcTempate类<br>  然后编写jdbc的固定代码：</p><p>  <code>1.创建connection：连接器</code></p><pre><code>     private Connection getConnection() {        Connection connection = null;        try {            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);            String url = &quot;jdbc:mysql://localhost:3306/school?useUnicode=true&amp;useSSL=true&quot;;            String user = &quot;root&quot;;            String password = &quot;123456&quot;;            connection = DriverManager.getConnection(url, user, password);        } catch (ClassNotFoundException | SQLException e) {            e.printStackTrace();            return null;        }        return connection;    }</code></pre><p> <code>2.编写获取用户的SQL代码</code>：</p><pre><code>     public User getUser(Long id) {        Connection connection = getConnection();        PreparedStatement preparedStatement = null;        ResultSet resultSet = null;        try {            preparedStatement = connection.prepareStatement(&quot;SELECT userId,user_age,user_name from user WHERE userId=?&quot;);            preparedStatement.setLong(1, id);            resultSet = preparedStatement.executeQuery();            while (resultSet.next()) {                String userId = resultSet.getString(&quot;userId&quot;);                long user_age = resultSet.getLong(&quot;user_age&quot;);                String user_name = resultSet.getString(&quot;user_name&quot;);                User user = new User();                user.setUserId(userId);                user.setUserAge(user_age);                user.setUserName(user_name);                return user;            }        } catch (SQLException e) {            e.printStackTrace();        } finally {            this.close(resultSet, preparedStatement, connection);        }        return null;    }</code></pre><p> <code>3.编写关闭资源的方法：</code></p><pre><code>     private void close(ResultSet resultSet, PreparedStatement preparedStatement, Connection connection) {        try {            if (resultSet != null &amp;&amp; !resultSet.isClosed()) {                resultSet.close();            }            if (preparedStatement != null &amp;&amp; !preparedStatement.isClosed()) {                preparedStatement.close();            }            if (connection != null &amp;&amp; !connection.isClosed()) {                connection.close();            }        } catch (Exception e) {            e.printStackTrace();        }    }</code></pre><p> 上面的关闭资源，我就简单的使用最大的异常来接受了，生产环境就不要这样了。</p><p> <code>4.编写主函数main：</code></p><pre><code>     public static void main(String[] args) {        JdbcExample jdbcExample = new JdbcExample();        User user = jdbcExample.getUser(1L);        System.out.println(user);    }</code></pre><hr><p> 以上成功的前提是，我们的mysql数据库中有数据呀，我的school数据库中，有user的表：<br>   <img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190308142223.png"></p><p> 现在，运行我们的main函数：</p><p> 发现出现了ClassNotFound异常：</p><p> 因为项目中还必须要包含mysql-connection的jar。</p><p> 在我们的idea中，点击file：<br> <img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190308142504.png" style="width: 50%"></p><p>点击：Modules，然后点击Dependencies，再点击右边的绿色的加号：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190308142758.png"></p><p>然后，在出现的选项中，选择第一项，添加jar包：</p><p>选中你的电脑中，下载的mysql-connector-java：jar包<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190308142926.png"></p><p>点击确定后，在我们的项目中，会在External Libraries中出现相应的jar包：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190308143135.png" style="width: 50%"></p><p>再次运行main函数：<br><img src="https://gakkil.gitee.io/gakkil-image/mybatis/QQ截图20190308143240.png"></p><p>输出了我们的数据库中的数据！！！</p><h3 id="jdbc的总结"><a href="#jdbc的总结" class="headerlink" title="jdbc的总结"></a>jdbc的总结</h3><ol><li><p>使用jdbc编程需要连接数据库，注册驱动和数据库信息</p></li><li><p>操作Connection，打开Statement对象</p></li><li><p>通过Statement执行SQL，返回结果到ResultSet对象。</p></li><li><p>使用ResultSet对象读取数据，然后通过代码转化为POJO对象。</p></li><li><p>关闭数据库相关的资源。</p></li></ol><hr><h3 id="ORM模型"><a href="#ORM模型" class="headerlink" title="ORM模型"></a>ORM模型</h3><p>由于jdbc存在缺陷，在实际工作中我们很少使用JDBC来进行编程，于是提出了对象关系映射（Object Relational Mapping，简称ORM）</p><p>ORM模型就是 将数据库中的表 和 简单的java对象（Plain Ordinary Java Object）进行关系映射。它主要解决了数据库中数据和POJO对象的相互映射。我们通过这层映射关系就可以简单迅速地把数据库表的数据转化为POJO对象，以便程序员更加容易理解和应用java程序。</p><p>ORM映射模型，有Hibernate和Mybatis等，这里，我主要讲解Mybatis的映射，至于HIbernate的使用，大家可以自行的去学习，类似。只不过Hibernate是全表映射，Mybatis是半自动映射的框架。</p><p>Mybatis所需要提供的映射文件包含以下三个部分：</p><ol><li><p>POJO</p></li><li><p>映射规则</p></li><li><p>SQL</p></li></ol><p>在Mybatis中，你需要自己编写SQL语句，虽然比Hibernate配置得多，但是Mybatis可以配置动态的SQL，这解决了Hibernate的表名根据时间变化，不同的条件下列名不一样的问题。同时你也可以优化SQL语句，通过配置决定你的SQl映射规则，也能支持存储过程，所以对于一些复杂的和需要优化性能的SQL的查询它更加方便，Mybatis几乎能做到JDBC所能做到的所有事情。Mybatis具有自动映射功能。换句话说，在注意一些规则的基础上，Mybatis可以给我们自动完成自动映射，而无需写任何的映射规则，这大大提高了开发效率和灵活性。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的父子类的执行顺序</title>
      <link href="/2019/01/22/java-zhong-de-fu-zi-lei-de-zhi-xing-shun-xu/"/>
      <url>/2019/01/22/java-zhong-de-fu-zi-lei-de-zhi-xing-shun-xu/</url>
      
        <content type="html"><![CDATA[<p>Java中的父子类执行顺序</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>类的加载顺序。</p><p>(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)</p><p>(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )</p><p>(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )</p><p>(4) 父类构造函数</p><p>(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )</p><p>(6) 子类构造函数</p><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><p>根据以上结论，运行下面代码，输出的结果是：</p><pre><code>class A {   public A() {//构造函数       System.out.println(&quot;class A&quot;);   }   { //代码块       System.out.println(&quot;I&#39;m A class&quot;);    }   static { //静态代码块       System.out.println(&quot;class A static&quot;);    }}public class B extends A {   public B() {//构造函数       System.out.println(&quot;class B&quot;);   }   { //代码块       System.out.println(&quot;I&#39;m B class&quot;);    }   static { System.out.println(&quot;class B static&quot;);    }   //静态代码块   public static void main(String[] args) {        new B();   }}</code></pre><p>答案：</p><pre><code>class A static class B static I&#39;m A class class AI&#39;m B class class B</code></pre><hr><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>那，父类中的既有静态属性，又有静态代码块的话，谁先执行呢？</p><pre><code>class Print{   Print(){       System.out.println(&quot;haha&quot;);   }}public class Cats {   static {       System.out.println(&quot;static Casts&quot;);   }   static Print test1 = new Print();}class qiaoGeli extends Cats{   public static void main(String [] args)   {       qiaoGeli t1 = new qiaoGeli();   }}</code></pre><p>以上输出：</p><pre><code>static Castshaha</code></pre><p>换一下静态变量和静态代码块的执行顺序。</p><pre><code>class Print{   Print(){       System.out.println(&quot;haha&quot;);   }}public class Cats {   static Print test1 = new Print();   static {       System.out.println(&quot;static Casts&quot;);   }}class qiaoGeli extends Cats{   public static void main(String [] args)   {       qiaoGeli t1 = new qiaoGeli();   }}</code></pre><p>以上输出：</p><pre><code>hahastatic Casts</code></pre><p><strong>结论：</strong>静态代码块和静态属性的执行顺序，取决于它两在代码中的位置。</p><h3 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h3><p>那，类中非静态属性与非静态代码块的顺序呢？</p><pre><code>class Print{   Print(){       System.out.println(&quot;haha&quot;);   }}public class Cats {   Print test = new Print();      //非静态属性   Cats(){                        //构造函数       System.out.println(&quot;I&#39;m qiaoGeLi&quot;);   }   {                              //非静态代码块       System.out.println(&quot;I&#39;m xiaoMeng&quot;);   }   public static void main(String [] args)   {       Cats cat = new Cats();   }}</code></pre><p>以上输出：</p><pre><code>haha              //非静态属性I&#39;m xiaoMeng      //非静态代码块I&#39;m qiaoGeLi      //构造方法</code></pre><p>那是不是：非静态属性 &gt; 非静态代码块 &gt; 构造器 呢 ？</p><font color="red">不是哦!</font><h3 id="例子4"><a href="#例子4" class="headerlink" title="例子4"></a>例子4</h3><pre><code>class Print{   Print(){       System.out.println(&quot;haha&quot;);   }}public class Cats {   Cats(){       System.out.println(&quot;I&#39;m qiaoGeLi&quot;);   }   {       System.out.println(&quot;I&#39;m xiaoMeng&quot;);   }   Print test = new Print();   public static void main(String [] args)   {       Cats cat = new Cats();   }}</code></pre><p>以上输出结果：</p><pre><code>I&#39;m xiaoMenghahaI&#39;m qiaoGeLi</code></pre><font color="red">故意将构造器放在最上面，但是它还是最后执行的，可是非静态属性与非静态代码块的执行顺序变了。</font><p><strong>结论：</strong>非静态属性和非静态代码块谁在前谁先执行，构造器在最后执行！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>类的执行顺序。</p><p>(1)父类静态变量 和 静态代码块（先声明的先执行）;</p><p>(2)子类静态变量 和 静态代码块（先声明的先执行）;</p><p>(3)父类的非静态属性（变量）和 非静态代码块（先声明的先执行）；</p><p>(4)父类构造函数</p><p>(5)子类的非静态属性（变量）和 非静态代码块（先声明的先执行）；</p><p>(6)子类构造函数</p>]]></content>
      
      
      <categories>
          
          <category> 父子类 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 父子类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat的启动分析(四)webapp</title>
      <link href="/2019/01/18/tomcat-de-qi-dong-fen-xi-si-webapp/"/>
      <url>/2019/01/18/tomcat-de-qi-dong-fen-xi-si-webapp/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章中我们分析了 Service、Engine、Host、Pipeline、Valve 组件的启动逻辑，在 HostConfig 中会实例化 StandardContext，并启动 Context 容器，完成 webapp 应用程序的启动，这一块是最贴近我们开发的应用程序。在这一篇文章中，我们将要分析 tomcat 是如何解析并初始化应用程序定义的 Servlet、Filter、Listener 等</p><p>首先我们思考几个问题： </p><p>1.tomcat 如何支持 servlet3.0 的注解编程，比如对 javax.servlet.annotation.WebListener 注解的支持？</p><pre><code>如果 tomcat 利用 ClassLoader 加载 webapp 下面所有的 class，从而分析 Class 对象的注解，这样子肯定会导致很多问题，比如 MetaSpace 出现内存溢出，而且加载了很多不想干的类，我们知道 jvm 卸载 class 的条件非常苛刻，这显然是不可取的。因此，tomcat 开发了字节码解析的工具类，位于  org.apache.tomcat.util.bcel，bcel 即 ：Byte Code Engineering Library，专门用于解析 class 字节码，而不是像我们前面猜测的那样，把类加载到 jvm 中.</code></pre><p>2.假如 webapp 目录有多个应用，使用的开源框架的 jar 版本不尽一致，tomcat 是怎样避免出现类冲突？</p><pre><code>不同的 webapp 使用不同的 ClassLoader 实例加载 class，因此 webapp 内部加载的 class 是不同的，自然不会出现类冲突，当然这里要排除 ClassLoader 的 parent 能够加载的 class。关于 ClassLoader 这一块，后续会专门写一篇博客进行分析</code></pre><h3 id="Context-容器"><a href="#Context-容器" class="headerlink" title="Context 容器"></a>Context 容器</h3><p>首先，我们来看下StandardContext重要的几个属性，包括了我们熟悉的 ServletContext、servlet容器相关的Listener(比如 SessionListener 和 ContextListener)、FilterConfig</p><pre><code>protected ApplicationContext context：即ServletContext上下文private InstanceManager instanceManager：根据 class 实例化对象，比如 Listener、Filter、Servlet 实例对象private List&lt;Object&gt; applicationEventListenersList：SessionListener、ContextListner 等集合private HashMap&lt;String, ApplicationFilterConfig&gt; filterConfigs：filer 名字与 FilterConfig 的映射关系private Loader loader：用于加载class等资源private final ReadWriteLock loaderLock：用于对loader的读写操作protected Manager manager：Session管理器private final ReadWriteLock managerLock：用于对manager的读写操作private HashMap&lt;String, String&gt; servletMappings：url与Servlet名字的映射关系private HashMap&lt;Integer, ErrorPage&gt; statusPages：错误码与错误页的映射private JarScanner jarScanner：用于扫描jar包资源private CookieProcessor cookieProcessor：cookies处理器，默认使用Rfc6265CookieProcessor</code></pre><p>StandardContext 和其他 Container 一样，也是重写了 startInternal 方法。由于涉及到 webapp 的启动流程，需要很多准备工作，比如使用 WebResourceRoot 加载资源文件、利用 Loader 加载 class、使用 JarScanner 扫描 jar 包，等等。因此StandardContext 的启动逻辑比较复杂，这里描述下几个重要的步骤：</p><ol><li><p>创建工作目录，比如$CATALINA_HOME\work\Catalina\localhost\examples；实例化 ContextServlet，应用程序拿到的是 ApplicationContext的外观模式 </p></li><li><p>实例化 WebResourceRoot，默认实现类是 StandardRoot，用于读取 webapp 的文件资源 </p></li><li><p>实例化 Loader 对象，Loader 是 tomcat 对于 ClassLoader 的封装，用于支持在运行期间热加载 class </p></li><li><p>发出 CONFIGURE_START_EVENT 事件，ContextConfig 会处理该事件，主要目的是从 webapp 中读取 servlet 相关的 Listener、Servlet、Filter 等 </p></li><li><p>实例化 Sesssion 管理器，默认使用 StandardManager </p></li><li><p>调用 listenerStart，实例化 servlet 相关的各种 Listener，并且调用ServletContextListener </p></li><li><p>处理 Filter </p></li><li><p>加载 Servlet</p></li></ol><p>下面，将分析下几个重要的步骤</p><h4 id="触发-CONFIGURE-START-EVENT-事件"><a href="#触发-CONFIGURE-START-EVENT-事件" class="headerlink" title="触发 CONFIGURE_START_EVENT 事件"></a>触发 CONFIGURE_START_EVENT 事件</h4><p>ContextConfig 它是一个 LifycycleListener，它在 Context 启动过程中是承担了一个非常重要的角色。StandardContext 会发出 CONFIGURE_START_EVENT 事件，而 ContextConfig 会处理该事件，主要目的是通过 web.xml 或者 Servlet3.0 的注解配置，读取 Servlet 相关的配置信息，比如 Filter、Servlet、Listener 等，其核心逻辑在 ContextConfig#webConfig() 方法中实现。下面，我们对 ContextConfig 进行详细分析</p><ol><li>首先，是通过 WebXmlParser 对 web.xml 进行解析，如果存在 web.xml 文件，则会把文件中定义的 Servlet、Filter、Listener 注册到 WebXml 实例中</li></ol><pre><code>WebXmlParser webXmlParser = new WebXmlParser(context.getXmlNamespaceAware(),            context.getXmlValidation(), context.getXmlBlockExternal());Set&lt;WebXml&gt; defaults = new HashSet&lt;&gt;();defaults.add(getDefaultWebXmlFragment(webXmlParser));// 创建 WebXml实例，并解析 web.xml 文件WebXml webXml = createWebXml();InputSource contextWebXml = getContextWebXmlSource();if (!webXmlParser.parseWebXml(contextWebXml, webXml, false)) {    ok = false;}</code></pre><p>1、 接下来，会处理 javax.servlet.ServletContainerInitializer，把对象实例保存到 ContextConfig 的 Map 中，待 Wrapper 子容器添加到 StandardContext 子容器中之后，再把 ServletContainerInitializer 加入 ServletContext 中。ServletContainerInitializer 是 servlet3.0 提供的一个 SPI，可以通过 HandlesTypes 筛选出相关的 servlet 类，并可以对 ServletContext 进行额外处理，下面是一个自定义的 ServletContainerInitializer，实现了 ServletContainerInitializer 接口，和 jdk 提供的其它 SPI 一样，需要在 META-INF/services/javax.servlet.ServletContainerInitializer 文件中指定该类名 net.dwade.tomcat.CustomServletContainerInitializer</p><pre><code>@HandlesTypes( Filter.class )public class CustomServletContainerInitializer implements ServletContainerInitializer {    @Override    public void onStartup(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx) throws ServletException {        for ( Class&lt;?&gt; type : c ) {            System.out.println( type.getName() );        }    }}</code></pre><p>2、如果没有 web.xml 文件，tomcat 会先扫描 WEB-INF/classes 目录下面的 class 文件，然后扫描 WEB-INF/lib 目录下面的 jar 包，解析字节码读取 servlet 相关的注解配置类，这里不得不吐槽下 serlvet3.0 注解，对 servlet 注解的处理相当重量级。tomcat 不会预先把该 class 加载到 jvm 中，而是通过解析字节码文件，获取对应类的一些信息，比如注解、实现的接口等，核心代码如下所示：</p><pre><code>protected void processAnnotationsStream(InputStream is, WebXml fragment,            boolean handlesTypesOnly, Map&lt;String,JavaClassCacheEntry&gt; javaClassCache)            throws ClassFormatException, IOException {    // is 即 class 字节码文件的 IO 流    ClassParser parser = new ClassParser(is);    // 使用 JavaClass 封装 class 相关的信息    JavaClass clazz = parser.parse();    checkHandlesTypes(clazz, javaClassCache);    if (handlesTypesOnly) {        return;    }    AnnotationEntry[] annotationsEntries = clazz.getAnnotationEntries();    if (annotationsEntries != null) {        String className = clazz.getClassName();        for (AnnotationEntry ae : annotationsEntries) {            String type = ae.getAnnotationType();            if (&quot;Ljavax/servlet/annotation/WebServlet;&quot;.equals(type)) {                processAnnotationWebServlet(className, ae, fragment);            }else if (&quot;Ljavax/servlet/annotation/WebFilter;&quot;.equals(type)) {                processAnnotationWebFilter(className, ae, fragment);            }else if (&quot;Ljavax/servlet/annotation/WebListener;&quot;.equals(type)) {                fragment.addListener(className);            } else {                // Unknown annotation - ignore            }        }    }}</code></pre><p>tomcat 使用自己的工具类 ClassParser 通过对字节码文件进行解析，获取其注解，并把 WebServlet、WebFilter、WebListener 注解的类添加到 WebXml 实例中，统一由它对 ServletContext 进行参数配置。tomcat 对字节码的处理是由<br>org.apache.tomcat.util.bcel 包完成的，bcel 即 Byte Code Engineering Library，其实现比较繁锁，需要对字节码结构有一定的了解，感兴趣的童鞋可以研究下底层实现。</p><p>3、配置信息读取完毕之后，会把 WebXml 装载的配置赋值给 ServletContext，在这个时候，ContextConfig 会往 StardardContext 容器中添加子容器（即 Wrapper 容器），部分代码如下所示：</p><pre><code>private void configureContext(WebXml webxml) {    // 设置 Filter 定义    for (FilterDef filter : webxml.getFilters().values()) {        if (filter.getAsyncSupported() == null) {            filter.setAsyncSupported(&quot;false&quot;);        }        context.addFilterDef(filter);    }    // 设置 FilterMapping，即 Filter 的 URL 映射    for (FilterMap filterMap : webxml.getFilterMappings()) {        context.addFilterMap(filterMap);    }    // 往 Context 中添加子容器 Wrapper，即 Servlet    for (ServletDef servlet : webxml.getServlets().values()) {        Wrapper wrapper = context.createWrapper();        // 省略若干代码。。。        wrapper.setOverridable(servlet.isOverridable());        context.addChild(wrapper);    }}</code></pre><p>4、 tomcat 还会加载 WEB-INF/classes/META-INF/resources/、WEB-INF/lib/xxx.jar/META-INF/resources/ 的静态资源，这一块的作用暂时不清楚，关键代码如下所示：</p><pre><code>// fragments 包括了 WEB-INF/classes、WEB-INF/lib/xxx.jarprotected void processResourceJARs(Set&lt;WebXml&gt; fragments) {    for (WebXml fragment : fragments) {        URL url = fragment.getURL();        if (&quot;jar&quot;.equals(url.getProtocol()) || url.toString().endsWith(&quot;.jar&quot;)) {            try (Jar jar = JarFactory.newInstance(url)) {                jar.nextEntry();                String entryName = jar.getEntryName();                while (entryName != null) {                    if (entryName.startsWith(&quot;META-INF/resources/&quot;)) {                        context.getResources().createWebResourceSet(                                WebResourceRoot.ResourceSetType.RESOURCE_JAR,                                &quot;/&quot;, url, &quot;/META-INF/resources&quot;);                        break;                    }                    jar.nextEntry();                    entryName = jar.getEntryName();                }            }        } else if (&quot;file&quot;.equals(url.getProtocol())) {            File file = new File(url.toURI());            File resources = new File(file, &quot;META-INF/resources/&quot;);            if (resources.isDirectory()) {                context.getResources().createWebResourceSet(                        WebResourceRoot.ResourceSetType.RESOURCE_JAR,                        &quot;/&quot;, resources.getAbsolutePath(), null, &quot;/&quot;);            }        }    }}</code></pre><h4 id="启动-Wrapper-容器"><a href="#启动-Wrapper-容器" class="headerlink" title="启动 Wrapper 容器"></a>启动 Wrapper 容器</h4><p>ContextConfig 把 Wrapper 子容器添加到 StandardContext 容器中之后，便会挨个启动 Wrapper 子容器。但是实际上，由于 StandardContext 至 ContainerBase，在添加子容器的时候，便会调用 start 方法启动 Wrapper，关于 Wrapper 的启动在下文进行详细分析</p><pre><code>for (Container child : findChildren()) {    if (!child.getState().isAvailable()) {        child.start();    }}</code></pre><h4 id="调用-ServletContainerInitializer"><a href="#调用-ServletContainerInitializer" class="headerlink" title="调用 ServletContainerInitializer"></a>调用 ServletContainerInitializer</h4><p>在初始化 Servlet、Listener 之前，便会先调用 ServletContainerInitializer，进行额外的初始化处理。注意：ServletContainerInitializer 需要的是 Class 对象，而不是具体的实例对象，这个时候 servlet 相关的 Listener 并没有被实例化，因此不会产生矛盾</p><pre><code>// 指定 ServletContext 的相关参数mergeParameters();// 调用 ServletContainerInitializer#onStartup()for (Map.Entry&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; entry :    initializers.entrySet()) {    try {        entry.getKey().onStartup(entry.getValue(),                getServletContext());    } catch (ServletException e) {        log.error(sm.getString(&quot;standardContext.sciFail&quot;), e);        ok = false;        break;    }}</code></pre><h4 id="启动-Servlet-相关的-Listener"><a href="#启动-Servlet-相关的-Listener" class="headerlink" title="启动 Servlet 相关的 Listener"></a>启动 Servlet 相关的 Listener</h4><p>WebConfig 加载 Listener 时，只是保存了 className，实例化动作由 StandardContext 触发。前面在介绍 StandardContext 的时候提到了 InstanceManager，创建实例的逻辑由 InstanceManager 完成。</p><p>Listener 监听器分为 Event、Lifecycle 监听器，WebConfig 在加载 Listener 的时候是不会区分的，实例化之后才会分开存储。在完成 Listener 实例化之后，tomcat 容器便启动 OK 了。此时，tomcat 需要通知应用程序定义的 ServletContextListener，方便应用程序完成自己的初始化逻辑，它会遍历 ServletContextListener 实例，并调用其 contextInitialized 方法，比如 spring 的 ContextLoaderListener</p><p>有以下 Event 监听器，主要是针对事件通知：</p><ul><li><p>ServletContextAttributeListener</p></li><li><p>ServletRequestAttributeListener</p></li><li><p>ServletRequestListener </p></li><li><p>HttpSessionIdListener </p></li></ul><p>*　HttpSessionAttributeListener</p><p>有以下两种 Lifecycle 监听器，主要是针对 ServletContext、HttpSession 的生命周期管理，比如创建、销毁等 </p><ul><li><p>ServletContextListener</p></li><li><p>HttpSessionListener</p></li></ul><h3 id="初始化-Filter"><a href="#初始化-Filter" class="headerlink" title="初始化 Filter"></a>初始化 Filter</h3><p>ContextConfig 在处理 CONFIGURE_START_EVENT 事件的时候，会使用 FilterDef 保存 Filter 信息。而 StandardContext 会把 FilterDef 转化成 ApplicationFilterConfig，在 ApplicationFilterConfig 构造方法中完成 Filter 的实例化，并且调用 Filter 接口的 init 方法，完成 Filter 的初始化。ApplicationFilterConfig 是 javax.servlet.FilterConfig<br>接口的实现类。</p><pre><code>public boolean filterStart() {    boolean ok = true;    synchronized (filterConfigs) {        filterConfigs.clear();        for (Entry&lt;String,FilterDef&gt; entry : filterDefs.entrySet()) {            String name = entry.getKey();            try {                // 在构造方法中完成 Filter 的实例化，并且调用 Filter 接口的 init 方法，完成 Filter 的初始化                ApplicationFilterConfig filterConfig =                        new ApplicationFilterConfig(this, entry.getValue());                filterConfigs.put(name, filterConfig);            } catch (Throwable t) {                // 省略 logger 处理                ok = false;            }        }    }    return ok;}</code></pre><h3 id="处理-Wrapper-容器"><a href="#处理-Wrapper-容器" class="headerlink" title="处理 Wrapper 容器"></a>处理 Wrapper 容器</h3><p>Servlet 对应 tomcat 的 Wrapper 容器，完成 Filter 初始化之后便会对 Wrapper 容器进行处理，如果 Servlet 的 loadOnStartup &gt;= 0，便会在这一阶段完成 Servlet 的加载，并且值越小越先被加载，否则在接受到请求的时候才会加载 Servlet。</p><p>加载过程，主要是完成 Servlet 的实例化，并且调用 Servlet 接口的 init 方法，具体的逻辑将在下文进行详细分析</p><pre><code>// StandardWrapper 实例化并且启动 Servlet，由于 Servlet 存在 loadOnStartup 属性// 因此使用了 TreeMap，根据 loadOnStartup 值 对 Wrapper 容器进行排序，然后依次启动 Servletif (ok) {    if (!loadOnStartup(findChildren())){        log.error(sm.getString(&quot;standardContext.servletFail&quot;));        ok = false;    }}</code></pre><p>loadOnStartup 方法使用 TreeMap 对 Wrapper 进行排序，loadOnStartup 值越小越靠前，值相同的 Wrapper 放在同一个 List 中，代码如下所示：</p><pre><code>public boolean loadOnStartup(Container children[]) {    // 使用 TreeMap 对 Wrapper 进行排序，loadOnStartup 值越小越靠前，值相同的 Wrapper 放在同一个 List 中    TreeMap&lt;Integer, ArrayList&lt;Wrapper&gt;&gt; map = new TreeMap&lt;&gt;();    for (int i = 0; i &lt; children.length; i++) {        Wrapper wrapper = (Wrapper) children[i];        int loadOnStartup = wrapper.getLoadOnStartup();        if (loadOnStartup &lt; 0)            continue;        Integer key = Integer.valueOf(loadOnStartup);        ArrayList&lt;Wrapper&gt; list = map.get(key);        if (list == null) {            list = new ArrayList&lt;&gt;();            map.put(key, list);        }        list.add(wrapper);    }    // 根据 loadOnStartup 值有序加载 Wrapper 容器    for (ArrayList&lt;Wrapper&gt; list : map.values()) {        for (Wrapper wrapper : list) {            try {                wrapper.load();            } catch (ServletException e) {                if(getComputedFailCtxIfServletStartFails()) {                    return false;                }            }        }    }    return true;}</code></pre><h3 id="Wrapper-容器"><a href="#Wrapper-容器" class="headerlink" title="Wrapper 容器"></a>Wrapper 容器</h3><p>Wrapper 容器是 tomcat 所有容器中最底层子容器，它没有子容器，并且父容器是 Context，对这一块不了解的童鞋请移步前面的博客《tomcat框架设计》。默认实现是 StandardWrapper，我们先来看看类定义，它继承至 ContainBase，实现了 servlet 的 ServletConfig 接口，以及 tomcat 的 Wrapper 接口，说明 StandardWrapper 不仅仅是一个 Wrapper 容器实现，还是 ServletConfig 实现，部分代码如下所示：</p><pre><code>public class StandardWrapper extends ContainerBase    implements ServletConfig, Wrapper, NotificationEmitter {    // Wrapper 的门面模式，调用 Servlet 的 init 方法传入的是该对象    protected final StandardWrapperFacade facade = new StandardWrapperFacade(this);        protected volatile Servlet instance = null; // Servlet 实例对象    protected int loadOnStartup = -1;   // 默认值为 -1，不立即启动 Servlet    protected String servletClass = null;    public StandardWrapper() {        super();        swValve=new StandardWrapperValve();        pipeline.setBasic(swValve);        broadcaster = new NotificationBroadcasterSupport();    }}</code></pre><p>由前面对 Context 的分析可知，StandardContext 在启动的时候会发出 CONFIGURE_START_EVENT 事件，ContextConfig 会处理该事件，通过解析 web.xml 或者读取注解信息获取 Wrapper 子容器，并且会添加到 Context 容器中。由于 StandardContext 继承至 ContainerBase，在调用 addChild 的时候默认会启动 child 容器(即 Wrapper)，我们来看看 StandardWrapper 的启动逻辑。</p><h4 id="启动-Wrapper-容器-1"><a href="#启动-Wrapper-容器-1" class="headerlink" title="启动 Wrapper 容器"></a>启动 Wrapper 容器</h4><p>StandardWrapper 没有子容器，启动逻辑相对比较简单清晰，它重写了 startInternal 方法，主要是完成了 jmx 的事件通知，先后向 jmx 发出 starting、running 事件，代码如下所示：</p><pre><code>protected synchronized void startInternal() throws LifecycleException {    // 发出 j2ee.state.starting 事件通知    if (this.getObjectName() != null) {        Notification notification =            new Notification(&quot;j2ee.state.starting&quot;, this.getObjectName(), sequenceNumber++);        broadcaster.sendNotification(notification);    }    // ConainerBase 的启动逻辑    super.startInternal();    setAvailable(0L);    // 发出 j2ee.state.running 事件通知    if (this.getObjectName() != null) {        Notification notification =            new Notification(&quot;j2ee.state.running&quot;, this.getObjectName(), sequenceNumber++);        broadcaster.sendNotification(notification);    }}</code></pre><h4 id="加载-Wrapper"><a href="#加载-Wrapper" class="headerlink" title="加载 Wrapper"></a>加载 Wrapper</h4><p>由前面对 Context 容器的分析可知，Context 完成 Filter 初始化之后，如果 loadOnStartup &gt;= 0 便会调用 load 方法加载 Wrapper 容器。StandardWrapper 使用 InstanceManager 实例化 Servlet，并且调用 Servlet 的 init 方法进行初始化，传入的 ServletConfig 是 StandardWrapperFacade 对象</p><pre><code>public synchronized void load() throws ServletException {    // 实例化 Servlet，并且调用 init 方法完成初始化    instance = loadServlet();    if (!instanceInitialized) {        initServlet(instance);    }    if (isJspServlet) {        // 处理 jsp Servlet    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>tomcat 实现了 javax.servlet.ServletContext 接口，在 Context 启动的时候会实例化该对象。由 Context 容器通过 web.xml 或者 扫描 class 字节码读取 servlet3.0 的注解配置，从而加载 webapp 定义的 Listener、Servlet、Filter 等 servlet 组件，但是并不会立即实例化对象。</p><p>全部加载完毕之后，依次对 Listener、Filter、Servlet 进行实例化、并且调用其初始化方法，比如 ServletContextListener#contextInitialized()、Flter#init() 等。</p>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat的启动分析(三)Catalina启动</title>
      <link href="/2019/01/18/tomcat-de-qi-dong-fen-xi-san-catalina-qi-dong/"/>
      <url>/2019/01/18/tomcat-de-qi-dong-fen-xi-san-catalina-qi-dong/</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章中，我们分析了tomcat的初始化过程，是由Bootstrap反射调用Catalina的load方法完成tomcat的初始化，包括server.xml的解析、实例化各大组件、初始化组件等逻辑。那么tomcat又是如何启动webapp应用，又是如何加载应用程序的ServletContextListener，以及Servlet呢？我们将在这篇文章进行分析。</p><p>我们先来看下整体的启动逻辑，tomcat由上往下，挨个启动各个组件： </p><p><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190118133508.png"></p><p>针对如此复杂的组件关系，tomcat 又是如何将各个组件串联起来，实现统一的生命周期管控呢？在这篇文章中，我们将分析 Service、Engine、Host、Pipeline、Valve 组件的启动逻辑，进一步理解tomcat的架构设计</p><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><p>启动过程和初始化一样，由Bootstrap反射调用Catalina的 start 方法</p><pre><code>public void start() throws Exception {    if( catalinaDaemon==null ) init();    Method method = catalinaDaemon.getClass().getMethod(&quot;start&quot;, (Class [] )null);    method.invoke(catalinaDaemon, (Object [])null);}</code></pre><h3 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h3><p>主要分为以下三个步骤，其核心逻辑在于Server组件： </p><ol><li><p>调用Server的start方法，启动Server组件 </p></li><li><p>注册jvm关闭的勾子程序，用于安全地关闭Server组件，以及其它组件</p></li><li><p>开启shutdown端口的监听并阻塞，用于监听关闭指令</p></li></ol><pre><code>public void start() {    // 省略若干代码......    // Start the new server    try {        getServer().start();    } catch (LifecycleException e) {        // 省略......        return;    }    // 注册勾子，用于安全关闭tomcat    if (useShutdownHook) {        if (shutdownHook == null) {            shutdownHook = new CatalinaShutdownHook();        }        Runtime.getRuntime().addShutdownHook(shutdownHook);    }    // Bootstrap中会设置await为true，其目的在于让tomcat在shutdown端口阻塞监听关闭命令    if (await) {        await();        stop();    }}</code></pre><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>在前面的Lifecycle文章中，我们介绍了StandardServer重写了startInternal方法，完成自己的逻辑，如果对tomcat的Lifecycle还不熟悉的童鞋，先学习下Lifecycle，<font color="red">《Tomcat8源码分析系列-启动分析(一) Lifecycle》</font></p><p>StandardServer的代码如下所示：</p><pre><code>protected void startInternal() throws LifecycleException {    fireLifecycleEvent(CONFIGURE_START_EVENT, null);    setState(LifecycleState.STARTING);    globalNamingResources.start();    // Start our defined Services    synchronized (servicesLock) {        for (int i = 0; i &lt; services.length; i++) {            services[i].start();        }    }}</code></pre><p>先是由LifecycleBase统一发出STARTING_PREP事件，StandardServer额外还会发出CONFIGURE_START_EVENT、STARTING事件，用于通知LifecycleListener在启动前做一些准备工作，比如NamingContextListener会处理CONFIGURE_START_EVENT事件，实例化tomcat相关的上下文，以及ContextResource资源</p><p>然后，启动内部的NamingResourcesImpl实例，这个类封装了各种各样的数据，比如ContextEnvironment、ContextResource、Container等等，它用于Resource资源的初始化，以及为webapp应用提供相关的数据资源，比如 JNDI 数据源(对应ContextResource)</p><p>接着，启动Service组件，这一块的逻辑将在下面进行详细分析，最后由LifecycleBase发出STARTED事件，完成start</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>StandardService的start代码如下所示： </p><ol><li><p>启动Engine，Engine的child容器都会被启动，webapp的部署会在这个步骤完成； </p></li><li><p>启动Executor，这是tomcat用Lifecycle封装的线程池，继承至java.util.concurrent.Executor以及tomcat的Lifecycle接口 </p></li><li><p>启动Connector组件，由Connector完成Endpoint的启动，这个时候意味着tomcat可以对外提供请求服务了</p></li></ol><pre><code>protected void startInternal() throws LifecycleException {    setState(LifecycleState.STARTING);    // 启动Engine    if (engine != null) {        synchronized (engine) {            engine.start();        }    }    // 启动Executor线程池    synchronized (executors) {        for (Executor executor: executors) {            executor.start();        }    }    // 启动MapperListener    mapperListener.start();    // 启动Connector    synchronized (connectorsLock) {        for (Connector connector: connectors) {            try {                // If it has already failed, don&#39;t try and start it                if (connector.getState() != LifecycleState.FAILED) {                    connector.start();                }            } catch (Exception e) {                // logger......            }        }    }}</code></pre><h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><p>在Server调用startInternal启动的时候，首先会调用start启动StandardEngine，而StandardEngine继承至ContainerBase，我们再来回顾下Lifecycle类图，关于Container，我们只需要关注右下角的部分即可。</p><p><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190118134119.png"></p><p>StandardEngine、StandardHost、StandardContext、StandardWrapper各个容器存在父子关系，一个父容器包含多个子容器，并且一个子容器对应一个父容器。Engine是顶层父容器，它不存在父容器，关于各个组件的详细介绍，请参考《tomcat框架设计》。各个组件的包含关系如下图所示，默认情况下，StandardEngine只有一个子容器StandardHost，一个StandardContext对应一个webapp应用，而一个StandardWrapper对应一个webapp里面的一个 Servlet。</p><p><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190118134247.png"></p><p>由类图可知，StandardEngine、StandardHost、StandardContext、StandardWrapper都是继承至ContainerBase，各个容器的启动，都是由父容器调用子容器的start方法，也就是说由StandardEngine启动StandardHost，再StandardHost启动StandardContext，以此类推。</p><p>由于它们都是继续至ContainerBase，当调用 start 启动Container容器时，首先会执行 ContainerBase 的 start 方法，它会寻找子容器，并且在线程池中启动子容器，StandardEngine也不例外。</p><h4 id="ContainerBase"><a href="#ContainerBase" class="headerlink" title="ContainerBase"></a>ContainerBase</h4><p>ContainerBase的startInternal方法如下所示，主要分为以下3个步骤： </p><ol><li><p>启动子容器 </p></li><li><p>启动Pipeline，并且发出STARTING事件</p></li><li><p>如果backgroundProcessorDelay参数 &gt;= 0，则开启ContainerBackgroundProcessor线程，用于调用子容器的backgroundProcess</p></li></ol><pre><code>protected synchronized void startInternal() throws LifecycleException {    // 省略若干代码......    // 把子容器的启动步骤放在线程中处理，默认情况下线程池只有一个线程处理任务队列    Container children[] = findChildren();    List&lt;Future&lt;Void&gt;&gt; results = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; children.length; i++) {        results.add(startStopExecutor.submit(new StartChild(children[i])));    }    // 阻塞当前线程，直到子容器start完成    boolean fail = false;    for (Future&lt;Void&gt; result : results) {        try {            result.get();        } catch (Exception e) {            log.error(sm.getString(&quot;containerBase.threadedStartFailed&quot;), e);            fail = true;        }    }    // 启用Pipeline    if (pipeline instanceof Lifecycle)        ((Lifecycle) pipeline).start();    setState(LifecycleState.STARTING);    // 开启ContainerBackgroundProcessor线程用于调用子容器的backgroundProcess方法，默认情况下backgroundProcessorDelay=-1，不会启用该线程    threadStart();}</code></pre><h4 id="启动子容器"><a href="#启动子容器" class="headerlink" title="启动子容器"></a>启动子容器</h4><p>startStopExecutor是在init阶段创建的线程池，默认情况下 coreSize = maxSize = 1，也就是说默认只有一个线程处理子容器的 start，通过调用 <font color="red">Container.setStartStopThreads(int startStopThreads) 可以改变默认值 1</font> 。</p><p>如果我们有4个webapp，希望能够尽快启动应用，我们只需要设置Host的startStopThreads值即可，如下所示。</p><pre><code>server.xml&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; startStopThreads=&quot;4&quot;&gt;  &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;         prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;         pattern=&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; /&gt;&lt;/Host&gt;</code></pre><p>ContainerBase会把StartChild任务丢给线程池处理，得到Future，并且会遍历所有的Future进行阻塞result.get()，这个操作是将异步启动转同步，子容器启动完成才会继续运行。我们再来看看submit到线程池的StartChild任务，它实现了java.util.concurrent.Callable接口，在call里面完成子容器的start动作</p><pre><code>private static class StartChild implements Callable&lt;Void&gt; {    private Container child;    public StartChild(Container child) {        this.child = child;    }    @Override    public Void call() throws LifecycleException {        child.start();        return null;    }}</code></pre><h4 id="启动Pipeline"><a href="#启动Pipeline" class="headerlink" title="启动Pipeline"></a>启动Pipeline</h4><p><strong>pipeline是什么？</strong></p><pre><code>Pipeline是管道组件，用于封装了一组有序的Valve，便于Valve顺序地传递或者处理请求</code></pre><p>Pipeline的接口定义如下，定义了 Valve 的常用操作，以及 Container 的 getter/setter 方法，它的默认实现类是org.apache.catalina.core.StandardPipeline，同时它也是一个Lifecycle组件</p><pre><code>public interface Pipeline {    public Valve getBasic();    public void setBasic(Valve valve);    public void addValve(Valve valve);    public Valve[] getValves();    public void removeValve(Valve valve);    public Valve getFirst();    public boolean isAsyncSupported();    public Container getContainer();    public void setContainer(Container container);    public void findNonAsyncValves(Set&lt;String&gt; result);}</code></pre><p><strong>Valve是什么？</strong></p><pre><code>Valve 是阀门组件，穿插在 Container 容器中，可以把它理解成请求拦截器，在 tomcat 接收到网络请求与触发 Servlet 之间执行</code></pre><p>Valve的接口如下所示，我们主要关注它的invoke方法，Request、Response分别是HttpServletRequest、HttpServletResponse的实现类</p><pre><code>public interface Valve {    public Valve getNext();    public void backgroundProcess();    public void invoke(Request request, Response response) throws IOException, ServletException;    public boolean isAsyncSupported();}</code></pre><p>我们再来看看 Pipeline 启动过程，默认使用 StandardPipeline 实现类，它也是一个Lifecycle。在容器启动的时候，StandardPipeline 会遍历 Valve 链表，如果 Valve 是 Lifecycle 的子类，则会调用其 start 方法启动 Valve 组件，代码如下:</p><pre><code>public class StandardPipeline extends LifecycleBase        implements Pipeline, Contained {    // 省略若干代码......    protected synchronized void startInternal() throws LifecycleException {        Valve current = first;        if (current == null) {            current = basic;        }        while (current != null) {            if (current instanceof Lifecycle)                ((Lifecycle) current).start();            current = current.getNext();        }        setState(LifecycleState.STARTING);    }}</code></pre><p>tomcat为我们提供了一系列的Valve :</p><ul><li><p>AccessLogValve，记录请求日志，默认会开启 </p></li><li><p>RemoteAddrValve，可以做访问控制，比如限制IP黑白名单 </p></li><li><p>RemoteIpValve，主要用于处理 X-Forwarded-For 请求头，用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段</p></li></ul><p>关于更详细的说明，请参考<a href="http://tomcat.apache.org/tomcat-8.5-doc/config/valve.html" target="_blank" rel="noopener"><font color="red">tomcat官方文档</font></a></p><h3 id="StandardHost"><a href="#StandardHost" class="headerlink" title="StandardHost"></a>StandardHost</h3><p>前面我们分析了 StandardEngine 的启动逻辑，它会启动其子容器 StandardHost，接下来我们看下 StandardHost 的 start 逻辑。其实， StandardHost 重写的 startInternal 方法主要是为了查找报告错误的 Valve 阀门</p><pre><code>protected synchronized void startInternal() throws LifecycleException {    // errorValve默认使用org.apache.catalina.valves.ErrorReportValve    String errorValve = getErrorReportValveClass();    if ((errorValve != null) &amp;&amp; (!errorValve.equals(&quot;&quot;))) {        try {            boolean found = false;            // 如果所有的阀门中已经存在这个实例，则不进行处理，否则添加到  Pipeline 中            Valve[] valves = getPipeline().getValves();            for (Valve valve : valves) {                if (errorValve.equals(valve.getClass().getName())) {                    found = true;                    break;                }            }            // 如果未找到则添加到 Pipeline 中，注意是添加到 basic valve 的前面            // 默认情况下，first valve 是 AccessLogValve，basic 是 StandardHostValve            if(!found) {                Valve valve =                    (Valve) Class.forName(errorValve).getConstructor().newInstance();                getPipeline().addValve(valve);            }        } catch (Throwable t) {            // 处理异常，省略......        }    }    // 调用父类 ContainerBase，完成统一的启动动作    super.startInternal();}</code></pre><p>StandardHost Pipeline 包含的 Valve 组件： </p><ol><li><p>basic：org.apache.catalina.core.StandardHostValve </p></li><li><p>first：org.apache.catalina.valves.AccessLogValve</p></li></ol><p>需要注意的是，在往 Pipeline 中添加 Valve 阀门时，是添加到 first 后面，basic 前面</p><p>由上面的代码可知，在 start 的时候，StandardHost 并没有做太多的处理，<strong>那么 StandardHost 又是怎么知道它有哪些 child 容器需要启动呢？</strong></p><pre><code>tomcat 在这块的逻辑处理有点特殊，使用 HostConfig 加载子容器，而这个 HostConfig 是一个 LifecycleListener，它会处理 start、stop 事件通知，并且会在线程池中启动、停止 Context 容器，接下来看下 HostConfig 是如何工作的</code></pre><h4 id="HostConfig"><a href="#HostConfig" class="headerlink" title="HostConfig"></a>HostConfig</h4><p>以下是 HostConfig 处理事件通知的代码，我们着重关注下 start 方法，这个方法里面主要是做一些应用部署的准备工作，比如过滤无效的webapp、解压war包等，而主要的逻辑在于 deployDirectories 中，它会往线程池中提交一个 DeployDirectory 任务，并且调用 Future#get() 阻塞当前线程，直到 deploy 工作完成。</p><pre><code>public void lifecycleEvent(LifecycleEvent event) {    // (省略若干代码) 判断事件是否由 Host 发出，并且为 HostConfig 设置属性    if (event.getType().equals(Lifecycle.PERIODIC_EVENT)) {        check();    } else if (event.getType().equals(Lifecycle.BEFORE_START_EVENT)) {        beforeStart();    } else if (event.getType().equals(Lifecycle.START_EVENT)) {        start();    } else if (event.getType().equals(Lifecycle.STOP_EVENT)) {        stop();    }}public void start() {    // (省略若干代码)    if (host.getDeployOnStartup())        deployApps();}protected void deployApps() {    File appBase = host.getAppBaseFile();    File configBase = host.getConfigBaseFile();    // 过滤出 webapp 要部署应用的目录    String[] filteredAppPaths = filterAppPaths(appBase.list());    // 部署 xml 描述文件    deployDescriptors(configBase, configBase.list());    // 解压 war 包，但是这里还不会去启动应用    deployWARs(appBase, filteredAppPaths);    // 处理已经存在的目录，前面解压的 war 包不会再行处理    deployDirectories(appBase, filteredAppPaths);}···而这个 DeployDirectory 任务很简单，只是调用 `HostConfig#deployDirectory(cn, dir)`​```javaprivate static class DeployDirectory implements Runnable {    // (省略若干代码)    @Override    public void run() {        config.deployDirectory(cn, dir);    }}···我们再回到 HostConfig，看看 deployDirectory 的具体逻辑，分为以下几个步骤： 1. 使用 digester，或者反射实例化 StandardContext 2. 实例化 ContextConfig，并且为 Context 容器注册事件监听器，和 StandardHost 的套路一样，借助 XXXConfig 完成容器的启动、停止工作 3. 将当前 Context 实例作为子容器添加到 Host 容器中，添加子容器的逻辑在 ContainerBase 中已经实现了，如果当前 Container 的状态是 STARTING_PREP 并且 startChildren 为 true，则还会启动子容器​```javaprotected void deployDirectory(ContextName cn, File dir) {    Context context = null;    File xml = new File(dir, Constants.ApplicationContextXml);    File xmlCopy = new File(host.getConfigBaseFile(), cn.getBaseName() + &quot;.xml&quot;);    // 实例化 StandardContext    if (deployThisXML &amp;&amp; xml.exists()) {        synchronized (digesterLock) {            // 省略若干异常处理的代码            context = (Context) digester.parse(xml);        }        // (省略)为 Context 设置 configFile    } else if (!deployThisXML &amp;&amp; xml.exists()) {        // 异常处理        context = new FailedContext();    } else {        context = (Context) Class.forName(contextClass).getConstructor().newInstance();    }    // 实例化 ContextConfig，作为 LifecycleListener 添加到 Context 容器中，这和 StandardHost 的套路一样，都是使用 XXXConfig    Class&lt;?&gt; clazz = Class.forName(host.getConfigClass());    LifecycleListener listener = (LifecycleListener) clazz.getConstructor().newInstance();    context.addLifecycleListener(listener);    context.setName(cn.getName());    context.setPath(cn.getPath());    context.setWebappVersion(cn.getVersion());    context.setDocBase(cn.getBaseName());    // 实例化 Context 之后，为 Host 添加子容器    host.addChild(context);}</code></pre><p>现在有两个疑问： </p><p>1.为什么要使用 HostConfig 组件启动 Context 容器呢，不可以直接在 Host 容器中直接启动吗？</p><pre><code>HostConfig 不仅仅是启动、停止 Context 容器，还封装了很多应用部署的逻辑，此外，还会对 web.xml、context.xml 文件的改动进行监听，默认情况会重新启动 Context 容器。而这个 Host 只是负责管理 Context 的生命周期，基于单一职责的原则，tomcat 利用事件通知的方式，很好地解决了藕合问题，Context 容器也是如此，它会对应一个 ContextConfig</code></pre><p>2.Context 容器又是如何启动的？</p><pre><code>前面我们也提到了，HostConfig 将当前 Context 实例作为子容器添加到 Host 容器中（调用 ContainerBase.addChild 方法 ），而 Context 的启动就是在添加的时候调用的，ContainerBase 的关键代码如下所示，Context 启动的时候会解析web.xml，以及启动 Servlet、Listener，Servlet3.0还支持注解配置，等等这一系列逻辑将在下一篇文章进行分析</code></pre><pre><code>@Overridepublic void addChild(Container child) {    if (Globals.IS_SECURITY_ENABLED) {        PrivilegedAction&lt;Void&gt; dp = new PrivilegedAddChild(child);        AccessController.doPrivileged(dp);    } else {        addChildInternal(child);    }}private void addChildInternal(Container child) {    synchronized(children) {        // 省略部分代码，避免重复添加子容器    }    try {        if ((getState().isAvailable()                || LifecycleState.STARTING_PREP.equals(getState()))                &amp;&amp; startChildren) {            // 启动添加的子容器            child.start();        }    } catch (LifecycleException e) {        throw new IllegalStateException(&quot;ContainerBase.addChild: start: &quot; + e);    } finally {        fireContainerEvent(ADD_CHILD_EVENT, child);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat的启动分析(二)Catalina初始化</title>
      <link href="/2019/01/17/tomcat-de-qi-dong-fen-xi-er-catalina-chu-shi-hua/"/>
      <url>/2019/01/17/tomcat-de-qi-dong-fen-xi-er-catalina-chu-shi-hua/</url>
      
        <content type="html"><![CDATA[<p>Tomcat的启动分析：Catalina</p><p>Tomcat的运行是通过Bootstrap的main方法，在开发工具中，我们只需要运行Bootstrap的main方法，便可以启动tomcat进行代码调试和分析。Bootstrap是tomcat的入口，它会完成初始化ClassLoader，实例化Catalina以及load、start动作。在这一篇文章中，我们将会对tomcat初始化过程进行分析。</p><hr><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><p>首先实例化Bootstrap，并调用init方法对其初始化</p><pre><code>Bootstrap bootstrap = new Bootstrap();bootstrap.init();</code></pre><h4 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h4><p>首先初始化commonLoader、catalinaLoader、sharedLoader，默认情况下这三个是相同的实例，用于加载不同的资源。然后，使用反射实例化Catalina，设置其parentClassLoader为sharedLoader</p><pre><code>public void init() throws Exception {    // 初始化commonLoader、catalinaLoader、sharedLoader，关于ClassLoader的后面再单独分析    initClassLoaders();    Thread.currentThread().setContextClassLoader(catalinaLoader);    SecurityClassLoad.securityClassLoad(catalinaLoader);    // 反射方法实例化Catalina，后面初始化Catalina也用了很多反射，不知道意图是什么    Class&lt;?&gt; startupClass = catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;);    Object startupInstance = startupClass.getConstructor().newInstance();    // 反射调用setParentClassLoader方法，设置其parentClassLoader为sharedLoader    String methodName = &quot;setParentClassLoader&quot;;    Class&lt;?&gt; paramTypes[] = new Class[1];    paramTypes[0] = Class.forName(&quot;java.lang.ClassLoader&quot;);    Object paramValues[] = new Object[1];    paramValues[0] = sharedLoader;    Method method =        startupInstance.getClass().getMethod(methodName, paramTypes);    method.invoke(startupInstance, paramValues);    // 引用Catalina实例    catalinaDaemon = startupInstance;}</code></pre><h4 id="load-amp-start"><a href="#load-amp-start" class="headerlink" title="load &amp; start"></a>load &amp; start</h4><p>初始化Bootstrap之后，接下来就是<strong>加载配置，启动容器</strong>。而load、start实际上是由Bootstrap反射调用Catalina的load、start，这一部分代码将在下面的Catalina部分进行分析</p><ul><li><p>启动时，Catalina.setAwait(true)，其目的是为了让tomcat在关闭端口阻塞监听关闭命令，参考Catalina.await()方法</p></li><li><p>deamon.load(args)，实际上会去调用Catalina#load(args)方法，会去初始化一些资源，优先加载conf/server.xml，找不到再去加载server-embed.xml；此外，load方法还会初始化Server</p></li><li><p>daemon.start()，实例上是调用Catalina.start()</p></li></ul><pre><code>// daemon即Bootstrap实例daemon.setAwait(true);daemon.load(args);daemon.start();</code></pre><hr><h3 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h3><p>由前面的分析，可知Bootstrap中的load逻辑实际上是交给Catalina去处理的，下面我们对Catalina的初始化过程进行分析</p><h4 id="load-init"><a href="#load-init" class="headerlink" title="load(init)"></a>load(init)</h4><p>load阶段主要是通过读取conf/server.xml或者server-embed.xml，实例化Server、Service、Connector、Engine、Host等组件，并调用Lifecycle#init()完成初始化动作，以及发出INITIALIZING、INITIALIZED事件</p><ol><li><p>首先初始化jmx的环境变量</p></li><li><p>定义解析server.xml的配置，告诉Digester哪个xml标签应该解析成什么类，如果我们要改变server.xml的某个属性值(比如优化tomcat线程池)，直接查看对应实现类的setXXX方法即可</p></li><li><p>解析conf/server.xml或者server-embed.xml，并且实例化对应的组件并且赋值操作，比如Server、Container、Connector等等</p></li><li><p>为Server设置catalina信息，指定Catalina实例，设置catalina的home、base路径</p></li><li><p>调用StarndServer#init()方法，完成各个组件的初始化，并且由parent组件初始化child组件，一层套一层，这个设计真心牛逼！</p></li></ol><pre><code>public void load() {    initDirs();    // 初始化jmx的环境变量    initNaming();    // Create and execute our Digester    // 定义解析server.xml的配置，告诉Digester哪个xml标签应该解析成什么类    Digester digester = createStartDigester();    InputSource inputSource = null;    InputStream inputStream = null;    File file = null;    try {      // 首先尝试加载conf/server.xml，省略部分代码......      // 如果不存在conf/server.xml，则加载server-embed.xml(该xml在catalina.jar中)，省略部分代码......      // 如果还是加载不到xml，则直接return，省略部分代码......      try {          inputSource.setByteStream(inputStream);          // 把Catalina作为一个顶级实例          digester.push(this);          // 解析过程会实例化各个组件，比如Server、Container、Connector等          digester.parse(inputSource);      } catch (SAXParseException spe) {          // 处理异常......      }    } finally {        // 关闭IO流......    }    // 给Server设置catalina信息    getServer().setCatalina(this);    getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());    getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());    // Stream redirection    initStreams();    // 调用Lifecycle的init阶段    try {        getServer().init();    } catch (LifecycleException e) {        // ......    }    // ......}</code></pre><p><strong>load的时序图如下所示:</strong><br><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190117103649.png"></p><ul><li><p>Digester利用jdk提供的sax解析功能，将server.xml的配置解析成对应的Bean，并完成注入，比如往Server中注入Service</p></li><li><p>EngineConfig，它是一个LifecycleListener实现，用于配置Engine，但是只会处理START_EVENT和STOP_EVENT事件</p></li><li><p>Connector默认会有两种：HTTP/1.1、AJP，不同的Connector内部持有不同的CoyoteAdapter和ProtocolHandler，在Connector初始化的时候，也会对ProtocolHandler进行初始化，完成端口的监听</p></li><li><p>ProtocolHandler常用的实现有Http11NioProtocol、AjpNioProtocol，还有apr系列的Http11AprProtocol、AjpAprProtocol，apr系列只有在使用apr包的时候才会使用到</p></li><li><p>在ProtocolHandler调用init初始化的时候，还会去执行AbstractEndpoint的init方法，完成请求端口绑定、初始化NIO等操作，在tomcat7中使用JIoEndpoint阻塞IO，而tomcat8中直接移除了JIoEndpoint，具体信息请查看org.apache.tomcat.util.net这个包</p></li></ul><p>Catalina在load结束之前，会调用Server的init()完成各个组件的初始化，下面我们来分析下各个组件在init初始化过程中都做了哪些操作</p><h4 id="Server初始化"><a href="#Server初始化" class="headerlink" title="Server初始化"></a>Server初始化</h4><p>StandardServer是由Catalina进行init初始化的，调用的是LifecycleBase父类的init方法，而StandardServer继承至LifecycleMBeanBase，重写了initInternal方法。关于这块的知识，请参考上一篇Lifecycle的博客</p><p>StandardServer初始化的时序图如下所示，为了表述清楚，我这里把LifecycleBase、LifecycleMBeanBase拆开了，实际上是同一个StandardServer实例对象，存在继承关系<br><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190117104152.png"></p><p>由上图可以很清晰地看到，StandardServer的初始化过程，先由父类LifecycleBase改变当前的state值并发出事件通知，<strong>那么这个时候StandardServer的子容器StandardService内部的state是否会发生改变呢，是否会发出事件通知呢？</strong> 当然是不会的，因为这个state值不是LifecycleBase的静态成员变量，StandardServer只能改变自己的值，而StandardService只有在被StandardServer调用init初始化的时候才会改变，二者拥有独立的状态。考虑到有其它线程可能会改变StandardServer的state值，比如利用jmx执行init操作，因此要考虑并发问题，所以LifecycleBase#init()使用了synchronized锁，并且state是volatile修饰的。</p><p>LifecycleBase改变state、发出事件通知之后，便会执行StandardServer自身的initInternal，我们来看看这个里面都干嘛了</p><pre><code>protected void initInternal() throws LifecycleException {    super.initInternal();    // 往jmx中注册全局的Stringcache，尽管这个cache是全局的，但是如果在同一个jvm中存在多个Server，    // 那么则会注册多个不同名字的StringCache，这种情况在内嵌的tomcat中可能会出现    onameStringCache = register(new StringCache(), &quot;type=StringCache&quot;);    // 注册MBeanFactory，用来管理Server    MBeanFactory factory = new MBeanFactory();    factory.setContainer(this);    onameMBeanFactory = register(factory, &quot;type=MBeanFactory&quot;);    // 往jmx中注册全局的NamingResources    globalNamingResources.init();    // Populate the extension validator with JARs from common and shared class loaders    if (getCatalina() != null) {        // 忽略ClassLoader操作    }    // 初始化内部的Service    for (int i = 0; i &lt; services.length; i++) {        services[i].init();    }}</code></pre><ol><li><p>先是调用super.initInternal()，把自己注册到jmx</p></li><li><p>然后注册StringCache和MBeanFactory</p></li><li><p>初始化NamingResources，就是server.xml中指定的GlobalNamingResources</p></li><li><p>调用Service子容器的init方法，让Service组件完成初始化，注意：在同一个Server下面，可能存在多个Service组件</p></li></ol><h4 id="Service初始化"><a href="#Service初始化" class="headerlink" title="Service初始化"></a>Service初始化</h4><p>StandardService和StandardServer都是继承至LifecycleMBeanBase，因此公共的初始化逻辑都是一样的，这里不做过多介绍，我们直接看下initInternal</p><pre><code>protected void initInternal() throws LifecycleException {    // 往jmx中注册自己    super.initInternal();    // 初始化Engine    if (engine != null) {        engine.init();    }    // 存在Executor线程池，则进行初始化，默认是没有的    for (Executor executor : findExecutors()) {        if (executor instanceof JmxEnabled) {            ((JmxEnabled) executor).setDomain(getDomain());        }        executor.init();    }    // 暂时不知道这个MapperListener的作用    mapperListener.init();    // 初始化Connector，而Connector又会对ProtocolHandler进行初始化，开启应用端口的监听    synchronized (connectorsLock) {        for (Connector connector : connectors) {            try {                connector.init();            } catch (Exception e) {                // 省略部分代码，logger and throw exception            }        }    }}</code></pre><ol><li><p>首先，往jmx中注册StandardService</p></li><li><p>初始化Engine，而Engine初始化过程中会去初始化Realm(权限相关的组件)</p></li><li><p>如果存在Executor线程池，还会进行init操作，这个Excecutor是tomcat的接口，继承至java.util.concurrent.Executor、org.apache.catalina.Lifecycle</p></li><li><p>初始化Connector连接器，默认有http1.1、ajp连接器，而这个Connector初始化过程，又会对ProtocolHandler进行初始化，开启应用端口的监听，后面会详细分析</p></li></ol><h4 id="Engine初始化"><a href="#Engine初始化" class="headerlink" title="Engine初始化"></a>Engine初始化</h4><p>StandardEngine在init阶段，需要获取Realm，这个Realm是干嘛用的？</p><pre><code>Realm(域)是用于对单个用户进行身份验证的底层安全领域的只读外观，并标识与这些用户相关联的安全角色。域可以在任何容器级别上附加，但是通常只附加到Context，或者更高级别的容器。</code></pre><p>StandardEngine初始化的代码如下：</p><pre><code>@Overrideprotected void initInternal() throws LifecycleException {    getRealm();    super.initInternal();}public Realm getRealm() {    Realm configured = super.getRealm();    if (configured == null) {        configured = new NullRealm();        this.setRealm(configured);    }    return configured;}</code></pre><p>由前面的类图可知，StandardEngine继承至ContainerBase，而ContainerBase重写了initInternal()方法，用于初始化start、stop线程池，这个线程池有以下特点：</p><ol><li><p>core线程和max是相等的，默认为1 </p></li><li><p>允许core线程在超时未获取到任务时退出线程 </p></li><li><p>线程获取任务的超时时间是10s，也就是说所有的线程(包括core线程)，超过10s未获取到任务，那么这个线程就会被销毁</p></li></ol><p>这么做的初衷是什么呢？因为这个线程池只需要在容器启动和停止的时候发挥作用，没必要时时刻刻处理任务队列</p><p>ContainerBase的代码如下所示：</p><pre><code>// 默认是1个线程private int startStopThreads = 1;protected ThreadPoolExecutor startStopExecutor;@Overrideprotected void initInternal() throws LifecycleException {    BlockingQueue&lt;Runnable&gt; startStopQueue = new LinkedBlockingQueue&lt;&gt;();    startStopExecutor = new ThreadPoolExecutor(            getStartStopThreadsInternal(),            getStartStopThreadsInternal(), 10, TimeUnit.SECONDS,            startStopQueue,            new StartStopThreadFactory(getName() + &quot;-startStop-&quot;));    // 允许core线程超时未获取任务时退出    startStopExecutor.allowCoreThreadTimeOut(true);    super.initInternal();}private int getStartStopThreadsInternal() {    int result = getStartStopThreads();    if (result &gt; 0) {        return result;    }    result = Runtime.getRuntime().availableProcessors() + result;    if (result &lt; 1) {        result = 1;    }    return result;}</code></pre><p>这个startStopExecutor线程池有什么用呢？</p><ol><li><p>在start的时候，如果发现有子容器，则会把子容器的start操作放在线程池中进行处理</p></li><li><p>在stop的时候，也会把stop操作放在线程池中处理</p></li></ol><p>在前面的文章中我们介绍了Container组件，StandardEngine作为顶层容器，它的直接子容器是StardandHost，但是对StandardEngine的代码分析，我们并没有发现它会对子容器StardandHost进行初始化操作，StandardEngine不按照套路出牌，而是把初始化过程放在start阶段。个人认为Host、Context、Wrapper这些容器和具体的webapp应用相关联了，初始化过程会更加耗时，因此在start阶段用多线程完成初始化以及start生命周期，否则，像顶层的Server、Service等组件需要等待Host、Context、Wrapper完成初始化才能结束初始化流程，整个初始化过程是具有传递性的。</p><h4 id="Connector初始化"><a href="#Connector初始化" class="headerlink" title="Connector初始化"></a>Connector初始化</h4><p>Connector也是继承至LifecycleMBeanBase，公共的初始化逻辑都是一样的。我们先来看下Connector的默认配置，大部分属性配置都可以在Connector类中找到，tomcat默认开启了HTTP/1.1、AJP/1.3，其实AJP的用处不大，可以去掉。</p><pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;               connectionTimeout=&quot;20000&quot;               redirectPort=&quot;8443&quot; /&gt;&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code></pre><p>Connector定义了很多属性，比如port、redirectPort、maxCookieCount、maxPostSize等等，比较有意思的是竟然找不到connectionTimeout的定义，全文搜索后发现使用了属性名映射，估计是为了兼容以前的版本.</p><pre><code>protected static final HashMap&lt;String,String&gt; replacements = new HashMap&lt;&gt;();static {    replacements.put(&quot;acceptCount&quot;, &quot;backlog&quot;);    replacements.put(&quot;connectionLinger&quot;, &quot;soLinger&quot;);    replacements.put(&quot;connectionTimeout&quot;, &quot;soTimeout&quot;);    replacements.put(&quot;rootFile&quot;, &quot;rootfile&quot;);}public Object getProperty(String name) {    String repl = name;    if (replacements.get(name) != null) {        repl = replacements.get(name);    }    return IntrospectionUtils.getProperty(protocolHandler, repl);}public boolean setProperty(String name, String value) {    String repl = name;    if (replacements.get(name) != null) {        repl = replacements.get(name);    }    return IntrospectionUtils.setProperty(protocolHandler, repl, value);}</code></pre><p>initInternal过程如下所示： </p><ol><li><p>实例化Coyote适配器，这个适配器是用于Coyote的Request、Response与HttpServlet的Request、Response适配的，后续的博客会进行深入分析 </p></li><li><p>为ProtocolHander指定CoyoteAdapter用于处理请求 </p></li><li><p>初始化ProtocolHander，这一部分放在Connector后面进行分析</p></li></ol><pre><code>protected void initInternal() throws LifecycleException {    // 注册jmx    super.initInternal();    // 初始化Coyote适配器，这个适配器是用于Coyote的Request、Response与HttpServlet的Request、Response适配的    adapter = new CoyoteAdapter(this);    // protocolHandler需要指定Adapter用于处理请求    protocolHandler.setAdapter(adapter);    // Make sure parseBodyMethodsSet has a default    if (null == parseBodyMethodsSet) {        setParseBodyMethods(getParseBodyMethods());    }    // apr支持，忽略部分代码......    // 初始化ProtocolHandler，这个init不是Lifecycle定义的init，而是ProtocolHandler接口的init    try {        protocolHandler.init();    } catch (Exception e) {        throw new LifecycleException(                sm.getString(&quot;coyoteConnector.protocolHandlerInitializationFailed&quot;), e);    }}</code></pre><h4 id="ProtocolHandler初始化"><a href="#ProtocolHandler初始化" class="headerlink" title="ProtocolHandler初始化"></a>ProtocolHandler初始化</h4><p>接下来，我们分析下HTTP/1.1的ProtocolHandler的初始化过程。首先，我们来认识下ProtocolHandler，它是一个抽象的协议实现，它不同于JNI这样的Jk协议，它是单线程、基于流的协议。ProtocolHandler是一个Cycote连接器实现的主要接口，而Adapter适配器是由一个Coyote Servlet容器实现的主要接口，定义了处理请求的抽象接口。</p><pre><code>public interface ProtocolHandler {    public void setAdapter(Adapter adapter);    public Adapter getAdapter();    public Executor getExecutor();    public void init() throws Exception;    public void start() throws Exception;    public void pause() throws Exception;    public void resume() throws Exception;    public void stop() throws Exception;    public void destroy() throws Exception;    // other code......}public interface Adapter {    public void service(Request req, Response res) throws Exception;    public boolean prepare(Request req, Response res) throws Exception;    public boolean asyncDispatch(Request req,Response res, SocketEvent status) throws Exception;    public void log(Request req, Response res, long time);    public void checkRecycled(Request req, Response res);    public String getDomain();}</code></pre><p>ProtocolHandler的子类如下所示，AbstractProtocol是基本的实现，而NIO默认使用的是Http11NioProtocol</p><p><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190117111122.png"></p><p>调用ProtocolHandler的init进行初始化是调用的AbstractProtocol，首先完成jmx的注册，然后对NioEndpoint进行初始化</p><pre><code>public abstract class AbstractProtocol&lt;S&gt; implements ProtocolHandler,        MBeanRegistration {    public void init() throws Exception {        // 完成jmx注册        if (oname == null) {            oname = createObjectName();            if (oname != null) {                Registry.getRegistry(null, null).registerComponent(this, oname, null);            }        }        if (this.domain != null) {            rgOname = new ObjectName(domain + &quot;:type=GlobalRequestProcessor,name=&quot; + getName());            Registry.getRegistry(null, null).registerComponent(                    getHandler().getGlobal(), rgOname, null);        }        String endpointName = getName();        endpoint.setName(endpointName.substring(1, endpointName.length()-1));        endpoint.setDomain(domain);        // 初始化endpoint        endpoint.init();    }}</code></pre><p>NioEndpoint初始化过程，最重要的是完成端口和地址的绑定监听工作，关于网络通信这块的内容将在后面着重介绍</p><pre><code>public class NioEndpoint extends AbstractJsseEndpoint&lt;NioChannel&gt; {    public void bind() throws Exception {        // 实例化ServerSocketChannel，并且绑定端口和地址        serverSock = ServerSocketChannel.open();        socketProperties.setProperties(serverSock.socket());        InetSocketAddress addr = (getAddress()!=null?new InetSocketAddress(getAddress(),getPort()):new InetSocketAddress(getPort()));        // 设置最大连接数，原来是在这里设置的        serverSock.socket().bind(addr,getAcceptCount());        serverSock.configureBlocking(true); //mimic APR behavior        // 初始化acceptor、poller线程的数量        // Initialize thread count defaults for acceptor, poller        if (acceptorThreadCount == 0) {            // FIXME: Doesn&#39;t seem to work that well with multiple accept threads            acceptorThreadCount = 1;        }        if (pollerThreadCount &lt;= 0) {            pollerThreadCount = 1;        }        setStopLatch(new CountDownLatch(pollerThreadCount));        // 如果有必要的话初始化ssl        initialiseSsl();        // 初始化selector        selectorPool.open();    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，整个初始化过程便告一段落。整个初始化过程，由parent组件控制child组件的初始化，一层层往下传递，直到最后全部初始化OK。下图描述了整体的传递流程</p><p><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190117111556.png"></p><p>默认情况下，Server只有一个Service组件，Service组件先后对Engine、Connector进行初始化。而Engine组件并不会在初始化阶段对子容器进行初始化，<strong>Host、Context、Wrapper容器的初始化是在start阶段完成的</strong>。tomcat默认会启用HTTP1.1和AJP的Connector连接器，这两种协议默认使用Http11NioProtocol、AJPNioProtocol进行处理。</p>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat的启动分析(一) Lifecycle</title>
      <link href="/2019/01/16/tomcat-de-qi-dong-fen-xi-yi-lifecycle/"/>
      <url>/2019/01/16/tomcat-de-qi-dong-fen-xi-yi-lifecycle/</url>
      
        <content type="html"><![CDATA[<p>Tomcat组件生命周期管理:Lifecycle</p><p>Lifecycle在其他框架中也很常见，比如spring，它常用于具有生命周期的组件，由Lifecycle控制组件的初始化、启动、销毁等动作，方便应用程序获取、释放某些资源，或者是触发某些特定的事件。Tomcat也是如此，在学习整个启动流程之前，我们先行了解下Lifecycle的实现机制，便于理解整个流程。</p><h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><p>Lifecycle接口是一个公用的接口，定义了组件生命周期的一些方法，用于启动、停止Catalina组件。它是一个非常重要的接口，组件的生命周期包括：init、start、stop、destory，以及各种事件的常量、操作LifecycleListener的API，典型的观察者模式。</p><pre><code>public interface Lifecycle {    // ----------------------- 定义各种EVENT事件 -----------------------    public static final String BEFORE_INIT_EVENT = &quot;before_init&quot;;    public static final String AFTER_INIT_EVENT = &quot;after_init&quot;;    public static final String START_EVENT = &quot;start&quot;;    // 省略事件常量定义……    /**     * 注册一个LifecycleListener     */    public void addLifecycleListener(LifecycleListener listener);    /**     * 获取所有注册的LifecycleListener     */    public LifecycleListener[] findLifecycleListeners();    /**     * 移除指定的LifecycleListener     */    public void removeLifecycleListener(LifecycleListener listener);    /**     * 组件被实例化之后，调用该方法完成初始化工作，发会出以下事件     * &lt;ol&gt;     *   &lt;li&gt;INIT_EVENT: On the successful completion of component initialization.&lt;/li&gt;     * &lt;/ol&gt;     * @exception LifecycleException if this component detects a fatal error     *  that prevents this component from being used     */    public void init() throws LifecycleException;    /**     * 在组件投入使用之前调用该方法，先后会发出以下事件：BEFORE_START_EVENT、START_EVENT、AFTER_START_EVENT     * @exception LifecycleException if this component detects a fatal error     *  that prevents this component from being used     */    public void start() throws LifecycleException;    /**     * 使组件停止工作     */    public void stop() throws LifecycleException;    /**     * 销毁组件时被调用     */    public void destroy() throws LifecycleException;    /**     * Obtain the current state of the source component.     */    public LifecycleState getState();    /**     * 获取state的文字说明     */    public String getStateName();    /**     * Marker interface used to indicate that the instance should only be used     * once. Calling {@link #stop()} on an instance that supports this interface     * will automatically call {@link #destroy()} after {@link #stop()}     * completes.     */    public interface SingleUse {    }}</code></pre><p>各大组件均实现了Lifecycle接口，类图如下所示： </p><p><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190116175426.png"></p><ul><li><p>LifecycleBase：它实现了Lifecycle的init、start、stop等主要逻辑，向注册在LifecycleBase内部的LifecycleListener发出对应的事件，并且预留了<strong>initInternal、startInternal、stopInternal</strong>等模板方法，便于子类完成自己的逻辑。</p></li><li><p>MBeanRegistration：JmxEnabled 的父类， jmx框架提供的注册MBean的接口，引入此接口是为了便于使用JMX提供的管理功能</p></li><li><p>LifecycleMBeanBase：JmxEnabled的子类，通过重写initInternal、destroyInternal方法，统一向jmx中注册/取消注册当前实例，方便利用jmx对实例对象进行管理，代码上特别强调要求子类先行调用super.initInternal</p></li><li><p>ContainerBase、StandardServer、StandardService、WebappLoader、Connector、StandardContext、StandardEngine、StandardHost、StandardWrapper等容器都继承了LifecycleMBeanBase，因此这些容器都具有了同样的生命周期并可以通过JMX进行管理。</p></li></ul><pre><code>public abstract class LifecycleMBeanBase extends LifecycleBase        implements JmxEnabled {    /**     * Sub-classes wishing to perform additional initialization should override     * this method, ensuring that super.initInternal() is the first call in the     * overriding method.     */    protected void initInternal() throws LifecycleException {        if (oname == null) {            mserver = Registry.getRegistry(null, null).getMBeanServer();            oname = register(this, getObjectNameKeyProperties());        }    }}public class Connector extends LifecycleMBeanBase  {    protected void initInternal() throws LifecycleException {        super.initInternal();        adapter = new CoyoteAdapter(this);        protocolHandler.setAdapter(adapter);        // other code......    }}</code></pre><h3 id="LifecycleState"><a href="#LifecycleState" class="headerlink" title="LifecycleState"></a>LifecycleState</h3><p>LifecycleState是枚举类，定义了各种状态:</p><pre><code>public enum LifecycleState {    // LifecycleBase实例化完成时的状态    NEW(false, null),       // 容器正在初始化的状态，在INITIALIZED之前    INITIALIZING(false, Lifecycle.BEFORE_INIT_EVENT),    // 初始化完成的状态    INITIALIZED(false, Lifecycle.AFTER_INIT_EVENT),    // 启动前    STARTING_PREP(false, Lifecycle.BEFORE_START_EVENT),    // 启动过程中的状态    STARTING(true, Lifecycle.START_EVENT),    // 启动完成    STARTED(true, Lifecycle.AFTER_START_EVENT),    // 停止前的状态    STOPPING_PREP(true, Lifecycle.BEFORE_STOP_EVENT),    // 停止过程中    STOPPING(false, Lifecycle.STOP_EVENT),    // 停止完成    STOPPED(false, Lifecycle.AFTER_STOP_EVENT),    // 销毁中    DESTROYING(false, Lifecycle.BEFORE_DESTROY_EVENT),    // 完成销毁    DESTROYED(false, Lifecycle.AFTER_DESTROY_EVENT),    // 启动、停止过程中出现异常    FAILED(false, null);    private final boolean available;    private final String lifecycleEvent;    private LifecycleState(boolean available, String lifecycleEvent) {        this.available = available;        this.lifecycleEvent = lifecycleEvent;    }    public boolean isAvailable() {        return available;    }    public String getLifecycleEvent() {        return lifecycleEvent;    }}</code></pre><h3 id="LifecycleListener"><a href="#LifecycleListener" class="headerlink" title="LifecycleListener"></a>LifecycleListener</h3><p>要订阅事件的实体类需要实现LifecycleListener</p><pre><code>public interface LifecycleListener {    public void lifecycleEvent(LifecycleEvent event);}</code></pre><p>默认情况下，tomcat会内置一些LifecycleListener，配置在server.xml中，除了xml中的LifecycleListener，还有org.apache.catalina.core.NamingContextListener，<strong>而这个LifecycleListener是在StandardServer的构造器中添加的</strong>，各个LifecycleListener的作用在此不再细说。如果我们在tomcat启动、停止的时候增加额外的逻辑，比如发送邮件通知，则可以从这个地方入手。</p><pre><code>&lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;&lt;!--APR library loader. Documentation at /docs/apr.html --&gt;&lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt;&lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&gt;&lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;&lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt;&lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&gt;</code></pre><pre><code>public StandardServer() {    // 忽略部分代码    if (isUseNaming()) {        namingContextListener = new NamingContextListener();        addLifecycleListener(namingContextListener);    } else {        namingContextListener = null;    }}</code></pre><h3 id="LifecycleBase"><a href="#LifecycleBase" class="headerlink" title="LifecycleBase"></a>LifecycleBase</h3><p>LifecycleBase实现了Lifecycle接口，完成了核心逻辑</p><ul><li><p>StringManager：用来做日志信息参数化输出的，支持国际化</p></li><li><p>内部使用CopyOnWriteArrayList维护所有的LifecycleListener，因为在各个生命周期，内部的LifecycleListener是会变化的，并且存在并发操作问题，因此使用了并发的List。注意，不同的LifecycleBase子类，其内部的lifecycleListeners存放不同的LifecyListener，比如Server和Service，它们是不同的Lifecycle实例，内部的lifecycleListeners也是不同 </p></li><li><p>LifecycleBase的state初始值是LifecycleState.NEW，也存在并发修改的问题，用了volatile修饰 </p></li><li><p>addLifecycleListener、removeLifecycleListener允许添加、删除LifecycleListener，告诉LifecycleBase有哪些监听者需要进行事件通知 </p></li><li><p>fireLifecycleEvent：向内部注册的LifecycleListener发出事件通知，它是protected的方法，所以LifecycleBase的子类可以在适当的时机调用该方法发出事件通知。事件通知由LifecycleListener实现类决定要不要对特定的事件进行处理 </p></li><li><p>setState：更新state值，并发出对应的事件通知，同样是调用fireLifecycleEvent</p></li></ul><pre><code>public abstract class LifecycleBase implements Lifecycle {    // 日志国际化输出使用    private static final StringManager sm = StringManager.getManager(LifecycleBase.class);    // 维护LifecycleListener    private final List&lt;LifecycleListener&gt; lifecycleListeners = new CopyOnWriteArrayList&lt;&gt;();    // 初始状态是NEW    private volatile LifecycleState state = LifecycleState.NEW;    /**     * 注册LifecycleListener     */    @Override    public void addLifecycleListener(LifecycleListener listener) {        lifecycleListeners.add(listener);    }    @Override    public LifecycleListener[] findLifecycleListeners() {        return lifecycleListeners.toArray(new LifecycleListener[0]);    }    /**     * 移除LifecycleListener     */    @Override    public void removeLifecycleListener(LifecycleListener listener) {        lifecycleListeners.remove(listener);    }    /**     * 发出事件通知，遍历内部所有的LifecycleListener，并调用其lifecycleEvent     */    protected void fireLifecycleEvent(String type, Object data) {        LifecycleEvent event = new LifecycleEvent(this, type, data);        for (LifecycleListener listener : lifecycleListeners) {            listener.lifecycleEvent(event);        }    }    @Override    public LifecycleState getState() {        return state;    }    @Override    public String getStateName() {        return getState().toString();    }    protected synchronized void setState(LifecycleState state)            throws LifecycleException {        setStateInternal(state, null, true);    }    protected synchronized void setState(LifecycleState state, Object data)            throws LifecycleException {        setStateInternal(state, data, true);    }    /**     * 设置state值，并发出事件通知     */    private synchronized void setStateInternal(LifecycleState state,            Object data, boolean check) throws LifecycleException {        // 校验state的正确性        if (check) {            if (state == null) {                invalidTransition(&quot;null&quot;);                return;            }            // Any method can transition to failed            // startInternal() permits STARTING_PREP to STARTING            // stopInternal() permits STOPPING_PREP to STOPPING and FAILED to            // STOPPING            if (!(state == LifecycleState.FAILED ||                    (this.state == LifecycleState.STARTING_PREP &amp;&amp;                            state == LifecycleState.STARTING) ||                    (this.state == LifecycleState.STOPPING_PREP &amp;&amp;                            state == LifecycleState.STOPPING) ||                    (this.state == LifecycleState.FAILED &amp;&amp;                            state == LifecycleState.STOPPING))) {                // No other transition permitted                invalidTransition(state.name());            }        }        this.state = state;        String lifecycleEvent = state.getLifecycleEvent();        if (lifecycleEvent != null) {            fireLifecycleEvent(lifecycleEvent, data);        }    }    // 省略其它代码......}</code></pre><p>Lifecycle组件的：init、start、stop、destory的套路基本上一样，先由LifecycleBase完成前期的校验、事件通知动作，再调用子类的方法完成自己的逻辑。</p><pre><code>校验state--&gt;发出事件通知发出事件通知--&gt;子类doInternal</code></pre><hr><h4 id="init分析"><a href="#init分析" class="headerlink" title="init分析"></a>init分析</h4><pre><code>@Overridepublic final synchronized void init() throws LifecycleException {        // 1        if (!state.equals(LifecycleState.NEW)) {            invalidTransition(Lifecycle.BEFORE_INIT_EVENT);        }        setStateInternal(LifecycleState.INITIALIZING, null, false);        try {            // 2             initInternal();        } catch (Throwable t) {            ExceptionUtils.handleThrowable(t);            setStateInternal(LifecycleState.FAILED, null, false);            throw new LifecycleException(                    sm.getString(&quot;lifecycleBase.initFail&quot;,toString()), t);        }        // 3         setStateInternal(LifecycleState.INITIALIZED, null, false);}</code></pre><p>下面我们逐一来分析一下上述代码中标注了数字的地方：</p><ol><li><p>标注1的代码首先检测当前组件的状态是不是NEW(新建)，如果不是就调用org.apache.catalina.util.LifecycleBase#invalidTransition方法来将当前的状态转换过程<strong>终止</strong>，<font color="red">而<strong>invalidTransition</strong>的实现是抛出了org.apache.catalina.LifecycleException异常。</font>接着调用了setStateInternal方法将状态设置为INITIALIZING（正在初始化）</p></li><li><p>标注2的代码就是<strong>init模板方法的钩子</strong>，子类可以通过实现protected abstract void initInternal() throws LifecycleException;方法来纳入初始化的流程。</p></li><li><p>标注3的代码将组件的状态改为INITIALIZED(已初始化)。</p></li></ol><h4 id="start分析"><a href="#start分析" class="headerlink" title="start分析"></a>start分析</h4><p>start过程会触发LifecycleState的STARTING_PREP、STARTED事件，如果出现启动失败还会触发FAILED事件，并且调用stop。因为会涉及多线程操作，因此对方法加了锁。如果start期间出现了异常，则会调用stop停止tomcat，或者state状态有误也会抛出异常</p><p><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190116184357.png"></p><p>state状态变更时调用setStateInternal方法，遍历内部所有的LifecycleListener，并向其发起对应的事件通知，由LifecycleListener去完成某些动作。其子类可以直接调用fireLifecycleEvent，比如在StandardServer中，start过程会发出CONFIGURE_START_EVENT事件。注：所有事件的命名均定义在Lifecycle接口中。</p><pre><code>public abstract class LifecycleBase implements Lifecycle {    @Override    public final synchronized void start() throws LifecycleException {        // 如果是start前、进行中、start完成，则直接return        if (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) ||                LifecycleState.STARTED.equals(state)) {            // 忽略logger日志            return;        }        // 完成init初始化        if (state.equals(LifecycleState.NEW)) {            init();        } else if (state.equals(LifecycleState.FAILED)) {            stop();        } else if (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;                !state.equals(LifecycleState.STOPPED)) {            invalidTransition(Lifecycle.BEFORE_START_EVENT);        }        try {            // 发出STARTING_PREP事件            setStateInternal(LifecycleState.STARTING_PREP, null, false);            // 由子类实现            startInternal();            // 如果启动失败直接调用stop            if (state.equals(LifecycleState.FAILED)) {                stop();            }            // 说明状态有误            else if (!state.equals(LifecycleState.STARTING)) {                invalidTransition(Lifecycle.AFTER_START_EVENT);            }            // 成功完成start，发出STARTED事件            else {                setStateInternal(LifecycleState.STARTED, null, false);            }        } catch (Throwable t) {            ExceptionUtils.handleThrowable(t);            setStateInternal(LifecycleState.FAILED, null, false);            throw new LifecycleException(sm.getString(&quot;lifecycleBase.startFail&quot;, toString()), t);        }    }    /**     * 由子类实现     */    protected abstract void startInternal() throws LifecycleException;}</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上面我们分析了init和start方法的流程，对于stop和destroy方法的总体过程是类似的，大家可以自己阅读一下，但是通过上面的分析，我们可以得出生命周期方法的总体的骨架，如果用 <strong>伪代码</strong> 来表示可以简化为如下：</p><pre><code>public final synchronized void lfieCycleMethod() throws LifecycleException {        stateCheck();//状态检查        //设置为进入相应的生命周期之前的状态        setStateInternal(LifecycleState.BEFORE_STATE, null, false);        lfieCycleMethodInternal();//钩子方法        //进入相应的生命周期之后的状态        setStateInternal(LifecycleState.AFTER_STATE, null, false);}</code></pre><h3 id="LifecycleMBeanBase"><a href="#LifecycleMBeanBase" class="headerlink" title="LifecycleMBeanBase"></a>LifecycleMBeanBase</h3><p>由前面的类图可知，LifecycleMBeanBase是LifecycleBase的直接子类，并且实现了JmxEnabled接口，很多组件都是直接继承它。</p><p>LifecycleMBeanBase完成了jmx注册的主要逻辑，重写了LifecycleBase的initInternal、destroyInternal方法，用于完成jmx的注册、注销动作，这两个模板方法中特别说明：</p><pre><code>Sub-classes wishing to perform additional initialization should override this method,ensuring that super.initInternal() is the first call in the overriding method.</code></pre><p>为了保证jmx的正常注册和注销，要求子类在重写initInternal、destroyInternal方法时，必须先调用super.initInternal()。例如Connector：</p><pre><code>public class Connector extends LifecycleMBeanBase  {    @Override    protected void initInternal() throws LifecycleException {        // 先行调用LifecycleMBeanBase的initInternal        super.initInternal();        // Initialize adapter        adapter = new CoyoteAdapter(this);        protocolHandler.setAdapter(adapter);        // other code......    }    // other code......}</code></pre><p>我们再来看看LifecycleMBeanBase的内部实现，在initInternal阶段初始化MBeanServer实例，并且把当前实例注册到jmx中；而destroyInternal阶段则是根据ObjectName注销MBean:</p><pre><code>public abstract class LifecycleMBeanBase extends LifecycleBase        implements JmxEnabled {    /**     * jmx的域，默认使用Service的name，即&quot;Catalina&quot;     */    private String domain = null;    /**     * 用于标识一个MBean的对象名称，也可以根据这个name来查找MBean     */    private ObjectName oname = null;    /**     * jmx的核心组件，提供代理端操作MBean的接口，提供了创建、注册、删除MBean的接口，它由MBeanServerFactory创建     */    protected MBeanServer mserver = null;    @Override    protected void initInternal() throws LifecycleException {        if (oname == null) {            mserver = Registry.getRegistry(null, null).getMBeanServer();            oname = register(this, getObjectNameKeyProperties());        }    }    @Override    protected void destroyInternal() throws LifecycleException {        unregister(oname);    }    protected final void unregister(ObjectName on) {        if (on == null) {            return;        }        if (mserver == null) {            log.warn(sm.getString(&quot;lifecycleMBeanBase.unregisterNoServer&quot;, on));            return;        }        try {            mserver.unregisterMBean(on);        } catch (MBeanRegistrationException e) {            log.warn(sm.getString(&quot;lifecycleMBeanBase.unregisterFail&quot;, on), e);        } catch (InstanceNotFoundException e) {            log.warn(sm.getString(&quot;lifecycleMBeanBase.unregisterFail&quot;, on), e);        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat的总体框架设计</title>
      <link href="/2019/01/16/tomcat-de-zong-ti-kuang-jia-she-ji/"/>
      <url>/2019/01/16/tomcat-de-zong-ti-kuang-jia-she-ji/</url>
      
        <content type="html"><![CDATA[<p>今天来学习tomcat的总体框架设计，帮助大家理解web的执行流程，fighting~~~</p><p>tomcat的总体架构如下图所示：</p><p><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190116163946.png"></p><p>如上图所示，tomcat由：Server、Service、Engine、Connerctor、Host、Context组件组成，其中带有s的代表在一个tomcat实例上可以存在多个组件，比如Context(s)，tomcat允许我们部署多个应用，每个应用对应一个Context。这些组件在tomcat的<strong>conf/server.xml</strong>文件中可以找到，对tomcat的调优需要改动该文件。</p><p><code>server.xml:</code></p><pre><code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;&lt;Service name=&quot;Catalina&quot;&gt;    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;           connectionTimeout=&quot;20000&quot;           redirectPort=&quot;8443&quot; /&gt;    &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;      &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;        &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;               resourceName=&quot;UserDatabase&quot;/&gt;      &lt;/Realm&gt;      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;               pattern=&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; /&gt;      &lt;/Host&gt;    &lt;/Engine&gt;&lt;/Service&gt;&lt;/Server&gt;</code></pre><p>Tomcat加载时，相应组件（容器）的配置参数都是从这个文件读进去的，这个文件也是Tomcat性能优化的关键。接下来我们就根据上图以及conf/server.xml的内容来一步步描述一下上面所说的各种组件吧。</p><hr><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>Server是Tomcat中最顶层的组件，它可以包含多个Service组件。在Tomcat源代码中Server组件对应源码中的  org.apache.catalina.core.StandardServer 类。StandardServer的继承关系图如下图所示：<br><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190116165355.png"></p><p>Lifecycle是Tomcat的生命周期接口。保持组件启动和停止一致的的机制通过实现org.apache.catalina.Lifecycle接口来实现。</p><ul><li><p>Server继承至LifeCycle，LifeCycle是一个非常重要的接口，各大组件都继承了这个接口，用于管理tomcat的生命周期，比如init、start、stop、destory；另外，它使用了观察者模式，LifeCycle是一个监听者，它会向注册的LifecycleListener观察者发出各种事件</p></li><li><p>Server提供了findService、getCatalina、getCatalinaHome、getCatalinaBase等接口，支持查找、遍历Service组件，这里似乎看到了和Serivce组件的些许联系。</p></li></ul><pre><code>public interface Server extends Lifecycle {    public NamingResourcesImpl getGlobalNamingResources();    public void setGlobalNamingResources(NamingResourcesImpl globalNamingResources);    public javax.naming.Context getGlobalNamingContext();    public int getPort();    public void setPort(int port);    public String getAddress();    public void setAddress(String address);    public String getShutdown();    public void setShutdown(String shutdown);    public ClassLoader getParentClassLoader();    public void setParentClassLoader(ClassLoader parent);    public Catalina getCatalina();    public void setCatalina(Catalina catalina);    public File getCatalinaBase();    public void setCatalinaBase(File catalinaBase);    public File getCatalinaHome();    public void setCatalinaHome(File catalinaHome);    public void await();    public Service findService(String name);    public Service[] findServices();    public void removeService(Service service);    public Object getNamingToken();}</code></pre><hr><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service的默认实现类是StardardService，类结构和StardardServer很相似，也是继承至LifecycleMBeanBase，实现了Service接口。</p><p>Service组件相当于Connetor和Engine组件的包装器，它将一个或者多个Connector组件和一个Engine建立关联。上述配置文件中，定义一个叫Catalina的服务，并将Http,AJP（定向包的协议）这两个Connector关联到了一个名为Catalina的Service，注意一个Connetor对应处理一种协议。Service组件对应Tomcat源代码中的org.apache.catalina.core.StandardService,StandardService的继承关系图如下图所示：</p><p><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190116170002.png"></p><p>由Service接口不难发现Service组件的内部结构 </p><ul><li><p>持有Engine实例</p></li><li><p>持有Server实例 </p></li><li><p>可以管理多个Connector实例</p></li><li><p>持有Executor引用</p></li></ul><pre><code>public class StandardService extends LifecycleMBeanBase implements Service {    // 省略若干代码}public interface Service extends Lifecycle {    public Engine getContainer();    public void setContainer(Engine engine);    public String getName();    public void setName(String name);    public Server getServer();    public void setServer(Server server);    public ClassLoader getParentClassLoader();    public void setParentClassLoader(ClassLoader parent);    public String getDomain();    public void addConnector(Connector connector);    public Connector[] findConnectors();    public void removeConnector(Connector connector);    public void addExecutor(Executor ex);    public Executor[] findExecutors();    public Executor getExecutor(String name);    public void removeExecutor(Executor ex);    Mapper getMapper();}</code></pre><hr><h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><p>Connector是tomcat中监听TCP端口的组件，server.xml默认定义了两个Connector，分别用于监听http、ajp端口。对应的代码是org.apache.catalina.connector.Connector，它是一个实现类，并且实现了Lifecycle接口。</p><pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</code></pre><ul><li>HTTP/1.1<br><connector port="8080" protocol="HTTP/1.1" connectiontimeout="20000" redirectport="8443"> 上面定义了一个Connector，它缺省监听端口8080,这个端口我们可以根据具体情况进行改动。connectionTimeout定义了连接超时时间，单位是毫秒，redirectPort定义了ssl的重定向接口，根据缺省的配置，Connector会将ssl请求重定向到8443端口。</connector></li></ul><pre><code>&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code></pre><ul><li>AJP/1.3<br>AJP表示Apache Jserv Protocol,此连接器将处理Tomcat和Apache http服务器之间的交互，这个连接器是用来处理我们将Tomcat和Apache http服务器结合使用的情况。假如在同样的一台物理Server上面部署了一台Apache http服务器和多台Tomcat服务器，通过Apache服务器来处理静态资源以及负载均衡的时候，针对不同的Tomcat实例需要AJP监听不同的端口。<strong>但是，在实际的项目应用中，AJP协议并不常用，大多数应用场景会使用 nginx + tomcat 实现负载均衡。</strong></li></ul><p>Connector对应源代码中的org.apache.catalina.connector.Connector,它的继承关系图如下所示：</p><p><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190116170422.png"></p><hr><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>org.apache.catalina.Container接口定义了容器的api，它是一个处理用户servlet请求并返回对象给web用户的模块，它有四种不同的容器： </p><ul><li><p>Engine，表示整个Catalina的servlet引擎 </p></li><li><p>Host，表示一个拥有若干个Context的虚拟主机 </p></li><li><p>Context，表示一个Web应用，一个context包含一个或多个wrapper </p></li><li><p>Wrapper，表示一个独立的servlet</p></li></ul><p><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190116171006.png"></p><p>Engine、Host、Context、Wrapper都有一个默认的实现类StandardXXX，均继承至ContainerBase。此外，一个容器还包含一系列的Lodder、Logger、Manager、Realm和Resources等</p><p>一个容器可以有一个或多个低层次上的子容器，并且一个Catalina功能部署并不一定需要全部四种容器。一个Context有一个或多个wrapper，而wrapper作为容器层次中的最底层，不能包含子容器。从一个容器添加到另一容器中可以使用在Container接口中定义的addChild()方法义：</p><pre><code>public void addChild(Container child);</code></pre><p>删除一个容器可以使用Container接口中定义的removeChild()方法：</p><pre><code>public void removeChild(Container child);</code></pre><p>另外容器接口支持子接口查找和获得所有子接口集合的方法findChild和findChildren方法：</p><pre><code>public Container findChild(String name);public Container[] findChildren();</code></pre><hr><h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><p>Tomcat中有一个容器的概念，而Engine,Host,Context,Wrapper都属于Contanier，我们先来说说最顶层的容器Engine.<br>一个Engine可以包含一个或者多个Host,也就是说我们一个Tomcat的实例可以配置多个虚拟主机。</p><p>缺省的情况下<code>&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</code>定义了一个名称为 Cataline 的 Engine。</p><p>Engine对应源代码中的org.apache.catalina.core.StandardEngine，它的继承关系图如下图所示：</p><p><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190116171521.png"></p><p>Engine表示Catalina的Servlet引擎，如果使用了Engine的话，则它是Catalina的<strong>顶层容器</strong>，因此在StardardCataline的setParent()方法中是直接抛出异常的。</p><pre><code>public interface Engine extends Container {    public String getDefaultHost();    public void setDefaultHost(String defaultHost);    public String getJvmRoute();    public void setJvmRoute(String jvmRouteId);    public Service getService();    public void setService(Service service);}public class StandardEngine extends ContainerBase implements Engine {    // other code...    public void setParent(Container container) {        throw new IllegalArgumentException(sm.getString(&quot;standardEngine.notParent&quot;));    }}</code></pre><p><code>server.xml:</code></p><pre><code>&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;  &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;    &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;           resourceName=&quot;UserDatabase&quot;/&gt;  &lt;/Realm&gt;  &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;    &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;           prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;           pattern=&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; /&gt;  &lt;/Host&gt;&lt;/Engine&gt;</code></pre><hr><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>Host定义了一个虚拟主机，正所谓虚拟主机，当然是可以用来部署应用程序的，Tomcat的Host也是如此。它在server.xml中定义了一个localhost的Host，应用根目录在webapps下面，默认是支持解压重新部署的。</p><pre><code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;...&lt;/Host&gt;</code></pre><p>其中appBase为webapps，也就是&lt;CATALINA_HOME&gt;\webapps目录，unpackingWARS属性指定在appBase指定的目录中的war包都自动的解压，缺省配置为true，autoDeploy属性指定是否对加入到appBase目录的war包进行自动的部署，缺省为true.</p><p>Host对应源代码中的org.apache.catalina.core.StandardHost,它的继承关系图如下所示：</p><p><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190116172108.png"></p><hr><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>Context代表一个独立的web应用，针对每个Context，tomcat都是使用不同的Classloader避免类冲突。如果我们希望使用一个自定义的目录作为部署路径的话，可以在server.xml中新增Context即可。</p><p>在Tomcat中，每一个运行的webapp其实最终都是以Context的形成存在，<strong>每个Context都有一个根路径和请求URL路径</strong>，Context对应源代码中的org.apache.catalina.core.StandardContext,它的继承关系图如下图所示：</p><p><img src="https://gakkil.gitee.io/gakkil-image/tomcat/QQ截图20190116172254.png"></p><pre><code>&lt;Context path=&quot;/static&quot; docBase=&quot;D:/static&quot; reloadable=&quot;true&quot;&gt;&lt;/Context&gt;</code></pre><p>在Tomcat中我们通常采用如下的两种方式创建一个Context.下面分别描述一下：</p><ol><li><p>在<catalina-home>\webapps目录中创建一个目录，这个时候将自动创建一个context，默认context的访问url为<code>http://host:port/dirname</code>,你也可以通过在ContextRoot\META-INF中创建一个context.xml的文件，其中包含如下的内容来指定应用的访问路径。<code>&lt;Context path=&quot;/yourUrlPath&quot; /&gt;</code></catalina-home></p></li><li><p>conf\server.xml文件中增加context元素。 第二种创建context的方法，我们可以选择在server.xml文件的<host>元素，比如我们在server.xml文件中增加如下内容：</host></p></li></ol><pre><code>&lt;Context path=&quot;/mypath&quot; docBase=&quot;/Users/xxx&quot; reloadable=&quot;true&quot;&gt;&lt;/Context&gt;</code></pre><p>这样的话，我们就可以通过 <code>http://host:port/mypath</code> 访问上面配置的 context 了。</p><hr><p><strong>Valve:</strong></p><p>Valve中文意思是阀门，Valve是Tomcat中责任链模式的实现，通过链接多个Valve对请求进行处理。每个容器都有一个流水线Pipeline（过滤器链），每个流水线至少有一个阀门。其中Valve可以定义在任何的Container中，上面说的Engine,Host,Context都属于容器。tomcat 默认定义了一个名为org.apache.catalina.valves.AccessLogValve的Valve,这个Valve负责拦截每个请求，然后记录一条访问日志。</p><p>通过上面的分析，我们发现Server,Service,Engine,Host,Context都实现了org.apache.catalina.Lifecycle接口，通过这个接口管理了这些核心组件的生命周期，关于这些组件的生命周期，我们在下一篇文章描述。</p>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解CAS</title>
      <link href="/2019/01/15/shen-ru-li-jie-cas/"/>
      <url>/2019/01/15/shen-ru-li-jie-cas/</url>
      
        <content type="html"><![CDATA[<p>CAS，Compare And Swap，即比较并交换。Doug lea大神在同步组件中大量使用CAS技术鬼斧神工地实现了Java多线程的并发操作。</p><hr><p>整个AQS同步组件、Atomic原子类操作等等都是以CAS实现的，甚至ConcurrentHashMap在1.8的版本中也调整为了CAS+Synchronized。可以说CAS是整个JUC的基石。</p><p><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190115133741.png"></p><h3 id="CAS分析"><a href="#CAS分析" class="headerlink" title="CAS分析"></a>CAS分析</h3><p>在CAS中有三个参数：内存值V、旧的预期值A、要更新的值B，当且仅当内存值V的值等于旧的预期值A时，才会将内存值V的值修改为B，否则什么都不干。其伪代码如下：</p><pre><code>if(this.value == A){    this.value = B    return true;}else{    return false;}</code></pre><p>JUC下的atomic类都是通过CAS来实现的，下面就以AtomicInteger为例来阐述CAS的实现。如下：</p><pre><code>    private static final Unsafe unsafe = Unsafe.getUnsafe();    private static final long valueOffset;    static {        try {            valueOffset = unsafe.objectFieldOffset                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));        } catch (Exception ex) { throw new Error(ex); }    }    private volatile int value;</code></pre><p>Unsafe是CAS的核心类，Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门：Unsafe，它提供了硬件级别的原子操作。</p><p>valueOffset为变量值在内存中的偏移地址，unsafe就是通过偏移地址来得到数据的原值的。</p><p>value当前值，使用volatile修饰，保证多线程环境下看见的是同一个。</p><p>我们就以AtomicInteger的addAndGet()方法来做说明，先看源代码：</p><pre><code>    public final int addAndGet(int delta) {        return unsafe.getAndAddInt(this, valueOffset, delta) + delta;    }    public final int getAndAddInt(Object var1, long var2, int var4) {        int var5;        do {            var5 = this.getIntVolatile(var1, var2);        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));        return var5;    }</code></pre><p>内部调用unsafe的getAndAddInt方法，在getAndAddInt方法中主要是看compareAndSwapInt方法：</p><p><code>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</code></p><p>该方法为本地方法，有四个参数，分别代表：对象、对象的地址、预期值、修改值（<strong>有位伙伴告诉我他面试的时候就问到这四个变量是啥意思…</strong>）。该方法的实现这里就不做详细介绍了，有兴趣的伙伴可以看看openjdk的源码。</p><p>CAS可以保证一次的<strong>读-改-写</strong>操作是原子操作，在单处理器上该操作容易实现，但是在多处理器上实现就有点儿复杂了。</p><p>CPU提供了两种方法来实现多处理器的原子操作：总线加锁或者缓存加锁。</p><ul><li><p><strong>总线加锁：</strong>总线加锁就是就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。但是这种处理方式显得有点儿霸道，不厚道，他把CPU和内存之间的通信锁住了，在锁定期间，其他处理器都不能读取其他内存地址的数据，其开销有点儿大。所以就有了缓存加锁。</p></li><li><p><strong>缓存加锁：</strong>其实针对于上面那种情况我们只需要保证在同一时刻对某个内存地址的操作是原子性的即可。缓存加锁就是缓存在内存区域的数据如果在加锁期间，当它执行锁操作写回内存时，处理器不在输出LOCK#信号，而是修改内部的内存地址，利用缓存一致性协议来保证原子性。缓存一致性机制可以保证同一个内存区域的数据仅能被一个处理器修改，也就是说当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。</p></li></ul><hr><h3 id="CAS缺陷"><a href="#CAS缺陷" class="headerlink" title="CAS缺陷"></a>CAS缺陷</h3><p>CAS虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方法：循环时间太长、只能保证一个共享变量原子操作、ABA问题。</p><h4 id="循环时间太长"><a href="#循环时间太长" class="headerlink" title="循环时间太长"></a>循环时间太长</h4><p>如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。</p><h4 id="只能保证一个共享变量原子操作"><a href="#只能保证一个共享变量原子操作" class="headerlink" title="只能保证一个共享变量原子操作"></a>只能保证一个共享变量原子操作</h4><p>看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高地位</p><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A。</p><p>用一个例子来阐述ABA问题所带来的影响。</p><p>有如下链表：</p><p><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190115134714.png"></p><p>假如我们想要把A替换成B，也就是compareAndSet(this,A,B)。线程1执行B替换A的操作，线程2主要执行如下动作，A 、B出栈，然后C、A入栈，最终该链表如下：</p><p><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190115134830.png"></p><p>完成后，线程1发现仍然是A，那么compareAndSet(this,A,B)成功，但是这时会存在一个问题就是B.next = null,compareAndSet(this,A,B)后，会导致C丢失，该栈仅有一个B元素了，平白无故把C给丢失了。</p><p>CAS的ABA隐患问题，解决方案则是<strong>版本号</strong>，Java提供了AtomicStampedReference来解决。AtomicStampedReference通过包装[E,Integer]的元组来对对象标记<strong>版本戳stamp</strong>，从而避免ABA问题。对于上面的案例应该线程1会失败。</p><p>AtomicStampedReference的compareAndSet()方法定义如下：</p><pre><code>    public boolean compareAndSet(V   expectedReference,                                 V   newReference,                                 int expectedStamp,                                 int newStamp) {        Pair&lt;V&gt; current = pair;        return            expectedReference == current.reference &amp;&amp;            expectedStamp == current.stamp &amp;&amp;            ((newReference == current.reference &amp;&amp;              newStamp == current.stamp) ||             casPair(current, Pair.of(newReference, newStamp)));    }</code></pre><p>compareAndSet有四个参数，分别表示：<strong>预期引用、更新后的引用、预期标志、更新后的标志</strong>。源码部分很好理解：预期的引用 == 当前引用，预期的标识 == 当前标识，如果更新后的引用和标志和当前的引用和标志相等则直接返回true，否则通过Pair生成一个新的pair对象与当前pair CAS替换。Pair为AtomicStampedReference的内部类，主要用于记录引用和版本戳信息（标识），定义如下：</p><pre><code>    private static class Pair&lt;T&gt; {        final T reference;        final int stamp;        private Pair(T reference, int stamp) {            this.reference = reference;            this.stamp = stamp;        }        static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) {            return new Pair&lt;T&gt;(reference, stamp);        }    }    private volatile Pair&lt;V&gt; pair;</code></pre><p>Pair记录着对象的引用和版本戳，版本戳为int型，保持自增。同时Pair是一个不可变对象，其所有属性全部定义为final，对外提供一个of方法，该方法返回一个新建的Pari对象。pair对象定义为volatile，保证多线程环境下的可见性。在AtomicStampedReference中，大多方法都是通过调用Pair的of方法来产生一个新的Pair对象，然后赋值给变量pair。如set方法：</p><pre><code>    public void set(V newReference, int newStamp) {        Pair&lt;V&gt; current = pair;        if (newReference != current.reference || newStamp != current.stamp)            this.pair = Pair.of(newReference, newStamp);    }</code></pre><p>下面我们将通过一个例子可以可以看到AtomicStampedReference和AtomicInteger的区别。我们定义两个线程，线程1负责将<br>100 —&gt; 110 —&gt; 100，线程2执行 100 —&gt;120，看两者之间的区别。</p><pre><code>public class Test {    private static AtomicInteger atomicInteger = new AtomicInteger(100);    private static AtomicStampedReference atomicStampedReference = new AtomicStampedReference(100,1);    public static void main(String[] args) throws InterruptedException {        //AtomicInteger        Thread at1 = new Thread(new Runnable() {            @Override            public void run() {                atomicInteger.compareAndSet(100,110);                atomicInteger.compareAndSet(110,100);            }        });        Thread at2 = new Thread(new Runnable() {            @Override            public void run() {                try {                    TimeUnit.SECONDS.sleep(2);      // at1,执行完，这里睡眠时间可以设置大点！！                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(&quot;AtomicInteger:&quot; + atomicInteger.compareAndSet(100,120));            }        });        at1.start();        at2.start();        at1.join();        at2.join();        //AtomicStampedReference        Thread tsf1 = new Thread(new Runnable() {            @Override            public void run() {                try {                    //让 tsf2先获取stamp，导致预期时间戳不一致                    TimeUnit.SECONDS.sleep(2);                } catch (InterruptedException e) {                    e.printStackTrace();                }                // 预期引用：100，更新后的引用：110，预期标识getStamp() 更新后的标识getStamp() + 1                atomicStampedReference.compareAndSet(100,110,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() + 1);                atomicStampedReference.compareAndSet(110,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() + 1);            }        });        Thread tsf2 = new Thread(new Runnable() {            @Override            public void run() {                int stamp = atomicStampedReference.getStamp();                try {                    TimeUnit.SECONDS.sleep(2);      //线程tsf1执行完                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(&quot;AtomicStampedReference:&quot; +atomicStampedReference.compareAndSet(100,120,stamp,stamp + 1));            }        });        tsf1.start();        tsf2.start();    }}</code></pre><p>运行结果：</p><pre><code>AtomicInteger:trueAtomicStampedReference:false</code></pre><p><strong>注意：</strong>如果，运行结果和我不一样，请注意上面的睡眠时间的设置，才能达到相同的效果！！！</p>]]></content>
      
      
      <categories>
          
          <category> CAS </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap的实现原理</title>
      <link href="/2019/01/14/concurrenthashmap-de-shi-xian-yuan-li/"/>
      <url>/2019/01/14/concurrenthashmap-de-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>接着上篇的HashMap的原理分析后，今天来学ConcurrentHashMap的实现原理</p><p>在现实开发中，不可避免地会碰到一些多线程并发访问的情况。为了解决这个问题，HashTable 和 HashMap 先后诞生。</p><p>问题也随之而来，使用后发现HashTable 虽然能保证线程安全但是效率低下，而HashMap 虽然效率高于hashTable 但是是非线程安全的。这个很像一个鱼与熊掌的问题，真的不可兼得吗？</p><p>于是人们就考虑有没有一种及支持并发有能保证线程安全的方法。终于，在JDK1.5中，伟大的Doug Lea 给我们带来了concurrent 包，从此Map 也有安全的了，这就是ConcurrentHashMap。安全且高效，像一条长了熊掌的鱼。</p><p>为了更好的理解ConcurrentHashMap的优点，我们先了解下它的两个前辈HashTable 和HashMap。</p><p><strong>HashMap</strong>：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。</p><p><strong>HashMap</strong>：非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p><p><strong>HashMap的线程安全问题如下：</strong></p><p>在hashmap 做put 操作的时候，假如A线程和B线程同时对同一个数组位置调用addEntry，两个线程会同时得到现在的头结点，然后A写入新的头结点之后，B也写入新的头结点，那B的写入操作就会覆盖A的写入操作造成A的写入操作丢失。同理，当多线程对同一数组位置进行remove操作时也会产生覆盖。</p><p>因此如果不进行额外的外同步操作，HashMap 是非线程安全的。如果加锁必然导致效率低下，而且竞争越激烈，效率越低下。</p><hr><p><strong>Hashtable：</strong>Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是<strong>线程安全</strong>的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p><p><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190114142923.png"></p><p>HashTable 只有一把锁，当一个线程访问HashTable的同步方法时，会将整张table 锁住，当其他线程也想访问HashTable 同步方法时，就会进入阻塞或轮询状态。也就是确保同一时间只有一个线程对同步方法的占用，避免多个线程同时对数据的修改，确保线程的安全性。</p><p>但HashTable 对 get，put，remove 方法都使用了同步操作，这就造成如果两个线程都只想使用get 方法去读取数据时，因为一个线程先到进行了锁操作，另一个线程就不得不等待，这样必然导致效率低下，而且竞争越激烈，效率越低下。</p><hr><h3 id="并发又安全的ConcurrentHashMap"><a href="#并发又安全的ConcurrentHashMap" class="headerlink" title="并发又安全的ConcurrentHashMap"></a>并发又安全的ConcurrentHashMap</h3><p>ConcurrentHashMap 保证线程安全的方法是：<strong>分段锁技术</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190114143134.png"></p><p>ConcurrentHashMap采用了非常精妙的”分段锁”策略，ConcurrentHashMap的主干是个Segment数组。</p><p>如上图，在hashMap 的基础上，ConcurrentHashMap 将数据分为多个segment（默认16个），然后每次操作对一个segment 加锁，HashTable 在竞争激烈的并发环境下表现出效率低下的原因是，由于所有访问HashTable的线程都必须竞争同一把锁，而ConcurrentHashMap 将数据分到多个segment 中（默认16，也可在申明时自己设置，不过一旦设定就不能更改，扩容都是扩充各个segment 的容量），每个segment 都有一个自己的锁，只要多个线程访问的不是同一个segment 就没有锁争用，就没有堵塞，也就是允许16个线程并发的更新而尽量没有锁争用。</p><p>ConcurrentHashMap 的 segment 就类似一个HashTable，但比HashTable 更加优化，前面说过HashTable对get，put，remove 方法都会使用锁，而ConcurrnetHashMap 中get 方法是不涉及到锁的。</p><p>在并发读取时，除了key 对应的value 为null 外，并没有用到锁，所以对于读操作无论多少线程并发都是安全高效的。</p><p>举个日常生活中的例子（背景是你在网上订好了一家旅店，然后拿着材料来入住，map就相当于这个旅店，你就相当于是操作map的线程）：上述这家旅店（Collections.synchronizedMap）如果只有一个前台，所有人要登记入住都得在前台办理手续，如果只有你一个人，那么你可以马上入住，如果有一群人，那你就得等着，这样效率不高。而ConcurrentHashMap在每层都有一个前台，你根据你的楼层号（哈希值）去相应的楼层办理入住手续，这样就减少排队等待的概率及时间。</p><hr><h3 id="ConcurrentHashMap源码分析"><a href="#ConcurrentHashMap源码分析" class="headerlink" title="ConcurrentHashMap源码分析"></a>ConcurrentHashMap源码分析</h3><p>ConcurrentHashMap采用了非常精妙的”分段锁”策略，ConcurrentHashMap的主干是个Segment数组。</p><pre><code> final Segment&lt;K,V&gt;[] segments;</code></pre><p>Segment继承了 <strong>ReentrantLock</strong>，所以它就是一种可重入锁（ReentrantLock)。在ConcurrentHashMap，一个Segment就是一个子哈希表，Segment里维护了一个HashEntry数组，并发环境下，对于不同Segment的数据进行操作是不用考虑锁竞争的。（就按默认的ConcurrentLeve为16来讲，理论上就允许16个线程并发执行，有木有很酷）</p><font color="red">所以，对于同一个Segment的操作才需考虑线程同步，不同的Segment则无需考虑。</font><p>Segment类似于HashMap，一个Segment维护着一个HashEntry数组:</p><pre><code> transient volatile HashEntry&lt;K,V&gt;[] table;</code></pre><p>HashEntry是目前我们提到的最小的逻辑处理单元了。一个ConcurrentHashMap维护一个Segment数组，一个Segment维护一个HashEntry数组。</p><pre><code> static final class HashEntry&lt;K,V&gt; {        final int hash;        final K key;        volatile V value;        volatile HashEntry&lt;K,V&gt; next;        //其他省略}    </code></pre><p>我们说Segment类似哈希表，那么一些属性就跟我们之前提到的HashMap差不离，比如负载因子loadFactor，比如阈值threshold等等，看下Segment的构造方法</p><pre><code>Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) {            this.loadFactor = lf;//负载因子            this.threshold = threshold;//阈值            this.table = tab;//主干数组即HashEntry数组        }</code></pre><p>我们来看下ConcurrentHashMap的构造方法:</p><pre><code>   public ConcurrentHashMap(int initialCapacity , float loadFactor, int concurrencyLevel) {          if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)                throw new IllegalArgumentException();          //MAX_SEGMENTS 为1&lt;&lt;16=65536，也就是最大并发数为65536          if (concurrencyLevel &gt; MAX_SEGMENTS)               concurrencyLevel = MAX_SEGMENTS;          //2的sshif次方等于ssize，例:ssize=16,sshift=4;ssize=32,sshif=5          int sshift = 0;          //ssize 为segments数组长度，根据concurrentLevel计算得出          int ssize = 1;          while (ssize &lt; concurrencyLevel) {              ++sshift;              ssize &lt;&lt;= 1;          }          //segmentShift和segmentMask这两个变量在定位segment时会用到，后面会详细讲          this.segmentShift = 32 - sshift;          this.segmentMask = ssize - 1;          if (initialCapacity &gt; MAXIMUM_CAPACITY)              initialCapacity = MAXIMUM_CAPACITY;          //计算cap的大小，即Segment中HashEntry的数组长度，cap也一定为2的n次方.          int c = initialCapacity / ssize;          if (c * ssize &lt; initialCapacity)              ++c;          int cap = MIN_SEGMENT_TABLE_CAPACITY;          while (cap &lt; c)              cap &lt;&lt;= 1;          //创建segments数组并初始化第一个Segment，其余的Segment延迟初始化          Segment&lt;K,V&gt; s0 =              new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),                               (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);          Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];          UNSAFE.putOrderedObject(ss, SBASE, s0);           this.segments = ss;      }</code></pre><p>初始化方法有三个参数，如果用户不指定则会使用默认值，initialCapacity为16，loadFactor为0.75（负载因子，扩容时需要参考），concurrentLevel为16。</p><p>从上面的代码可以看出来,Segment数组的大小ssize是由concurrentLevel来决定的，但是却不一定等于concurrentLevel，ssize一定是大于或等于concurrentLevel的最小的2的次幂。比如：默认情况下concurrentLevel是16，则ssize为16；若concurrentLevel为14，ssize为16；若concurrentLevel为17，则ssize为32。为什么Segment的数组大小一定是2的次幂？其实主要是便于通过按位与的散列算法来定位Segment的index。</p><h4 id="put的过程分析："><a href="#put的过程分析：" class="headerlink" title="put的过程分析："></a>put的过程分析：</h4><pre><code> public V put(K key, V value) {        Segment&lt;K,V&gt; s;        //concurrentHashMap不允许key/value为空        if (value == null)            throw new NullPointerException();        //hash函数对key的hashCode重新散列，避免差劲的不合理的hashcode，保证散列均匀        int hash = hash(key);        //返回的hash值无符号右移segmentShift位与段掩码进行位运算，定位segment        int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment            s = ensureSegment(j);        return s.put(key, hash, value, false);    }</code></pre><p>从源码看出，put的主要逻辑也就两步：1.定位segment并确保定位的Segment已初始化 2.调用Segment的put方法。</p><p>关于segmentShift和segmentMask：</p><p>segmentShift 和 segmentMask 这两个全局变量的主要作用是用来定位Segment，int j =(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask。</p><p><strong>segmentMask：</strong>段掩码，假如segments数组长度为16，则段掩码为16-1=15；segments长度为32，段掩码为32-1=31。这样得到的所有bit位都为1，可以更好地保证散列的均匀性。</p><p><strong>segmentShift：</strong>2的sshift次方等于ssize，segmentShift=32-sshift。若segments长度为16，segmentShift=32-4=28;若segments长度为32，segmentShift=32-5=27。而计算得出的hash值最大为32位，<strong>无符号右移segmentShift，则意味着只保留高几位</strong>（其余位是没用的），然后与段掩码segmentMask位运算来定位Segment。</p><hr><h4 id="get的过程分析："><a href="#get的过程分析：" class="headerlink" title="get的过程分析："></a>get的过程分析：</h4><pre><code> public V get(Object key) {        Segment&lt;K,V&gt; s;         HashEntry&lt;K,V&gt;[] tab;        int h = hash(key);        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;        //先定位Segment，再定位HashEntry        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;            (tab = s.table) != null) {            for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile                     (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);                 e != null; e = e.next) {                K k;                if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))                    return e.value;            }        }        return null;    }</code></pre><p><font color="red">get方法无需加锁，由于其中涉及到的共享变量都使用volatile修饰，volatile可以保证内存可见性，所以不会读取到过期数据。<font></font></font></p><p>来看下concurrentHashMap代理到Segment上的put方法，Segment中的put方法是要加锁的。只不过是锁粒度细了而已。</p><pre><code>final V put(K key, int hash, V value, boolean onlyIfAbsent) {            //tryLock不成功时会遍历定位到的HashEnry位置的链表（遍历主要是为了使CPU缓存链表)            //若找不到，则创建HashEntry。tryLock一定次数后（MAX_SCAN_RETRIES变量决定）则lock。            //若遍历过程中，由于其他线程的操作导致链表头结点变化，则需要重新遍历。            HashEntry&lt;K,V&gt; node = tryLock() ? null :scanAndLockForPut(key, hash, value);            V oldValue;            try {                HashEntry&lt;K,V&gt;[] tab = table;                //定位HashEntry，可以看到，这个hash值在定位Segment时和在Segment中定位HashEntry都会用到                //只不过定位Segment时只用到高几位。                int index = (tab.length - 1) &amp; hash;                HashEntry&lt;K,V&gt; first = entryAt(tab, index);                for (HashEntry&lt;K,V&gt; e = first;;) {                    if (e != null) {                        K k;                        if ((k = e.key) == key ||                            (e.hash == hash &amp;&amp; key.equals(k))) {                            oldValue = e.value;                            if (!onlyIfAbsent) {                                e.value = value;                                ++modCount;                            }                            break;                        }                        e = e.next;                    }                    else {                        if (node != null)                            node.setNext(first);                        else                            node = new HashEntry&lt;K,V&gt;(hash, key, value, first);                        int c = count + 1;　　　　　　　　　　　　 //若c超出阈值threshold，需要扩容并rehash。扩容后的容量是当前容量的2倍。                        if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)                            rehash(node);                        else                            setEntryAt(tab, index, node);                        ++modCount;                        count = c;                        oldValue = null;                        break;                    }                }            } finally {                unlock();            }            return oldValue;        }</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ConcurrentHashMap作为一种线程安全且高效的哈希表的解决方案，尤其其中的”分段锁”的方案，相比HashTable的全表锁在性能上的提升非常之大。本文对ConcurrentHashMap的实现原理进行了详细分析，并解读了部分源码，希望能帮助到有需要的童鞋。</p>]]></content>
      
      
      <categories>
          
          <category> ConcurrentHashMap </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConcurrentHashMap </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的实现原理</title>
      <link href="/2019/01/14/hashmap-de-shi-xian-yuan-li/"/>
      <url>/2019/01/14/hashmap-de-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>帮助大家理解，HashMap的底层原理，方便大家面试</p><h3 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h3><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p><pre><code>//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</code></pre><p>Entry是HashMap中的一个静态内部类。代码如下:</p><pre><code>    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final K key;        V value;        Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构        int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算        /**         * Creates new entry.         */        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {            hash = h;            key = k;            value = v;            next = n;        } </code></pre><p>所以，HashMap的整体结构如下:<br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190114130741.png"></p><p>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</p><p><strong>几个重要字段：</strong></p><pre><code>//实际存储的key-value键值对的个数transient int size;//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到int threshold;//负载因子，代表了table的填充度有多少，默认是0.75final float loadFactor;//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationExceptiontransient int modCount;</code></pre><p>HashMap有4个构造器，其他构造器如果用户没有传入 <strong>initialCapacity</strong> 和 <strong>loadFactor</strong> 这两个参数，会使用默认值:</p><p>initialCapacity默认为16，loadFactory默认为0.75。</p><p>我们看下其中一个:</p><pre><code>public HashMap(int initialCapacity, float loadFactor) {　　　　　//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)        if (initialCapacity &lt; 0)            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                               initialCapacity);        if (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                               loadFactor);        this.loadFactor = loadFactor;        threshold = initialCapacity;　　　　　        init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现    }</code></pre><p>从上面这段代码我们可以看出，在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组。</p><h4 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><pre><code>    public V put(K key, V value) {        //如果table数组为空数组{}，进行数组填充（为table分配实际内存空间）        //入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)        if (table == EMPTY_TABLE) {            inflateTable(threshold);        }        //如果key为null，存储位置为table[0]或table[0]的冲突链上        if (key == null)            return putForNullKey(value);        int hash = hash(key); //对key的hashcode进一步计算，确保散列均匀        int i = indexFor(hash, table.length); //获取在table中的实际位置        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {        //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value            Object k;            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {                V oldValue = e.value;                e.value = value;                e.recordAccess(this);                return oldValue;            }        }        modCount++; //保证并发访问时，若HashMap内部结构发生变化，快速响应失败        addEntry(hash, key, value, i); //新增一个entry        return null;    }  </code></pre><p><strong>inflateTable方法：</strong></p><pre><code>private void inflateTable(int toSize) {        //capacity一定是2的次幂        int capacity = roundUpToPowerOf2(toSize);         //此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值        //capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);        table = new Entry[capacity];        initHashSeedAsNeeded(capacity);    }</code></pre><p>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过 <strong>roundUpToPowerOf2(toSize)</strong> 可以确保capacity为大于或等于toSize的最接近toSize的二次幂，<strong>比如 toSize=13, 则capacity=16; to_size=16, capacity=16 ; to_size=17 , capacity=32.</strong></p><p><strong>roundUpToPowerOf2方法：</strong></p><pre><code> private static int roundUpToPowerOf2(int number) {        // assert number &gt;= 0 : &quot;number must be non-negative&quot;;        return number &gt;= MAXIMUM_CAPACITY                ? MAXIMUM_CAPACITY                : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;    }</code></pre><p>roundUpToPowerOf2 中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit 是用来获取最左边的bit（其他bit位为0）所代表的数值.</p><p><strong>hash函数：</strong></p><pre><code>//这是一个神奇的函数，用了很多的异或，移位等运算//对key的hashcode 进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀final int hash(Object k) {        int h = hashSeed;        if (0 != h &amp;&amp; k instanceof String) {            return sun.misc.Hashing.stringHash32((String) k);        }        h ^= k.hashCode();        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);    }</code></pre><p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置.</p><p><strong>indexFor方法：</strong></p><pre><code>    /**     * 返回数组下标     */    static int indexFor(int h, int length) {        return h &amp; (length-1);    }</code></pre><p>h &amp;（length-1）保证获取的 index 一定在数组范围内，举个例子，默认容量16，length-1=15，h=18 , 转换成二进制计算为:</p><pre><code>        1  0  0  1  0    &amp;   0  1  1  1  1    __________________        0  0  0  1  0    = 2</code></pre><p>最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）。</p><p>所以最终存储位置的确定流程是这样的：<br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190114133102.png"></p><p>再来看看<strong>addEntry</strong>的实现：</p><pre><code>void addEntry(int hash, K key, V value, int bucketIndex) {        // 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {            resize(2 * table.length);            // 扩容以后，重新计算 hash 值            hash = (null != key) ? hash(key) : 0;            // 重新计算扩容后的新的下标            bucketIndex = indexFor(hash, table.length);        }        // 往下看        createEntry(hash, key, value, bucketIndex);    }// 这个很简单，其实就是将新值放到链表的表头，然后 size++void createEntry(int hash, K key, V value, int bucketIndex) {    Entry&lt;K,V&gt; e = table[bucketIndex];    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);    size++;}</code></pre><p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p><p>前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p><p><strong>resize方法：</strong></p><pre><code>void resize(int newCapacity) {    Entry[] oldTable = table;    int oldCapacity = oldTable.length;    if (oldCapacity == MAXIMUM_CAPACITY) {        threshold = Integer.MAX_VALUE;        return;    }    // 新的数组    Entry[] newTable = new Entry[newCapacity];    // 将原来数组中的值迁移到新的更大的数组中    transfer(newTable, initHashSeedAsNeeded(newCapacity));    table = newTable;    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);}</code></pre><p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p><p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。</p><h3 id="为何HashMap的数组长度一定是2的次幂？"><a href="#为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="为何HashMap的数组长度一定是2的次幂？"></a>为何HashMap的数组长度一定是2的次幂？</h3><p>上述，我们已经知道了数组扩容的知识了，如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法：</p><pre><code>void transfer(Entry[] newTable, boolean rehash) {        int newCapacity = newTable.length;　　　　//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）        for (Entry&lt;K,V&gt; e : table) {            while(null != e) {                Entry&lt;K,V&gt; next = e.next;                if (rehash) {                    e.hash = null == e.key ? 0 : hash(e.key);                }                int i = indexFor(e.hash, newCapacity);　　　　　　　　//将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。                e.next = newTable[i];                newTable[i] = e;                e = next;            }        }    }</code></pre><p>这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p><p>hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会<strong>保证低位全为1</strong>，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p><p><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190114134358.png"></p><p>还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：</p><p><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190114134446.png"></p><p>我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p><p><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190114134636.png"></p><p>如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。(如上图)</p><hr><h4 id="get过程分析"><a href="#get过程分析" class="headerlink" title="get过程分析"></a>get过程分析</h4><pre><code> public V get(Object key) {　　　　 //如果key为null,则直接去table[0]处去检索即可。        if (key == null)            return getForNullKey();        Entry&lt;K,V&gt; entry = getEntry(key);        return null == entry ? null : entry.getValue(); }</code></pre><p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法:</p><p><strong>getEntry方法：</strong></p><pre><code>final Entry&lt;K,V&gt; getEntry(Object key) {        if (size == 0) {            return null;        }        //通过key的hashcode值计算hash值        int hash = (key == null) ? 0 : hash(key);        //indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];             e != null;             e = e.next) {            Object k;            if (e.hash == hash &amp;&amp;                 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                return e;        }        return null;    } </code></pre><p>可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。<font color="red">要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，<strong>e.hash == hash这个判断没必要</strong>，仅通过equals判断就可以。</font>其实不然，试想一下，<font color="red">如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null</font>，后面的例子会做出进一步解释。</p><hr><h3 id="重写equals方法需同时重写hashCode方法"><a href="#重写equals方法需同时重写hashCode方法" class="headerlink" title="重写equals方法需同时重写hashCode方法"></a>重写equals方法需同时重写hashCode方法</h3><p>关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题呢？</p><pre><code>public class MyTest {    private static class Person{        int idCard;        String name;        public Person(int idCard, String name) {            this.idCard = idCard;            this.name = name;        }        @Override        public boolean equals(Object o) {            if (this == o) {                return true;            }            if (o == null || getClass() != o.getClass()){                return false;            }            Person person = (Person) o;            //两个对象是否等值，通过idCard来确定            return this.idCard == person.idCard;        }    }    public static void main(String []args){        HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;();        Person person = new Person(1234,&quot;乔峰&quot;);        //put到hashmap中去        map.put(person,&quot;天龙八部&quot;);        //get取出，从逻辑上讲应该能输出“天龙八部”        System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));    }}</code></pre><p>实际输出结果：</p><font color="red"><strong>结果：null</strong></font><p>如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p><p>所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p>]]></content>
      
      
      <categories>
          
          <category> HashMap </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java原子类实现原理分析</title>
      <link href="/2019/01/13/java-yuan-zi-lei-shi-xian-yuan-li-fen-xi/"/>
      <url>/2019/01/13/java-yuan-zi-lei-shi-xian-yuan-li-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>浅谈java中的原子类实现原理</p><p>在谈谈java中的volatile一文中，我们提到过并发包中的原子类可以解决类似num++这样的复合类操作的原子性问题，相比锁机制，使用原子类更精巧轻量，性能开销更小，本章就一起来分析下原子类的实现机理。</p><h3 id="悲观的解决方案（阻塞同步）"><a href="#悲观的解决方案（阻塞同步）" class="headerlink" title="悲观的解决方案（阻塞同步）"></a>悲观的解决方案（阻塞同步）</h3><p>我们知道，num++看似简单的一个操作，实际上是由<strong>1.读取 2.加一 3.写入 </strong>三步组成的，这是个复合类的操作（所以我们之前提到过的volatile是无法解决num++的原子性问题的），在并发环境下，如果不做任何同步处理，就会有线程安全问题。最直接的处理方式就是<strong>加锁</strong>。</p><pre><code>synchronized(this){    num++; }</code></pre><p>使用独占锁机制来解决，是一种<strong>悲观的并发策略</strong>，抱着一副“总有刁民想害朕”的态势，每次操作数据的时候都认为别的线程会参与</p><p>竞争修改，所以直接加锁。同一刻只能有一个线程持有锁，那其他线程就会阻塞。线程的挂起恢复会带来很大的性能开销，尽管</p><p>jvm对于非竞争性的锁的获取和释放做了很多优化，但是一旦有多个线程竞争锁，频繁的阻塞唤醒，还是会有很大的性能开销的。</p><p>所以，使用synchronized或其他重量级锁来处理显然不够合理。</p><hr><h3 id="乐观的解决方案（非阻塞同步）"><a href="#乐观的解决方案（非阻塞同步）" class="headerlink" title="乐观的解决方案（非阻塞同步）"></a>乐观的解决方案（非阻塞同步）</h3><p>乐观的解决方案，顾名思义，就是很大度乐观，每次操作数据的时候，都认为别的线程不会参与竞争修改，也不加锁。如果操作成功了那最好；如果失败了，比如中途确有别的线程进入并修改了数据（依赖于冲突检测），也不会阻塞，可以采取一些补偿机制，一般的策略就是<strong>反复重试</strong>。很显然，这种思想相比简单粗暴利用锁来保证同步要合理的多。</p><p>鉴于并发包中的原子类其实现机理都差不太多，本章我们就通过AtomicInteger这个原子类来进行分析。我们先来看看对于num++这样的操作AtomicInteger是如何保证其原子性的。</p><pre><code> /**     * Atomically increments by one the current value.     *     * @return the updated value     */    public final int incrementAndGet() {        for (;;) {            int current = get();            int next = current + 1;            if (compareAndSet(current, next))                return next;        }    }</code></pre><p>我们来分析下incrementAndGet的逻辑：</p><ol><li><p>先获取当前的value值</p></li><li><p>对value加一</p></li><li><p>第三步是关键步骤，调用<strong>compareAndSet</strong>方法来来进行原子更新操作，这个方法的语义是：</p></li></ol><font color="red"><strong>先检查当前value是否等于current，如果相等，则意味着value没被其他线程修改过，更新并返回true。如果不相等，compareAndSet则会返回false，然后循环继续尝试更新。</strong></font><p>compareAndSet调用了Unsafe类的compareAndSwapInt方法:</p><pre><code>/**     * Atomically sets the value to the given updated value     * if the current value {@code ==} the expected value.     *     * @param expect the expected value     * @param update the new value     * @return true if successful. False return indicates that     * the actual value was not equal to the expected value.     */    public final boolean compareAndSet(int expect, int update) {        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);    }</code></pre><p>Unsafe的compareAndSwapInt是个native方法，也就是平台相关的。它是基于CPU的CAS指令来完成的。</p><pre><code>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</code></pre><hr><h3 id="CAS-Compare-and-Swap"><a href="#CAS-Compare-and-Swap" class="headerlink" title="CAS(Compare-and-Swap)"></a>CAS(Compare-and-Swap)</h3><p>CAS算法是由硬件直接支持来保证原子性的，有三个操作数：<font color="red"><strong>内存位置V、旧的预期值A 和 新值B，当且仅当V符合预期值A时，CAS用新值B原子化地更新V的值，否则，它什么都不做。</strong></font></p><p><strong>CAS的ABA问题:</strong></p><p>当然CAS也并不完美，它存在”ABA”问题，假若一个变量初次读取是A，<strong>在compare阶段依然是A，但其实可能在此过程中</strong>，<strong>它先被改为B，再被改回A</strong>，<strong>而CAS是无法意识到这个问题的。</strong>CAS只关注了比较前后的值是否改变，而无法清楚在此过程中变量的变更明细，这就是所谓的ABA漏洞。 </p>]]></content>
      
      
      <categories>
          
          <category> 原子类 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 原子类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈java中的volatile</title>
      <link href="/2019/01/13/tan-tan-java-zhong-de-volatile/"/>
      <url>/2019/01/13/tan-tan-java-zhong-de-volatile/</url>
      
        <content type="html"><![CDATA[<p>浅谈java中的volatile关键字</p><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>volatile是Java提供的一种轻量级的同步机制，在并发编程中，它也扮演着比较重要的角色。同synchronized相比（synchronized通常称为重量级锁），volatile更轻量级，相比使用synchronized所带来的庞大开销，倘若能恰当的合理的使用volatile，自然是美事一桩。</p><p>为了能比较清晰彻底的理解volatile，我们一步一步来分析。首先来看看如下代码：</p><pre><code>public class TestVolatile {    boolean status = false;    /**     * 状态切换为true     */    public void changeStatus(){        status = true;    }    /**     * 若状态为true，则running。     */    public void run(){        if(status){            System.out.println(&quot;running....&quot;);        }    }}</code></pre><p>上面这个例子，在 <strong>多线程环境</strong> 里，假设 线程A 执行changeStatus()方法后 , 线程B 运行run()方法，可以保证输出”running…..”吗？</p><font color="red">答案是NO! </font><p>这个结论会让人有些疑惑，可以理解。因为倘若在单线程模型里，先运行changeStatus方法，再执行run方法，自然是可以正确输出”running….”的；但是在多线程模型中，是没法做这种保证的。因为对于共享变量status来说，线程A的修改，对于线程B来讲，<strong>是”不可见”的</strong>。也就是说，线程B此时可能无法观测到status已被修改为true。那么什么是可见性呢？</p><font color="red">所谓可见性，是指当一条线程修改了共享变量的值，新值对于其他线程来说是<strong>可以立即得知的</strong>。很显然，上述的例子中是没有办法做到内存可见性的。</font><p><strong>Java内存模型</strong></p><p>为什么出现这种情况呢，我们需要先了解一下JMM（java内存模型）</p><p>java虚拟机有自己的内存模型（Java Memory Model，JMM），JMM可以屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。</p><p>JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。这三者之间的交互关系如下:</p><p><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190113132739.png"></p><p>　　需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存。当然如果是出于理解的目的，这样对应起来也无不可。</p><p>大概了解了JMM的简单定义后，问题就很容易理解了，对于普通的共享变量来讲，比如我们上文中的status，线程A将其修改</p><p>为true这个动作发生在线程A的本地内存中，此时还未同步到主内存中去；而线程B缓存了status的初始值false，此时可能</p><p>没有观测到status的值被修改了，所以就导致了上述的问题。那么这种共享变量在多线程模型中的不可见性如何解决呢？比</p><p>较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，有点炮打蚊子的意思。比较合理的方式其实就是volatile。</p><p>volatile具备两种特性，第一就是保证共享变量对所有线程的可见性。将一个共享变量声明为volatile后，会有以下效应：</p><ul><li><p><strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的变量强制刷新到主内存中去；</strong></p></li><li><p><strong>这个写会操作会导致其他线程中的缓存无效。</strong></p></li></ul><p>上面的例子只需将status声明为volatile，即可保证在线程A将其修改为true时，线程B可以立刻得知：</p><p><code>volatile boolean status = false;</code></p><hr><h3 id="留意复合类操作"><a href="#留意复合类操作" class="headerlink" title="留意复合类操作"></a>留意复合类操作</h3><p>但是需要注意的是，我们一直在拿volatile和synchronized做对比，仅仅是因为这两个关键字在某些内存语义上有共通之处，volatile并不能完全替代synchronized，它依然是个轻量级锁，在很多场景下，volatile并不能胜任。看下这个例子：</p><pre><code>package test;import java.util.concurrent.CountDownLatch;public class Counter {    public static volatile int num = 0;    //使用CountDownLatch来等待计算线程执行完    static CountDownLatch countDownLatch = new CountDownLatch(30);    public static void main(String []args) throws InterruptedException {        //开启30个线程进行累加操作        for(int i=0;i&lt;30;i++){            new Thread(){                public void run(){                    for(int j=0;j&lt;10000;j++){                        num++;//自加操作                    }                    countDownLatch.countDown();                }            }.start();        }        //等待计算线程执行完        countDownLatch.await();        System.out.println(num);    }}</code></pre><p>执行结果：</p><p><code>224291</code></p><p>针对这个示例，一些同学可能会觉得疑惑，如果用volatile修饰的共享变量可以保证可见性，那么结果不应该是<code>300000么</code>?</p><p>问题就出在num++这个操作上，<strong>因为num++不是个原子性的操作</strong>，<strong>而是个复合操作</strong>。我们可以简单讲这个操作理解为由这三步组成:</p><ol><li><p>读取</p></li><li><p>加一</p></li><li><p>赋值</p></li></ol><p>所以，在多线程环境下，有可能线程A将num读取到本地内存中，此时其他线程可能已经将num增大了很多，线程A依然对过期的num进行自加，重新写到主存中，最终导致了num的结果不合预期，而是小于30000。</p><hr><h3 id="解决num-操作的原子性问题"><a href="#解决num-操作的原子性问题" class="headerlink" title="解决num++操作的原子性问题"></a>解决num++操作的原子性问题</h3><p>针对 num++ 这类复合类的操作，可以使用 java并发包 中的原子操作类 , 原子操作类是通过循环CAS的方式来保证其原子性的。</p><pre><code>public class Counter {　　//使用原子操作类    public static AtomicInteger num = new AtomicInteger(0);    //使用CountDownLatch来等待计算线程执行完    static CountDownLatch countDownLatch = new CountDownLatch(30);    public static void main(String []args) throws InterruptedException {        //开启30个线程进行累加操作        for(int i=0;i&lt;30;i++){            new Thread(){                public void run(){                    for(int j=0;j&lt;10000;j++){                        num.incrementAndGet();//原子性的num++,通过循环CAS方式                    }                    countDownLatch.countDown();                }            }.start();        }        //等待计算线程执行完        countDownLatch.await();        System.out.println(num);    }}</code></pre><p>执行结果:</p><p><code>300000</code></p><p>关于原子类操作的基本原理，会在以后的章节进行介绍，此处不再赘述。</p><hr><h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><p>volatile还有一个特性：<strong>禁止指令重排序优化。</strong></p><font color="red">重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。但是重排序也需要遵守一定规则：</font><p><strong>1.重排序操作不会对存在数据依赖关系的操作进行重排序。</strong></p><p>比如：a=1; b=a;  这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</p><p><strong>2.重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变</strong></p><p>比如：a=1; b=2; c=a+b 这三个操作，第一步（a=1) 和 第二步(b=2)由于不存在数据依赖关系，所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。</p><p>重排序在单线程模式下是一定会保证最终结果的正确性，但是在多线程环境下，问题就出来了，来开个例子，我们对第一个TestVolatile的例子稍稍改进，再增加个共享变量a:</p><pre><code>public class TestVolatile {    int a = 1;    boolean status = false;    /**     * 状态切换为true     */    public void changeStatus(){        a = 2; //1        status = true; //2    }    /**     * 若状态为true，则running。     */    public void run(){        if(status){ //3            int b = a + 1; //4            System.out.println(b);        }    }}</code></pre><p>假设线程A执行changeStatus后，线程B执行run，我们能保证在4处，b一定等于3么？</p><p><strong>答案依然是无法保证！</strong>也有可能b仍然为2。上面我们提到过，为了提供程序并行度，编译器和处理器可能会对指令进行重排序，</p><p>而上例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true,再执行a=2。而此时线程B会顺利到达4处，</p><p>而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。</p><p><strong>使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序</strong></p><p>volatile禁止指令重排序也有一些规则，简单列举一下：</p><p><strong>1.当第二个操作是voaltile写时，无论第一个操作是什么，都不能进行重排序</strong></p><p><strong>2.当第一个操作是volatile读时，不管第二个操作是什么，都不能进行重排序</strong></p><p><strong>3.当第一个操作是volatile写时，第二个操作是volatile读时，不能进行重排序</strong></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单总结下，volatile是一种轻量级的同步机制，它主要有两个特性：一是保证共享变量对所有线程的<code>可见性</code>；二是<code>禁止指令重排序优化</code>。同时需要注意的是，<code>volatile对于单个的共享变量的读/写具有原子性</code>，但是像num++这种复合操作，volatile无法保证其原子性，当然文中也提出了解决方案，就是使用并发包中的原子操作类，通过循环CAS地方式来保证num++操作的原子性。关于原子操作类，会在后续的文章进行介绍。</p>]]></content>
      
      
      <categories>
          
          <category> volatile </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试中的单例问题</title>
      <link href="/2019/01/13/mian-shi-zhong-de-dan-li-wen-ti/"/>
      <url>/2019/01/13/mian-shi-zhong-de-dan-li-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>给大家普及一下，我在面试中遇到的单例问题。</p><p>当我兴冲冲的带着笔记答案参加面试时，突然发现面前的面试官显得很严肃而且眉头紧锁，不知道是工作太累了，还是说他对今天的面试者不是很满意。</p><p>于是我就勇敢的坐过去在他的面前坐了下来，没想到第一道题就让面试官看出了我的水平，因此今天跟大家聊聊面试中单例的问题，希望大家都能了解这块内容。</p><p>在早期的项目代码中，如果我们想使用类的某个方法，我们基本都会创建一个类的对象实例然后再调用方法，这样的实现往往在系统内就会存在某个类的大量实例。如此一来，项目框架很难管理大量的对象，而且如果java虚拟机不能及时回收，容易造成内存溢出。</p><p>首先我们要明白什么是单例，所谓单例就是说在项目框架内某个类的对象实例只存在一个，任何调用方获取到的对象实例都是一个，那么很明显这个类是不能够被外部直接调用类构造器创建的。</p><h3 id="只适合单线程环境（不好）"><a href="#只适合单线程环境（不好）" class="headerlink" title="只适合单线程环境（不好）"></a>只适合单线程环境（不好）</h3><p>我们先看下一个简单的单例设计：<br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190113123252.png"><br>上面代码在单线程是没有问题的，而且只有当线程调用类的静态方法时，才会生成类的静态变量。但是当多线程访问时，上面代码是有问题的，会生成多个对象的实例。</p><p>例如：当两个线程同时运行到判断instance是否为空的if语句，并且instance确实没有创建好时，那么两个线程都会创建一个实例。</p><hr><h3 id="多线程的情况（懒汉式，不好）"><a href="#多线程的情况（懒汉式，不好）" class="headerlink" title="多线程的情况（懒汉式，不好）"></a>多线程的情况（懒汉式，不好）</h3><p>那么，我们可以用另外一种方法实现，比如说在类加载时候就初始化对象的实例，这样后面无论怎么调用类静态方法都不创建新的实例。还有一种方法，但是会<strong>牺牲部分系统性能</strong>，意思就是在多线程访问方法时通过<strong>锁机制</strong>让线程排队访问。我们先通过在类方法上加锁来实现类的单例，比如：<br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190113123708.png"></p><p>注解：在解法一的基础上加上了同步锁，使得在多线程的情况下可以用。</p><p>例如：当两个线程同时想创建实例，由于在一个时刻只有一个线程能得到同步锁，当第一个线程加上锁以后，第二个线程只能等待。</p><p>第一个线程发现实例没有创建，创建之。第一个线程释放同步锁，第二个线程才可以加上同步锁，执行下面的代码。由于第一个线程已经创建了实例，所以第二个线程不需要创建实例。保证在多线程的环境下也只有一个实例。</p><p>缺点：每次通过getInstance方法得到singleton实例的时候都有一个试图去获取同步锁的过程。<strong>而众所周知，加锁是很耗时的。能避免则避免。</strong></p><hr><h3 id="双重锁-Double-CheckLock-机制"><a href="#双重锁-Double-CheckLock-机制" class="headerlink" title="双重锁(Double CheckLock)机制"></a>双重锁(Double CheckLock)机制</h3><p>一方面需要在实例上加上<strong>volatile关键字</strong> 通知操作系统实现线程访问时<strong>内存屏障</strong>，然后还需要在方法中通过虚拟机实现的synchronized来同步方法访问，写法如下：<br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190113124128.png"></p><p>注解：只有当 singleton 为 null 时，需要获取同步锁，创建一次实例。当实例被创建，则无需试图加锁。</p><p>缺点：用 双重 if 判断，复杂，容易出错。</p><hr><h3 id="饿汉式（建议使用）"><a href="#饿汉式（建议使用）" class="headerlink" title="饿汉式（建议使用）"></a>饿汉式（建议使用）</h3><p>如果说我们不考虑服务负载问题，在多线程环境下可以<strong>预先加载类的静态实例</strong>，当虚拟机加载完成类后就会创建类的静态变量，甭管你到时用不用，反正给你留在那里。所有线程访问到的都是同一静态实例，有人也称这种方式为饿汉式，具体写法如下：<br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190113124637.png"></p><p>注解：初试化静态的 singleton 创建一次。如果我们在 Singleton类 里面写一个静态的方法不需要创建实例，它仍然会早早的创建一次实例。而降低内存的使用率。</p><p>缺点：没有 <strong>延迟加载</strong> 的效果，从而降低内存的使用率。</p><h3 id="静态内部内（建议使用）"><a href="#静态内部内（建议使用）" class="headerlink" title="静态内部内（建议使用）"></a>静态内部内（建议使用）</h3><p>上面写法实现单例也是没有问题的，但是有些同学就会觉得如果我只是想调用一个类的某个静态方法，并不想生成它的实例，那有没有其他方法呢，经过各路大神的指点结合自身的总结，可以使用内部静态类来实现这个需求。</p><p>开发的同学都知道，虚拟机在加载类的过程中一开始并不会初始化类的内部静态类。如果线程调用内部静态类时，虚拟机只会初始化一次，这样既可以实现单例，同时也是线程安全的。具体写法如下：<br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190113130451.png"></p><p>注解：定义一个私有的内部类，在第一次用这个嵌套类时，会创建一个实例。而类型为SingletonHolder的类，只有在Singleton.getInstance()中调用时，由于私有的属性，他人无法使用SingletonHolder，不调用Singleton.getInstance()就不会创建实例。</p><p>优点：达到了 <strong>延迟加载</strong> 的效果，即按需创建实例。</p><hr><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>除了以上讲到的几种方式外，JDK自身的枚举类型本身就是单例的实现，调用者不能显式的调用构造器完成实例创建，因此很多Java规范文档推荐使用枚举来实现单例。<br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20190113130413.png"></p><p>上面提到的四种实现多线程下单例的方式都有共同的缺点：</p><p>1）需要额外的工作来实现序列化，否则每次反序列化一个序列化的对象时都会创建一个新的实例。</p><p>2）可以使用反射强行调用私有构造器（如果要避免这种情况，可以修改构造器，让它在创建第二个实例的时候抛异常）</p><p>而枚举类很好的解决了这两个问题，使用枚举除了线程安全和防止反射调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。因此，《Effective Java》作者推荐使用的方法。不过，在实际工作中，很少看见有人这么写。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文总结了五种Java中实现单例的方法，其中懒汉式和饿汉式两种都不够完美，双重校验锁 和 静态内部类的方式可以解决大部分问题，平时工作中使用的最多的也是这两种方式。枚举方式虽然很完美的解决了各种问题，但是这种写法多少让人感觉有些生疏。</p><p>个人的建议是，在没有特殊需求的情况下，使用 <strong>双重校验锁</strong> 和 <strong>静态内部类</strong> 方式实现单例模式。</p>]]></content>
      
      
      <categories>
          
          <category> 单例 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 单例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker中的本地镜像发布到阿里云</title>
      <link href="/2019/01/12/docker-zhong-de-ben-di-jing-xiang-fa-bu-dao-a-li-yun/"/>
      <url>/2019/01/12/docker-zhong-de-ben-di-jing-xiang-fa-bu-dao-a-li-yun/</url>
      
        <content type="html"><![CDATA[<p>这篇主要来学习怎么将Docker中的本地镜像发布到阿里云上面。</p><h2 id="本地镜像发布到阿里云流程"><a href="#本地镜像发布到阿里云流程" class="headerlink" title="本地镜像发布到阿里云流程"></a>本地镜像发布到阿里云流程</h2><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112165829.png"></p><h2 id="镜像的生成方法"><a href="#镜像的生成方法" class="headerlink" title="镜像的生成方法"></a>镜像的生成方法</h2><h3 id="使用Dockerfile文件生成"><a href="#使用Dockerfile文件生成" class="headerlink" title="使用Dockerfile文件生成"></a>使用Dockerfile文件生成</h3><p><code>docker build -f Dockerfile路径 -t 镜像名:TAG</code> 指令来生成，参考Dockerfile文件解析那篇文章。</p><h3 id="从已有的容器中创建一个新的镜像"><a href="#从已有的容器中创建一个新的镜像" class="headerlink" title="从已有的容器中创建一个新的镜像"></a>从已有的容器中创建一个新的镜像</h3><p><code>docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]]</code></p><pre><code>OPTIONS说明：-a :提交的镜像作者；-m :提交时的说明文字；</code></pre><p>这里，我使用mycentos:1.3为例，来生成 mycentos:1.4镜像：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112170636.png"></p><p>首先启动 mycentos:1.3 容器：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112170847.png"></p><p>接下来，生成 mycentos:1.4 镜像：</p><p><code>docker commit -a gakki -m &#39;gakki commit mycentos:1.4&#39; mycentos:1.3的容器ID mycentos:1.4</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112171218.png"></p><hr><h2 id="将本地镜像推送到阿里云"><a href="#将本地镜像推送到阿里云" class="headerlink" title="将本地镜像推送到阿里云"></a>将本地镜像推送到阿里云</h2><h3 id="本地要推送的镜像素材"><a href="#本地要推送的镜像素材" class="headerlink" title="本地要推送的镜像素材"></a>本地要推送的镜像素材</h3><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112171359.png"></p><h3 id="进入阿里云开发者平台"><a href="#进入阿里云开发者平台" class="headerlink" title="进入阿里云开发者平台"></a>进入阿里云开发者平台</h3><p><code>https://dev.aliyun.com/search.html</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112171634.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112171805.png"></p><h3 id="创建仓库镜像"><a href="#创建仓库镜像" class="headerlink" title="创建仓库镜像"></a>创建仓库镜像</h3><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112172159.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112172330.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112172701.png"></p><h3 id="将本地镜像推送到阿里云-1"><a href="#将本地镜像推送到阿里云-1" class="headerlink" title="将本地镜像推送到阿里云"></a>将本地镜像推送到阿里云</h3><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112172831.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112172921.png"></p><pre><code>$ sudo docker login --username=liuzhuo19940206 registry.cn-hangzhou.aliyuncs.com$ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/gakkij/mycentos:[镜像版本号]$ sudo docker push registry.cn-hangzhou.aliyuncs.com/gakkij/mycentos:[镜像版本号]如果你是 root，就不需要加上sudo。上面是我的账号，如果是你的话，请改成你的账号，即：拷贝阿里云上面的关键步骤</code></pre><p>第一步：登入<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112173427.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112173632.png"></p><p>第二步：设置镜像的版本号<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112173913.png"></p><p>第三步：推送<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112174050.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112174317.png"></p><h3 id="在阿里云的公有云可以查到"><a href="#在阿里云的公有云可以查到" class="headerlink" title="在阿里云的公有云可以查到"></a>在阿里云的公有云可以查到</h3><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112174617.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112174741.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112174811.png"></p><h3 id="将阿里云上的镜像下载到本地"><a href="#将阿里云上的镜像下载到本地" class="headerlink" title="将阿里云上的镜像下载到本地"></a>将阿里云上的镜像下载到本地</h3><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112175134.png"></p><pre><code>拼接起来如下：docker pull registry.cn-hangzhou.aliyuncs.com/gakkij/mycentos:1.4.1</code></pre><p>首先删除本地的mycentos:1.4.1的镜像：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112175450.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112175634.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112175722.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day08/QQ截图20190112175847.png"></p><hr><p>以上，就是今天所有的内容了，相信大家已经学会了，从本地上传镜像到阿里云，也会从阿里云上拉取镜像了。爱生活，爱技术，我是gakkij酱。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker中的常用安装</title>
      <link href="/2019/01/12/docker-zhong-de-chang-yong-an-zhuang/"/>
      <url>/2019/01/12/docker-zhong-de-chang-yong-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>今天，主要来介绍Docker中的常用安装，希望大家学习完毕后，可以举一反三。</p><h2 id="总体步骤"><a href="#总体步骤" class="headerlink" title="总体步骤"></a>总体步骤</h2><ul><li><p>搜索镜像：docker search 镜像名</p></li><li><p>拉取镜像：docker pull 镜像名:TAG</p></li><li><p>查看镜像：docker images 镜像名</p></li><li><p>启动镜像：docker run 镜像名</p></li><li><p>停止容器：docker stop 容器ID</p></li><li><p>移除容器：docker rm 容器ID</p></li></ul><hr><h2 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h2><p>1.docker hub 上面查找tomcat镜像 或者 docker search tomcat<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112143621.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112143711.png"></p><p>2.从docker hub上面拉取tomcat镜像到本地</p><p><code>docker pull tomcat</code></p><p>官网命令：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112143916.png"></p><p>拉取完成：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112144007.png"></p><p>3.docker images 查看是否有拉取到的tomcat<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112144124.png"></p><p>4.使用tomcat镜像启动容器</p><p><code>docker run -it -p 8080:8080 tomcat</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112144307.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112144405.png"></p><hr><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>1.从docker hub上面搜索mysql镜像<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112144556.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112144632.png"></p><p>2.从docker hub上拉取mysql镜像到本地，标签为：5.6</p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112145414.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112145518.png"></p><p>3.启动mysql镜像</p><pre><code>docker run -p 3306:3306 --name mysql -v /gakki/mysql/conf:/etc/mysql/conf.d -v /gakki/mysql/logs:/logs -v /gakki/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6拆开：docker run -p 3306:3306 --name mysql -v /gakki/mysql/conf:/etc/mysql/conf.d -v /gakki/mysql/logs:/logs -v /gakki/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456-d mysql:5.6命令说明：-p 3306:3306：将主机的3306端口映射到docker容器的3306端口。--name mysql：运行服务名字-v /gakki/mysql/conf:/etc/mysql/conf.d ：将主机/gakki/mysql目录下的conf目录 挂载到容器的 /etc/mysql/conf.d-v /gakki/mysql/logs:/logs：将主机/gakki/mysql目录下的 logs 目录挂载到容器的 /logs。-v /gakki/mysql/data:/var/lib/mysql ：将主机/gakki/mysql目录下的data目录挂载到容器的 /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。-d mysql:5.6 : 后台程序运行mysql5.6docker run -p 3306:3306 --name mysql -v /gakki/mysql/conf:/etc/mysql/conf.d -v /gakki/mysql/logs:/logs -v /gakki/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112150227.png"></p><p>4.进入启动后的mysql容器内：</p><p><code>docker exec -it MySQL运行成功后的容器ID /bin/bash</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112150441.png"></p><p>进入容器中的mysql服务内：</p><p><code>mysql -uroot -p</code></p><p><code>Enter password: 输入你的mysql密码</code></p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112150631.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112150933.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112151207.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112151353.png"></p><p>5.使用我们的windows机来验证这个mysql是否成功：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112151634.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112151745.png"></p><p>现在，在windows上面插入数据，在docker容器检查：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112151908.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112152012.png"></p><hr><p>5.备份数据</p><p><code>docker exec myql服务容器ID sh -c &#39;exec mysqldump --all-databases -uroot -p&quot;123456&quot;&#39; &gt; /gakki/all-databases.sql</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112152311.png"></p><p>然后，我们就可以使用这个备份文件来恢复数据，或者在其他机器上执行。</p><h2 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h2><p>1.从docker hub上搜索redis镜像<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112152715.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112152740.png"></p><p>2.拉取redis镜像，标签为：3.2<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112153022.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112153127.png"></p><p>3.使用redis:3.2生成容器</p><pre><code>docker run -p 6379:6379 --name myredis -v /gakki/myredis/data:/data -v /gakki/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis:3.2 redis-server /usr/local/etc/redis/redis.conf --appendonly yes拆开：docker run -p 6379:6379 --name myredis -v /gakki/myredis/data:/data-v /gakki/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf-d redis:3.2 redis-server /usr/local/etc/redis/redis.conf--appendonly yes</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112153817.png"></p><p>4.在宿主机的：/gakki/myredis/conf/redis.conf目录下：新建redis.conf文件</p><p><code>vim /gakki/myredis/conf/redis.conf/redis.conf</code></p><p>redis.conf内容：</p><pre><code>就是标准的redis.conf的内容，这里就不演示了，因为文件内容比较多。主要是：关闭 bind 主机的功能：# bind 127.0.0.1</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112154401.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112154536.png"></p><p>5.使用redis-cli来测试：</p><p><code>docker exec -it 运行着Redis服务的容器ID redis-cli</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112154823.png"></p><p>6.测试持久化文件<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day07/QQ截图20190112155035.png"></p><hr><p>我相信大家对这三个常用的软件安装熟悉后，对于其他的软件安装应该也就没有问题了。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker中的Dockerfile解析</title>
      <link href="/2019/01/11/docker-zhong-de-dockerfile-jie-xi/"/>
      <url>/2019/01/11/docker-zhong-de-dockerfile-jie-xi/</url>
      
        <content type="html"><![CDATA[<p>这篇专门来讲解Docker中比较重要的DockerFile文件</p><h2 id="DockerFile是什么"><a href="#DockerFile是什么" class="headerlink" title="DockerFile是什么"></a>DockerFile是什么</h2><p>Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p><p>构建三步骤：</p><ul><li><p>编写Dockerfile文件</p></li><li><p>docker build</p></li><li><p>docker run</p></li></ul><p>Dockerfile文件是什么样呢？</p><p>以我们熟悉的CentOS为例：</p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111192141.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111192322.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111192232.png"></p><hr><h2 id="DockerFile构建过程解析"><a href="#DockerFile构建过程解析" class="headerlink" title="DockerFile构建过程解析"></a>DockerFile构建过程解析</h2><h3 id="Dockerfile内容基础知识"><a href="#Dockerfile内容基础知识" class="headerlink" title="Dockerfile内容基础知识"></a>Dockerfile内容基础知识</h3><p>1：每条保留字指令都必须为大写字母且后面要跟随至少一个参数</p><p>2：指令按照从上到下，顺序执行</p><p>3：#表示注释</p><p>4：每条指令都会创建一个新的镜像层，并对镜像进行提交</p><h3 id="Docker执行Dockerfile的流程"><a href="#Docker执行Dockerfile的流程" class="headerlink" title="Docker执行Dockerfile的流程"></a>Docker执行Dockerfile的流程</h3><p>（1）docker从基础镜像运行一个容器</p><p>（2）执行一条指令并对容器作出修改</p><p>（3）执行类似docker commit的操作提交一个新的镜像层</p><p>（4）docker再基于刚提交的镜像运行一个新容器</p><p>（5）执行dockerfile中的下一条指令直到所有指令都执行完成</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段：</p><ul><li><p>Dockerfile是软件的原材料</p></li><li><p>Docker镜像是软件的交付品</p></li><li><p>Docker容器则可以认为是软件的运行态。</p></li></ul><p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111192957.png"></p><ol><li><p>Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</p></li><li><p>Docker镜像，在用Dockerfile定义一个文件之后，docker build 时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;</p></li><li><p>Docker容器，容器是直接提供服务的。</p></li></ol><h2 id="DockerFile体系结构-保留字指令"><a href="#DockerFile体系结构-保留字指令" class="headerlink" title="DockerFile体系结构(保留字指令)"></a>DockerFile体系结构(保留字指令)</h2><pre><code>FROM:         基础镜像，当前新镜像是基于哪个镜像的MAINTAINER:   镜像维护者的姓名和邮箱地址RUN:          容器构建时需要运行的linux命令EXPOSE:       当前容器对外暴露出的端口------------------------------------------------------ENV:          用来在构建镜像过程中设置环境变量ENV MY_PATH /usr/mytest这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；也可以在其它指令中直接使用这些环境变量，比如：WORKDIR $MY_PATH------------------------------------------------------WORKDIR:      指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点ADD:          将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包COPY:         类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置.VOLUME:       容器数据卷，用于数据保存和持久化工作。-------------------------------------------------------CMD:          指定一个容器启动时要运行的命令,Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换.CMD指令的格式与RUN相似，也是两种格式：shell 格式：CMD &lt;命令&gt;exec 格式：CMD [&quot;可执行文件&quot;,&quot;参数1&quot;,&quot;参数2&quot;,···]参数列表格式：CMD [&quot;参数1&quot;,&quot;参数2&quot;,···]。在指定了 ENTRYPOINT 指令后，可以用 CMD 指定具体的参数。--------------------------------------------------------ENTRYPOINT：  指定一个容器启动时要运行的命令，ENTRYPOINT 的目的 和 CMD 一样，都是在指定容器启动程序及参数，但是它是叠加命令，不是覆盖命令。ONBUILD：     当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</code></pre><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111194330.png"></p><hr><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="Base镜像-scratch"><a href="#Base镜像-scratch" class="headerlink" title="Base镜像(scratch)"></a>Base镜像(scratch)</h3><p>Docker Hub 中 99% 的镜像都是 通过在 base 镜像中安装和配置需要的软件构建出来的。<code>scratch</code> 就是最基础的镜像，和 java中对象默认继承Object对象一样。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111194719.png"></p><h3 id="自定义镜像mycentos"><a href="#自定义镜像mycentos" class="headerlink" title="自定义镜像mycentos"></a>自定义镜像mycentos</h3><h4 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h4><p>1.默认的centos镜像是什么情况呢？<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111195155.png"></p><p>现在：我们想创建自己的mycentos镜像，修改登入后的工作目录，支持vim编辑器，支持ifconfig网络配置。</p><p>2.编写dockerfile文件</p><p>由于之前，我们在mydocker文件下，写过Dockerfile文件，所以接着在里面写了，你们如果没有，就在根目录下创建即可，随意。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111195627.png"></p><p>Dockerfile文件中的内容：</p><pre><code>FROM centos                               #继承centos镜像MAINTAINER gakki&lt;gakki167@126.com&gt;        #填写作者与邮箱地址ENV mypath /usr/local                     #编写环境变量，方便后续使用WORKDIR $mypath                           #修改登入后的工作目录RUN yum -y install vim                    #使用RUN命令，下载vim编辑RUN yum -y install net-tools              #使用RUN命令，下载网络配置工具EXPOSE 80                                 #暴露端口号为80CMD echo $mypath                          #为了测试，随便写的，不写也行CMD echo &quot;success--------------ok&quot;        #为了测试，随便写的，不写也行CMD /bin/bash                             #启动容器，执行/bin/bash命令</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111200217.png"></p><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p><code>docker build -f Dockerfile文件的路径 -t 新镜像名字:TAG .</code>  注意最后有一个点,  . 表示当前目录</p><p>如果当前目录下，存在Dockerfile文件话，而且就是<code>Dockerfile</code>这个名字，那么可以不写 <code>-f Dockerfile的路径</code></p><pre><code>docker build -t mycentos:1.3 .</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111200803.png"></p><p>然后开始一顿哗啦啦的代码，因为要下载 vim 和 net-tools。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111200933.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111201130.png"></p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p><code>docker run -it 新镜像名:TAG</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111201358.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111201459.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111201548.png"></p><h4 id="列出镜像的变更历史"><a href="#列出镜像的变更历史" class="headerlink" title="列出镜像的变更历史"></a>列出镜像的变更历史</h4><p><code>docker history 镜像名</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111201937.png"></p><h3 id="CMD-ENTRYPOINT-镜像案例"><a href="#CMD-ENTRYPOINT-镜像案例" class="headerlink" title="CMD/ENTRYPOINT 镜像案例"></a>CMD/ENTRYPOINT 镜像案例</h3><p>为了区分 CMD 与 ENTRYPOINT 命令的区别，而做了案例。</p><p>两者都是：指定一个容器启动时要运行的命令。</p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>采用 CMD 的话，当Dockerfile 中有多个 CMD 指令时，只能最后一个生效。而且 CMD 会被 docker run 之后的参数替换。</p><pre><code>比如，当Dockerfile文件中的最后是:CMD [&quot;/bin/bash&quot;]CMD [&quot;ls&quot;,&quot;-l&quot;]那么，只会执行 ls -l 命令，不会执行/bin/bash 命令。当使用 docker run -it 镜像名 ls -l ： 启动容器也是一样的效果，这里的ls -l 会覆盖掉Dockerfile文件中的：CMD [&quot;/bin/bash&quot;]</code></pre><p>这里，我以tomcat为例来演示：</p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111202901.png"></p><p>如果不加 ls -l ，就会执行默认的 CMD [“catalina.sh”, “run”] （上图写错了）<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111203033.png"></p><hr><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合，不会覆盖之前的命令。</p><p>制作CMD版可以查询IP信息的容器：</p><p>在mydocker文件夹下，创建Dockerfile2文件：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111203430.png"></p><p>Dockerfile2文件内容：</p><pre><code>FROM centosRUN yum install -y curlCMD [&quot;curl&quot;, &quot;-s&quot;, &quot;www.baidu.com&quot;]</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111204426.png"></p><p>生成 myip镜像：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111203855.png"></p><p>运行 myip镜像：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111204646.png"></p><p>那是因为，我们生成myip的镜像的Dockerfile文件，最后执行了：<code>CMD [&quot;curl&quot;, &quot;-s&quot;, &quot;www.baidu.com&quot;]。</code></p><p>如果，我们想要获取抓包过程中的头部信息，还需要加上 -i 。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111204950.png"></p><p>现在，我在启动myip的过程中 加上 -i：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111205157.png"></p><p>因为，我们使用的是CMD，不是ENTRYPOINT，所以，在docker run 后面的参数，会直接覆盖Dockerfile中的<code>CMD [&quot;curl&quot;, &quot;-s&quot;, &quot;www.baidu.com&quot;]</code>，相当于现在变成了<code>CMD [&quot;-i&quot;]</code> ，这个当然报错呀，都不知道是什么玩意！！！</p><hr><p>现在，在mydocker文件夹下，创建Dockerfile3：</p><pre><code>FROM centosRUN yum install -y curlENTRYPOINT [&quot;curl&quot;, &quot;-s&quot;, &quot;www.baidu.com&quot;]</code></pre><p>唯一的区别就是：将CMD 换成了 ENTRYPOINT 。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111205600.png"></p><p>生成新的镜像：myip2<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111205729.png"></p><p>启动 myip2 容器：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111205905.png"></p><p>到目前为止，都和CMD一样。现在 再次启动 myip2 还面带上 -i 参数：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111210120.png"></p><p>发现，没有报错，返回了 头部信息 和 主体信息。</p><p>以上：就是 CMD 和 ENTRYPOINT 的区别！！！</p><h4 id="CURL"><a href="#CURL" class="headerlink" title="CURL"></a>CURL</h4><p>考虑到大家有可能对 curl 不熟，这里简单介绍一下：</p><p>curl命令可以用来执行 下载、发送各种HTTP请求，指定HTTP头部等操作。</p><p>如果系统没有curl可以使用 yum install curl安装，也可以下载安装。</p><p><code>curl是将下载文件输出到stdout</code></p><pre><code>使用命令：curl http://www.baidu.com执行后，www.baidu.com的html就会显示在屏幕上了这是最简单的使用方法。用这个命令获得了http://curl.haxx.se指向的页面同样，如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。如果下载的是HTML文档，那么缺省的将只显示文件头部，即HTML文档的header。要全部显示，请加参数 -i</code></pre><hr><h3 id="自定义镜像Tomcat9"><a href="#自定义镜像Tomcat9" class="headerlink" title="自定义镜像Tomcat9"></a>自定义镜像Tomcat9</h3><h4 id="创建一个目录来编写Dockerfile文件"><a href="#创建一个目录来编写Dockerfile文件" class="headerlink" title="创建一个目录来编写Dockerfile文件"></a>创建一个目录来编写Dockerfile文件</h4><p><code>mkdir -p /gakki/mydocker/tomcat9</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111210844.png"></p><h4 id="在上述目录下创建c-txt"><a href="#在上述目录下创建c-txt" class="headerlink" title="在上述目录下创建c.txt"></a>在上述目录下创建c.txt</h4><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190111211019.png"></p><p>创建c.txt，主要是为了使用：COPY命令来玩的，没有什么作用意义。</p><h4 id="将jdk和tomcat安装的压缩包拷贝进上一步目录"><a href="#将jdk和tomcat安装的压缩包拷贝进上一步目录" class="headerlink" title="将jdk和tomcat安装的压缩包拷贝进上一步目录"></a>将jdk和tomcat安装的压缩包拷贝进上一步目录</h4><p>在我的centos中，已经下载过 jdk 和 tocmat 的压缩包，如果大家没有，请自行下载，自学，比较简单。</p><p><code>cp /usr/local/src/apache-tomcat-8.5.37.tar.gz ./</code></p><p><code>cp /usr/local/src/jdk-8u191-linux-x64.tar.gz ./</code></p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112105516.png"></p><h4 id="在当前目录下创建Dockerfile文件"><a href="#在当前目录下创建Dockerfile文件" class="headerlink" title="在当前目录下创建Dockerfile文件"></a>在当前目录下创建Dockerfile文件</h4><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112105740.png"></p><p>Dockerfile文件内容：</p><pre><code>#基于centos镜像FROM centos#作者以及邮箱MAINTAINER gakki&lt;gakkij@126.com&gt;#把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下COPY c.txt /usr/local/copycontainer.txt#把java与tomcat添加到容器中ADD jdk-8u191-linux-x64.tar.gz /usr/local/ADD apache-tomcat-8.5.37.tar.gz /usr/local/#安装vim编辑器RUN yum -y install vim#设置工作访问时候的WORKDIR路径，登录落脚点ENV MYPATH /usr/localWORKDIR $MYPATH#配置java与tomcat环境变量ENV JAVA_HOME /usr/local/jdk1.8.0_191ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-8.5.37ENV CATALINA_BASE /usr/local/apache-tomcat-8.5.37ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin#容器运行时监听的端口EXPOSE  8080#启动时运行tomcat# ENTRYPOINT [&quot;/usr/local/apache-tomcat-8.5.37/bin/startup.sh&quot; ]# CMD [&quot;/usr/local/apache-tomcat-8.5.37/bin/catalina.sh&quot;,&quot;run&quot;]CMD /usr/local/apache-tomcat-8.5.37/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-8.5.37/bin/logs/catalina.out</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112110723.png"></p><p><strong>注意：</strong>上面的 jdk 和 tomcat 填写成你的机器上面的 jdk 和 tomcat 的版本，不要和我一样，除非你下载的jdk和tomcat的版本和我一样！！！</p><h4 id="构建-1"><a href="#构建-1" class="headerlink" title="构建"></a>构建</h4><p><code>docker build -t gakkitomcat9 .</code></p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112111444.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112111531.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112111623.png"></p><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><pre><code>docker run -d -p 9080:8080 --name myt9 -v /gakki/mydocker/tomcat9/app:/usr/local/apache-tomcat-8.5.37/webapps/app -v /gakki/mydocker/tomcat9/tomcat9logs/:/usr/local/apache-tomcat-8.5.37/logs --privileged=true gakkitomcat9解释：上面创建了两个数据卷，一个用来创建app来与gakkitomcat9共享，放置网站用的，这样的话，我们直接就可以在宿主机上操作网站中的内容了另一个数据卷是用来存放gakkitomcat9容器启动后的日志信息。</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112112223.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112112335.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112112437.png"></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112112648.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112112801.png"></p><h4 id="发布webapp"><a href="#发布webapp" class="headerlink" title="发布webapp"></a>发布webapp</h4><p>在我们的宿主机的app目录下(数据卷目录)，创建webapp的标准目录结构：</p><pre><code>app---a.jsp---WEB-INF------web.xmlapp目录下：有a.jsp文件 和 WEB-INF目录WEB-INF目录下：有web.xml文件</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112113341.png"></p><p>web.xml中的内容：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;  xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;  id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;  &lt;display-name&gt;myApp&lt;/display-name&gt;&lt;/web-app&gt;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112113625.png"></p><p>a.jsp中的内容：</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    -----------welcome------------    &lt;%=&quot;i am in docker tomcat self &quot;%&gt;    &lt;br&gt;    &lt;br&gt;    &lt;% System.out.println(&quot;=============docker tomcat self&quot;);%&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112113715.png"></p><p>测试：</p><p>在浏览器中输入：<code>localhost:9080/app/a.jsp</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112113853.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112113939.png"></p><hr><p>现在，我们稍微修改一下，a.jsp中的内容：</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    -----------welcome------------&lt;br&gt;    &lt;%=&quot;i am update in docker tomcat self &quot;%&gt;    &lt;br&gt;    &lt;br&gt;    &lt;% System.out.println(&quot;=============docker tomcat self&quot;);%&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>就是在：welcome后面加了换行，修改了输出语句加了：update。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112114252.png"></p><p>现在，来查看日志信息：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112115253.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112115340.png"></p><p>现在稍微明白容器数据卷的作用的吧，以后我们只需要在宿主机中的 app目录下修改、添加内容，docker容器中就会同步数据，方便开发和查看日志信息。</p><hr><p>现在，我们进入gakkitomcat9中，验证：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112115727.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112120945.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112121214.png"></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day06/QQ截图20190112121346.png"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker中的容器数据卷</title>
      <link href="/2019/01/10/docker-zhong-de-rong-qi-shu-ju-juan/"/>
      <url>/2019/01/10/docker-zhong-de-rong-qi-shu-ju-juan/</url>
      
        <content type="html"><![CDATA[<p>Docker中的容器数据卷，我们知道redis是一个内存数据库，为啥，退出后，下次重启后，数据库中还有之前的数据呢？因为有rdb和aof持久化。<br>因此，Docker中的容器数据卷，也是为了将容器中的数据，保存到宿主机中的技术，防止容器停止后，数据丢失。</p><h2 id="数据卷是什么"><a href="#数据卷是什么" class="headerlink" title="数据卷是什么"></a>数据卷是什么</h2><p>先来看看Docker的理念：</p><ul><li><p>将应用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望是持久化的</p></li><li><p>容器之间希望有可能共享数据</p></li></ul><p>Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了。</p><p>为了能保存在docker中的数据，我们使用卷。</p><h2 id="数据卷能干嘛"><a href="#数据卷能干嘛" class="headerlink" title="数据卷能干嘛"></a>数据卷能干嘛</h2><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性。</p><p>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><p>特点：</p><p>1：数据卷可在容器之间共享或重用数据<br>2：卷中的更改可以直接生效<br>3：数据卷中的更改不会包含在镜像的更新中<br>4：数据卷的生命周期一直持续到没有容器使用它为止</p><h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><p>容器内添加，有两种方式：</p><ul><li><p>直接命令添加</p></li><li><p>DockerFile添加</p></li></ul><h3 id="直接命令添加"><a href="#直接命令添加" class="headerlink" title="直接命令添加"></a>直接命令添加</h3><p><strong><code>docker run -it -v /宿主机绝对路径目录:/容器内目录   镜像名</code></strong></p><pre><code>这里主要就是添加了一个 -v 的选项参数。</code></pre><p>现在，我们来正式演示一遍：</p><p><strong>在宿主机的根目录下创建：mydataVolume目录。</strong></p><p>然后使用：<code>docker run -it -v /mydataVolume:/dataVolumeContainer centos /bin/bash</code> 将两者挂载在一起，实现数据共享。</p><p>该命令会帮我们以交换式的方式启动centos容器，然后会自动帮我们在centos的根目录下创建：dataVolumeContainer目录。</p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111112831.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111113633.png"></p><p><strong>查看数据卷是否挂载成功：</strong></p><p><code>docker inspect 容器ID</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111113940.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111114243.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111114421.png"></p><p>出现上面的信息，说明挂载数据卷成功。</p><hr><p><strong>宿主机与容器之间数据共享：</strong></p><p>在宿主机中的：mydataVolume目录下：创建一个host.txt文件，随便编写一些数据。</p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111114942.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111115028.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111115109.png"></p><p>在centos容器中，查看：dataVolumeContainer目录下，是否存在host.txt，并且里面有数据：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111115709.png"></p><p>瞬间懵逼了，后来发现：我是宿主机的root目录下创建的：mydataVolume，然后在该目录下创建的host.txt文件，当然是无法共享的呀。</p><p>因为，<code>docker run -it -v /mydataVolume:/dataVolumeContainer centos /bin/bash</code> <strong>是宿主机的根目录下创建：mydataVolume ！！！！</strong></p><p>现在，在宿主机下，切换到根目录下，发现mydataVolume目录已经存在了，说明执行了：<code>docker run -it -v /mydataVolume:/dataVolumeContainer centos /bin/bash</code> 命令后，会自动帮我们创建这两个共享的目录。</p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111120217.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111120316.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111120500.png"></p><p>那，在容器下，创建新的文件，修改旧的文件，在宿主机中能更新吗？ 能，数据卷是互相共享的。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111120811.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111120941.png"></p><hr><p><strong>那么，容器退出后，在宿主机中修改数据，等到原来的容器再次启动时，数据是否会同步呢？</strong><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111121222.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111121327.png"></p><p>接着，在宿主机中，修改host.txt文件中的内容：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111121514.png"></p><p>启动，<strong>原先的</strong>centos容器：</p><p><code>docker start 容器的ID</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111121959.png"></p><p>进入centos容器内部：</p><p><code>docker attach 容器ID</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111122237.png"></p><p>上面就是，宿主机与容器之间的数据卷共享，可读可写。</p><hr><p><strong>那么，可不可以，只能宿主机可读可写，而容器只读呢？ 可以的。</strong></p><p><code>docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</code></p><p>请看，上面命令，只是下后面加了一个 <code>:ro</code> , ro : readonly的意思，只读。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111122815.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111123127.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111123217.png"></p><p>使用 <code>docker inspect 容器ID</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111123350.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111123441.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111123526.png"></p><hr><h3 id="使用DockerFile添加"><a href="#使用DockerFile添加" class="headerlink" title="使用DockerFile添加"></a>使用DockerFile添加</h3><p>这里，不会讲太多的DockerFile的知识，只是简单带大家了解一下，使用DockerFile来数据共享，下篇文章，我会继续带大家进行DockerFile的探索。</p><p><strong>第一步：在宿主机的根目录下，创建mydocker文件夹并进入：</strong><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111135831.png"></p><p>可在 Dockerfile中 使用 <strong>VOLUME指令</strong> 来给镜像添加一个或多个数据卷。</p><p><code>VOLUME[&quot;/dataVolumeContainer&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumeContainer3&quot;]</code></p><p>说明：</p><p>出于 <strong>可移植</strong> 和 <strong>分享</strong> 的考虑，用 -v <strong>主机目录:容器目录</strong> 这种方法不能够直接在Dockerfile中实现。</p><p>由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。</p><p>所以，使用DockerFile来进行数据卷的共享时，不需要创建宿主机的共享目录，只需要确定容器内的共享目录即可，这是与使用 -v 命令的区别所在。</p><p>那么，什么是DockerFile文件呢？ 这里还是带大家简单了解一下：</p><p>打开docker hub的官网，随便搜索一个镜像，比如tomcat：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111141044.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111141140.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111141243.png"></p><p>简单来看一下：最上面是基于jdk1.8的镜像来生成tomcat镜像的，所以tomcat镜像文件才几百兆，不想在windows中下在一个tomcat几十兆那么小，因为tomcat镜像中包括了jdk的运行环境等，所以比较大。</p><pre><code>EVN :  配置环境变量的EXPOSE 8080   ：配置暴露的端口号CMD [&quot;catalina.sh&quot;, &quot;run&quot;]  ：运行镜像最外层的可写的那层</code></pre><p>使用Dockerfile来数据卷的共享，就是编写一个Dockerfile文件，然后使用这个Dockerfile来生成新的镜像。这里只是简单了解一下。</p><p><strong>第二步，在mydocker文件夹下，编写dockerfile文件：</strong><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111141828.png"></p><p>在dockerfile中：</p><pre><code># volume testFROM centos                                               #相当于继承centos镜像VOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;]  #配置数据卷容器内的目录，可以是多个CMD echo &quot;finished,--------success1&quot;                      #CMD执行命令，这里是简单测试语句CMD /bin/bash                                             #执行 /bin/bash 命令，进入终端</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111142130.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111142226.png"></p><p><strong>第三步，build我们的dockerfile文件，生成镜像</strong></p><p><code>docker build -f /mydocker/dockerfile -t liuzhuo/centos .</code></p><pre><code>-f：     dockerfile文件的路径-t：     命名空间/镜像名称注意：最后有一个 空格 + 点</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111142918.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111143207.png"></p><p><strong>第四步，查看有没有生成新的镜像</strong><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111143325.png"></p><p><strong>第五步，启动新的镜像</strong><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111143523.png"></p><p><strong>通过上述步骤，容器内的卷目录地址已经知道，对应的主机目录地址哪？？</strong></p><p>使用 <code>docker inspect 容器id</code> 来查看宿主机的目录地址：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111143950.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111144227.png"></p><p>这里，我就使用 <strong>/dataVolumeContainer1</strong> 对应的宿主机的地址来演示了</p><pre><code>/var/lib/docker/volumes/ef6a4b962d138913b14a43750d12c1a553c2837c34481ff732796e79e62203b3/_data</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111144408.png"></p><p>创建新的文件，container.txt<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111144609.png"></p><p>然后在，容器中查看是否有：container.txt<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111144609.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111144738.png"></p><hr><p><strong>备注:</strong></p><p>Docker挂载主机目录Docker访问出现 cannot open directory . : Permission denied</p><p><strong>解决办法：在挂载目录后多加一个 –privileged=true 参数即可。</strong></p><p>即：<code>docker run -it -v /mydataVolume:/dataVolumeContainer --privileged=true centos /bin/bash</code></p><p>一般情况下，是不会出现这样的问题的。</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><h3 id="数据卷容器是什么"><a href="#数据卷容器是什么" class="headerlink" title="数据卷容器是什么"></a>数据卷容器是什么</h3><p>命名的容器 挂载 数据卷后，<strong>其它容器</strong> 通过 挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器。</p><h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h3><p>使用上面的：liuzhuo/centos 为模板，运行三个容器：doc01、doc02、doc03。</p><p>它们三个容器本身都具有两个容器卷：<code>/dataVolumeContainer1</code> 和 <code>/dataVolumeContainer2</code></p><h3 id="容器间传递共享"><a href="#容器间传递共享" class="headerlink" title="容器间传递共享"></a>容器间传递共享</h3><p><strong>1.先启动一个父容器doc01</strong></p><p><code>docker run -it --name doc01 liuzhuo/centos</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111145928.png"></p><p>在 /dataVolumeContainer2 中：添加新的文件：doc01.txt<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111150102.png"></p><p><strong>2.将doc02、doc03容器都继承自doc01</strong></p><p><code>docker run -it --name doc02 --volumes-from doc01 liuzhuo/centos</code></p><pre><code>--volumes-from  :  继承自哪个容器</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111150614.png"></p><p>查看：/dataVolumeContainer2 目录：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111150750.png"></p><p>在doc02中的 /dataVolumeContainer2 目录下：创建新的文件：doc02.txt<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111150908.png"></p><p>接着：<code>docker run -it --name doc03 --volumes-from doc01 liuzhuo/centos</code></p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111151244.png"></p><p>查看：/dataVolumeContainer2 目录：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111151340.png"></p><p>在doc03中的 /dataVolumeContainer2 目录下：创建新的文件：doc03.txt<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111151826.png"></p><p>大家到此，有没有觉得疑惑呢？ 明明doc03 只是继承 doc01 ，为啥连doc02的文件也共享了呢？这就是docker强大之处，其实就像一个网状结构一样，doc03 继承 doc01，而 doc01 与 doc02 互通，所以 doc02 与 doc03 也就互通了。</p><hr><p><strong>回到doc01，可以看到doc02、doc03创建的文件</strong><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111151937.png"></p><p><strong>删除doc01，doc02修改doc02.txt文件，doc03中能检查到文件发生改变</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111152312.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111152540.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111152655.png"></p><p>验证了，虽然 doc03 继承与 doc01 ，现在将 doc01 停止了，但是还能与 doc02 互通。（网状结构）</p><p><strong>删除doc02后，doc03能否访问</strong><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111153020.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111153116.png"></p><p>现在，在doc03中，再添加一个新的文件：doc03_update.txt<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111153248.png"></p><p><strong>新建doc04容器，删除doc03容器</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111153938.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111154035.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111154132.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day05/QQ截图20190111154226.png"></p><hr><p><strong>结论：</strong></p><p><strong><font color="red">容器之间 配置信息的传递，数据卷的生命周期 一直持续到 没有容器使用它为止。</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的镜像原理</title>
      <link href="/2019/01/10/docker-de-jing-xiang-yuan-li/"/>
      <url>/2019/01/10/docker-de-jing-xiang-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>今天来学习docker中镜像原理，以及相关的commit命令。</p><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><p>镜像是一种轻量级、可执行的独立软件包，<font color="red">用来打包软件运行环境和基于运行环境开发的软件</font>，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><h3 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h3><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。<strong>镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</strong></p><p><strong>特性</strong>：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h3 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h3><font color="red">Docker镜像加载原理：</font><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p><font color="blue">平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？</font><p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p><h3 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h3><p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110160603.png"></p><h3 id="为什么Docker镜像要采用这种分层结构呢"><a href="#为什么Docker镜像要采用这种分层结构呢" class="headerlink" title="为什么Docker镜像要采用这种分层结构呢"></a>为什么Docker镜像要采用这种分层结构呢</h3><p>最大的一个好处就是 - 共享资源</p><p>比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像</p><p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><h2 id="镜像的特点"><a href="#镜像的特点" class="headerlink" title="镜像的特点"></a>镜像的特点</h2><ul><li><p>docker镜像都是<strong>只读的</strong>。</p></li><li><p>当容器启动时，一个新的<strong>可写层</strong>被加载到镜像的<strong>顶部</strong>。</p></li><li><p>这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p></li></ul><h2 id="镜像的提交"><a href="#镜像的提交" class="headerlink" title="镜像的提交"></a>镜像的提交</h2><p>我们能不能提交自己的镜像呢？ 然后根据自己的镜像生成相应的容器呢？</p><p>答案：当然是可以的撒，不然的话，docker将无法适应开发者多变的需要。</p><h3 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h3><p><code>docker commit</code>: 提交容器副本使之成为一个新的镜像。</p><pre><code>docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot;  容器ID  命名空间/要创建的目标镜像名:[标签名]</code></pre><h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><p>这里，我们来使用tomcat镜像来演示。</p><p><strong>1.从Hub上下载tomcat镜像到本地并成功运行</strong></p><p><code>docker pull tomcat</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110155847.png"></p><p><strong>2.运行tomcat容器</strong></p><p><code>docker run -it -p 8080:8080 tomcat</code></p><pre><code>启动容器后面的参数，之前应该讲过了，这里再重复一遍-it：以后台交互的方式启动容器。-p：dockerPort:containerPort     docker的端口号映射到docker容器的端口号。（小写的p）-P：docker会随机帮我们分配端口号 (大写的P)解释：我们的docker是运行在宿主机上面的，而宿主机只能访问到docker的端口号，如果想要访问到docker内部容器的端口号，就需要映射。    </code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110161525.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110161629.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110161827.png"></p><p>验证tomcat容器是否启动成功：</p><p>1.在虚拟机验证<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110162108.png"></p><p>2.在本机中验证<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110162230.png"></p><p><strong>3.删除tomcat的文档说明文件</strong></p><p>现在，我们故意删除tomcat的文档说明文件，然后提交生成新的镜像来说明问题。</p><p>怎么删除tomcat中是文档说明文件呢？</p><p>在window系统中，我们知道下载好的tomcat的目录下的webapp下有一个doc目录，就是文档说明文件。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110162737.png"></p><p>在linux中，下载好的tomcat也有相关的文档说明文件，但是使用docker镜像生成的tomcat容器，怎么进入里面呢？</p><p>我们知道，docker镜像文件，就相当于一个微小型linux系统，因此进入里面的方法，就是相当于进入centos的交互方法一样。</p><p> <code>docker exec -it tomcat容器id /bin/bash</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110163823.png"></p><p>在浏览器中输入：<code>localhost:8888</code> , 然后点击Documentation<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110164641.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110164727.png"></p><p>如果，没有出现404，刷新一下，因为有缓存。注意：以上都是一气呵成的，中途tomcat容器不能停止运行呀。</p><p><strong>4.将已经删除文档的tomcat容器生成新的镜像</strong></p><p><code>docker commit -a=&#39;liuzhuo&#39; -m=&#39;del tomcat docs&#39; tomcat容器的ID gakki/mytomcat:1.1</code></p><pre><code>说明：-a：  提交的作者-m：  提交的信息gakki/mytomcat:1.1         命名空间/新的镜像名:标签命令空间：只是为了区分而已。</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110165701.png"></p><p><strong>5.启动我们的新的镜像并与原来的镜像进行对比</strong></p><p>启动gakki/mytomcat:1.1<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110170937.png"></p><p>启动原来的tomcat<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110170958.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110171048.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110171205.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110171314.png"></p><p>以上就是演示，怎么提交新的镜像，根据新的镜像，启动新的容器的过程。</p><hr><p>演示，使用<code>-P</code>（大写的P）<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110171629.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110171718.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110171842.png"></p><p>演示，使用 <code>-d</code> 后台运行tomcat容器</p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110172200.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day04/QQ截图20190110172250.png"></p><p><strong>注意：</strong></p><p>之前不是说，后台运行的容器，只是运行一下下就退出的嘛？怎么这里不是呢？</p><p>因为，tomcat后台启动后，会挂起，如果不是挂起的后台启动，都只是会启动一下就停止运行。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的常用命令</title>
      <link href="/2019/01/09/docker-de-chang-yong-ming-ling/"/>
      <url>/2019/01/09/docker-de-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>接着上篇，我们来学习docker的常用命令，大家是不是已经开始蠢蠢欲动了呢？come on！！！</p><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><h3 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a>docker version</h3><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190109212142.png"></p><h3 id="docker-info"><a href="#docker-info" class="headerlink" title="docker info"></a>docker info</h3><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190109212258.png"></p><h3 id="docker-help"><a href="#docker-help" class="headerlink" title="docker --help"></a><code>docker --help</code></h3><p>重要，帮助指令，就像linux中的man指令一样。</p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190109212428.png"></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><p>列出本地主机上的镜像</p><pre><code>docker images [OPTIONS]各个选项说明:REPOSITORY： 表示镜像的仓库源TAG：        镜像的标签IMAGE ID：   镜像IDCREATED：    镜像创建时间SIZE：       镜像大小</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190109213548.png"></p><p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p><p>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</p><pre><code>OPTIONS说明-a：        列出所有镜像-q：        只列出镜像的id--digests:  显示出镜像的摘要信息--no-trunc: 显示出完整的镜像信息</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190109214237.png"></p><h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><p>在docker hub上面查找某个镜像</p><pre><code>docker search 镜像名 [OPTION]NAME：           镜像的名字DESCRPTION:      镜像的描述信息STARS:           相当于点赞数，星数，越多说明人用的越多OFFICIAL:        是否官方AUTOMATED:       是否自动构建、组装</code></pre><p>使用该命令 与 在docker hub上面直接查找镜像是一样。docker hub地址：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></p><p>比如说：查找 tomcat镜像<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190109215126.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190109215251.png"></p><pre><code>OPTIONS说明：--no-trunc:    显示完整的镜像描述-s 3:          列出收藏数（点赞数）不小于指定值的镜像。（这里就是不小于3）这里说明一下，  命令已经过时了，现在使用：--filter=stars=3 来代替了--automated:   只列出automated build类型的镜像这里说明一下，  命令已经过时了，现在使用：--filter=is-automated=true 来代替了 </code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190109220322.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190109220719.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190109221006.png"></p><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><p>下载某个镜像，如果没有配置阿里云镜像，就是从docker huh上面拉取镜像，配置了的话，就是从阿里云镜像上面拉取镜像。<br>没有配置的话，下载速度老慢了，会吓死个人的。</p><pre><code>docker pull 镜像名字[:TAG]如果镜像名后面不加 :TAG , 那么就是下载最新的镜像。即  :latest。docker pull tomcat   &lt;======&gt; docker pull tomcat:latest</code></pre><p>现在，比如下载tomcat镜像。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190109223129.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190109223225.png"></p><p>如果，不想下载最新的镜像，要么就需要加上tag标签，那tag在哪里可以看呢？查官网。</p><p>比如，要下载tomcat镜像，点击进去后，会发现很多tag。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190109223409.png"></p><h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h3><p>删除某个镜像</p><pre><code>docker rmi 某个XXX镜像名字（或镜像ID）注意，如果你不加tag，那么就是删除latest的镜像。强制删除一个镜像docker rmi -f 镜像名字（或镜像ID）删除多个镜像：docker rmi -f 镜像名1:TAG 镜像名2:TAG多个镜像，用空格隔开删除全部：docker rmi -f $(docker images -qa)使用了$(),很像mysql中的 in的作用，delete from table where id in（id1，id2，id3）。docker images -qa：查找本地所有镜像的id</code></pre><p>使用镜像名删除：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190109224931.png"></p><p>使用镜像id删除：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190109224736.png"></p><hr><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><font color="red"><strong>有镜像才能创建容器，这是根本的前提(下载一个CentOS镜像演示)</strong></font><p><code>docker pull centos</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110111910.png"></p><h3 id="docker-run-image"><a href="#docker-run-image" class="headerlink" title="docker run image"></a>docker run image</h3><p>新建并启动一个容器：</p><pre><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]OPTIONS说明（常用）：有些是一个减号，有些是两个减号--name=&quot;容器新名字&quot;: 为容器指定一个名称；-d: 后台运行容器，并返回容器ID，也即启动守护式容器；-i：以交互模式运行容器，通常与 -t 同时使用；-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；-P: 随机端口映射；(大写)-p: 指定端口映射，有以下四种格式 （小写）    ip:hostPort:containerPort    ip::containerPort    hostPort:containerPort    containerPort</code></pre><p>启动交互式容器：</p><p><code>docker run -it centos</code>  (-i -t 可以缩写成：-it)<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110113630.png"></p><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><p>列出当前所有<strong>运行</strong>的容器</p><pre><code>docker ps [OPTIONS]OPTIONS说明（常用）：-a :列出当前所有正在运行的容器 + 历史上运行过的。-l :显示最近创建的容器(不管是否运行)。-n：显示最近 n个创建的容器(不管是否运行)。-q :静默模式，只显示容器编号。--no-trunc :不截断输出。</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110114219.png"></p><p>退出使用交互式运行的容器：</p><pre><code>两种方式：exit：    容器停止并退出交互式。ctrl+P+Q：容器不停止但退出交互式。</code></pre><p>使用 exit 退出刚刚我们启动的centos容器：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110114603.png"></p><p>检测是否停止了容器：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110114823.png"></p><h3 id="docker-start"><a href="#docker-start" class="headerlink" title="docker start"></a>docker start</h3><p>启动容器</p><pre><code>docker start 容器ID或者容器名</code></pre><p>再次启动，centos容器<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110115559.png"></p><h3 id="docker-restart"><a href="#docker-restart" class="headerlink" title="docker restart"></a>docker restart</h3><p>重启容器</p><pre><code>docker restart 容器ID或者容器名</code></pre><p>重启centos容器<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110120004.png"></p><h3 id="docker-stop"><a href="#docker-stop" class="headerlink" title="docker stop"></a>docker stop</h3><p>停止容器</p><pre><code>docker stop 容器ID或者容器名</code></pre><p>停止centos容器运行：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110120253.png"></p><h3 id="docker-kill"><a href="#docker-kill" class="headerlink" title="docker kill"></a>docker kill</h3><p>强制停止</p><pre><code>docker kill 容器ID或者容器名强制停止：就好比直接拔掉了电源，而stop停止就相当于正常的关机操作。</code></pre><h3 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h3><p>删除容器</p><pre><code>docker rm 容器ID或者容器名-f：选项，用来强制删除正在运行的容器。注意：rmi：是删除镜像，rm才是删除容器。一次性删除多个容器方式一：docker rm -f $(docker ps -a -q)方式二：docker ps -a -q | xargs docker rm</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110121246.png"></p><hr><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p><strong>1.启动守护式容器</strong></p><pre><code>docker run -d 镜像ID或镜像名 </code></pre><p>之前，我们使用的是交互式启动容器，现在我们来以后台的方式来启动容器：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110125011.png"></p><p>问题：然后docker ps -a 进行查看, 会发现容器已经退出了。</p><p>很重要的要说明的一点: <font color="red">Docker容器后台运行 , 就必须有一个前台进程. 否则会自动退出。</font><br>容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。</p><p><strong>这个是docker的机制问题</strong>,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如：service nginx start<br>但是,这样做,nginx为后台进程模式运行，就导致docker前台没有运行的应用，这样的容器后台启动后，会立即自杀，因为他觉得他没事可做了。<font color="blue">所以，最佳的解决方案是，将你要运行的程序以前台进程的形式运行。</font></p><p><strong>2.查看容器运行的日记</strong></p><pre><code>docker logs -f -t --tail 容器ID-t：           打印日志时，会加入时间戳-f：           只打印最新的日志，会不退出，一直打印。--tail 数字：  显示最后的多少条日志。（数字是几，就打印几条日志）       </code></pre><p>使用：<code>docker run -d centos /bin/sh -c &quot;while true;do echo hello zzyy;sleep 2;done&quot;</code></p><p>因为后台运行会自动退出，所以当以后台运行容器时，我们加入了shell脚本，使其一直打印 hello zzyy，所以容器就不会退出。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110130157.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110130315.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110130442.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110130705.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110130617.png"></p><p><strong>3.查看容器内运行的进程</strong></p><pre><code>docker top 容器的ID</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110131211.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110131324.png"></p><p><strong>4.查看容器内部的细节</strong></p><pre><code>docker inspect 容器的ID</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110131530.png"></p><p><strong>5.进入正在运行的容器并以命令行交互</strong></p><pre><code>有两种方式：方式一：docker attach 容器ID方式二：docker exec -it 容器ID /bin/bash方式二的功能更强大些，其实docker exec 是运行当前容器的命令，运行完命令后，就返回到宿主机，由于运行的是/bin/bash，所以才没有返回到宿主机</code></pre><p>方式一：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110132223.png"></p><p>方式二：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110132352.png"></p><p>更强大的功能：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110132800.png"></p><font color="blue">两者的区别：</font><p>attach：直接进入容器启动命令的终端，不会启动新的进程。</p><p>exec：是在容器中打开新的终端，并且可以启动新的进程。</p><p><strong>6.从容器内拷贝文件到宿主机上</strong></p><pre><code>docker cp  容器ID:容器内路径 目的主机路径</code></pre><p>将centos中的/tmp下的yum.log 拷贝到root根目录下。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110133245.png"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110133436.png"></p><hr><h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day03/QQ截图20190110133708.png"></p><pre><code>attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像commit    Create a new image from a container changes   # 提交当前容器为新的镜像cp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器diff      Inspect changes on a container&#39;s filesystem   # 查看 docker 容器变化events    Get real time events from the server          # 从 docker 服务获取容器实时事件exec      Run a command in an existing container        # 在已存在的容器上运行命令export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]history   Show the history of an image                  # 展示一个镜像形成历史images    List images                                   # 列出系统当前镜像import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]info      Display system-wide information               # 显示系统相关信息inspect   Return low-level information on a container   # 查看容器详细信息kill      Kill a running container                      # kill 指定 docker 容器load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器logout    Log out from a Docker registry server         # 从当前 Docker registry 退出logs      Fetch the logs of a container                 # 输出当前容器日志信息port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口pause     Pause all processes within a container        # 暂停容器ps        List containers                               # 列出容器列表pull      Pull an image or a repository from the docker registry server  # 从docker镜像源服务器拉取指定镜像或者库镜像push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器restart   Restart a running container                   # 重启运行的容器rm        Remove one or more containers                 # 移除一个或者多个容器rmi       Remove one or more images                     # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]run       Run a command in a new container              # 创建一个新的容器并运行一个命令save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像start     Start a stopped containers                    # 启动容器stop      Stop a running containers                     # 停止容器tag       Tag an image into a repository                # 给源中镜像打标签top       Lookup the running processes of a container   # 查看容器中运行的进程信息unpause   Unpause a paused container                    # 取消暂停容器version   Show the docker version information           # 查看 docker 版本号wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值</code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的安装</title>
      <link href="/2019/01/09/docker-de-an-zhuang/"/>
      <url>/2019/01/09/docker-de-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>本篇讲解docker的安装</p><h2 id="Docker安装前提说明"><a href="#Docker安装前提说明" class="headerlink" title="Docker安装前提说明"></a>Docker安装前提说明</h2><font color="blue">CentOS Docker 安装：</font><p>Docker支持以下的CentOS版本：<br>CentOS 7 (64-bit)<br>CentOS 6.5 (64-bit) 或更高的版本</p><p><strong>前提条件</strong></p><p>目前，CentOS 仅发行版本中的内核支持 Docker。<br>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。<br>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统<strong>内核版本为 2.6.32-431</strong> 或者更高版本。</p><p><strong>查看自己的内核</strong></p><p>uname命令用于打印当前系统相关信息（<strong>内核版本号</strong>、硬件架构、主机名称和操作系统类型等）。</p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109164948.png"></p><p>查看已安装的CentOS版本信息<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109165254.png"></p><h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h2><p>Docker的架构图：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109165533.png" style="width:50%"></p><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Docker 镜像（Image）就是一个只读的模板。<strong>镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。</strong><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109165653.png"></p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>Docker 利用容器（Container）独立运行的一个或一组应用。<strong><code>容器是用镜像创建的运行实例。</code></strong></p><p>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p><p><font color="red"><i><strong>可以把容器看做是一个简易版的 Linux 环境</strong></i></font>（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p><p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，<strong>唯一区别在于容器的最上面那一层是可读可写的。</strong></p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>仓库（Repository）是<font color="red"> 集中存放镜像文件的场所</font>。</p><p>仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p><p>仓库分为 公开仓库（Public）和 私有仓库（Private）两种形式。</p><p>最大的公开仓库是 Docker Hub <code>(https://hub.docker.com/)</code> , 存放了数量庞大的镜像供用户下载。</p><p>国内的公开仓库包括：<strong>阿里云 、网易云</strong> 等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>需要正确的理解：仓储 / 镜像 / 容器 这几个概念:</p><p>Docker 本身是一个容器运行载体或称之为<strong>管理引擎</strong>。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><ul><li><p>image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</p></li><li><p>一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</p></li><li><p>至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。</p></li></ul><h2 id="Docker的安装步骤"><a href="#Docker的安装步骤" class="headerlink" title="Docker的安装步骤"></a>Docker的安装步骤</h2><h3 id="CentOS6-8安装Docker"><a href="#CentOS6-8安装Docker" class="headerlink" title="CentOS6.8安装Docker"></a>CentOS6.8安装Docker</h3><p>1.<code>yum install -y epel-release</code></p><p>Docker使用EPEL发布，RHEL系的OS首先要确保已经持有EPEL仓库，否则先检查OS的版本，然后安装相应的EPEL包。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109172137.png"></p><p>2.<code>yum install -y docker-io</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109172251.png"></p><p>3.<code>检测docker的配置文件</code></p><p><code>/etc/sysconfig/docker</code>:该文件是否存在<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109172409.png"></p><p>4.<code>启动Docker后台服务</code></p><p><font color="red"><strong>service docker start</strong></font>（开机启动docker服务）</p><p>5.<code>docker version验证</code></p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109172603.png"></p><p>以上五个步骤就是：centOS:6.8的安装docker的步骤。</p><hr><h3 id="CentOS7安装Docker"><a href="#CentOS7安装Docker" class="headerlink" title="CentOS7安装Docker"></a>CentOS7安装Docker</h3><p>1.请看官方手册：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a></p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109173019.png"></p><p>看上图，我们能知道，docker有社区版和企业版，社区版是免费的，如果你的公司有钱，那你就下载企业版，这里，我下载的是社区版的docker。</p><p><strong>如果大家英文不好的话，这里有中文版的安装手册：</strong></p><p><a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/#prerequisites" target="_blank" rel="noopener">https://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/#prerequisites</a></p><p>2.确定你的CentOS的版本是否是7以及以上</p><p><code>cat /etc/redhat-release</code></p><p>3.yum安装gcc相关</p><ul><li><p>CentOS7能上外网</p></li><li><p>yum -y install gcc</p></li><li><p>yum -y install gcc-c++<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109173704.png"></p></li></ul><p>4.卸载旧版本</p><p>方法一：<code>yum -y remove docker docker-common docker-selinux docker-engine</code></p><p>方法二：查看官网删除</p><pre><code>$ sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-selinux \                  docker-engine-selinux \                  docker-engine</code></pre><p>如果 yum 报告未安装任何这些软件包，这表示情况正常。</p><p>将保留 /var/lib/docker/ 的内容，包括镜像、容器、存储卷和网络。Docker CE 软件包现在称为 docker-ce。</p><p>5.安装需要的软件包</p><p><code>yum install -y yum-utils device-mapper-persistent-data lvm2</code></p><p>6.设置stable镜像仓库</p><p>方式一：官网上面：</p><p><code>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></p><pre><code>如果出现报错：（请使用方法二）1   [Errno 14] curl#35 - TCP connection reset by peer2   [Errno 12] curl#35 - Timeout</code></pre><p>方式二：推荐：</p><p><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></p><p>7.更新yum软件包索引</p><p><code>yum makecache fast</code></p><p>如果这是自添加 Docker 镜像仓库以来您首次刷新软件包索引，系统将提示您接受 GPG 密钥，并且将显示此密钥的指纹。验证指纹是否正确，并且在正确的情况下接受此密钥。指纹应匹配 060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35。</p><p>8.安装DOCKER CE</p><p><code>yum -y install docker-ce</code></p><p>该命令是安装最新版本的，在生产系统中，您应该安装特定版本的 Docker CE，而不是始终使用最新版本。列出可用版本。</p><pre><code>注：此 yum list 命令仅显示二进制软件包。如果还需要显示 源软件包，请从软件包名称中省略 .x86_64。$ yum list docker-ce.x86_64  --showduplicates | sort -rdocker-ce.x86_64  17.06.0.el7                               docker-ce-stable  使用下面的命令，安装指定的版本：$ sudo yum install docker-ce-&lt;VERSION&gt;</code></pre><p>9.启动docker</p><p><code>systemctl start docker</code> (注意CentOS7 与 CentOS6 系列的启动命令不一样了)</p><p>10.测试</p><p><code>docker version</code></p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109181449.png"></p><p>11.配置镜像加速</p><pre><code>1.  mkdir -p /etc/docker2.  vim  /etc/docker/daemon.json#网易云{&quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;] }#阿里云{  &quot;registry-mirrors&quot;: [&quot;https://｛自已的编码｝.mirror.aliyuncs.com&quot;]}注意上面的配置，不要加上 #网易云 和 #阿里云。在配置文件中，直接写入文字下面的花括号里面的内容即可！！！配置一个加速器就行，推荐阿里云加速度阿里云的编码，从阿里云的容器镜像服务里面找即可。3.  systemctl daemon-reload4.  systemctl restart docker</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109183932.png"></p><p>12.卸载</p><pre><code>1.   systemctl stop docker 2.   yum -y remove docker-ce3.   rm -rf /var/lib/docker</code></pre><hr><h2 id="永远的hello-world"><a href="#永远的hello-world" class="headerlink" title="永远的hello-world"></a>永远的hello-world</h2><p>在我们实际开发中，如果是使用dicker-hub的话，会很慢，因为是国外的网站，所以为了方便开发，一般会使用国内的镜像加速地址。</p><p>国内属于：阿里云 与 网易云 镜像加速比较好，现在来详细说明两者的配置。</p><h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><p>1.打开阿里云的官网：<a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com/search.html</a><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109194448.png"></p><p>2.注册一个属于自己的阿里云账户（可复用淘宝账户）</p><p>3.获取加速器地址连接</p><p>登入阿里云，进入控制台：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109194804.png"></p><p>找到容器镜像服务：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109195001.png"></p><p>点击左侧的容器镜像服务：<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109195201.png"></p><hr><h4 id="CentOS6的系统镜像加速配置"><a href="#CentOS6的系统镜像加速配置" class="headerlink" title="CentOS6的系统镜像加速配置"></a>CentOS6的系统镜像加速配置</h4><p>如果你是<strong>CentOS6的系统</strong>，当你安装好docker之后，docker的配置<strong>文件</strong>是在：<code>/etc/sysconfig/docker</code></p><p><code>vim /etc/sysconfig/docker</code></p><p>将获得的自己账户下的阿里云加速地址配置进</p><p><code>other_args=&quot;--registry-mirror=https://你自己的账号加速信息.mirror.aliyuncs.com&quot;</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109195423.png"></p><p>配置成功后，重新启动docker的后台服务：<code>service docker restart</code></p><p>检查Linux 系统下配置完加速器需要检查是否生效：</p><p>如果从结果中看到了配置的<code>--registry-mirror</code>参数说明配置成功，如下所示:</p><p><code>ps -ef|grep docker</code><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109195724.png"></p><hr><h4 id="CentOS7的系统镜像加速配置"><a href="#CentOS7的系统镜像加速配置" class="headerlink" title="CentOS7的系统镜像加速配置"></a>CentOS7的系统镜像加速配置</h4><p>如果你是<strong>CentOS7的系统</strong>，当你安装好docker之后，docker的配置文件<strong>目录</strong>是在：<code>/etc/docker</code></p><p>在该目录下，创建一个新的文件：daemon.json文件。</p><p><code>mkdir -p /etc/docker</code></p><p>将该文件中，输入：</p><pre><code>{  &quot;registry-mirrors&quot;: [&quot;https://你的加速编码.mirror.aliyuncs.com&quot;]}</code></pre><p>配置成功后，重启加速配置文件：</p><p><code>systemctl daemon-reload</code></p><p>重新启动docker后台服务：</p><p><code>systemctl restart docker</code></p><h3 id="网易云镜像加速"><a href="#网易云镜像加速" class="headerlink" title="网易云镜像加速"></a>网易云镜像加速</h3><p>网易云的镜像加速配置 与 阿里云镜像加速配置一样，只是加速地址变了。</p><p>只要把其中的加速地址换成：<code>http://hub-mirror.c.163.com</code> 即可。</p><p>例如：</p><pre><code>{ &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]}</code></pre><p><strong>一般推荐：阿里云的镜像加速配置。</strong></p><h3 id="不使用国内镜像加速"><a href="#不使用国内镜像加速" class="headerlink" title="不使用国内镜像加速"></a>不使用国内镜像加速</h3><p>还可以不使用国内镜像加速的方法，在国内有一个镜像加速下载的网站：<a href="https://www.docker-cn.com/registry-mirror" target="_blank" rel="noopener">https://www.docker-cn.com/registry-mirror</a><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190110134356.png"></p><p>按照网站上面的说明，当pull镜像的时候：</p><p><code>$ docker pull registry.docker-cn.com/myname/myrepo:mytag</code></p><p>例如：拉取ubuntu:16.04 （tag为16.04）</p><p><code>$ docker pull registry.docker-cn.com/library/ubuntu:16.04</code></p><p>意思就是：当pull的时候，加上前缀：<code>registry.docker-cn.com/library/</code> 即可。</p><h3 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h3><p>启动Docker后台容器(测试运行 hello-world)</p><p><code>docker run hello-world</code></p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109201836.png"></p><p>输出这段提示以后，hello world 就会停止运行，容器自动终止。</p><p>这个run干了什么呢？<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109202054.png"></p><p>因为我们配置了阿里云镜像，所以当本地找不到镜像的时候，会去阿里云镜像找，而不是去docker hub中找相关的镜像！！！</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="docker是怎么工作的"><a href="#docker是怎么工作的" class="headerlink" title="docker是怎么工作的"></a>docker是怎么工作的</h4><p>docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 <strong>容器，是一个运行时环境，就是我们前面说到的集装箱。</strong><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109203549.png"></p><h4 id="为什么Docker比较比VM快"><a href="#为什么Docker比较比VM快" class="headerlink" title="为什么Docker比较比VM快"></a>为什么Docker比较比VM快</h4><p>(1) docker有着比虚拟机更少的抽象层。由于docker不需要<strong>Hypervisor</strong>实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p><p>(2) docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。然而避免了引寻、加载操作系统内核这个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,所以新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了这个过程,因此新建一个docker容器只需要几秒钟。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109204013.png" style="width:50%"><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day02/QQ截图20190109204054.png" style="width:50%"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的简介</title>
      <link href="/2019/01/09/docker-de-jian-jie/"/>
      <url>/2019/01/09/docker-de-jian-jie/</url>
      
        <content type="html"><![CDATA[<p>今天开始学习Docker的基础篇章的学习。</p><p>前提知识：首先，确定大家是已经学习过linux和git的相关知识的，如果大家不了解的话，请看我的前面的相关博客。</p><h2 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h2><p>问题：为什么会有docker的出现？</p><p>一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验。</p><p>Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。</p><p><img src="https://gakkil.gitee.io/gakkil-image/docker/day01/QQ截图20190109154747.png"></p><p>之前在服务器配置一个应用的运行环境，要安装各种软件，就拿电商项目的环境来说吧，Java/Tomcat/MySQL/JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。</p><p>传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，<font color="blue">开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。</font><font color="red">Docker镜像的设计，使得Docker得以打破过去「程序即应用」的观念。<strong>透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。</strong></font></p><p>docker的理念：</p><p>Docker是基于Go语言实现的云开源项目。</p><p>Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到<font color="red"><strong> “一次封装，到处运行”。</strong></font><br><img src="https://gakkil.gitee.io/gakkil-image/docker/day01/QQ截图20190109155823.png"></p><p>Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</p><p>一句话：<strong>解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</strong></p><h2 id="Docker能干嘛"><a href="#Docker能干嘛" class="headerlink" title="Docker能干嘛"></a>Docker能干嘛</h2><h3 id="之前的虚拟技术"><a href="#之前的虚拟技术" class="headerlink" title="之前的虚拟技术"></a>之前的虚拟技术</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。</p><p>它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day01/QQ截图20190109160213.png"></p><p> 虚拟机的缺点：</p><ol><li>资源占用多　　　　2. 冗余步骤多　　　　　3. 启动慢</li></ol><h3 id="容器虚拟化技术"><a href="#容器虚拟化技术" class="headerlink" title="容器虚拟化技术"></a>容器虚拟化技术</h3><p>由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p><p><font color="red">Linux 容器不是模拟一个完整的操作系统</font>，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。<br><img src="https://gakkil.gitee.io/gakkil-image/docker/day01/QQ截图20190109160730.png"></p><p>比较了 Docker 和 传统虚拟化方式的不同之处：</p><ul><li><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</p></li><li><p>而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，<strong>而且也没有进行硬件虚拟</strong>。因此容器要比传统虚拟机更为轻便。</p></li><li><p>每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p></li></ul><h3 id="开发与运维-DevOps"><a href="#开发与运维-DevOps" class="headerlink" title="开发与运维(DevOps)"></a>开发与运维(DevOps)</h3><p>一次构建、随处运行：</p><ul><li>更快速的应用交付和部署：</li></ul><p>传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。</p><ul><li>更便捷的升级和扩缩容：</li></ul><p>随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。</p><ul><li>更简单的系统运维：</li></ul><p>应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。</p><ul><li>更高效的计算资源利用：</li></ul><p>Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。</p><h2 id="Docker去哪里下"><a href="#Docker去哪里下" class="headerlink" title="Docker去哪里下"></a>Docker去哪里下</h2><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p>docker官网：<a href="http://www.docker.com" target="_blank" rel="noopener">http://www.docker.com</a>  （外网，估计会很慢）</p><p>docker中文网站：<a href="https://www.docker-cn.com" target="_blank" rel="noopener">https://www.docker-cn.com</a>  </p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>Docker Hub官网: <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a>  （外网，下载速度慢）</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么分布式一定要有Redis</title>
      <link href="/2019/01/08/wei-shi-me-fen-bu-shi-yi-ding-yao-you-redis/"/>
      <url>/2019/01/08/wei-shi-me-fen-bu-shi-yi-ding-yao-you-redis/</url>
      
        <content type="html"><![CDATA[<p>考虑到绝大部分写业务的程序员，在实际开发中使用 Redis 的时候，只会 Set Value 和 Get Value 两个操作，对 Redis 整体缺乏一个认知。所以对 Redis 常见问题做一个总结，希望能够弥补大家的知识盲点。</p><p>本文围绕以下几点进行阐述：</p><ol><li><p>为什么使用 Redis</p></li><li><p>使用 Redis 有什么缺点</p></li><li><p>单线程的 Redis 为什么这么快</p></li><li><p>Redis 的数据类型，以及每种数据类型的使用场景</p></li><li><p>Redis 的过期策略以及内存淘汰机制</p></li><li><p>Redis 和数据库双写一致性问题</p></li><li><p>如何应对缓存穿透和缓存雪崩问题</p></li><li><p>如何解决 Redis 的并发竞争 Key 问题</p></li></ol><h2 id="为什么使用-Redis"><a href="#为什么使用-Redis" class="headerlink" title="为什么使用 Redis"></a>为什么使用 Redis</h2><p>我觉得在项目中使用 Redis，主要是从两个角度去考虑：性能和并发。</p><p>当然，Redis 还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件，如 ZooKpeer 等代替，并不是非要使用 Redis。因此，这个问题主要从性能和并发两个角度去答。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的 SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day15/QQ截图20190108225346.png"></p><p><strong>题外话：</strong>忽然想聊一下这个迅速响应的标准。根据交互效果的不同，这个响应时间没有固定标准。</p><p><strong>不过曾经有人这么告诉我：</strong>“在理想状态下，我们的页面跳转需要在瞬间解决，对于页内操作则需要在刹那间解决。</p><p>另外，超过一弹指的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。”</p><p>那么瞬间、刹那、一弹指具体是多少时间呢？</p><pre><code>根据《摩诃僧祗律》记载：一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。</code></pre><p>那么，经过周密的计算，一瞬间为 0.36 秒、一刹那有 0.018 秒、一弹指长达 7.2 秒。</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。</p><p>这个时候，就需要使用 Redis 做一个缓冲操作，让请求先访问到 Redis，而不是直接访问数据库。</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day15/QQ截图20190108225619.png"></p><h2 id="使用-Redis-有什么缺点"><a href="#使用-Redis-有什么缺点" class="headerlink" title="使用 Redis 有什么缺点"></a>使用 Redis 有什么缺点</h2><p>大家用 Redis 这么久，这个问题是必须要了解的，基本上使用 Redis 都会碰到一些问题，常见的也就几个。</p><p><strong><code>回答主要是四个问题：</code></strong></p><p>1.缓存和数据库双写一致性问题</p><p>2.缓存雪崩问题</p><p>3.缓存击穿问题</p><p>4.缓存的并发竞争问题</p><p>这四个问题，我个人觉得在项目中是常遇见的，具体解决方案，后文给出。</p><h2 id="单线程的-Redis-为什么这么快"><a href="#单线程的-Redis-为什么这么快" class="headerlink" title="单线程的 Redis 为什么这么快"></a>单线程的 Redis 为什么这么快</h2><p>这个问题是对 Redis 内部机制的一个考察。根据我的面试经验，很多人都不知道Redis 是单线程工作模型。所以，这个问题还是应该要复习一下的。</p><p><strong><code>回答主要是以下三点：</code></strong></p><p>1.纯内存操作</p><p>2.单线程操作，避免了频繁的上下文切换</p><p>3.采用了非阻塞 I/O 多路复用机制</p><p>下面类比到真实的 Redis 线程模型，如图所示：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day15/QQ截图20190108230004.png"></p><p>简单来说，就是我们的 redis-client 在操作的时候，会产生具有不同事件类型的 Socket。</p><p>在服务端，有一段 I/O 多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。</p><p>需要说明的是，这个 I/O 多路复用机制，Redis 还提供了 select、epoll、evport、kqueue 等多路复用函数库，大家可以自行去了解。</p><h2 id="Redis-的数据类型，以及每种数据类型的使用场景"><a href="#Redis-的数据类型，以及每种数据类型的使用场景" class="headerlink" title="Redis 的数据类型，以及每种数据类型的使用场景"></a>Redis 的数据类型，以及每种数据类型的使用场景</h2><p>是不是觉得这个问题很基础？我也这么觉得。然而根据面试经验发现，至少百分之八十的人答不上这个问题。</p><p>建议，在项目中用到后，再类比记忆，体会更深，不要硬记。基本上，一个合格的程序员，五种类型都会用到。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>这个没啥好说的，最常规的 set/get 操作，Value 可以是 String 也可以是数字。一般做一些复杂的计数功能的缓存。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>这里 Value 存放的是结构化的对象，比较方便的就是操作其中的某个字段。</p><p>我在做单点登录的时候，就是用这种数据结构存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>使用 List 的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>因为 Set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用 JVM 自带的 Set 进行去重？</p><p>因为我们的系统一般都是集群部署，使用 JVM 自带的 Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。</p><p>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p><h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><p>Sorted Set多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。</p><p>可以做排行榜应用，取 TOP N 操作。Sorted Set 可以用来做延时任务。最后一个应用就是可以做范围查找。</p><h2 id="Redis-的过期策略以及内存淘汰机制"><a href="#Redis-的过期策略以及内存淘汰机制" class="headerlink" title="Redis 的过期策略以及内存淘汰机制"></a>Redis 的过期策略以及内存淘汰机制</h2><p>这个问题相当重要，到底 Redis 有没用到家，这个问题就可以看出来。</p><p>比如你 Redis 只能存 5G 数据，可是你写了 10G，那会删 5G 的数据。怎么删的，这个问题思考过么?</p><p>还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</p><p><strong>回答：Redis 采用的是定期删除+惰性删除策略。</strong></p><h3 id="为什么不用定时删除策略"><a href="#为什么不用定时删除策略" class="headerlink" title="为什么不用定时删除策略?"></a>为什么不用定时删除策略?</h3><p>定时删除，用一个定时器来负责监视 Key，过期则自动删除。虽然内存及时释放，但是十分消耗 CPU 资源。</p><p>在大并发请求下，CPU 要将时间应用在处理请求，而不是删除 Key，因此没有采用这一策略。</p><h3 id="定期删除-惰性删除是如何工作"><a href="#定期删除-惰性删除是如何工作" class="headerlink" title="定期删除+惰性删除是如何工作"></a>定期删除+惰性删除是如何工作</h3><p>定期删除，Redis 默认每个 100ms 检查，是否有过期的 Key，有过期 Key 则删除。</p><p>需要说明的是，Redis 不是每个 100ms 将所有的 Key 检查一次，而是随机抽取进行检查(如果每隔 100ms，全部 Key 进行检查，Redis 岂不是卡死)。</p><p>因此，如果只采用定期删除策略，会导致很多 Key 到时间没有删除。于是，惰性删除派上用场。</p><p>也就是说在你获取某个 Key 的时候，Redis 会检查一下，这个 Key 如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。</p><p><strong><code>采用定期删除+惰性删除就没其他问题了么?</code></strong></p><p>不是的，如果定期删除没删除 Key。然后你也没即时去请求 Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高。那么就应该采用内存淘汰机制。</p><p><strong><code>在 redis.conf 中有一行配置：</code></strong></p><pre><code># maxmemory-policy volatile-lru</code></pre><p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)：</p><pre><code>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。</code></pre><p>PS：如果没有设置 expire 的 Key，不满足先决条件(prerequisites)；那么 volatile-lru，volatile-random 和 volatile-ttl 策略的行为，和 noeviction(不删除) 基本上一致。</p><h2 id="Redis-和数据库双写一致性问题"><a href="#Redis-和数据库双写一致性问题" class="headerlink" title="Redis 和数据库双写一致性问题"></a>Redis 和数据库双写一致性问题</h2><p>一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。</p><p>答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。</p><p>另外，我们所做的方案从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p><p><strong>回答：</strong>首先，采取正确更新策略，<strong>先更新数据库，再删缓存</strong>。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</p><h2 id="如何应对缓存穿透和缓存雪崩问题"><a href="#如何应对缓存穿透和缓存雪崩问题" class="headerlink" title="如何应对缓存穿透和缓存雪崩问题"></a>如何应对缓存穿透和缓存雪崩问题</h2><p>这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。</p><p><strong>缓存穿透:</strong> 即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p><p><strong><code>缓存穿透解决方案：</code></strong></p><p>1.利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。</p><p>2.采用异步更新策略，无论 Key 是否取到值，都直接返回。Value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。</p><p>3.提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。</p><p><strong>缓存雪崩:</strong> 即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p><p><strong><code>缓存雪崩解决方案：</code></strong></p><p>1.给缓存的失效时间，加上一个随机值，避免集体失效。</p><p>2.使用互斥锁，但是该方案吞吐量明显下降了。</p><p>3.双缓存。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作。</p><p>然后细分以下几个小点：从缓存 A 读数据库，有则直接返回；A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程，更新线程同时更新缓存 A 和缓存 B。</p><h2 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h2><p>这个问题大致就是，同时有多个子系统去 Set 一个 Key。这个时候大家思考过要注意什么呢？</p><p>需要说明一下，我提前百度了一下，发现答案基本都是推荐用 Redis 事务机制。</p><p>我并不推荐使用 Redis 的事务机制。因为我们的生产环境，基本都是 Redis 集群环境，做了数据分片操作。</p><p>你一个事务中有涉及到多个 Key 操作的时候，这多个 Key 不一定都存储在同一个 redis-server 上。因此，Redis 的事务机制，十分鸡肋。</p><h3 id="如果对这个Key操作-不要求顺序"><a href="#如果对这个Key操作-不要求顺序" class="headerlink" title="如果对这个Key操作,不要求顺序"></a>如果对这个Key操作,不要求顺序</h3><p>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可，比较简单。</p><h3 id="如果对这个Key操作-要求顺序"><a href="#如果对这个Key操作-要求顺序" class="headerlink" title="如果对这个Key操作,要求顺序"></a>如果对这个Key操作,要求顺序</h3><p>假设有一个 key1，系统 A 需要将 key1 设置为 valueA，系统 B 需要将 key1 设置为 valueB，系统 C 需要将 key1 设置为 valueC。</p><p>期望按照 key1 的 value 值按照 valueA &gt; valueB &gt; valueC 的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。</p><p><strong><code>假设时间戳如下：</code></strong></p><pre><code>系统A key 1 {valueA  3:00}系统B key 1 {valueB  3:05}系统C key 1 {valueC  3:10}</code></pre><p>那么，假设这会系统 B 先抢到锁，将 key1 设置为{valueB 3:05}。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了，以此类推。</p><p>其他方法，比如利用队列，将 set 方法变成串行访问也可以。总之，灵活变通。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对 Redis 的常见问题做了一个总结。大部分是自己在工作中遇到，以及之前面试别人的时候，爱问的一些问题。</p><p>另外，不推荐大家临时抱佛脚，真正碰到一些有经验的工程师，其实几下就能把你问懵。最后，希望大家有所收获吧。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Redis实现分布式锁</title>
      <link href="/2019/01/08/li-yong-redis-shi-xian-fen-bu-shi-suo/"/>
      <url>/2019/01/08/li-yong-redis-shi-xian-fen-bu-shi-suo/</url>
      
        <content type="html"><![CDATA[<p>我在之前总结幂等性的时候，写过一种分布式锁的实现，可惜当时没有真正应用过，着实的心虚啊。正好这段时间对这部分实践了一下，也算是对之前填坑了。</p><p>分布式锁按照网上的结论，大致分为三种：1、数据库乐观锁； 2、基于Redis的分布式锁；3、基于ZooKeeper的分布式锁。</p><p>关于数据库的乐观锁实现网上已经有很多了，如果有必要的话，留言一下，我以后会出相关的mysql乐观锁。</p><p>今天先简单总结下redis的实现方法，后面详细研究过ZooKeeper的实现原理后再具体说说ZooKeeper的实现。</p><h2 id="为什么需要分布式锁"><a href="#为什么需要分布式锁" class="headerlink" title="为什么需要分布式锁"></a>为什么需要分布式锁</h2><p>在传统单体应用单机部署的情况下，可以使用Java并发相关的锁，如<strong>ReentrantLcok</strong>或<strong>synchronized</strong>进行互斥控制。但是，随着业务发展的需要，原单体单机部署的系统，渐渐的被部署在多机器多JVM上同时提供服务，这使得原单机部署情况下的并发控制锁策略失效了，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。</p><h2 id="分布式锁的实现条件"><a href="#分布式锁的实现条件" class="headerlink" title="分布式锁的实现条件"></a>分布式锁的实现条件</h2><p>1、互斥性，和单体应用一样，要保证任意时刻，只能有一个客户端持有锁</p><p>2、可靠性，要保证系统的稳定性，不能产生死锁</p><p>3、一致性，要保证锁只能由加锁人解锁，不能出现A用户产生的锁被B用户解锁的情况</p><h2 id="Redis分布式锁的实现"><a href="#Redis分布式锁的实现" class="headerlink" title="Redis分布式锁的实现"></a>Redis分布式锁的实现</h2><p>Redis实现分布式锁，不同的人可能有不同的实现逻辑，但是核心就是下面三个方法。</p><h3 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a>SETNX</h3><p>SETNX key val<br>当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。</p><h3 id="Expire"><a href="#Expire" class="headerlink" title="Expire"></a>Expire</h3><p>expire key timeout<br>为key设置一个超时时间，单位为second（秒），超过这个时间锁会自动释放，避免死锁。</p><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>delete key<br>删除key。</p><h2 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h2><p>首先讲一个目前网上应用最多的一种实现:</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day14/QQ截图20190108214911.png"></p><p>实现思路：</p><p>1.获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁以免产生死锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</p><p>2.获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p><p>3.释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</p><pre><code>public String getRedisLock(Jedis jedis, String lockKey, Long acquireTimeout, Long timeOut) {    try {        // 定义 redis 对应key 的value值(uuid) 作用 释放锁 随机生成value,根据项目情况修改        String identifierValue = UUID.randomUUID().toString();        // 定义在获取锁之后的超时时间        int expireLock = (int) (timeOut / 1000);// 以秒为单位，timeOut：传入的是毫秒值。        // 定义在获取锁之前的超时时间        // 使用循环机制 如果没有获取到锁，要在规定acquireTimeout时间 保证重复进行尝试获取锁        // 使用循环方式重试的获取锁        Long endTime = System.currentTimeMillis() + acquireTimeout;        while (System.currentTimeMillis() &lt; endTime) {            // 获取锁            // 使用setnx命令插入对应的redislockKey ，如果返回为1 成功获取锁            if (jedis.setnx(lockKey, identifierValue) == 1) {                // 设置对应key的有效期                jedis.expire(lockKey, expireLock);                return identifierValue;            }        }    } catch (Exception e) {        e.printStackTrace();    }     return null;    }</code></pre><p>这种实现方法也是目前应用最多的实现，我一直以为这确实是正确的。<strong>然而由于这是两条Redis命令，不具有原子性</strong>，如果程序在执行完setnx()之后突然崩溃，导致锁没有设置过期时间。那么还是会发生死锁的情况。<strong>网上之所以有人这样实现，是因为低版本的 jedis 并不支持多参数的set()方法。</strong></p><p>当然这种情况 jedis 的设计者也显然想到了，新版的 jedis 可以<strong>同时set多个参数</strong>，具体实现如下：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day14/QQ截图20190108215608.png"></p><p>实现思路：</p><p>基本上和原来的逻辑类似，<strong>只是将 setnx 和 expire 的操作合并为一步</strong>，改为使用新的set多参的方法。</p><p>set(final String key, final String value, final String nxxx, final String expx , final long time)</p><p>key和value自然不用多说。nxxx参数只可以传String 类型的NX（仅在不存在的情况下设置）和 XX（和普通的set操作一样会做更新操作）两种。</p><p>expx是指到期时间单位，可传参数为EX （秒）和 PX （毫秒）, time就是具体的过期时间了，单位为前面expx所指定的。</p><pre><code>public String getRedisLock(Jedis jedis, String lockKey, Long acquireTimeout, Long timeOut) {    try {        // 定义 redis 对应key 的value值(uuid) 作用 释放锁 随机生成value,根据项目情况修改        String identifierValue = UUID.randomUUID().toString();        // 定义在获取锁之前的超时时间        // 使用循环机制 如果没有获取到锁，要在规定acquireTimeout时间 保证重复进行尝试获取锁        // 使用循环方式重试的获取锁        Long endTime = System.currentTimeMillis() + acquireTimeout;        while (System.currentTimeMillis() &lt; endTime) {            // 获取锁            // set使用NX参数的方式就等同于 setnx()方法，成功返回OK。PX以毫秒为单位            if (&quot;OK&quot;.equals(jedis.set(lockKey, identifierValue, &quot;NX&quot;, &quot;PX&quot;, timeOut))) {                return identifierValue;            }        }    } catch (Exception e) {        e.printStackTrace();    }     return null;    }</code></pre><p>好了，获取锁的操作基本上就上面这些，有同学可能要问，为什么不直接返回一个Boolean型的true或false呢？</p><p>正如我前面所说的，要保证解锁的一致性，所以就需要通过value值来保证解锁人就是加锁人，而不能直接返回true或false了。</p><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>还是先举一个错误的例子：</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day14/QQ截图20190108220325.png"></p><p>实现思路：</p><p>释放锁的时候，通过传入key和加锁时返回的value值，判断传入的value是否和key从redis中取出的相等。相等则证明解锁人就是加锁人，执行delete释放锁的操作。</p><pre><code>// 释放redis锁public void unRedisLock(Jedis jedis, String lockKey, String identifierValue) {    try {        // 如果该锁的id 等于identifierValue 是同一把锁情况才可以删除        if (jedis.get(lockKey).equals(identifierValue)) {            jedis.del(lockKey);        }    } catch (Exception e){        e.printStackTrace();    }}</code></pre><p>看着好像没啥问题哈。然而仔细想想又总感觉哪里不对。</p><p>如果在执行jedis.del(lockKey)操作之前，刚好锁的过期时间到了，而这个时候又有别的客户端取到了锁，我们在此时执行删除操作，不是又不符合一致性的要求了嘛？</p><p>然后我们修改为下述方案：</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day14/QQ截图20190108220645.png"></p><p>修改后的代码为：</p><pre><code>  public void unRedisLock(Jedis jedis, String lockKey, String identifierValue) {    try {        String script = &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;;        Long result = (Long) jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(identifierValue));        //0释放锁失败。1释放成功        if (1 == result) {            //如果你想返回删除成功还是失败，可以在这里返回            System.out.println(result+&quot;释放锁成功&quot;);        }         if (0 == result){            System.out.println(result+&quot;释放锁失败&quot;);        }    } catch (Exception e){        e.printStackTrace();    } }</code></pre><p>实现思路：</p><p>我们将 <strong>Lua代码</strong> 传到 <strong>jedis.eval()</strong> 方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为identifierValue。eval()方法是将Lua代码交给Redis服务端执行。</p><p>那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与identifierValue相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？<strong>因为要确保上述操作是原子性的。</strong></p><p>那么为什么执行eval()方法可以确保原子性？源于Redis的特性，因为Redis是单线程，在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 分布式锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的常用配置选项</title>
      <link href="/2019/01/08/redis-de-chang-yong-pei-zhi-xuan-xiang/"/>
      <url>/2019/01/08/redis-de-chang-yong-pei-zhi-xuan-xiang/</url>
      
        <content type="html"><![CDATA[<p>列举redis中的常用配置选项</p><pre><code>==配置文件全解======基本配置=======bind 127.0.0.1    #绑定的主机地址port 6379         #指定Redis监听端口，默认端口为6379daemonize no      #是否以后台进程启动,no：不是，yes：是pidfile /var/run/redis.pid  #当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定timeout 300       #当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能。databases 16      #创建database的数量(默认选中的是database 0)loglevel verbose  #指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verboselogfile stdout    #日志记录方式，默认为标准输出,如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null----------------------------------------------------------save &lt;seconds&gt; &lt;changes&gt;Redis默认配置文件中提供了三个条件：(or)save 900 1        #刷新快照到硬盘中，必须满足两者要求才会触发，即900秒之后至少1个关键字发生变化。save 300 10       #必须是300秒之后至少10个关键字发生变化。save 60 10000     #必须是60秒之后至少10000个关键字发生变化。-----------------------------------------------------------stop-writes-on-bgsave-error yes    #后台存储错误停止写。rdbcompression yes         #使用LZF压缩rdb文件。rdbchecksum yes            #存储和加载rdb文件时校验。dbfilename dump.rdb        #设置rdb文件名。dir ./                     #设置工作目录，rdb文件会写入该目录。=====主从配置======slaveof &lt;masterip&gt; &lt;masterport&gt;   #设为某台机器的从服务器,新版本是：replicaof &lt;masterip&gt; &lt;masterport&gt;masterauth &lt;master-password&gt;      #连接主服务器的密码slave-server-stale-data yes       #当主从断开或slave正在复制中 , slave从服务器是否应答。yes：slave会仍然响应客户端请求,此时可能会有问题，no: slave会返回&quot;SYNC with master in progress&quot;这样的错误信息slave-read-only yes               #从服务器只读,不能执行set等写入命令repl-ping-slave-period 10         #从服务器ping主服务器的时间间隔 , 秒为单位repl-timeout 60                   #主从超时时间(超时认为断线了) , 要比repl-ping-slave-period大.slave-priority 100                #如果master不能再正常工作，那么会在多个slave中，选择优先值最小的一个slave提升为master，优先值为0表示不能提升为master。repl-disable-tcp-nodelay no       #主服务器端是否合并数据,大块发送给slave。=====安全配置======requirepass foobared              # 需要密码#命令重命名rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52 #如果公共环境,可以重命名部分敏感命令 如config=====限制配置=======maxclients 10000                  #最大客户端连接数maxmemory &lt;bytes&gt;                 #最大使用内存,如果你想把Redis视为一个真正的DB的话，那不要设置&lt;maxmemory&gt;,只有你只想把Redis作为cache.-------------------------------------------------------maxmemory-policy volatile-lru     #内存到极限后的处理volatile-lru     -&gt; LRU算法删除过期keyallkeys-lru      -&gt; LRU算法删除key(不区分过不过期)volatile-random  -&gt; 随机删除过期key，allkeys-random   -&gt; 随机删除key(不区分过不过期)，volatile-ttl     -&gt; 删除快过期的key，noeviction       -&gt; 不删除,返回错误信息。-------------------------------------------------------#解释LRU ttl 都是近似算法,可以选N个,再比较最适宜T踢出的数据。默认的样本数是3，你可以修改它。maxmemory-samples 3====日志模式配置=====appendonly  no                     #是否开启aof日志持久化appendfilename appendonly.aof      # append only 文件名 (默认: &quot;appendonly.aof&quot;)--------------------------------------------------------------------------------# Redis支持3中模式:appendfsync no                     #系统缓冲 , 统一写,速度快appendfsync always                 #系统不缓冲,直接写,慢,丢失数据少。appendfsync everysec               #折衷 , 每秒写1次--------------------------------------------------------------------------------no-appendfsync-on-rewrite no       #为yes,则其他线程的数据放内存里,合并写入(速度快,容易丢失的多)。# append only 文件的自动重写auto-aof-rewrite-percentage 100    #当前aof文件比上次重写文件大N%时，重写。auto-aof-rewrite-percentage 设置为 0 ，可以关闭AOF重写功能。auto-aof-rewrite-min-size 64mb     #aof重写至少要达到的大小。====慢查询配置=======slowlog-log-slower-than 10000       #记录响应时间大于10000微秒的慢查询，负数则关闭slow log，0则会导致每个命令都被记录。单位：微秒！！！slowlog-max-len 128                 #最多记录慢查询128条====高级配置=======hash-max-zipmap-entries 512        #存储hash的键，当hash的键值对的数量超过指定的数字时，底层使用字典来存储hash键，否则使用压缩列表。hash-max-zipmap-value 64           #存储hash的键，当hash的键值对的大小超过指定的数字时，底层使用字典来存储hash键，否则使用压缩列表。activerehashing yes                #指定是否激活重置hash，默认开启。list-max-ziplist-entries 512       #类似，list的底层结构也有很多种。list-max-ziplist-value 64set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64include /path/to/local.conf       #指定包含其他配置文件，可以在同一主机上多个redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 --------------------------------------------------------------------------------------------------------------------------------------------=============服务端命令===============（是指令，不是配置在配置文件中）time                               #返回时间戳+微秒dbsize                             #返回key的数量bgrewriteaof                       #重写aofbgsave                             #后台开启子进程，进行dump数据save                               #阻塞进程，进行dump数据lastsave                           #上次进行dump数据的时间slaveof host port                  #做host port的从服务器(数据清空,复制新主内容)slaveof no one                     #变成主服务器(原数据不丢失,一般用于主服失败后)flushdb                            #清空当前数据库的所有数据flushall                           #清空所有数据库的所有数据(误用了怎么办?)shutdown [save/nosave]             #关闭服务器,保存数据,修改AOF(如果设置)slowlog get N                      #获取N条慢查询日志slowlog len                        #获取慢查询日志条数slowlog reset                      #清空慢查询info []                            #查看很多服务器端的信息config get   选项(支持*通配)       #查看配置文件中的信息config set   选项值                #修改配置文件中的信息（临时的）config rewrite                     #把值写到配置文件（永久的）config restart                     #更新info命令的信息。debug object key                   #调试选项 , 看一个key的情况。debug segfault                     #模拟段错误,让服务器崩溃。object key (refcount|encoding|idletime)monitor                            #打开控制台,观察命令(调试用)client list                        #列出所有客户端的连接client kill                        #杀死某个客户端连接 ，CLIENT KILL 127.0.0.1:43501client getname                     #获取连接的名称 默认是nilclient setname &quot;名称&quot;              #设置连接名称,便于调试====连接命令=====auth 密码                          #密码登陆(如果有密码)ping                               #测试服务器是否可用echo &quot;some content&quot;                #测试服务器是否正常交互select 0/1/2...                    #选择数据库quit                               #退出连接</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的伪微博项目</title>
      <link href="/2019/01/04/redis-de-wei-wei-bo-xiang-mu/"/>
      <url>/2019/01/04/redis-de-wei-wei-bo-xiang-mu/</url>
      
        <content type="html"><![CDATA[<p>之前的篇章，介绍了redis中的大多数用法，今天使用redis来设计与实现一个伪微博项目。</p><p>具体使用什么客户端语言（java、python等），这里就不详细写了，主要是讲解该项目怎么使用redis这个key-value数据库来设计。</p><p>我一直觉得，一个程序猿，思想很重要，语言只是一种工具！！！</p><h2 id="微博项目的key设计"><a href="#微博项目的key设计" class="headerlink" title="微博项目的key设计"></a>微博项目的key设计</h2><h3 id="全局key的设计"><a href="#全局key的设计" class="headerlink" title="全局key的设计"></a>全局key的设计</h3><pre><code>-----------------------------------------------------------表名                  global列名                  操作                  备注global:userid         incr                 产生全局的useridglobal:postid         incr                 产生全局的postid-----------------------------------------------------------说明：在以前，我们使用mysql等关系型数据库时，一般会使用数据库自带的自增主键，在redis中，我们可以设置一个全局的key，然后通过incr指令来实现mysql中的自增主键。userid：代表用户的idpostid：代表微博的id</code></pre><h3 id="用户相关的key的设计"><a href="#用户相关的key的设计" class="headerlink" title="用户相关的key的设计"></a>用户相关的key的设计</h3><pre><code>用户相关的表设计(mysql中)------------------------------------------------------------------------表名                  useruserid               username             password            authsecret1                    test1                11111111            #Ujkdjf#o4&amp;2                    test2                22222222            zzuWNM#$jkf···                  ···                  ···                 ···------------------------------------------------------------------------在redis中,变成以下几个key-----------------------------------------------------------------------------------------------------key的前缀             useruser:userid:*        user:userid:*:username      user:userid:*:password      user:userid:*:authsecretuser:userid:1        user:userid:1:username      user:userid:1:password      user:userid:1:authsecret-----------------------------------------------------------------------------------------------------get global:userid  ====&gt; 返回一个userid假设返回：1set user:userid:1:username test1set user:userid:1:password 11111111set user:userid:1:authsecret #Ujkdjf#o4&amp;说明：authsecret是为了防止，客户端修改cookie中的userid和username来切换用户的身份，为了安全性，所以设置了authsecret。每次用户登入，都会随机设置新的authsecret值。</code></pre><h3 id="微博相关的key设计"><a href="#微博相关的key设计" class="headerlink" title="微博相关的key设计"></a>微博相关的key设计</h3><pre><code>微博相关的表设计-------------------------------------------------------------表名              postpostid            userid            time             content4                 2                 13792238923      测试内容-------------------------------------------------------------微博在redis中, 与表设计对应的key设计--------------------------------------------------------------------------------------------------------------------key的前缀           postpost:postid:*       post:postid:*:userid       post:postid:*:username     post:postid:*:time   post:postid:*:contentpost:postid:4       post:postid:4:userid       post:postid:4:username     post:postid:4:time   post:postid:4:content--------------------------------------------------------------------------------------------------------------------注意：在这里，可以看到，我们在redis中，多设置了username的属性，这是为啥？username不是存在user:userid:*:username里面嘛，这样不是数据冗余了嘛，有时候，为了提高查询的速度，适当的增加一些冗余数据是可以的，我们使用redis，不就是因为它的执行速度快嘛。这里，使用的是string结构来存储的，但是可以改成hash更棒哦，大家可以自己设计一个hash结构。</code></pre><h3 id="关注表和粉丝表的设计"><a href="#关注表和粉丝表的设计" class="headerlink" title="关注表和粉丝表的设计"></a>关注表和粉丝表的设计</h3><p>在伪微博的项目中，一定会有关注者，被关注者的功能，即：你的粉丝，和你关注的人。</p><p><strong>关注表：</strong><br>我们使用redis中的集合结构来存储：</p><p>following:$userid —&gt;  set</p><p>即：sadd following:1 2 3 4<br>表示：用户1，关注了用户id为2、3、4的用户。</p><p><strong>粉丝表：</strong><br>我们使用redis中的集合结构来存储：</p><p>follower:$userid —–&gt;  set</p><p>即：sadd follower:2 6 7 8<br>表示：用户id为2的粉丝有：6、7、8。</p><h3 id="微博推送的设计"><a href="#微博推送的设计" class="headerlink" title="微博推送的设计"></a>微博推送的设计</h3><p>在该项目中，一个用户发表了一条微博，那么他的粉丝应该也会收到微博的推送信息。即：在用户的首页，可以看到自己发的微博和你们关注的博主的微博。</p><p>这个功能是该项目的难点，也是最重要的部分。</p><p><strong>方法一：采用推送的方式</strong></p><p>推送表: revicepost<br>使用list结构：</p><p>recivepost:$userid   —-&gt; list(3,4,7)</p><p>即当一个用户发布一条微博的时候，他会自己主动的向他的粉丝发送该条微博。</p><p>即：lpush recivepost:$userid   —-&gt; list(3,4,7)<br>表示的是，当前博主发送了多条微博的话，会向redis数据库中，recivepost列表中加入发布的微博的id。<br>使用一个for循环，向自己的粉丝，调用:lpush recivepost:$userid  $postid。$userid：粉丝的id，postid：自己发布的微博的id。</p><p>然后，在其中一个粉丝登入之后，点击首页的时候，获取到recivepost中的所有微博id，再通过post来获取微博的信息。</p><p><strong>方法二：采用拉取的方式</strong></p><p>推送的方式，有一个致命的缺点，那就是当一个粉丝有可能会很久不登入微博来了，那么那些博主自己主动推的意义也不大，会浪费内存，因为该粉丝短时间不登入微博。某一天，粉丝突然登入微博的话，会接受到大量的博主的推送信息，会造成大量的数据发送，而且该粉丝只想看到最近的博主发送的微博，这个方式会发送所有的微博，意义不大。</p><p>采用拉取方式，是粉丝登入后，自己主动拉取博主的微博信息，不是被动的接受信息，而且，我们可以设置只拉取关注的每个博主的最近的20条数据，不需要很久之前的微博信息。</p><p>该怎么实现呢？这是一个难点。</p><p>拉取表<br>pull:$userid:  —–&gt; list(3,4,7)</p><p>问: 上次我拉取了 A -&gt; 5,6,7, 三条微博, 下次刷新首页 , 需要从postid大于7的微博开始拉取。<br>解决: 拉取时, 设定一个lastpull时间点, 下次拉取时, 取&gt;lastpull的微博</p><p>问: 有很多关注人,如何取?<br>解决: 循环自己的关注列表 , 逐个取他们的新微博</p><p>问:  取出来之后放在哪儿?<br>答:  pull:$userid的链接里面</p><p>问: 如果个人中心 , 只有前1000条<br>答: ltrim,只取前1000条</p><p>问: 如果我关注 A,B两人, 从2人中,各取3条最新信息, 这3+3条信息, 从时间上,是交错的, 如何按时间排序?<br>答: 我们发布时, 是发布的hash结构 , 不能按时间来排序.</p><p>解决: 同步时, 取微博后, 记录本次取的微博的最大id,下次同步时, 只取比最大id更大的微博。</p><hr><p>思路：<br>（1）当博主发送微博后，会pull:$userid $postid。 $userid：博主的userid，博主发送的postid。因为postid的自增的，所以postid越大表示该微博是最近发布的，这样就可以根据postid的大小来决定获取最近的1000条数据了。</p><p>（2）当粉丝登入到首页后，使用for循环来获取到博主的userid，然后通过userid来获取到每个博主发送的postid，该postid &gt; lastpull (lastpull初始化为0，后来就赋值为上次访问后的最大的postid)</p><p>（3）然后将第二步获取到的所有postid，取其中的最近的1000条数据。</p><h3 id="将redis中的数据写入到mysql中"><a href="#将redis中的数据写入到mysql中" class="headerlink" title="将redis中的数据写入到mysql中"></a>将redis中的数据写入到mysql中</h3><p>前面的操作，都是在redis中操作的，现在，我们需要将每个用户的不经常访问的微博放到mysql中，redis中只保存最新的1000条数据即可。</p><p>思路：</p><p>每个用户发微博的时候，将自己的微博构新建成一个链表，然后还有添加一个全局的链表</p><p>即：mypost:userid:* —–&gt; postid  和 global:storge —–&gt; postid</p><p>当mypost:userid中的postid的数量，大于1000后，就将mypost链表最后的一条postid，插入到global:storge的最左端。</p><p>当global:storge中的postid的数量大于1000后，一致性将global:storge中的最右端的1000条数据，批量插入到mysql中。</p><p>示意图如下：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day13/QQ截图20190105112749.png"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中key的设计技巧</title>
      <link href="/2019/01/02/redis-zhong-key-de-she-ji-ji-qiao/"/>
      <url>/2019/01/02/redis-zhong-key-de-she-ji-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p>传统，我们都使用关系型数据库，比如mysql数据库，一般大家都熟悉了关系型数据库的表设计技巧了，这篇来讲解key-value数据库中key的设计技巧。</p><h2 id="redis与关系型数据库的适合场景"><a href="#redis与关系型数据库的适合场景" class="headerlink" title="redis与关系型数据库的适合场景"></a>redis与关系型数据库的适合场景</h2><p>现在，我们来考虑一个场景需求，比如豆瓣网站中的书，每本书都有标签，比如西游记，标签：文学等。</p><h3 id="mysql中的设计"><a href="#mysql中的设计" class="headerlink" title="mysql中的设计"></a>mysql中的设计</h3><p>在mysql中，我们设计表结构如下：</p><p>书签系统设计：</p><pre><code>#book表create table book (bookid int,         # book的idtitle char(20)      # book的书名)engine myisam charset utf8;insert into book values (5 , &#39;PHP圣经&#39;),(6 , &#39;ruby实战&#39;),(7 , &#39;mysql运维&#39;)(8, &#39;ruby服务端编程&#39;);#书签表create table tags (tid int,          # 书签的idbookid int,       # book的idcontent char(20)  # 书签的内容)engine myisam charset utf8;insert into tags values (10 , 5 , &#39;PHP&#39;),(11 , 5 , &#39;WEB&#39;),(12 , 6 , &#39;WEB&#39;),(13 , 6 , &#39;ruby&#39;),(14 , 7 , &#39;database&#39;),(15 , 8 , &#39;ruby&#39;),(16 , 8 , &#39;server&#39;);</code></pre><p>现在，我想要知道既有”WEB”标签又有”PHP”标签的书名，sql语句该怎么写呢？</p><pre><code>select b.bookid , b.title from book as b,tags inner join tags as t on tags.bookid=t.bookidwhere tags.content=&#39;PHP&#39; and t.content=&#39;WEB&#39; and b.bookid = tags.bookid;</code></pre><p>大家可以看到，这是多么麻烦的操作，如果再加一个标签，还包括”ruby”标签呢？ 则 and c.content = ‘ruby’ </p><p>如果数据库中的数量很大，这样的内连接查询，会很耗时的。</p><p>因此，对于这样的需求，可以使用key-value数据库。</p><h3 id="key-value中的设计"><a href="#key-value中的设计" class="headerlink" title="key-value中的设计"></a>key-value中的设计</h3><pre><code>book使用string来存储set book:5:title &#39;PHP圣经&#39;set book:6:title &#39;ruby实战&#39;set book:7:title &#39;mysql运难&#39;set book:8:title ‘ruby server’tag使用set集合来存储sadd tag:PHP 5sadd tag:WEB 5 6sadd tag:database 7sadd tag:ruby 6 8sadd tag:SERVER 8</code></pre><p>查: 既有PHP,又有WEB的书。</p><pre><code>sinter tag:PHP tag:WEB  #查集合的交集</code></pre><p>查: 有PHP或有WEB标签的书.</p><pre><code>sunin tag:PHP tag:WEB  #查集合的并集</code></pre><p>查: 含有ruby,不含WEB标签的书.</p><pre><code>sdiff tag:ruby tag:WEB #求差集</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day12/QQ截图20190102222658.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day12/QQ截图20190102222938.png"></p><p>我们能很轻松的实现这样的需求，速度快。</p><hr><h2 id="redis中key的设计技巧"><a href="#redis中key的设计技巧" class="headerlink" title="redis中key的设计技巧"></a>redis中key的设计技巧</h2><p>通过上面的演示，我们知道了，key-value数据库可以实现一些特殊的需求，怎样设计key呢？</p><p>一般，分为以下4步：</p><p>1：第1段放置表名，作为为key前缀 ，如：<code>user:</code><br>2：第2段放置用于区分区key的字段–对应mysql中的主键的列名,如：<code>userid</code><br>3：第3段放置主键值,如 <code>2,3,4...., a , b ,c</code><br>4：第4段,写要存储的列名。如 <code>name,passwd,email</code></p><p>完整的key：<code>set user:userid:1:name gakki</code></p><hr><p>mysql中的表：</p><pre><code>user表：----------------------------------------------------------userid         username           password      email1              lisi               123456        a@a.com2              jack               987656        b@b.com3              rose               454354        c@c.com···            ···                ···           ···----------------------------------------------------------</code></pre><p>key-value：</p><pre><code>set user:userid:1:username lisiset user:userid:1:password 123456set user:userid:1:email a@a.com----------------------------------set user:userid:2:username jackset user:userid:2:password 987656set user:userid:2:email b@b.com----------------------------------set user:userid:3:username roseset user:userid:3:password 454354set user:userid:3:email c@c.com</code></pre><p>这样设计的好处是，通过设计的key的前缀，比如：<code>user:userid:1</code> 通过hash函数，定位到指定的redis服务器，从该服务器中获取所有的id：1的数据。</p><p>这样对于分布式存储很有用处，一般id相同的数据都存储在一个数据库中，不可能id：1的name存储在1号redis服务器，id：1的password存储在2号redis服务器中。</p><p><strong>注意：</strong></p><p>在关系型数据库中, 除主键外, 还有可能其他列也会频繁查询。<br>如上表中, username 也是极频繁查询的,往往这种列会通过加索引来加快查询的速度。</p><p>那么，在redis中，要查询username为lisi，该怎么呢？</p><p>不会使用：<code>keys user:userid:*:username lisi</code></p><p>这样查询的话，redis会从userid为1开始往后依次对比username是否为lisi，这样效率当然很低了。</p><p>没有什么其他好的办法了，只能使用<strong>冗余数据来加快username的查询</strong>。</p><pre><code>set user:username:lisi:userid 1set user:username:jack:userid 2set user:username:rose:userid 3</code></pre><p>注意，这里，我们额外添加了冗余的数据，使用username来作为前缀了，来保存userid的值，但是只保存userid的值，其他的值，可以通过username获取的id，再通过id来获取其他的值。</p><p>比如：我想获取 jack 的 email </p><p>首先，<strong>get user:username:<font color="red">jack</font>:userid</strong>     ====&gt; <code>返回id：2</code></p><p>然后，<strong>get user:userid:<font color="red">2</font>:email</strong>           ====&gt; <code>返回email：b@b.com</code></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中的sentinel运维工具</title>
      <link href="/2019/01/02/redis-zhong-de-sentinel-yun-wei-gong-ju/"/>
      <url>/2019/01/02/redis-zhong-de-sentinel-yun-wei-gong-ju/</url>
      
        <content type="html"><![CDATA[<p>接着上篇，来学习redis中的sentinel运维工具。</p><h2 id="场景问题"><a href="#场景问题" class="headerlink" title="场景问题"></a>场景问题</h2><p>在使用sentinel运维工具之前，首先来看一个问题：</p><p>当我们搭建好一个主从配置后，1个master，2个slave。入下图：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102151649.png" style="width:50%"></p><p>如果图中的master宕机了？此时，2个slave就成为了孤儿，该怎么解决呢？</p><p>应该将其中一台slave变成master，另一台slave成为这台新master的slave。如下图：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102152108.png" style="width:50%"></p><p>图中就是使用sentinel自动帮我们监控主从复制的原理图，当sentinel检测到与旧的master之间的通信断开了后，就自动帮我们创建一个新的mater，图中是使用slave1来作为新的master，slave2成为slave1的slave。</p><h2 id="手动解决"><a href="#手动解决" class="headerlink" title="手动解决"></a>手动解决</h2><p>再手动解决该问题之前，要先搭建好：这个master-slave的架构。</p><p>怎么搭建主从集群，之前的文章有，这里就不详细写了，搭建好后，示意图如下：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102153345.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102153553.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102153815.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102154007.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102154207.png"></p><hr><p>以上主从复制搭建好后的效果。现在断开master，使用：shutdown 指令。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102154412.png"></p><p>在6380中：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102154523.png"></p><p>在6381中：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102154646.png"></p><p>现在开始手动将slave1：即6380变为：master。</p><p>使用：<code>slaveof no one</code> 命令，将其修改为，不成为其他redis服务器的slave。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102155104.png"></p><p>修改成master后，还要修改那个：<code>replica-read-only yes</code> 只读，改为：no。不然这个master不能写入操作。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102155416.png"></p><p>接下来，将slave2：即6381，变为6380的slave。</p><p>使用：<code>slaveof ip port</code> 来变成其他redis服务器的slave。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102155744.png"></p><p>测试：在6380中，插入数据，在6781中，读取该数据。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102155935.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102160019.png"></p><p>以上就是手动解决master宕机后的方法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>运行时更改master-slave<br>修改一台slave(设为A)为new master<br>1) 命令该服务不作为其他redis服务器的slave<br>   <strong>命令: slaveof no one</strong><br>2) 修改其replica-read-only为 no （使用config指令）<br>   <strong>命令：config set replica-read-only no</strong></p><p>其他的slave再指向new master A<br>1) 命令该服务为new master A的slave<br>   <strong>命令： slaveof  ip  port</strong></p><hr><h2 id="使用sentinel自动解决"><a href="#使用sentinel自动解决" class="headerlink" title="使用sentinel自动解决"></a>使用sentinel自动解决</h2><p>手动解决，确实能行，但是，不能让运维工作人员，24小时待命，一有问题，就去手动解决一下吧，凌晨3点爬起来，手动一下？</p><p>因此，redis官网出了一个sentinel运维工具来自动解决这个问题。</p><p><strong>首先将之前的三个redis服务器断开。删除持久化文件，避免干扰。</strong></p><p>从redis的src源文件中，拷贝一份sentinel.conf配置文件到当前目录下：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102161000.png"></p><p>sentinel.conf配置文件的说明：</p><pre><code>port 26379   # 端口号daemonize no # 是否后台启动pidfile /var/run/redis-sentinel.pid #pid文件sentinel monitor mymaster 127.0.0.1 6379 2 这一行代表sentinel监控的master的名字叫做mymaster,地址为127.0.0.1:6379，行尾最后的一个2代表什么意思呢？我们知道，网络是不可靠的，有时候一个sentinel会因为网络堵塞而误以为一个master redis已经死掉了，当sentinel集群式，解决这个问题的方法就变得很简单，只需要多个sentinel互相沟通来确认某个master是否真的死了，这个2代表，当集群中有2个sentinel认为master死了时，才能真正认为该master已经不可用了。（sentinel集群中各个sentinel也有互相通信，通过gossip协议）。sentinel auth-pass &lt;master-name&gt; &lt;password&gt; # 如果监视的master设置了密码，该处就需要设置sentinel down-after-milliseconds mymaster 30000 #30秒之后监视的master还是没有响应，就认为一次监视失败，配合上述的sentinel monitor后的2来用。单位：毫秒。sentinel会向master发送心跳PING来确认master是否存活，如果master在“一定时间范围”内不回应PONG 或者是回复了一个错误消息，那么这个sentinel会主观地(单方面地)认为这个master已经不可用了(subjectively down, 也简称为SDOWN)。而这个down-after-milliseconds就是用来指定这个“一定时间范围”的，单位是毫秒。sentinel parallel-syncs mymaster 1 #恢复数据时的同步个数，我们知道只要master与slave断开后，重写连接后，都需要重写rdb、aof，如果同时间重连太多，会导致master产生大量的IO运行，容易将master搞奔溃的，所以数字尽量要小！！！在发生failover主备切换时，这个选项指定了最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave处于不能处理命令请求的状态。sentinel can-failover def_master yes #当前sentinel实例是否允许实施“failover”(故障转移) ，no表示当前sentinel为“观察者”(只参与&quot;投票&quot;.不参与实施failover)，全局中至少有一个为yes。sentinel failover-timeout mymaster 180000 #sentinel去执行failover的等待时间</code></pre><p><strong>Sentinel的”仲裁会”</strong></p><p>前面我们谈到，当一个master被sentinel集群监控时，需要为它指定一个参数，这个参数指定了当需要判决master为不可用，并且进行failover时，所需要的sentinel数量，本文中我们暂时称这个参数为票数.</p><p>不过，当failover主备切换真正被触发后，failover并不会马上进行，还需要sentinel中的大多数sentinel授权后才可以进行failover。<br>当ODOWN时，failover被触发。failover一旦被触发，尝试去进行failover的sentinel会去获得“大多数”sentinel的授权（如果票数比大多数还要大的时候，则询问更多的sentinel)<br>这个区别看起来很微妙，但是很容易理解和使用。例如，集群中有5个sentinel，票数被设置为2，当2个sentinel认为一个master已经不可用了以后，将会触发failover，但是，进行failover的那个sentinel必须先获得至少3个sentinel的授权才可以实行failover。<br>如果票数被设置为5，要达到ODOWN状态，必须所有5个sentinel都主观认为master为不可用，要进行failover，那么得获得所有5个sentinel的授权。</p><p><strong>配置版本号</strong></p><p>为什么要先获得大多数sentinel的认可时才能真正去执行failover呢？</p><p>当一个sentinel被授权后，它将会获得宕掉的master的一份最新配置版本号，当failover执行结束以后，这个版本号将会被用于最新的配置。因为大多数sentinel都已经知道该版本号已经被要执行failover的sentinel拿走了，所以其他的sentinel都不能再去使用这个版本号。这意味着，每次failover都会附带有一个独一无二的版本号。我们将会看到这样做的重要性。</p><p>而且，sentinel集群都遵守一个规则：如果sentinel A推荐sentinel B去执行failover，B会等待一段时间后，自行再次去对同一个master执行failover，这个等待的时间是通过failover-timeout配置项去配置的。从这个规则可以看出，sentinel集群中的sentinel不会再同一时刻并发去failover同一个master，第一个进行failover的sentinel如果失败了，另外一个将会在一定时间内进行重新进行failover，以此类推。</p><p>redis sentinel保证了活跃性：如果大多数sentinel能够互相通信，最终将会有一个被授权去进行failover.<br>redis sentinel也保证了安全性：每个试图去failover同一个master的sentinel都会得到一个独一无二的版本号。</p><p><strong>配置传播</strong></p><p>一旦一个sentinel成功地对一个master进行了failover，它将会把关于master的最新配置通过广播形式通知其它sentinel，其它的sentinel则更新对应master的配置。</p><p>一个faiover要想被成功实行，sentinel必须能够向选为master的slave发送<strong>SLAVEOF NO ONE</strong>命令，然后能够通过INFO命令看到新master的配置信息。</p><p>当将一个slave选举为master并发送<strong>SLAVEOF NO ONE</strong>后，即使其它的slave还没针对新master重新配置自己，failover也被认为是成功了的，然后所有sentinels将会发布新的配置信息。</p><p>新配在集群中相互传播的方式，就是为什么我们需要当一个sentinel进行failover时必须被授权一个版本号的原因。</p><p>每个sentinel使用##发布/订阅##的方式持续地传播master的配置版本信息，配置传播的##发布/订阅##管道是：<code>__sentinel__:hello</code>。</p><p>因为每一个配置都有一个版本号，所以以版本号最大的那个为标准。</p><p>举个栗子：假设有一个名为mymaster的地址为192.168.1.50:6379。一开始，集群中所有的sentinel都知道这个地址，于是为mymaster的配置打上版本号1。一段时候后mymaster死了，有一个sentinel被授权用版本号2对其进行failover。如果failover成功了，假设地址改为了192.168.1.50:9000，此时配置的版本号为2，进行failover的sentinel会将新配置广播给其他的sentinel，由于其他sentinel维护的版本号为1，发现新配置的版本号为2时，版本号变大了，说明配置更新了，于是就会采用最新的版本号为2的配置。</p><p>这意味着sentinel集群保证了第二种活跃性：一个能够互相通信的sentinel集群最终会采用版本号最高且相同的配置。</p><hr><p>说了这么多，我们来验证一下sentinel的功能：</p><p>就使用默认的sentinel.conf，不需要改变。</p><p>依次启动三个redis服务器：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102171724.png"></p><p>查看三个redis服务器的配置是否正确：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102171853.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102171933.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102172020.png"></p><p>首先：启动sentinel进程</p><p><code>redis-sever sentinel --sentinel</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102172230.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102172319.png"></p><p>现在已经启动sentinel进程了，进程阻塞在那里，一直在帮我们监视着：127.0.0.1：6379 redis服务器。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102172533.png"></p><p>现在：断开6379：master：redis服务器。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102172635.png"></p><p>等待一段时间，喝一杯茶，再看sentinel前台的信息：</p><p>会发现：输出 +sdown master mymaster 127.0.0.1 6379 之后就不输出了，只是提示我们，6379：master 挂了，但是没有帮我们自动指定新的master等一些列操作。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102173312.png"></p><p>这是为啥呢？这是因为默认的sentinel.conf配置文件中，<code>sentinel monitor mymaster 127.0.0.1 6379 2</code>,最后面为2，意思是需要两个sentinel确认master已经宕机了才会触发faiover操作。sentinel也是支持集群部署的。</p><p>所以，我们需要将其的数字改为：1.</p><p>退出三个redis服务器，修改sentinel配置文件：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102182328.png"></p><p>重启三个redis服务器和sentinel进程，然后shutdown：master。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102182704.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102182758.png"></p><p>这次，真的喝一杯茶，sentinel就会自动帮助我们处理。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102183150.png"></p><p>在6380中，info Replication：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102183405.png"></p><p>在6381中，info Replication：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102183541.png"></p><p>在6380中，随便插入新的数据， 验证在6381中是否能获取到：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102183708.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102183803.png"></p><p>以上就是，sentinel自动帮助我们处理的情况。</p><hr><p>这个，sentinel自动帮我们选择了6380作为新的master，但是有时，我们需要自己设置怎么办？不想让sentinel随机帮我们选择新的master。</p><p>这样的话，我们需要设置slave的优先级，如果我们想要使用6381作为新的master，修改其redis.conf配置文件，将其slave的优先级数字改小，越小优先级越高。</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102184259.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102184432.png"></p><p><strong>注意：在之前的redis版本中：是slave-priority , 现在是：replica-priority </strong></p><p>接下来重启三个redis服务器和sentinel进程，shutdown：6379。<br>注意：在此之前，因为此时三个redis服务器已经被sentinel改了，所以，需要恢复到初始状态，6379：作为6380和6381的master。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102185825.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day11/QQ截图20190102190120.png"></p><p>以上就是今天是所有内容，希望大家喜欢。</p><p>参考链接：<br><a href="https://blog.csdn.net/zhanglh046/article/details/78630336" target="_blank" rel="noopener">Redis的主从复制(Sentinel)</a><br><a href="https://www.cnblogs.com/zhoujinyi/p/5569462.html" target="_blank" rel="noopener">Redis中的Sentinel机制与用法</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中的aof恢复与rdb的迁移</title>
      <link href="/2019/01/02/redis-zhong-de-aof-hui-fu-yu-rdb-de-qian-yi/"/>
      <url>/2019/01/02/redis-zhong-de-aof-hui-fu-yu-rdb-de-qian-yi/</url>
      
        <content type="html"><![CDATA[<p>今天来学习redis中的aof恢复与rdb服务器之间的迁移。</p><p>基于上篇的知识，当我们在redis的开发中，一不小心，手贱 运行了 flushall，数据都被清空了，该怎么恢复呢？</p><p>今天的话题，就由此展开。</p><h2 id="aof的恢复"><a href="#aof的恢复" class="headerlink" title="aof的恢复"></a>aof的恢复</h2><p>目前redis下的目录结构如下：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102112932.png"></p><pre><code>bin :            与redis相关的命令目录redis.conf :     6379的redis配置文件（默认的）redis6380.conf : 6380的redis配置文件（拷贝的6379）</code></pre><p>我们知道，redis持久化的目录在：/var/rdb下。（配置文件中配置的）<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102113401.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102113617.png"></p><p>启动，redis:6379的服务器<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102113805.png"></p><p>先向redis中，随便存点数据。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102113957.png"></p><p>现在一不小心，执行了：flushall 。</p><p>赶紧：执行 shutdown nosave ，抢救一下。 （后面的参数，加上save的话，就是将shutdown指令也保存到aof文件中，nosave就是不保存）<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102114233.png"></p><p>查看持久化目录：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102114435.png"></p><p>查看aof文件中的内容：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102114435.png"><br><code>more /var/rdb/appendonly6379.aof</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102114705.png"></p><p>再次启动，redis服务器：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102114916.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102115022.png"></p><p>删除aof文件中 与flushall相关的指令即可恢复之前的数据。</p><p><code>vim /var/rdb/appendonly6379.aof</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102115338.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102115550.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102115654.png"></p><hr><p>再次启动redis服务器，验证数据是否恢复<br>启动之前，首先检查一下，我们修改后的aof是否有效：（防止格式不对，启动redis服务器失败）<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102120357.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102115806.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102120532.png"></p><p><strong>注意：当你执行flushall之后，如果恰好aof进行了重写，那么就真的完蛋了，准备写辞职信吧！</strong></p><p>进行aof重写后，aof文件就会清空了，因为里面是有flushall指令了，redis就会在重写的时候，认为数据库该清空，aof文件就会清空了。</p><h2 id="rdb在服务器之间的迁移"><a href="#rdb在服务器之间的迁移" class="headerlink" title="rdb在服务器之间的迁移"></a>rdb在服务器之间的迁移</h2><p>现在，我们想要进行数据的迁移怎么办呢？我们想将一台redis服务器中数据迁移到另一台redis服务器中。</p><p>这里，我们演示将6379：redis服务器中的数据迁移到6380：redis服务器中。</p><p>查看持久化目录，此时6380还没有rdb文件。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102125758.png"></p><p>修改6380配置文件，关闭aof持久化功能，避免干扰，因为如果rdb与aof同时存在的话，是会使用aof来恢复数据的。<br>（注意rdb功能是开启的。）<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102130035.png"></p><p>启动6380的redis服务器，验证该服务器中是否有数据：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102130806.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102130922.png"></p><p>关闭6380的redis服务器，并且删除：/var/rdb/下的dump6380.rdb文件（如果有的话）。</p><p><strong>在持久化目录下：拷贝一份dump6379.rdb 文件，名字为dump6380.rdb（与redis6380.conf配置文件配置的一样）</strong><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102131149.png"></p><p>分别开启：6379与6380的redis服务器。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102130324.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102131317.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102131445.png"></p><p><strong>注意：6379的redis服务器是通过aof文件来恢复内存中的数据的，所以如果在拷贝dump文件之前，需要执行save命令，强行执行rdb保存，这样aof持久化的数据就与rdb一致了，否则，有可能现在出现6380服务器中数据与6379不一致问题。</strong></p><hr><p><strong>要点：</strong></p><p>将要迁移的redis服务器的rdb文件，拷贝一份放到需要该数据的redis服务器的<strong>持久化目录下</strong>,而且名字必须与配置文件中<strong>一致</strong>。</p><p>比如：我这里，持久化的目录为：<code>/var/rdb</code>。rdb的名字为：<code>dump6380.rdb</code>。</p><p>因为：6380的redis.conf配置文件中：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day10/QQ截图20190102132109.png"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中运维相关的指令</title>
      <link href="/2019/01/01/redis-zhong-yun-wei-xiang-guan-de-zhi-ling/"/>
      <url>/2019/01/01/redis-zhong-yun-wei-xiang-guan-de-zhi-ling/</url>
      
        <content type="html"><![CDATA[<p>这篇文章，将讲述redis中与运维相关的指令。</p><p>上篇，我们讲解了redis中的集群搭建过程。现在来学习redis中的运维相关的知识。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>现在redis的目录结构如下：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101213016.png"></p><p>redis.conf配置文件中主要的配置：</p><pre><code>port 6379daemonize yespidfile /var/run/redis_6379.pidsave 900 1save 300 10save 60 10000dbfilename dump6379.rdbdir /var/rdbappendonly yesappendfilename &quot;appendonly6379.aof&quot;</code></pre><p>首先，删除：/var/rdb/下的所有持久化文件，为了防止干扰。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101214056.png"></p><p>使用这个配置文件，启动redis服务器：</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101213740.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101214242.png"></p><p>启动redis的客户端：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101214441.png"></p><hr><h2 id="运维常用指令"><a href="#运维常用指令" class="headerlink" title="运维常用指令"></a>运维常用指令</h2><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><pre><code>显示redis 服务器端命令。第一行：时间戳(秒)第二行：微秒数</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101214755.png"></p><h3 id="dbsize"><a href="#dbsize" class="headerlink" title="dbsize"></a>dbsize</h3><pre><code>显示当前数据库的key是数量</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101214927.png"></p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><pre><code>select N: 切换到N数据库下，默认16个数据库</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101215137.png"></p><h3 id="bgrewriteaof"><a href="#bgrewriteaof" class="headerlink" title="bgrewriteaof"></a>bgrewriteaof</h3><pre><code>后台进程重写aof文件</code></pre><p>我们知道，开启aof持久化后，必须满足一定的条件，才会执行aof重写操作，但是直接使用该命令，会立即重写aof文件。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101215852.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101215950.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101220120.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101220220.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101220359.png"></p><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><pre><code>save: 保存rdb快照之前，都是当系统满足那三个save条件后，自动帮我们保存rdb快照现在直接执行这个命令，就可以帮我们保存rdb快照了。</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101220829.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101220924.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101221014.png"></p><h3 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h3><pre><code>bgsave: 后台保存rdb快照。save是直接使用主进程来执行rdb保存操作，这样会阻塞当前进程。bgsave是后台进程执行，就不会阻塞当前进程。</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101221140.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101221451.png"></p><h3 id="lastsave"><a href="#lastsave" class="headerlink" title="lastsave"></a>lastsave</h3><pre><code>上次保存快照的时间戳</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101221647.png"></p><h3 id="flushdb"><a href="#flushdb" class="headerlink" title="flushdb"></a>flushdb</h3><pre><code>清空当前数据库中的所有数据实际生产中，轻易不要用这个命令！！！</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101221927.png"></p><h3 id="flushall"><a href="#flushall" class="headerlink" title="flushall"></a>flushall</h3><pre><code>清空所有数据库中的数据</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101222419.png"></p><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><pre><code>showdown [save/nosave] ：关闭服务器如果不小心执行了flushall，立即 shutdown nosave ， 关闭服务器然后，手动编辑aof文件，去掉文件中的&quot;flushall&quot;相关的行，然后开启服务器，就可以导入回原来的数据了。如果flushall之后 , 系统恰好bgrewriteaof了 , 那么aof就清空了 , 数据丢失.（无力回天）</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101222802.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101222957.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101223216.png"></p><h3 id="slowlog"><a href="#slowlog" class="headerlink" title="slowlog"></a>slowlog</h3><pre><code>slowlog: 显示慢查询怎样才算是一个慢执行过程呢？这是由redis.conf配置中的：slowlog-log-slower-than 10000（默认值） 来指定的单位是：微秒。最多能存储多少条慢查询信息呢？这是由redis.conf配置中的：slowlog-max-len 128 （默认值）, 来做限制slowlog get N ：获取N条慢查询的信息</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101223813.png"></p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><pre><code>用来修改redis.conf配置文件中的值，是在redis运行的期间。config get 配置项  config set 配置项 值 (特殊的选项,不允许用此命令设置,如slave-of, 需要用单独的slaveof命令来设置)注意：如果调用config set **** 之后，没有使用config rewrite命令的话，是不会将更改保存到redis.conf中的只对当前允许的redis实例生效，进程结束之后就失效里。所以如果想保存到配置文件的话，别忘了在使用config set ****之后，调用config rewrite</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101224601.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101224740.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101225054.png"></p><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><pre><code>查看redis服务器信息的。1: 内存# Memoryused_memory:859192      数据结构的空间used_memory_rss:7634944 实占空间mem_fragmentation_ratio:8.89 前2者的比例,1.N为佳,如果此值过大,说明redis的内存的碎片化严重,可以导出再导入一次.2: 主从复制# Replicationrole:slavemaster_host:192.168.1.128master_port:6379master_link_status:up3:持久化# Persistencerdb_changes_since_last_save:0rdb_last_save_time:13752240634: fork耗时#Statuslatest_fork_usec:936  上次导出rdb快照,持久化花费微秒注意: 如果某实例有10G内容,导出需要2分钟,每分钟写入10000次,导致不断的rdb导出,磁盘始处于高IO状态.</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101225516.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190101225740.png"></p><p>从上图可以看出，slaves：0，没有slave服务器，所以，现在配置一个。</p><p>将当前目录下的redis.conf 复制一份为：redis6380.conf.</p><p><code>cp redis.conf redis6380.conf</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190102095059.png"></p><p>redis.conf中的配置信息</p><pre><code>bind 127.0.0.1   # 实际生产中，添加自己的ip地址。port 6379daemonize yespidfile /var/run/redis_6379.pidsave 900 1save 300 10save 60 10000dbfilename dump6379.rdbdir /var/rdbappendonly yesappendfilename &quot;appendonly6379.aof&quot;</code></pre><p>redis6380.conf中的配置信息</p><pre><code>bind 127.0.0.1   # 实际生产中，添加自己的ip地址。port 6380daemonize yespidfile /var/run/redis_6380.pid#save 900 1       # 不要rdb，因为6379：master已经配置了。#save 300 10#save 60 10000dbfilename dump6380.rdbdir /var/rdbappendonly no     # 不要配置aof，6379：master已经配置了。appendfilename &quot;appendonly6380.aof&quot;#配置主从复制replicaof 127.0.0.1 6379  # 配置master的ip地址和端口号。注意这里不能写localhost！！！replica-read-only yes     # slave只读。</code></pre><p>分别启动这两个redis服务器。</p><p><code>./bin/redis-server ./redis.conf</code></p><p><code>./bin/redis-server ./redis6380.conf</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190102100807.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190102100930.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190102101103.png"></p><p>以上主从复制配置成功，在使用info来查看信息。</p><p>在6379：redis客户端中：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190102101446.png"></p><p>在6380：redis客户端中：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day09/QQ截图20190102101638.png"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中的集群部署</title>
      <link href="/2018/12/31/redis-zhong-de-ji-qun-bu-shu/"/>
      <url>/2018/12/31/redis-zhong-de-ji-qun-bu-shu/</url>
      
        <content type="html"><![CDATA[<p>今天来学习redis中的集群部署，防止一台master宕机后，就全盘皆输的局面。</p><h2 id="集群的作用"><a href="#集群的作用" class="headerlink" title="集群的作用"></a>集群的作用</h2><p>1:  主从备份 防止主机宕机<br>2:  读写分离,分担master的任务（master写，slave读）<br>3:  任务分离,如从服务器分担备份工作与计算工作</p><h2 id="redis中的集群"><a href="#redis中的集群" class="headerlink" title="redis中的集群"></a>redis中的集群</h2><p>通常有两种集群的搭建方式：</p><p>1）星型<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231175911.png" style="width:50%"></p><p>2) 链式<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231180020.png" style="width:50%"></p><p>第2种方式的好处:</p><p>master宕机后 , 可以直接切换到 slave1 。</p><h2 id="redis中主从的通信过程"><a href="#redis中主从的通信过程" class="headerlink" title="redis中主从的通信过程"></a>redis中主从的通信过程</h2><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231180204.png" style="width:50%"></p><p>首先，slave向master发出同步的命令，master会将dump文件发给slave，在dump的过程中向master发出的命令再使用aof文件来同步到slave中。之后就使用replicationFeedSlaves来同步。</p><h2 id="redis集群的配置"><a href="#redis集群的配置" class="headerlink" title="redis集群的配置"></a>redis集群的配置</h2><p>Master配置:<br>1:关闭rdb快照(备份工作交给slave)<br>2:可以开启aof</p><p>slave配置:<br>1: <strong>声明slave-of</strong><br>2: 配置密码[如果master有密码]<br>3: [某1个] slave 打开 rdb快照功能<br>4: <strong>配置是否只读[slave-read-only]</strong></p><hr><p>下面开始，真正的操作过程。</p><h3 id="redis中简单的主从复制配置"><a href="#redis中简单的主从复制配置" class="headerlink" title="redis中简单的主从复制配置"></a>redis中简单的主从复制配置</h3><p>准备搭 ：1个master + 2个slave的redis集群。</p><p>这里是模拟集群，可以使用多个配置文件来模拟多个redis服务器。启动一个配置文件，就是一个redis服务器。</p><p>master的配置文件：关闭rdb，开启aof。</p><p>第一个slave服务器：开启rdb，关闭aof，开启slave只读。</p><p>第二个slave服务器：rdb、aof都不关闭，开启slave只读。</p><hr><p>将当前目录下的redis.conf文件，复制两份，改个名字。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231202510.png"></p><p><strong>修改master的redis.conf配置文件：</strong><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231202701.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231203232.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231203341.png"></p><p><strong>修改第一个slave的redis6780.conf的配置文件</strong><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231203939.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231204258.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231204410.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231204626.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231205035.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231205144.png"></p><p><strong>修改第二个slave的redis6781.conf的配置文件</strong><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231205323.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231205428.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231205538.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231205726.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231205849.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231205940.png"></p><hr><p>分别启动这个三个redis服务器：</p><p>启动之前先删除之前的rdb与aof文件，避免形成干扰。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231211210.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231210422.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231210638.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231214510.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20181231214713.png"></p><p>发现，我们往master中插入name数据后，在两个slave服务器中，根本就没有name数据。</p><font color="red"><strong>这是为啥呢？这是因为redis版本更新后，在slave中配置master的ip时候，不能使用localhost ！！！必须是ip地址，即要写成127.0.0.1</strong></font><p>将两个slave中的：<code>replicaof 127.0.0.1 6379</code> 这样写就可以了。</p><p>下面是三个redis配置文件中的详细信息：</p><p>master：redis.conf</p><pre><code>bind 127.0.0.1   # 实际生产中，添加自己的ip地址。port 6379daemonize yespidfile /var/run/redis_6379.pid#save 900 1                     # master:关闭rdb，留给slave来完成#save 300 10#save 60 10000dbfilename dump6379.rdbdir /var/rdbappendonly yes                  # master：开启aof。appendfilename &quot;appendonly6379.aof&quot;</code></pre><p>slave：redis6780.conf</p><pre><code>bind 127.0.0.1   # 实际生产中，添加自己的ip地址。port 6780daemonize yespidfile /var/run/redis_6780.pidsave 900 1                     # 6780的slave开启：rdbsave 300 10save 60 10000dbfilename dump6780.rdbdir /var/rdbappendonly no                  # 关闭aof功能，因为master已经开启了appendfilename &quot;appendonly6780.aof&quot;#配置主从复制replicaof 127.0.0.1 6379  # 配置master的ip地址和端口号。注意这里不能写localhost！！！replica-read-only yes     # slave只读。</code></pre><p>slave：redis6781.conf</p><pre><code>bind 127.0.0.1   # 实际生产中，添加自己的ip地址。port 6781daemonize yespidfile /var/run/redis_6781.pid#save 900 1                     # 关闭rdb功能#save 300 10#save 60 10000dbfilename dump6781.rdbdir /var/rdbappendonly no                  # 关闭aof功能appendfilename &quot;appendonly6781.aof&quot;#配置主从复制replicaof 127.0.0.1 6379  # 配置master的ip地址和端口号。注意这里不能写localhost！！！replica-read-only yes     # slave只读。</code></pre><p>这样：分别启动三个redis客户端来验证，数据就一致了。</p><p><strong>注意：高版本的redis主从复制中配置文件中，是：replicaof 、replica-read-only；低版本中是：slaveof、slave-read-only。</strong></p><hr><p>下面，来演示redis-2版本之上的版本集群搭建方式：</p><h3 id="redis中的集群搭建"><a href="#redis中的集群搭建" class="headerlink" title="redis中的集群搭建"></a>redis中的集群搭建</h3><p>上面，我们演示了redis中的，简单主从复制的搭建，比较简单。其实slave就是将master中的数据拷贝了一份。<br>而redis中的集群的话，就不是那么简单了，当我们访问其中一个redis服务器时，首先会使用hash算法，定位到具体要使用哪个redis服务器，详细理论知识请看官网。</p><p>下面开始redis的搭建过程。</p><p>Redis的集群部署需要在每台集群部署的机器上安装Redis，然后修改配置以集群的方式启动。</p><p>这里演示的话，就是使用多个redis.conf配置文件来模拟redis集群。</p><h4 id="搭建redis集群"><a href="#搭建redis集群" class="headerlink" title="搭建redis集群"></a>搭建redis集群</h4><p>1）现在搭建redis集群，<strong>最小集群模式需要三个master实例</strong>，一般建议起六个实例，即三主三从。因此我们创建6个以端口号命名的目录存放实例的配置文件和其他信息。</p><pre><code>mkdir redis-clustercd redis-clustermkdir 7000 7001 7002 7003 7004 7005</code></pre><p>在对应端口号的目录中复制一份redis.conf的文件。每个配置文件中的端口号port参数改为对应目录的端口号。</p><p>目录结构可参考：</p><pre><code>redis-cluster/├── 7000│   ├── appendonly.aof│   ├── dump.rdb│   ├── nodes-7000.conf│   └── redis.conf├── 7001│   ├── appendonly.aof│   ├── dump.rdb│   ├── nodes-7001.conf│   └── redis.conf├── 7002│   ├── appendonly.aof│   ├── dump.rdb│   ├── nodes-7002.conf│   └── redis.conf├── 7003│   ├── appendonly.aof│   ├── dump.rdb│   ├── nodes-7003.conf│   └── redis.conf├── 7004│   ├── appendonly.aof│   ├── dump.rdb│   ├── nodes-7004.conf│   └── redis.conf├── 7005│   ├── appendonly.aof│   ├── dump.rdb│   ├── nodes-7005.conf│   └── redis.conf</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101112544.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101113222.png"></p><p>每个redis.conf配置文件的大致需要配置的内容：</p><pre><code>#可选操作，该项设置后台方式运行，daemonize yes                       # 开启后台运行bind 127.0.0.1                      # 如果是实际中，填写每个机器的ip地址port 7000                           # 对应每个文件夹的名字，设置不同的端口号pidfile /var/run/redis_7000.pid     # 设置pid文件，对应每个端口号cluster-enabled yes                 # 开启redis的集群cluster-config-file nodes-7000.conf # redis集群节点信息文件cluster-node-timeout 5000           # redis集群节点连接超时的设置appendonly yes                      # 开启aof持久化</code></pre><p>以7000为例：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101114057.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101114230.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101114311.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101114349.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101114436.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101114551.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101123950.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101115015.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101115120.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101120216.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101115259.png"></p><p>7003：<br>只是开启rdb持久化。7000-7002：master，关闭rdb；7003-7005：slaver，开启rdb。<br>其他的配置类似于7000。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101114700.png"></p><h4 id="启动redis服务器"><a href="#启动redis服务器" class="headerlink" title="启动redis服务器"></a>启动redis服务器</h4><p>2）启动六个redis服务器<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101121530.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101124528.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101124720.png"></p><p>如果是使用前台的方式启动redis服务器的话，会出现：</p><pre><code>[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I&#39;m 97a3a64667477371c4479320d683e4c8db5858b1</code></pre><p>每个实例都会生成一个Node ID，类似97a3a64667477371c4479320d683e4c8db5858b1，用来作为Redis实例在集群中的唯一标识，而不是通过IP和Port，IP和Port可能会改变，该Node ID不会改变。</p><h4 id="使用redis-trib创建集群"><a href="#使用redis-trib创建集群" class="headerlink" title="使用redis-trib创建集群"></a>使用redis-trib创建集群</h4><p>3）使用redis-trib创建集群</p><p>redis的实例全部运行之后，还需要redis-trib.rb工具来完成集群的创建，redis-trib.rb二进制文件在Redis包主目录下的src目录中，运行该工具依赖 <strong>ruby环境 和 gem</strong>，因此需要提前安装。</p><h5 id="安装：ruby"><a href="#安装：ruby" class="headerlink" title="安装：ruby"></a>安装：ruby</h5><p>安装：ruby</p><p><code>yum -y install ruby rubygems</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101125702.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101125829.png"></p><p>查看ruby的版本：<br><code>ruby --version</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101130020.png"></p><p><strong>由于centos系统默认支持Ruby版本为2.0.0，因此执行 gem install redis 命令时会报以下错误。</strong></p><p><code>gem install redis</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101130250.png"></p><p><strong>解决方法是先安装 rvm，再升级ruby版本。</strong></p><h5 id="安装：rvm"><a href="#安装：rvm" class="headerlink" title="安装：rvm"></a>安装：rvm</h5><p>安装rvm</p><p><code>curl -L get.rvm.io | bash -s stable</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101130536.png"></p><p>如果出现以下错误：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101130655.png"></p><p>则执行报错中的：<code>gpg2 --keyserver ·····</code> 命令。</p><pre><code>gpg2 --keyserver hkp://pool.sks-keyservers.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101131331.png"></p><p>再次执行命令curl -L get.rvm.io | bash -s stable。例如：</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101131715.png"></p><p>以上表示执行成功，然后执行以下命令。</p><p><code>source /usr/local/rvm/scripts/rvm</code></p><p>查看rvm库中已知的ruby版本</p><p><code>rvm list known</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101131922.png"></p><h5 id="升级：ruby"><a href="#升级：ruby" class="headerlink" title="升级：ruby"></a>升级：ruby</h5><p>升级Ruby:</p><pre><code>#安装rubyrvm install 2.5.0#使用新版本rvm use  2.5.0#移除旧版本rvm remove 2.0.0#查看当前版本ruby --version</code></pre><p>例如：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101134937.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101135058.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101135223.png"></p><h5 id="安装：gem"><a href="#安装：gem" class="headerlink" title="安装：gem"></a>安装：gem</h5><p>安装：gem</p><p><code>gem install redis</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101135356.png"></p><hr><h5 id="redis-trib-rb"><a href="#redis-trib-rb" class="headerlink" title="redis-trib.rb"></a>redis-trib.rb</h5><p>以上前提工具终于安装好了，可以开始执行：redis-trib.rb 命令</p><p>在redis的src源码下，存在：redis-trib.rb 命令。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101135937.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101140009.png"></p><p>在src目录下：执行<br><code>./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</code></p><pre><code>参数create表示创建一个新的集群，--replicas 1 :表示为每个master创建一个slave。</code></pre><p>如果创建成功会显示以下信息</p><pre><code>[OK] All 16384 slots covered</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101140758.png"></p><p><code>./redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1</code></p><p>执行成功后会停止在：</p><p>Can I set the above configuration? (type ‘yes’ to accept):</p><p>输入：yes 即可。</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101141229.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101141342.png"></p><hr><h4 id="部署结果验证"><a href="#部署结果验证" class="headerlink" title="部署结果验证"></a>部署结果验证</h4><p>4) 部署结果验证</p><p>1、客户端验证</p><p>使用客户端redis-cli二进制访问某个实例，执行set和get的测试。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101142210.png"></p><p><strong>注意：</strong> -h：填写实际中的ip地址，-p：端口号，<strong>-c：代表连接的是redis集群</strong>（一定要带上-c）<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101142637.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101142956.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101143006.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101143225.png"></p><p>2、集群状态</p><p>使用 cluster info 命令查看集群状态。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101143436.png"></p><p>3、节点状态</p><p>使用cluster nodes命令查看节点状态。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101143720.png"></p><h2 id="配置master密码"><a href="#配置master密码" class="headerlink" title="配置master密码"></a>配置master密码</h2><p>一般，我们搭建redis集群是在内网中，所以，不需要设置master密码，也不许要配置防火墙，这样会加快redis的访问速度。</p><p>如果，你一定要为了安全性，要配置master的密码的话。</p><p>首先退出redis集群，杀死六个redis服务器进程。</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101145033.png"></p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p><strong>修改所有redis集群中的redis.conf文件 </strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101145328.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101145614.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101150746.png"></p><p><strong>注意所有节点的密码都必须一致，masterauth也要加的。</strong></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><strong>通过指令找到安装的redis在ruby环境中的配置client.rb</strong></p><pre><code>find / -name &quot;client.rb&quot;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101151416.png"></p><p>编辑该文件:</p><pre><code>vim /usr/local/rvm/gems/ruby-2.5.0/gems/redis-4.1.0/lib/redis/client.rb</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101151542.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101151614.png"></p><p>修改其中的密码配置：pass</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101151753.png"></p><p>之后重启Redis，即可。</p><hr><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101152529.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101152635.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101152738.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101152836.png"></p><p><strong>现在，必须使用带密码的参数来连接redis服务器才有权限</strong><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101153331.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101153455.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day08/QQ截图20190101153612.png"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中的aof日志持久化</title>
      <link href="/2018/12/31/redis-zhong-de-aof-ri-zhi-chi-jiu-hua/"/>
      <url>/2018/12/31/redis-zhong-de-aof-ri-zhi-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<p>接着上篇的内容，来讲述redis中的aof日志持久化操作</p><p>通过上篇，我们知道了redis中的rdb快照持久化操作，但是由于其存在丢失数据的现象，所以提出了aof持久化的操作。</p><p>rdb恢复数据的速度是比aof快的，aof是通过将每次执行的操作命令，写入到一个文件中保存起来，当作持久化的。</p><h2 id="aof的原理"><a href="#aof的原理" class="headerlink" title="aof的原理"></a>aof的原理</h2><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231154133.png"></p><p>现在提出两个问题：</p><p>1:每次执行一次命令都要写入到aof文件中吗?<br>2:某key操作100次,产生100行记录,aof文件会很大,怎么解决?</p><p>首先先思考，在后面的学习中，会依次解决这两个问题。</p><h2 id="aof的配置选项"><a href="#aof的配置选项" class="headerlink" title="aof的配置选项"></a>aof的配置选项</h2><p>打开redis.conf文件<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231154509.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231154616.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231154717.png"></p><p>主要关注aof中几个重点配置选项</p><pre><code>appendonly no        # 是否仅要日志,就是是否开启aof日志appendfsync always   # 系统不缓冲,每次执行一次命令，就写入一次，慢,丢失数据少appendfsync everysec # 折中,每秒写如一次appendfsync no       # 系统缓冲,统一写,由操作系统来决定，速度快no-appendfsync-on-rewrite no     # 当重写aof文件时是否同步最新数据，no同步更新，yes不同步更新auto-AOF-rewrite-percentage 100  # 当前aof文件比上次重写时文件大N%时重写auto-AOF-rewrite-min-size 64mb   # aof重写至少要达到的大小</code></pre><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>1）开启aof日志，并设置aof文件的保存目录以及名字<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231155858.png"></p><p>2）开启redis服务器</p><p>如果已经开启了，就杀死：<code>pkill -9 redis</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231160138.png"></p><p>重新开启redis服务器，使用刚刚修改后的redis.conf配置文件<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231160423.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231160619.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231160709.png"></p><p>3）开启redis的客户端<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231161005.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231161144.png"></p><hr><p>如果aof是每执行一次命令，就向aof文件插入一条数据的话，那就不能体现redis快速缓存的优势了，因为每次都是写入到磁盘上面，和mysql一样了。</p><p>为了平衡 快速读取数据与持久化 ，aof所以出现了：appendfsync 配置。</p><p>根据你的实际需求，设置appendfsync的值，如果数据很重要，不能丢失一丁点，那就always。一般使用：everysec。</p><hr><p>我们也注意到了，每次对同一个key执行操作，都会写入到aof文件中。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231161921.png"></p><p>如果num想加到100，那么aof文件中就会出现很多incr指令，这样不是很浪费空间吗？aof文件会瞬间增涨很多，怎么解决呢？</p><p>redis中，就出现了aof重写的方法。我们知道num最后的状态是100，那么直接存指令set num 100就好了，就不用存在那么多的incr指令，节约空间。</p><p>使用：<code>auto-AOF-rewrite-percentage 和 auto-AOF-rewrite-min-size</code></p><p>如果不使用：auto-AOF-rewrite-min-size的话，前期aof文件很小，每次写入一个命令，都是之前文件的100%倍，那样的话，每次都会重写，因此出现了设置aof文件最小重写的大小，当到达最小要求时，才会重写。</p><p>现在我们来验证这个配置。</p><p>修改aof的最小重写大小，这里是为了方便演示，所以设置成了20mb。</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231162751.png"></p><p>重启redis服务器<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231162920.png"></p><p>使用测试redis性能的执行，来随机执行20000条指令<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231163103.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231163337.png"></p><p>接着再执行20000条数据。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231163530.png"></p><p>在右边的客户端执行redis命令时，左边的一直测试aof文件的大小，发现aof文件一开始是从13M开始增加，当超过20M后，就会突然变小成4.3M了，这是因为触发了aof的重写命令。</p><p>也可以直接执行aof重写的命令来重写：<code>bgrewriteaof</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231164124.png"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>注: 1）在dump rdb过程中 , aof如果停止同步 , 会不会丢失?<br>答: 不会 , 所有的操作缓存在内存的队列里, dump完成后,统一操作.</p><p>注: 2）aof重写是指什么?<br>答: aof重写是指把内存中的数据,逆化成命令,写入到.aof日志里.<br>以解决 aof日志过大的问题.</p><p><strong>问: 3）如果rdb文件,和aof文件都存在,优先用谁来恢复数据?</strong><br>答: <font color="red"><strong>aof</strong></font></p><p>问: 4）2种是否可以同时用?<br>答: 可以,而且推荐这么做</p><p>问: 5）恢复时rdb和aof哪个恢复的快<br>答: rdb快,因为其是数据的内存映射,直接载入到内存,而aof是命令,需要逐条执行.</p><hr><p>演示第三个问题。</p><p>当rdb文件和aof文件同时存在时，会使用aof来恢复数据！！！</p><p>1）首先查看是否存在rdb文件。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231164640.png"></p><p>2）删除aof文件，避免干扰<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231164851.png"></p><p>3）查看现在redis缓存中存在哪些数据<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231164942.png"></p><p>存在site数据。</p><p>4）杀死redis服务器，重启redis服务器<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231165054.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231165310.png"></p><p>为啥site不存了呢？这是因为，我们开启了aof日志，但是，目前aof文件中还没有保存任何数据，所以恢复数据的时候，啥也没有！</p><p>查看aof文件的保存目录：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231165538.png"></p><p>现在删除aof文件，并关闭aof日志。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231165659.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231165801.png"></p><p>重启redis服务器<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231170047.png"></p><p>此时site数据又存在了，这是因为，我们关闭了aof日志，此时是依靠rdb文件来恢复数据的。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day07/QQ截图20181231170228.png"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中的rdb快照持久化</title>
      <link href="/2018/12/31/redis-zhong-de-rdb-kuai-zhao-chi-jiu-hua/"/>
      <url>/2018/12/31/redis-zhong-de-rdb-kuai-zhao-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<p>今天来学习redis中的持久化操作，这是redis缓存一大优势。</p><h2 id="rdb的工作原理"><a href="#rdb的工作原理" class="headerlink" title="rdb的工作原理"></a>rdb的工作原理</h2><p>每隔 <font color="red"><strong>N分钟 或 N次写</strong></font> 操作后, 从内存dump数据形成rdb文件 , <font color="red"><strong>压缩</strong></font> 放在 <font color="red">备份<strong>目录</strong></font></p><p>注: <font color="red"><strong>红色部分</strong></font>可通过参数来配置。</p><h2 id="rdb的配置文件"><a href="#rdb的配置文件" class="headerlink" title="rdb的配置文件"></a>rdb的配置文件</h2><p>打开redis.conf文件。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231114006.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231114858.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231115310.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231115344.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231115423.png"></p><p>接下来详细说明：</p><pre><code>save 900 1    #刷新快照到硬盘中，必须满足两者要求才会触发，即900秒之内至少有1个key发生变化。save 300 10   #必须是300秒之内至少有10个key发生变化。save 60 10000 #必须是60秒之内至少有10000个key发生变化。stop-writes-on-bgsave-error yes    #后台存储rdb文件发生错误时停止写入。rdbcompression yes    #使用LZF压缩rdb文件。rdbchecksum yes       #存储和加载rdb文件时校验。dbfilename dump.rdb   #设置rdb文件名。dir ./                #设置工作目录，rdb文件会写入该目录。</code></pre><p>主要说一下：stop-writes-on-bgsave-error的配置。在之前的redis版本中，redis是单进程的，因此在redis在持久化的过程中，如果有其他的客户端发送请求，此时redis服务器是不会响应客户端的请求的，后来redis改版后，可以通过主进程来进行持久化的工作，子进程来响应客户端的请求。此时就会出现一个问题，当主进程进行持久化的过程中，客户端同时在向服务器端发送写的操作，如果突然断电等特殊情况，导致主进程的持久化出现了错误，在这个过程中的客户端的写入是否保存呢？就是该参数来配置的，stop-writes-on-bgsave-error <strong>yes</strong>,那就是此阶段客户端的写操作不写入。</p><hr><h2 id="rdb的缺陷"><a href="#rdb的缺陷" class="headerlink" title="rdb的缺陷"></a>rdb的缺陷</h2><p>在2个保存点之间 , 断电 , 将会丢失（1到N）分钟的数据。</p><p>出于对持久化的更精细要求 , redis增添了aof方式 （append only file）。</p><h3 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h3><p>1）设置保存rdb文件的目录<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231122100.png"></p><p>修改rdb持久化保存目录。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231124756.png"></p><p>2）删除当前目下的dump.rdb文件（防止干扰）<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231122214.png"></p><p>3）开启redis服务器<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231122636.png"></p><p>4）使用redis的工具，一秒钟中set一万条数据<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231122956.png"></p><p>上面的参数写错了，应该是 <code>./bin/redis-benchmark -n 10000</code>. 注意是 <strong>-n</strong><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231123119.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231123547.png"></p><p>5）再次插入一个不相干的数据<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231123710.png"></p><p>6）模拟断电，不正常的情况<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231123844.png"></p><p>7）再次启动redis服务器<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231124112.png"></p><p>8）测试数据是否存在<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231124242.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231124416.png"></p><p>想必，大家应该知道为啥最后的 address没有保存下来了吧，因为是刚刚插入那条数据，就模拟突然断电了，不符合那三个save的要求，所以没有保存。</p><p>这就是redis使用rdb持久化的缺陷，会存在数据丢失的情况。</p><p>查看redis的持久化文件dump.rdb<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231125002.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day06/QQ截图20181231125053.png"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果不想使用rdb来持久化操作，直接注释掉那三个save配置信息即可。</p><p>想要进行更加精细的持久化，请使用aop日志来持久化。一般，我使用两者来进行持久化。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的发布与订阅</title>
      <link href="/2018/12/30/redis-de-fa-bu-yu-ding-yue/"/>
      <url>/2018/12/30/redis-de-fa-bu-yu-ding-yue/</url>
      
        <content type="html"><![CDATA[<p>这篇介绍redis中的发布与订阅的简单操作。</p><h2 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h2><h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><pre><code>subscribe channel [channel ...]订阅给指定频道的信息。一旦客户端进入订阅状态，客户端就只可接受订阅相关的命令。如SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE和PUNSUBSCRIBE命令，除了这些命令，其他命令一律失效。</code></pre><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><pre><code>publish channel message将信息 message 发送到指定的频道 channel返回值收到消息的客户端数量。</code></pre><h3 id="unsubscribe"><a href="#unsubscribe" class="headerlink" title="unsubscribe"></a>unsubscribe</h3><pre><code>unsubscribe channel [channel ...]指示客户端退订给定的频道，若没有指定频道，则退订所有频道.如果没有频道被指定，即，一个无参数的 unsubscribe 调用被执行，那么客户端会将使用 SUBSCRIBE 命令订阅的所有频道都会被退订。在这种情况下，命令会返回一个信息，告知客户端所有被退订的频道。</code></pre><h3 id="psubscribe"><a href="#psubscribe" class="headerlink" title="psubscribe"></a>psubscribe</h3><pre><code>psubscribe channel [channel ...]订阅给定的模式(patterns)。支持的模式(patterns)有:h?llo subscribes to hello, hallo and hxlloh*llo subscribes to hllo and heeeelloh[ae]llo subscribes to hello and hallo, but not hillo如果想输入普通的字符，可以在前面添加\</code></pre><h2 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h2><p>1）开启两个redis客户端</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day05/QQ截图20181231100525.png"></p><p>2）第一个客户端订阅频道news<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day05/QQ截图20181231100701.png"></p><p>3）第二个客户端向news频道发布消息<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day05/QQ截图20181231100910.png"></p><p>4）再开启一个客户端，也订阅news频道<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day05/QQ截图20181231101121.png"></p><p>5）向news频道发送消息<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day05/QQ截图20181231101438.png"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中的简单事务</title>
      <link href="/2018/12/30/redis-zhong-de-jian-dan-shi-wu/"/>
      <url>/2018/12/30/redis-zhong-de-jian-dan-shi-wu/</url>
      
        <content type="html"><![CDATA[<p>今天来学习redis中的简单事务。</p><p>在Redis中只支持简单的事务。</p><h2 id="redis与mysql事务的对比"><a href="#redis与mysql事务的对比" class="headerlink" title="redis与mysql事务的对比"></a>redis与mysql事务的对比</h2><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day04/QQ截图20181230170926.png"></p><p>注: rollback与discard 的区别.</p><p>如果已经成功执行了2条语句, 第3条语句出错.</p><p>在mysql中，rollback后 , 前2条的语句影响消失.<br>在redis中，<font color="red"><strong>discard只是结束本次事务 , 前2条语句造成的影响仍然还在</strong></font></p><hr><p><strong>注意:</strong></p><p>在mutil后面的语句中, 语句出错可能有2种情况</p><p>1: 书写的<strong>指令语法</strong>本身就有问题<br>这种 , 执行exec命令时就会报错, 所有语句得不到执行。</p><p>2: 语法本身没错 , 但像那种命令的操作对象有问题时. 比如 zadd 操作list对象。<br>这种，执行exec命令之后 , <strong>会执行正确的语句 , 并跳过有不适当的语句</strong>.</p><p>(如果zadd操作list这种事怎么避免? 这一点,由程序员负责)</p><hr><h2 id="演示操作"><a href="#演示操作" class="headerlink" title="演示操作"></a>演示操作</h2><p>现在通过演示转账的案例，来讲解redis中的事务。</p><p>首先flushdb，清空redis中的数据库。</p><p>1）设置 wang 和 zhao 的初始化金额</p><pre><code>127.0.0.1:6379&gt; set wang 200OK127.0.0.1:6379&gt; set zhao 700OK127.0.0.1:6379&gt; mget wang zhao1) &quot;200&quot;2) &quot;700&quot;127.0.0.1:6379&gt; </code></pre><p>现在，wang：200元 ，zhao：700元。</p><p>2）zhao 向 wang 转入100元。</p><pre><code>127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incrby wang 100QUEUED127.0.0.1:6379&gt; decrby zhao 100QUEUED127.0.0.1:6379&gt; exec1) (integer) 3002) (integer) 600127.0.0.1:6379&gt; mget wang zhao1) &quot;300&quot;2) &quot;600&quot;127.0.0.1:6379&gt; </code></pre><p>首先使用 <strong>multi命令</strong> 开启redis的事务，之后的所有操作命令都会放到一个队列中（从返回的QUEUED可以看出来），当执行exec命令后，redis会将队列中的所有操作命令一次性执行完毕，即符合原子性。</p><p>最终的结果，wang：300 ，zhao：600 正确。</p><p>3）当操作的语法出现问题时</p><pre><code>127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; set wang 200OK127.0.0.1:6379&gt; set zhao 700OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incrby wang 100QUEUED127.0.0.1:6379&gt; xxxx zhao 100(error) ERR unknown command `xxxx`, with args beginning with: `zhao`, `100`, 127.0.0.1:6379&gt; exec(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; mget wang zhao1) &quot;200&quot;2) &quot;700&quot;127.0.0.1:6379&gt; </code></pre><p>从上演示的操作过程中可以看出，当在multi中执行错误的语法时，会提前退出事务环境，之前所有的操作都不会执行，其实就是放弃了队列中的任务。</p><p>4）当操作没有语法错误，但有操作命令对象不适合时</p><pre><code>127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; set wang 200OK127.0.0.1:6379&gt; set zhao 700OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incrby wang 100QUEUED127.0.0.1:6379&gt; sadd zhao pigQUEUED127.0.0.1:6379&gt; exec1) (integer) 3002) (error) WRONGTYPE Operation against a key holding the wrong kind of value127.0.0.1:6379&gt; mget wang zhao1) &quot;300&quot;2) &quot;700&quot;127.0.0.1:6379&gt; </code></pre><p>上面的操作过程中，故意使用了sadd集合命令来操作字符串对象，但是语法是对的，由于操作对象的不符，当执行exec时，就会发现操作对象的错误提示信息，<strong>但是我们会发现对wang的incrby指令居然执行了！！！，wang增加了100元，变成了300元。因此，redis的事务和mysql的事务不一样，请注意这个细节！！！</strong></p><p>出现类似sadd操作string的这种事时怎么避免呢？<font color="red"><strong>这种事情只能是程序员来避免。</strong></font></p><p>5) 自主回退的情况<br>程序员自己觉得不想执行之前的操作了，想要撤回之前的操作，使用discard。</p><pre><code>127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; set wang 200OK127.0.0.1:6379&gt; set zhao 700OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incrby wang 100QUEUED127.0.0.1:6379&gt; decrby zhao 100QUEUED127.0.0.1:6379&gt; discardOK127.0.0.1:6379&gt; mget wang zhao1) &quot;200&quot;2) &quot;700&quot;127.0.0.1:6379&gt; </code></pre><p>当不想执行之前的命令时，使用discard命令即可，redis就会把队列里的命令都丢掉，不执行。</p><hr><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>我正在买票：ticket -1 , money -100 。<br>而票只有1张, 如果在我multi之后 , 和exec之前, 票被别人买了<code>---即ticket变成0了.</code><br>我该如何观察这种情景,并不再提交呢？</p><p>1）首先开启两个redis客户端。</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day04/QQ截图20181230202305.png"></p><p>2）在一个客户端中，设置ticket票数为1，lisi：300元，wangwu：300元，票价为200。</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day04/QQ截图20181230202426.png"></p><p>3）在一个客户端中，执行multi，将票数减一，lisi减200元，但是不执行exec；在另一个客户端中，执行<br>multi，将票数减一，wangwu减200元，执行exec；在执行exec完成后，在第一个客户端中执行exec。</p><p><strong>第一个客户端中：</strong><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day04/QQ截图20181230203003.png"></p><p><strong>第二个客户端中：</strong><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day04/QQ截图20181230203230.png"></p><p><strong>第一个客户端中：</strong><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day04/QQ截图20181230203517.png"></p><p>解决这种问题，通常有两种解决办法：</p><p>悲观的想法：</p><p>世界是充满危险的，肯定有人同时和我抢票，给ticket上锁，只有我能操作。[悲观锁]</p><p>乐观的想法：</p><p>没有那么多人和我抢,因此,我只需要注意,有没有人更改ticket的值就可以了。[乐观锁]</p><font color="blue"><strong>Redis的事务中,启用的是乐观锁,只负责监测key没有被改动.</strong></font><p>具体是使用watch命令。</p><p><strong>第一个客户端中：</strong><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day04/QQ截图20181230204011.png"></p><p><strong>第二个客户端中：</strong><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day04/QQ截图20181230204339.png"></p><p><strong>第一个客户端中：</strong><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day04/QQ截图20181230204536.png"></p><hr><p>watch命令</p><pre><code>WATCH key [key ...]监视多个key的值的变化</code></pre><p>unwatch命令</p><pre><code>解除掉所有的被watch命令监视的key值</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的hash命令操作</title>
      <link href="/2018/12/25/redis-de-hash-ming-ling-cao-zuo/"/>
      <url>/2018/12/25/redis-de-hash-ming-ling-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>今天来学习redis中的最后一个数据结构hash结构。</p><p>redis中的hash的key-value，我一般称为field-value：域和值。主要是为了区别设置时候的key。</p><h2 id="hset-key-field-value"><a href="#hset-key-field-value" class="headerlink" title="hset key field value"></a>hset key field value</h2><pre><code>设置 key 指定的哈希集中指定字段的值。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。如果字段在哈希集中存在，它将被重写。返回值integer-reply：含义如下1如果field是一个新的字段0如果field原来在map里面已经存在redis&gt; HSET myhash field1 &quot;Hello&quot;(integer) 1redis&gt; HGET myhash field1&quot;Hello&quot;redis&gt; </code></pre><h2 id="hsetnx-key-field-value"><a href="#hsetnx-key-field-value" class="headerlink" title="hsetnx key field value"></a>hsetnx key field value</h2><pre><code>只在 key 指定的哈希集中不存在指定的字段时，设置字段的值。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。如果字段已存在，该操作无效果。redis&gt; HSETNX myhash field &quot;Hello&quot;(integer) 1redis&gt; HSETNX myhash field &quot;World&quot;(integer) 0redis&gt; HGET myhash field&quot;Hello&quot;redis&gt; </code></pre><h2 id="hmset-key-field-value-field-value-…"><a href="#hmset-key-field-value-field-value-…" class="headerlink" title="hmset key field value [field value …]"></a>hmset key field value [field value …]</h2><pre><code>hset：只能为key设置一组field-value，不能设置多组。hmset：能够设置多组field-value。设置 key 指定的哈希集中指定字段的值。该命令将重写所有在哈希集中存在的字段。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。redis&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;OKredis&gt; HGET myhash field1&quot;Hello&quot;redis&gt; HGET myhash field2&quot;World&quot;redis&gt;</code></pre><h2 id="hget-key-field"><a href="#hget-key-field" class="headerlink" title="hget key field"></a>hget key field</h2><pre><code>返回 key 指定的哈希集中该字段所关联的值。redis&gt; HSET myhash field1 &quot;foo&quot;(integer) 1redis&gt; HGET myhash field1&quot;foo&quot;redis&gt; HGET myhash field2(nil)redis&gt;</code></pre><h2 id="hmget-key-field-field-…"><a href="#hmget-key-field-field-…" class="headerlink" title="hmget key field [field …]"></a>hmget key field [field …]</h2><pre><code>返回 key 指定的哈希集中指定字段的值。对于哈希集中不存在的每个字段，返回 nil 值。因为不存在的keys被认为是一个空的哈希集，对一个不存在的 key 执行 HMGET 将返回一个只含有 nil 值的列表。redis&gt; HSET myhash field1 &quot;Hello&quot;(integer) 1redis&gt; HSET myhash field2 &quot;World&quot;(integer) 1redis&gt; HMGET myhash field1 field2 nofield1) &quot;Hello&quot;2) &quot;World&quot;3) (nil)redis&gt; </code></pre><h2 id="hgetall-key"><a href="#hgetall-key" class="headerlink" title="hgetall key"></a>hgetall key</h2><pre><code>返回 key 指定的哈希集中所有的字段和值。返回值中，每个字段名的下一个是它的值，所以返回值的长度是哈希集大小的两倍。redis&gt; HSET myhash field1 &quot;Hello&quot;(integer) 1redis&gt; HSET myhash field2 &quot;World&quot;(integer) 1redis&gt; HGETALL myhash1) &quot;field1&quot;2) &quot;Hello&quot;3) &quot;field2&quot;4) &quot;World&quot;redis&gt; </code></pre><h2 id="hdel-key-field-field-…"><a href="#hdel-key-field-field-…" class="headerlink" title="hdel key field [field …]"></a>hdel key field [field …]</h2><pre><code>从 key 指定的哈希集中移除指定的域。在哈希集中不存在的域将被忽略。如果 key 指定的哈希集不存在，它将被认为是一个空的哈希集，该命令将返回0。redis&gt; HSET myhash field1 &quot;foo&quot;(integer) 1redis&gt; HDEL myhash field1(integer) 1redis&gt; HDEL myhash field2(integer) 0redis&gt; </code></pre><h2 id="hexists-key-field"><a href="#hexists-key-field" class="headerlink" title="hexists key field"></a>hexists key field</h2><pre><code>返回hash里面field是否存在。integer-reply, 含义如下：1 hash里面包含该field。0 hash里面不包含该field或者key不存在。redis&gt; HSET myhash field1 &quot;foo&quot;(integer) 1redis&gt; HEXISTS myhash field1(integer) 1redis&gt; HEXISTS myhash field2(integer) 0redis&gt; </code></pre><h2 id="hincrby-key-field-increment"><a href="#hincrby-key-field-increment" class="headerlink" title="hincrby key field increment"></a>hincrby key field increment</h2><pre><code>增加 key 指定的哈希集中指定字段的数值。如果 key 不存在，会创建一个新的哈希集并与 key 关联。如果字段不存在，则字段的值在该操作执行前被设置为 0。HINCRBY 支持的值的范围限定在 64位 有符号整数。redis&gt; HSET myhash field 5(integer) 1redis&gt; HINCRBY myhash field 1(integer) 6redis&gt; HINCRBY myhash field -1(integer) 5redis&gt; HINCRBY myhash field -10(integer) -5redis&gt; </code></pre><h2 id="hincrbyfloat-key-field-increment"><a href="#hincrbyfloat-key-field-increment" class="headerlink" title="hincrbyfloat key field increment"></a>hincrbyfloat key field increment</h2><pre><code>为指定key的hash的field字段值执行float类型的increment加。如果field不存在，则在执行该操作前设置为0.如果出现下列情况之一，则返回错误：field的值包含的类型错误(不是字符串)。当前field或者increment不能解析为一个float类型。redis&gt; HSET mykey field 10.50(integer) 1redis&gt; HINCRBYFLOAT mykey field 0.1&quot;10.6&quot;redis&gt; HSET mykey field 5.0e3(integer) 1redis&gt; HINCRBYFLOAT mykey field 2.0e2&quot;5200&quot;redis&gt; </code></pre><h2 id="hlen-key"><a href="#hlen-key" class="headerlink" title="hlen key"></a>hlen key</h2><pre><code>返回 key 指定的哈希集包含的字段的数量。redis&gt; HSET myhash field1 &quot;Hello&quot;(integer) 1redis&gt; HSET myhash field2 &quot;World&quot;(integer) 1redis&gt; HLEN myhash(integer) 2redis&gt;</code></pre><h2 id="hstrlen-key-field"><a href="#hstrlen-key-field" class="headerlink" title="hstrlen key field"></a>hstrlen key field</h2><pre><code>返回hash指定field的value的字符串长度，如果hash或者field不存在，返回0。redis&gt; HMSET myhash f1 HelloWorld f2 99 f3 -256OKredis&gt; HSTRLEN myhash f1(integer) 10redis&gt; HSTRLEN myhash f2(integer) 2redis&gt; HSTRLEN myhash f3(integer) 4redis&gt;</code></pre><hr><h2 id="hkeys-key"><a href="#hkeys-key" class="headerlink" title="hkeys key"></a>hkeys key</h2><pre><code>返回 key 指定的哈希集中所有字段的名字。redis&gt; HSET myhash field1 &quot;Hello&quot;(integer) 1redis&gt; HSET myhash field2 &quot;World&quot;(integer) 1redis&gt; HKEYS myhash1) &quot;field1&quot;2) &quot;field2&quot;redis&gt; </code></pre><h2 id="hvals-key"><a href="#hvals-key" class="headerlink" title="hvals key"></a>hvals key</h2><pre><code>返回 key 指定的哈希集中所有字段的值。redis&gt; HSET myhash field1 &quot;Hello&quot;(integer) 1redis&gt; HSET myhash field2 &quot;World&quot;(integer) 1redis&gt; HVALS myhash1) &quot;Hello&quot;2) &quot;World&quot;redis&gt; </code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的sorted set命令操作</title>
      <link href="/2018/12/23/redis-de-sorted-set-ming-ling-cao-zuo/"/>
      <url>/2018/12/23/redis-de-sorted-set-ming-ling-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>redis中的有序集合：sorted set。</p><p>上一篇文章中，我们学习了redis中的集合set的相关操作，今天来学redis中的有序集合。set集合中，我们知道是无序性的，所以redis就出了一个有序的集合，方便用户操作使用。</p><p>有序集合的相关命令对比set集合，就是将s变成了z。</p><h2 id="zadd-key-NX-XX-CH-INCR-score-member-score-member-…"><a href="#zadd-key-NX-XX-CH-INCR-score-member-score-member-…" class="headerlink" title="zadd key [NX|XX] [CH] [INCR] score member [score member …]"></a>zadd key [NX|XX] [CH] [INCR] score member [score member …]</h2><pre><code>Redis Zadd 命令用于将一个或多个成员元素及其分数值加入到有序集当中。如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。分数值可以是整数值或双精度浮点数。如果有序集合 key 不存在，则创建一个空的有序集并执行 ZADD 操作。当 key 存在但不是有序集类型时，返回一个错误。XX：仅更新已存在的元素。 永远不要添加元素NX：不要更新现有元素。   始终添加新元素。CH：将返回值从添加的新元素数修改为更改的元素总数（CH是已更改的缩写）。     更改的元素是添加的新元素和已更新分数的已存在元素。 因此，命令行中指定的元素具有与过去相同的分数，不计算在内。     注意：通常ZADD的返回值仅计算添加的新元素的数量。INCR：指定此选项时，ZADD的作用类似于ZINCRBY。 在此模式下只能指定一个得分元素对。注意： 在 Redis 2.4 版本以前， ZADD 每次只能添加一个元素。redis 127.0.0.1:6379&gt; ZADD myset 1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; ZADD myset 1 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; ZADD myset 2 &quot;world&quot; 3 &quot;bar&quot;(integer) 2redis 127.0.0.1:6379&gt; ZRANGE myzset 0 -1 WITHSCORES1) &quot;hello&quot;2) &quot;1&quot;3) &quot;foo&quot;4) &quot;1&quot;5) &quot;world&quot;6) &quot;2&quot;7) &quot;bar&quot;8) &quot;3&quot;</code></pre><h2 id="zcard-key"><a href="#zcard-key" class="headerlink" title="zcard key"></a>zcard key</h2><pre><code>Redis Zcard 命令用于计算集合中元素的数量。redis 127.0.0.1:6379&gt; ZADD myset 1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; ZADD myset 1 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; ZADD myset 2 &quot;world&quot; 3 &quot;bar&quot;(integer) 2redis 127.0.0.1:6379&gt; ZCARD myzset(integer) 4</code></pre><h2 id="zcount-key-min-max"><a href="#zcount-key-min-max" class="headerlink" title="zcount key min max"></a>zcount key min max</h2><pre><code>计算在有序集合中指定区间分数的成员数min和max指的是score分数，不是排名！！！redis 127.0.0.1:6379&gt; ZADD myzset 1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; ZADD myzset 1 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; ZADD myzset 2 &quot;world&quot; 3 &quot;bar&quot;(integer) 2redis 127.0.0.1:6379&gt; ZCOUNT myzset 1 3(integer) 4</code></pre><h2 id="zincrby-key-increment-member"><a href="#zincrby-key-increment-member" class="headerlink" title="zincrby key increment member"></a>zincrby key increment member</h2><pre><code>Redis Zincrby 命令对有序集合中指定成员member的分数加上增量 increment可以通过传递一个负数值 increment ，让分数减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。当 key 不存在，或member不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。当 key 不是有序集类型时，返回一个错误。分数值可以是整数值或双精度浮点数。redis 127.0.0.1:6379&gt; ZADD myzset 1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; ZADD myzset 1 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; ZINCRBY myzset 2 &quot;hello&quot;(integer) 3redis 127.0.0.1:6379&gt; ZRANGE myzset 0 -1 WITHSCORES1) &quot;foo&quot;2) &quot;2&quot;3) &quot;hello&quot;4) &quot;3&quot;</code></pre><h2 id="zrange-key-start-stop-withscores"><a href="#zrange-key-start-stop-withscores" class="headerlink" title="zrange key start stop [withscores]"></a>zrange key start stop [withscores]</h2><pre><code>Redis Zrange 返回有序集中，指定区间内的成员。其中成员的位置按分数值递增(从小到大)来排序。具有相同分数值的成员按字典序(lexicographical order )来排列。如果你需要成员按值递减(从大到小)来排列，请使用 zrevrange 命令。下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。[withscores]:选项用来表示是否输出分数score。redis 127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES             # 显示整个有序集成员1) &quot;jack&quot;2) &quot;3500&quot;3) &quot;tom&quot;4) &quot;5000&quot;5) &quot;boss&quot;6) &quot;10086&quot;redis 127.0.0.1:6379&gt; ZRANGE salary 1 2 WITHSCORES              # 显示有序集下标区间 1 至 2 的成员1) &quot;tom&quot;2) &quot;5000&quot;3) &quot;boss&quot;4) &quot;10086&quot;redis 127.0.0.1:6379&gt; ZRANGE salary 0 200000 WITHSCORES         # 测试 end 下标超出最大下标时的情况1) &quot;jack&quot;2) &quot;3500&quot;3) &quot;tom&quot;4) &quot;5000&quot;5) &quot;boss&quot;6) &quot;10086&quot;redis &gt; ZRANGE salary 200000 3000000 WITHSCORES                  # 测试当给定区间不存在于有序集时的情况(empty list or set)</code></pre><h2 id="zrangebylex-key-min-max-LIMIT-offset-count"><a href="#zrangebylex-key-min-max-LIMIT-offset-count" class="headerlink" title="zrangebylex key min max [LIMIT offset count]"></a>zrangebylex key min max [LIMIT offset count]</h2><pre><code>ZRANGEBYLEX 返回指定成员区间内的成员，按成员字典正序排序, 分数必须相同。 在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行排序时,可以使用Redis中SortSet这种数据结构来处理。min: 字典中排序位置较小的成员,必须以&quot;[&quot;开头,或者以&quot;(&quot;开头,可使用&quot;-&quot;代替max: 字典中排序位置较大的成员,必须以&quot;[&quot;开头,或者以&quot;(&quot;开头,可使用&quot;+&quot;代替limit: 返回结果是否分页,指令中包含LIMIT后 offset 、count必须输入offset: 返回结果起始位置count: 返回结果数量提示:分数必须相同! 如果有序集合中的成员分数有不一致的,返回的结果就不准。成员字符串作为二进制数组的字节数进行比较。默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。可以使用 “-“ 和 “+” 表示得分最小值和最大值“min” 和 “max” 不能反, “max” 放前面 “min”放后面会导致返回结果为空与ZRANGEBYLEX获取顺序相反的指令是ZREVRANGEBYLEX。源码中采用C语言中 memcmp() 函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠后。可以使用 “-“ 和 “+” 表示得分最小值和最大值:redis&gt; zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1(integer) 12redis&gt; ZRANGEBYLEX zset - + 1) &quot;a&quot; 2) &quot;aa&quot; 3) &quot;abc&quot; 4) &quot;apple&quot; 5) &quot;b&quot; 6) &quot;c&quot; 7) &quot;d&quot; 8) &quot;d1&quot; 9) &quot;dd&quot;10) &quot;dobble&quot;11) &quot;z&quot;12) &quot;z1&quot;获取分页数据:redis&gt; ZRANGEBYLEX zset - + LIMIT 0 31) &quot;a&quot;2) &quot;aa&quot;3) &quot;abc&quot;redis&gt; ZRANGEBYLEX zset - + LIMIT 3 31) &quot;apple&quot;2) &quot;b&quot;3) &quot;c&quot;获取成员之间的元素:默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。“[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。redis&gt; ZRANGEBYLEX zset [aa [c1) &quot;aa&quot;2) &quot;abc&quot;3) &quot;apple&quot;4) &quot;b&quot;5) &quot;c&quot;“min” 和 “max” 不能反, “max” 放前面 “min”放后面会导致返回结果为空redis&gt; ZRANGEBYLEX zset [c [aa(empty list or set)使用 “(“ 小于号获取成员之间的元素:“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。redis&gt; ZRANGEBYLEX zset [aa (c1) &quot;aa&quot;2) &quot;abc&quot;3) &quot;apple&quot;4) &quot;b&quot;</code></pre><h2 id="zrangebyscore-key-min-max-withscores-limit-offset-count"><a href="#zrangebyscore-key-min-max-withscores-limit-offset-count" class="headerlink" title="zrangebyscore key min max [withscores] [limit offset count]"></a>zrangebyscore key min max [withscores] [limit offset count]</h2><pre><code>返回key的有序集合中的分数在min和max之间的所有元素（包括分数等于max或者min的元素）。元素被认为是从低分到高分排序的。具有相同分数的元素按字典序排列（这个根据redis对有序集合实现的情况而定，并不需要进一步计算）。可选的LIMIT参数指定返回结果的数量及区间（类似SQL中SELECT LIMIT offset, count）。注意，如果offset太大，定位offset就可能遍历整个有序集合，这会增加O(N)的复杂度。可选参数WITHSCORES会返回元素和其分数，而不只是元素。这个选项在redis2.0之后的版本都可用。##区间及无限min和max可以是-inf和+inf，这样一来，你就可以在不知道有序集的最低和最高score值的情况下，使用ZRANGEBYSCORE这类命令。默认情况下，区间的取值使用闭区间(小于等于或大于等于)，你也可以通过给参数前增加(符号来使用可选的开区间(小于或大于)。ZRANGEBYSCORE zset (1 5     返回所有符合条件 1 &lt; score &lt;= 5的成员。ZRANGEBYSCORE zset (5 (10   返回所有符合条件 5 &lt; score &lt;  10的成员。例子：redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZRANGEBYSCORE myzset -inf +inf1) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;redis&gt; ZRANGEBYSCORE myzset 1 21) &quot;one&quot;2) &quot;two&quot;redis&gt; ZRANGEBYSCORE myzset (1 21) &quot;two&quot;redis&gt; ZRANGEBYSCORE myzset (1 (2(empty list or set)redis&gt; </code></pre><h2 id="zrank-key-member"><a href="#zrank-key-member" class="headerlink" title="zrank key member"></a>zrank key member</h2><pre><code>返回有序集key中成员member的排名。其中有序集成员按score值递增(从小到大)顺序排列。排名以0为底，也就是说，score值最小的成员排名为0。使用ZREVRANK命令可以获得成员按score值递减(从大到小)排列的排名。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZRANK myzset &quot;three&quot;(integer) 2redis&gt; ZRANK myzset &quot;four&quot;(nil)redis&gt; </code></pre><h2 id="zrem-key-member-member-…"><a href="#zrem-key-member-member-…" class="headerlink" title="zrem key member [member …]"></a>zrem key member [member …]</h2><pre><code>删除有序集合key中的member。当key存在，但是其不是有序集合类型，就返回一个错误。返回的是从有序集合中删除的成员个数，不包括不存在的成员。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZREM myzset &quot;two&quot;(integer) 1redis&gt; ZRANGE myzset 0 -1 WITHSCORES1) &quot;one&quot;2) &quot;1&quot;3) &quot;three&quot;4) &quot;3&quot;redis&gt; </code></pre><h2 id="zremrangebylex-key-min-max"><a href="#zremrangebylex-key-min-max" class="headerlink" title="zremrangebylex key min max"></a>zremrangebylex key min max</h2><pre><code>ZREMRANGEBYLEX 删除名称按字典由低到高排序成员之间所有成员。不要在成员分数不同的有序集合中使用此命令, 因为它是基于分数一致的有序集合设计的,如果使用,会导致删除的结果不正确。待删除的有序集合中,分数最好相同,否则删除结果会不正常。min：字典中排序位置较小的成员,必须以&quot;[&quot;开头,或者以&quot;(&quot;开头,可使用&quot;-&quot;代替max：字典中排序位置较大的成员,必须以&quot;[&quot;开头,或者以&quot;(&quot;开头,可使用&quot;+&quot;代替删除所有元素：可以使用 “-“ 和 “+” 表示最小值和最大值redis&gt; zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1(integer) 12redis&gt; zrangebylex zset - + 1) &quot;a&quot; 2) &quot;aa&quot; 3) &quot;abc&quot; 4) &quot;apple&quot; 5) &quot;b&quot; 6) &quot;c&quot; 7) &quot;d&quot; 8) &quot;d1&quot; 9) &quot;dd&quot;10) &quot;dobble&quot;11) &quot;z&quot;12) &quot;z1&quot;redis&gt; zremrangebylex zset - +(integer) 7redis&gt; zrangebylex zset - +(empty list or set)按名称删除某个元素：下面是删除d1这个元素redis&gt; zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1(integer) 12redis&gt; zrangebylex  zset - + 1) &quot;a&quot; 2) &quot;aa&quot; 3) &quot;abc&quot; 4) &quot;apple&quot; 5) &quot;b&quot; 6) &quot;c&quot; 7) &quot;d&quot; 8) &quot;d1&quot; 9) &quot;dd&quot;10) &quot;dobble&quot;11) &quot;z&quot;12) &quot;z1&quot;redis&gt; zremrangebylex zset [d1 (dd(integer) 1redis&gt; zrangebylex  zset - + 1) &quot;a&quot; 2) &quot;aa&quot; 3) &quot;abc&quot; 4) &quot;apple&quot; 5) &quot;b&quot; 6) &quot;c&quot; 7) &quot;d&quot; 8) &quot;dd&quot; 9) &quot;dobble&quot;10) &quot;z&quot;11) &quot;z1&quot;按名称删除成员之间的元素,包含”max” 和 “min”成员：redis&gt; ZRANGEBYLEX zset - + 1) &quot;a&quot; 2) &quot;aa&quot; 3) &quot;abc&quot; 4) &quot;apple&quot; 5) &quot;b&quot; 6) &quot;c&quot; 7) &quot;d&quot; 8) &quot;dd&quot; 9) &quot;dobble&quot;10) &quot;z&quot;11) &quot;z1&quot;redis&gt; ZREMRANGEBYLEX zset [a [apple(integer) 4redis&gt; ZRANGEBYLEX zset - +1) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;dd&quot;5) &quot;dobble&quot;6) &quot;z&quot;7) &quot;z1&quot;按名称删除成员之间的元素,不包含”max” 和 “min”成员：redis&gt; ZRANGEBYLEX zset - +1) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;dd&quot;5) &quot;dobble&quot;6) &quot;z&quot;7) &quot;z1&quot;     redis&gt; ZREMRANGEBYLEX zset (d (dobble(integer) 1redis&gt; ZRANGEBYLEX zset - +1) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;dobble&quot;5) &quot;z&quot;6) &quot;z1&quot;</code></pre><h2 id="zremrangebyrank-key-start-stop"><a href="#zremrangebyrank-key-start-stop" class="headerlink" title="zremrangebyrank key start stop"></a>zremrangebyrank key start stop</h2><pre><code>移除有序集key中，指定排名(rank)区间内的所有成员。下标参数start和stop都以0为底，0处是分数最小的那个元素。这些索引也可是负数，表示位移从最高分处开始数。例如，-1是分数最高的元素，-2是分数第二高的，依次类推。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZREMRANGEBYRANK myzset 0 1(integer) 2redis&gt; ZRANGE myzset 0 -1 WITHSCORES1) &quot;three&quot;2) &quot;3&quot;redis&gt; </code></pre><h2 id="zremrangebyscore-key-min-max"><a href="#zremrangebyscore-key-min-max" class="headerlink" title="zremrangebyscore key min max"></a>zremrangebyscore key min max</h2><pre><code>移除有序集key中，所有score值介于min和max之间(包括等于min或max)的成员。 自版本2.1.6开始，score值等于min或max的成员也可以不包括在内，语法请参见ZRANGEBYSCORE命令。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZREMRANGEBYSCORE myzset -inf (2(integer) 1redis&gt; ZRANGE myzset 0 -1 WITHSCORES1) &quot;two&quot;2) &quot;2&quot;3) &quot;three&quot;4) &quot;3&quot;redis&gt; </code></pre><hr><h2 id="zrevrank-key-member"><a href="#zrevrank-key-member" class="headerlink" title="zrevrank key member"></a>zrevrank key member</h2><pre><code>返回有序集key中成员member的排名，其中有序集成员按score值从大到小排列。排名以0为底，也就是说，score值最大的成员排名为0。使用ZRANK命令可以获得成员按score值递增(从小到大)排列的排名。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZREVRANK myzset &quot;one&quot;(integer) 2redis&gt; ZREVRANK myzset &quot;four&quot;(nil)redis&gt; </code></pre><h2 id="zrevrange-key-start-stop-withscores"><a href="#zrevrange-key-start-stop-withscores" class="headerlink" title="zrevrange key start stop [withscores]"></a>zrevrange key start stop [withscores]</h2><pre><code>返回有序集key中，指定区间内的成员。其中成员的位置按score值递减(从大到小)来排列。具有相同score值的成员按字典序的反序排列。 除了成员按score值递减的次序排列这一点外，ZREVRANGE命令的其他方面和ZRANGE命令一样redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZREVRANGE myzset 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;redis&gt; ZREVRANGE myzset 2 31) &quot;one&quot;redis&gt; ZREVRANGE myzset -2 -11) &quot;two&quot;2) &quot;one&quot;redis&gt; </code></pre><h2 id="zrevrangebylex-key-max-min-limit-offset-count"><a href="#zrevrangebylex-key-max-min-limit-offset-count" class="headerlink" title="zrevrangebylex key max min [limit offset count]"></a>zrevrangebylex key max min [limit offset count]</h2><pre><code>zrevrangebylex 返回指定成员区间内的成员，按成员字典倒序排序, 分数必须相同。在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行倒序排列时,可以使用Redis中SortSet这种数据结构来处理。</code></pre><h2 id="zrevrangebyscore-key-max-min-withscores-limit-offset-count"><a href="#zrevrangebyscore-key-max-min-withscores-limit-offset-count" class="headerlink" title="zrevrangebyscore key max min [withscores] [limit offset count]"></a>zrevrangebyscore key max min [withscores] [limit offset count]</h2><pre><code>zrevrangebyscore 返回有序集合中指定分数区间内的成员，分数由高到低排序。</code></pre><h2 id="zscore-key-member"><a href="#zscore-key-member" class="headerlink" title="zscore key member"></a>zscore key member</h2><pre><code>返回有序集key中，成员member的score值。如果member元素不是有序集key的成员，或key不存在，返回nil。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZSCORE myzset &quot;one&quot;&quot;1&quot;redis&gt; </code></pre><h2 id="zpopmax-key-count"><a href="#zpopmax-key-count" class="headerlink" title="zpopmax key [count]"></a>zpopmax key [count]</h2><pre><code>删除并返回有序集合key中的最多count个具有最高得分的成员。如未指定，count的默认值为1。指定一个大于有序集合的基数的count不会产生错误。 当返回多个元素时候，得分最高的元素将是第一个元素，然后是分数较低的元素。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZPOPMAX myzset1) &quot;3&quot;2) &quot;three&quot;redis&gt; </code></pre><h2 id="zpopmin-key-count"><a href="#zpopmin-key-count" class="headerlink" title="zpopmin key [count]"></a>zpopmin key [count]</h2><pre><code>删除并返回有序集合key中的最多count个具有最低得分的成员。如未指定，count的默认值为1。指定一个大于有序集合的基数的count不会产生错误。 当返回多个元素时候，得分最低的元素将是第一个元素，然后是分数较高的元素。redis&gt; ZADD myzset 1 &quot;one&quot;(integer) 1redis&gt; ZADD myzset 2 &quot;two&quot;(integer) 1redis&gt; ZADD myzset 3 &quot;three&quot;(integer) 1redis&gt; ZPOPMIN myzset1) &quot;1&quot;2) &quot;one&quot;redis&gt; </code></pre><h2 id="zinterstore-destination-numkeys-key-key-…-weights-weight-aggregate-sum-min-max"><a href="#zinterstore-destination-numkeys-key-key-…-weights-weight-aggregate-sum-min-max" class="headerlink" title="zinterstore destination numkeys key [key …] [weights weight] [aggregate sum|min|max]"></a>zinterstore destination numkeys key [key …] [weights weight] [aggregate sum|min|max]</h2><pre><code>计算给定的numkeys个有序集合的交集，并且把结果放到destination中。 在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。默认情况下，结果中一个元素的分数是有序集合中该元素分数之和，前提是该元素在这些有序集合中都存在。因为交集要求其成员必须是给定的每个有序集合中的成员，结果集中的每个元素的分数和输入的有序集合个数相等。numkeys: 有序集合key的个数。weights：后面加上的是每个key的权重，就是后面的数字乘以每个key的score。aggregate：计算方式，默认是sum：求和。min：numkeys个key中score最小的，max：最大的。如果destination存在，就把它覆盖。127.0.0.1:6379&gt; zadd liu 3 cat 5 dog 7 horse (integer) 3127.0.0.1:6379&gt; zadd deng 4 cat 6 dog 8 horse 1 monkey(integer) 4127.0.0.1:6379&gt; zinterstore result 2 liu deng(integer) 3127.0.0.1:6379&gt; zrange result 0 -1 withscores1) &quot;cat&quot;2) &quot;7&quot;3) &quot;dog&quot;4) &quot;11&quot;5) &quot;horse&quot;6) &quot;15&quot;通过上述的结果看出，默认是求和。127.0.0.1:6379&gt; zinterstore result 2 liu deng weights 2 1(integer) 3127.0.0.1:6379&gt; zrange result 0 -1 withscores1) &quot;cat&quot;2) &quot;10&quot;3) &quot;dog&quot;4) &quot;16&quot;5) &quot;horse&quot;6) &quot;22&quot;liu的权重就是2了，就是liu中的每个score乘以2，deng乘以1；然后求和。127.0.0.1:6379&gt; zinterstore result 2 liu deng aggregate max(integer) 3127.0.0.1:6379&gt; zrange result 0 -1 withscores1) &quot;cat&quot;2) &quot;4&quot;3) &quot;dog&quot;4) &quot;6&quot;5) &quot;horse&quot;6) &quot;8&quot;127.0.0.1:6379&gt; 改变了计算方式：为max了，就是求keys中每个score分数最大的了，不是求和了。</code></pre><h2 id="zunionstore-destination-numkeys-key-key-…-weights-weight-sum-min-max"><a href="#zunionstore-destination-numkeys-key-key-…-weights-weight-sum-min-max" class="headerlink" title="zunionstore destination numkeys key [key …] [weights weight] [sum|min|max]"></a>zunionstore destination numkeys key [key …] [weights weight] [sum|min|max]</h2><pre><code>和zinterstore一样，只是求并集而已。redis&gt; ZADD zset1 1 &quot;one&quot;(integer) 1redis&gt; ZADD zset1 2 &quot;two&quot;(integer) 1redis&gt; ZADD zset2 1 &quot;one&quot;(integer) 1redis&gt; ZADD zset2 2 &quot;two&quot;(integer) 1redis&gt; ZADD zset2 3 &quot;three&quot;(integer) 1redis&gt; ZUNIONSTORE out 2 zset1 zset2 WEIGHTS 2 3(integer) 3redis&gt; ZRANGE out 0 -1 WITHSCORES1) &quot;one&quot;2) &quot;5&quot;3) &quot;three&quot;4) &quot;9&quot;5) &quot;two&quot;6) &quot;10&quot;redis&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的set命令操作</title>
      <link href="/2018/12/23/redis-de-set-ming-ling-cao-zuo/"/>
      <url>/2018/12/23/redis-de-set-ming-ling-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>今天来学习redis中的集合操作命令。</p><p>集合的性质: 唯一性,无序性,确定性</p><p>注: 在string 和 list的命令中,可以通过 range 来访问 string 中的某几个字符或某几个元素</p><p>但,因为集合的无序性,无法通过下标或范围来访问部分元素.</p><h2 id="sadd-key-member-member-…"><a href="#sadd-key-member-member-…" class="headerlink" title="sadd key member [member …]"></a>sadd key member [member …]</h2><pre><code>作用: 往集合key中增加元素。Redis Sadd 命令将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。假如集合 key 不存在，则创建一个只包含添加的元素作成员的集合。当集合 key 不是集合类型时，返回一个错误。注意：在Redis2.4版本以前， SADD 只接受单个成员值。redis&gt; SADD myset &quot;Hello&quot;(integer) 1redis&gt; SADD myset &quot;World&quot;(integer) 1redis&gt; SADD myset &quot;World&quot;(integer) 0redis&gt; SMEMBERS myset1) &quot;World&quot;2) &quot;Hello&quot;redis&gt; </code></pre><h2 id="smembers-key"><a href="#smembers-key" class="headerlink" title="smembers key"></a>smembers key</h2><pre><code>Redis Smembers 命令返回集合中的所有的成员。 不存在的集合 key 被视为空集合。redis 127.0.0.1:6379&gt; SADD myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SMEMBERS myset11) &quot;World&quot;2) &quot;Hello&quot;</code></pre><h2 id="srem-value-value…"><a href="#srem-value-value…" class="headerlink" title="srem value [value…]"></a>srem value [value…]</h2><pre><code>作用: 删除集合中集为 value1 value2的元素返回值: 忽略不存在的元素后,真正删除掉的元素的个数127.0.0.1:6379&gt; sadd gender male famale yao(integer) 3127.0.0.1:6379&gt; 127.0.0.1:6379&gt; smembers gender1) &quot;yao&quot;2) &quot;famale&quot;3) &quot;male&quot;127.0.0.1:6379&gt; srem gender yao(integer) 1127.0.0.1:6379&gt; smembers gender1) &quot;famale&quot;2) &quot;male&quot;</code></pre><h2 id="spop-key"><a href="#spop-key" class="headerlink" title="spop key"></a>spop key</h2><pre><code>作用: 返回并删除集合中key中1个随机元素.随机--体现了无序性.redis 127.0.0.1:6379&gt; SADD myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SPOP myset1&quot;bar&quot;redis 127.0.0.1:6379&gt; SMEMBERS myset11) &quot;Hello&quot;2) &quot;world&quot;不是删除第一个或最后一个插入集合的元素，而是随机删除的！！！</code></pre><h2 id="srandmember-key"><a href="#srandmember-key" class="headerlink" title="srandmember key"></a>srandmember key</h2><pre><code>作用: 返回集合key中,随机的1个元素。只是返回，不删除！！！127.0.0.1:6379&gt; srandmember gender&quot;famale&quot;127.0.0.1:6379&gt; srandmember gender&quot;famale&quot;127.0.0.1:6379&gt; srandmember gender&quot;famale&quot;127.0.0.1:6379&gt; srandmember gender&quot;famale&quot;127.0.0.1:6379&gt; srandmember gender&quot;male&quot;这里不是说famale的概率大啊，是随机的，只是测试次数少，所以看起来好像famale的概率大。</code></pre><h2 id="sismember-key-value"><a href="#sismember-key-value" class="headerlink" title="sismember key value"></a>sismember key value</h2><pre><code>作用: 判断value是否在key集合中是返回1,否返回0redis 127.0.0.1:6379&gt; SADD myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SISMEMBER myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SISMEMBER myset1 &quot;world&quot;(integer) 0</code></pre><h2 id="scard-key"><a href="#scard-key" class="headerlink" title="scard key"></a>scard key</h2><pre><code>作用: 返回集合中元素的个数redis 127.0.0.1:6379&gt; SADD myset &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;hello&quot;(integer) 0redis 127.0.0.1:6379&gt; SCARD myset(integer) 2</code></pre><h2 id="smove-source-dest-member"><a href="#smove-source-dest-member" class="headerlink" title="smove source dest member"></a>smove source dest member</h2><pre><code>作用:把source中的 member 删除 , 并添加到dest集合中。SMOVE 是原子性操作。如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 dest 集合中去。当 dest 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。当 source 或 dest 不是集合类型时，返回一个错误。redis 127.0.0.1:6379&gt; SADD myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SMOVE myset1 myset2 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SMEMBERS myset11) &quot;World&quot;2) &quot;Hello&quot;redis 127.0.0.1:6379&gt; SMEMBERS myset21) &quot;foo&quot;2) &quot;bar&quot;</code></pre><h2 id="sinter-key-key-…"><a href="#sinter-key-key-…" class="headerlink" title="sinter  key [key …]"></a>sinter  key [key …]</h2><pre><code>Redis Sinter 命令返回给定所有给定集合的交集。 不存在的集合 key 被视为空集。 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。redis 127.0.0.1:6379&gt; SADD myset &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SINTER myset myset21) &quot;hello&quot;</code></pre><h2 id="sinterstore-destination-key-key-…"><a href="#sinterstore-destination-key-key-…" class="headerlink" title="sinterstore destination key [key …]"></a>sinterstore destination key [key …]</h2><pre><code>Redis Sinterstore 命令将给定集合之间的交集存储在指定的集合中。如果指定的集合已经存在，则将其覆盖。redis 127.0.0.1:6379&gt; SADD myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SINTERSTORE myset myset1 myset2(integer) 1redis 127.0.0.1:6379&gt; SMEMBERS myset1) &quot;hello&quot;</code></pre><h2 id="sunion-key-key-…"><a href="#sunion-key-key-…" class="headerlink" title="sunion key [key …]"></a>sunion key [key …]</h2><pre><code>Redis Sunion 命令返回给定集合的并集。不存在的集合 key 被视为空集。redis 127.0.0.1:6379&gt; SADD myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SUNION myset1 myset21) &quot;bar&quot;2) &quot;world&quot;3) &quot;hello&quot;4) &quot;foo&quot;</code></pre><h2 id="sunionstore-destination-key-key-…"><a href="#sunionstore-destination-key-key-…" class="headerlink" title="sunionstore destination key [key …]"></a>sunionstore destination key [key …]</h2><pre><code>Redis Sunionstore 命令将给定集合的并集存储在指定的集合 destination 中。redis 127.0.0.1:6379&gt; SADD myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset1 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SUNIONSTORE myset myset1 myset2(integer) 1redis 127.0.0.1:6379&gt; SMEMBERS myset1) &quot;bar&quot;2) &quot;world&quot;3) &quot;hello&quot;4) &quot;foo&quot;</code></pre><h2 id="sdiff-key-key-…"><a href="#sdiff-key-key-…" class="headerlink" title="sdiff key [key …]"></a>sdiff key [key …]</h2><pre><code>Redis Sdiff 命令返回给定集合之间的差集。不存在的集合 key 将视为空集。redis 127.0.0.1:6379&gt; SADD myset &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SDIFF myset myset21) &quot;foo&quot;2) &quot;bar&quot;</code></pre><h2 id="sdiffstore-destination-key-key-…"><a href="#sdiffstore-destination-key-key-…" class="headerlink" title="sdiffstore destination key [key …]"></a>sdiffstore destination key [key …]</h2><pre><code>Redis Sdiffstore 命令将给定集合之间的差集存储在指定的集合中。如果指定的集合 key 已存在，则会被覆盖。redis 127.0.0.1:6379&gt; SADD myset &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset2 &quot;world&quot;(integer) 1redis 127.0.0.1:6379&gt; SDIFFSTORE destset myset myset2(integer) 2redis 127.0.0.1:6379&gt; SMEMBERS destset1) &quot;foo&quot;2) &quot;bar&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的list命令操作</title>
      <link href="/2018/12/22/redis-de-list-ming-ling-cao-zuo/"/>
      <url>/2018/12/22/redis-de-list-ming-ling-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>这篇文章来讲述redis中的list：链表的操作，学过数据结构的应该都清楚，链表的结构，这里就不详细描述了，只讲述redis中的链表操作。</p><h2 id="lpush-key-value-value-…"><a href="#lpush-key-value-value-…" class="headerlink" title="lpush key value [value …]"></a>lpush key value [value …]</h2><pre><code>作用: 把值插入到链接头部[从左边插入]redis&gt; LPUSH mylist &quot;world&quot;(integer) 1redis&gt; LPUSH mylist &quot;hello&quot;(integer) 2redis&gt; LRANGE mylist 0 -11) &quot;hello&quot;2) &quot;world&quot;redis&gt; </code></pre><h2 id="rpush-key-value-value-…"><a href="#rpush-key-value-value-…" class="headerlink" title="rpush key value [value …]"></a>rpush key value [value …]</h2><pre><code>作用: 把值插入到链接尾部[从右边插入]redis&gt; RPUSH mylist &quot;hello&quot;(integer) 1redis&gt; RPUSH mylist &quot;world&quot;(integer) 2redis&gt; LRANGE mylist 0 -11) &quot;hello&quot;2) &quot;world&quot;redis&gt; </code></pre><h2 id="lpop-key"><a href="#lpop-key" class="headerlink" title="lpop key"></a>lpop key</h2><pre><code>作用: 把链接头部的元素弹出[从左边弹出]redis&gt; RPUSH mylist &quot;one&quot;(integer) 1redis&gt; RPUSH mylist &quot;two&quot;(integer) 2redis&gt; RPUSH mylist &quot;three&quot;(integer) 3redis&gt; LPOP mylist&quot;one&quot;redis&gt; LRANGE mylist 0 -11) &quot;two&quot;2) &quot;three&quot;redis&gt; </code></pre><h2 id="rpop-key"><a href="#rpop-key" class="headerlink" title="rpop key"></a>rpop key</h2><pre><code>作用: 把链接尾部的元素弹出[从右边弹出]redis&gt; RPUSH mylist &quot;one&quot;(integer) 1redis&gt; RPUSH mylist &quot;two&quot;(integer) 2redis&gt; RPUSH mylist &quot;three&quot;(integer) 3redis&gt; RPOP mylist&quot;three&quot;redis&gt; LRANGE mylist 0 -11) &quot;one&quot;2) &quot;two&quot;redis&gt; </code></pre><h2 id="lrange-key-start-stop"><a href="#lrange-key-start-stop" class="headerlink" title="lrange key start  stop"></a>lrange key start  stop</h2><pre><code>作用: 返回链表中[start ,stop]中的元素规律: 左数从0开始,右数从-1开始redis&gt; RPUSH mylist &quot;one&quot;(integer) 1redis&gt; RPUSH mylist &quot;two&quot;(integer) 2redis&gt; RPUSH mylist &quot;three&quot;(integer) 3redis&gt; LRANGE mylist 0 01) &quot;one&quot;redis&gt; LRANGE mylist -3 21) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;redis&gt; LRANGE mylist -100 1001) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;redis&gt; LRANGE mylist 5 10(empty list or set)redis&gt; </code></pre><h2 id="lrem-key-count-value"><a href="#lrem-key-count-value" class="headerlink" title="lrem key count value"></a>lrem key count value</h2><pre><code>作用: 从key链表中删除 value值注:   删除count的绝对值个value后结束count&gt;0 从表头删除等于value的值count&lt;0 从表尾删除等于value的值count=0 从链表中删除所有等于value的值127.0.0.1:6379&gt; lrange mylist 0 -1 1) &quot;a&quot; 2) &quot;b&quot; 3) &quot;c&quot; 4) &quot;a&quot; 5) &quot;d&quot; 6) &quot;e&quot; 7) &quot;f&quot; 8) &quot;e&quot; 9) &quot;e&quot;10) &quot;g&quot;127.0.0.1:6379&gt; lrem mylist a(error) ERR wrong number of arguments for &#39;lrem&#39; command127.0.0.1:6379&gt; lrem mylist 0 a(integer) 2127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;e&quot;5) &quot;f&quot;6) &quot;e&quot;7) &quot;e&quot;8) &quot;g&quot;127.0.0.1:6379&gt; lrem mylist 1 e(integer) 1127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;f&quot;5) &quot;e&quot;6) &quot;e&quot;7) &quot;g&quot;127.0.0.1:6379&gt; rpush mylist d(integer) 8127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;f&quot;5) &quot;e&quot;6) &quot;e&quot;7) &quot;g&quot;8) &quot;d&quot;127.0.0.1:6379&gt; lrem mylist -1 d(integer) 1127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;b&quot;2) &quot;c&quot;3) &quot;d&quot;4) &quot;f&quot;5) &quot;e&quot;6) &quot;e&quot;7) &quot;g&quot;</code></pre><h2 id="ltrim-key-start-stop"><a href="#ltrim-key-start-stop" class="headerlink" title="ltrim key start stop"></a>ltrim key start stop</h2><pre><code>作用: 剪切key对应的链接,切[start,stop]一段,并把该段重新赋给keyredis&gt; RPUSH mylist &quot;one&quot;(integer) 1redis&gt; RPUSH mylist &quot;two&quot;(integer) 2redis&gt; RPUSH mylist &quot;three&quot;(integer) 3redis&gt; LTRIM mylist 1 -1&quot;OK&quot;redis&gt; LRANGE mylist 0 -11) &quot;two&quot;2) &quot;three&quot;redis&gt; </code></pre><h2 id="lindex-key-index"><a href="#lindex-key-index" class="headerlink" title="lindex key index"></a>lindex key index</h2><pre><code>作用: 返回index索引上的值,如  lindex key 2redis&gt; LPUSH mylist &quot;World&quot;(integer) 1redis&gt; LPUSH mylist &quot;Hello&quot;(integer) 2redis&gt; LINDEX mylist 0&quot;Hello&quot;redis&gt; LINDEX mylist -1&quot;World&quot;redis&gt; LINDEX mylist 3(nil)redis&gt;</code></pre><h2 id="lset-key-index-value"><a href="#lset-key-index-value" class="headerlink" title="lset key index value"></a>lset key index value</h2><pre><code>作用：在指定的index处，修改value值。redis&gt; RPUSH mylist &quot;one&quot;(integer) 1redis&gt; RPUSH mylist &quot;two&quot;(integer) 2redis&gt; RPUSH mylist &quot;three&quot;(integer) 3redis&gt; LSET mylist 0 &quot;four&quot;&quot;OK&quot;redis&gt; LSET mylist -2 &quot;five&quot;&quot;OK&quot;redis&gt; LRANGE mylist 0 -11) &quot;four&quot;2) &quot;five&quot;3) &quot;three&quot;redis&gt; </code></pre><h2 id="llen-key"><a href="#llen-key" class="headerlink" title="llen key"></a>llen key</h2><pre><code>作用:计算链接表的元素个数redis&gt; LPUSH mylist &quot;World&quot;(integer) 1redis&gt; LPUSH mylist &quot;Hello&quot;(integer) 2redis&gt; LLEN mylist(integer) 2redis&gt;</code></pre><h2 id="linsert-key-after-before-search-value"><a href="#linsert-key-after-before-search-value" class="headerlink" title="linsert  key after|before search value"></a>linsert  key after|before search value</h2><pre><code>作用: 在key链表中寻找’search’ , 并在search值 之后|之前 , 插入value注: 一旦找到一个search后,命令就结束了,因此不会插入多个valueredis&gt; RPUSH mylist &quot;Hello&quot;(integer) 1redis&gt; RPUSH mylist &quot;World&quot;(integer) 2redis&gt; LINSERT mylist BEFORE &quot;World&quot; &quot;There&quot;(integer) 3redis&gt; LRANGE mylist 0 -11) &quot;Hello&quot;2) &quot;There&quot;3) &quot;World&quot;redis&gt; </code></pre><h2 id="rpoplpush-source-dest"><a href="#rpoplpush-source-dest" class="headerlink" title="rpoplpush source dest"></a>rpoplpush source dest</h2><pre><code>作用: 把source的尾部拿出,放在dest的头部,并返回 该单元值注意：这是一个原子操作，那么都成功，要么都失败！！！redis&gt; RPUSH mylist &quot;one&quot;(integer) 1redis&gt; RPUSH mylist &quot;two&quot;(integer) 2redis&gt; RPUSH mylist &quot;three&quot;(integer) 3redis&gt; RPOPLPUSH mylist myotherlist&quot;three&quot;redis&gt; LRANGE mylist 0 -11) &quot;one&quot;2) &quot;two&quot;redis&gt; LRANGE myotherlist 0 -11) &quot;three&quot;redis&gt; ==================================================场景: task + bak 双链表完成安全队列业务逻辑:1:Rpoplpush task  bak2:接收返回值, 并做业务处理3:如果成功 , lpop bak 清除任务。 如不成功 , 下次从bak表里取任务。</code></pre><h2 id="brpop-blpop-key-timeout"><a href="#brpop-blpop-key-timeout" class="headerlink" title="brpop,blpop key timeout"></a>brpop,blpop key timeout</h2><pre><code>作用:等待弹出key的尾/头元素, Timeout为等待超时时间，单位秒如果timeout为0,则一直等待</code></pre><p>使用两个redis客户端来操作。</p><p>在一个redis客户端中弹出mylist里面的数据，但是没有数据，设置过期时间为5秒。</p><p>如果在5秒内，还没有往mylist中插入数据，那么会退出。</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day03/QQ截图20181222202823.png"></p><p>如果在规定的时间内插入了数据，就会弹出该数据。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day03/QQ截图20181222203213.png"></p><p>场景: 长轮询Ajax,在线聊天时,能够用到。</p><h2 id="brpoplpush-source-destination-timeout"><a href="#brpoplpush-source-destination-timeout" class="headerlink" title="brpoplpush source destination timeout"></a>brpoplpush source destination timeout</h2><pre><code>rpoplpush的阻塞版本。</code></pre><hr><h2 id="lpushx-key-value"><a href="#lpushx-key-value" class="headerlink" title="lpushx key value"></a>lpushx key value</h2><pre><code>作用：和lpush一样，只是当key不存在时，不会操作，而lpush当key不存在时，会创建插入数据。redis&gt; LPUSH mylist &quot;World&quot;(integer) 1redis&gt; LPUSHX mylist &quot;Hello&quot;(integer) 2redis&gt; LPUSHX myotherlist &quot;Hello&quot;(integer) 0redis&gt; LRANGE mylist 0 -11) &quot;Hello&quot;2) &quot;World&quot;redis&gt; LRANGE myotherlist 0 -1(empty list or set)redis&gt; </code></pre><h2 id="rpushx-key-value"><a href="#rpushx-key-value" class="headerlink" title="rpushx key value"></a>rpushx key value</h2><pre><code>作用：和rpush一样，只是当key不存在时，不会操作，而lpush当key不存在时，会创建插入数据。redis&gt; RPUSH mylist &quot;Hello&quot;(integer) 1redis&gt; RPUSHX mylist &quot;World&quot;(integer) 2redis&gt; RPUSHX myotherlist &quot;World&quot;(integer) 0redis&gt; LRANGE mylist 0 -11) &quot;Hello&quot;2) &quot;World&quot;redis&gt; LRANGE myotherlist 0 -1(empty list or set)redis&gt; </code></pre><hr><h2 id="面试题：setbit-的实际应用"><a href="#面试题：setbit-的实际应用" class="headerlink" title="面试题：setbit 的实际应用"></a>面试题：setbit 的实际应用</h2><p>场景: 1亿个用户 , 每个用户 登陆/做任意操作  , 记为 今天活跃 , 否则记为不活跃。</p><p>每周评出: 有奖活跃用户: 连续7天活动<br>每月评,等等…</p><p>思路: </p><pre><code>userid   dt             active1        2013-07-27     11        2013-07-26     1</code></pre><p>如果是放在表中, 1:表急剧增大, 2:要用group , sum运算 , 计算较慢。</p><p>用: 位图法 bit-map</p><pre><code>Log0721 :  ‘011001...............0’......log0726 :  ‘011001...............0’Log0727 :  ‘011000...............1’</code></pre><p>1: 记录用户登陆:<br>每天按日期生成一个位图, 用户登陆后,把user_id位上的bit值置为1</p><p>2: 把1周的位图  and 计算,<br>位上为1的,即是连续登陆的用户</p><pre><code>redis 127.0.0.1:6379&gt; setbit mon 100000000 0(integer) 0redis 127.0.0.1:6379&gt; setbit mon 3 1(integer) 0redis 127.0.0.1:6379&gt; setbit mon 5 1(integer) 0redis 127.0.0.1:6379&gt; setbit mon 7 1(integer) 0redis 127.0.0.1:6379&gt; setbit thur 100000000 0(integer) 0redis 127.0.0.1:6379&gt; setbit thur 3 1(integer) 0redis 127.0.0.1:6379&gt; setbit thur 5 1(integer) 0redis 127.0.0.1:6379&gt; setbit thur 8 1(integer) 0redis 127.0.0.1:6379&gt; setbit wen 100000000 0(integer) 0redis 127.0.0.1:6379&gt; setbit wen 3 1(integer) 0redis 127.0.0.1:6379&gt; setbit wen 4 1(integer) 0redis 127.0.0.1:6379&gt; setbit wen 6 1(integer) 0redis 127.0.0.1:6379&gt; bitop and  res mon feb wen(integer) 12500001</code></pre><p>如上例,优点:</p><p>1: 节约空间, 1亿人每天的登陆情况,用1亿bit,约1200WByte,约10M 的字符就能表示<br>2: 计算方便</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的String命令操作</title>
      <link href="/2018/12/22/redis-de-string-ming-ling-cao-zuo/"/>
      <url>/2018/12/22/redis-de-string-ming-ling-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>今天来学习Redis中的字符串类型操作</p><p>Redis字符串类型的操作</p><h2 id="set命令"><a href="#set命令" class="headerlink" title="set命令"></a>set命令</h2><pre><code>set key value [ex 秒数] / [px 毫秒数]  [nx不存在] /[xx存在]如: set a 1 ex 10    , 10秒有效    set a 1 px 9000  , 9秒有效注: 如果ex,px同时写 ,以后面的有效期为准如 set a 1 ex 100 px 9000 , 实际有效期是9000毫秒nx: 表示key不存在时,执行操作xx: 表示key存在时,执行操作=====================================127.0.0.1:6379&gt; set a 1 ex 10OK127.0.0.1:6379&gt; ttl a(integer) 8127.0.0.1:6379&gt; ttl a(integer) 7127.0.0.1:6379&gt; ttl a(integer) 6127.0.0.1:6379&gt; ttl a(integer) 1127.0.0.1:6379&gt; ttl a(integer) 0127.0.0.1:6379&gt; ttl a(integer) -2不能同时设置 ex 和 px127.0.0.1:6379&gt; set a 1 ex 4 px 9000(error) ERR syntax error127.0.0.1:6379&gt; set a 1 px 8000OK127.0.0.1:6379&gt; ttl a(integer) 6127.0.0.1:6379&gt; ttl a(integer) 5127.0.0.1:6379&gt; pttl a(integer) 2176127.0.0.1:6379&gt; pttl a(integer) 960127.0.0.1:6379&gt; pttl a(integer) -2=====================================127.0.0.1:6379&gt; get a&quot;1&quot;127.0.0.1:6379&gt; set a 2 nx(nil)127.0.0.1:6379&gt; set a 2 xxOK127.0.0.1:6379&gt; get a&quot;2&quot;当a存在时，使用nx不会修改a的值，必须使用xx才能修改存在的值。=====================================set key value [默认是当key不存在时，创建key，key存在时，修改key的value值]</code></pre><h2 id="setex-key-seconds-value"><a href="#setex-key-seconds-value" class="headerlink" title="setex key seconds value"></a>setex key seconds value</h2><pre><code>设置key的value的同时，并设置过期的时间，单位是秒等价于set mykey valueexpire mykey seconds=====================================redis&gt; SETEX mykey 10 &quot;Hello&quot;&quot;OK&quot;redis&gt; TTL mykey(integer) 10redis&gt; GET mykey&quot;Hello&quot;redis&gt; </code></pre><h2 id="psetex-key-milliseconds-value"><a href="#psetex-key-milliseconds-value" class="headerlink" title="psetex key milliseconds value"></a>psetex key milliseconds value</h2><pre><code>作用：设置key的同时，设置key的过期时间，单位是毫秒redis&gt; PSETEX mykey 1000 &quot;Hello&quot;&quot;OK&quot;redis&gt; PTTL mykey(integer) 999redis&gt; GET mykey&quot;Hello&quot;redis&gt; </code></pre><h2 id="setnx-key-value"><a href="#setnx-key-value" class="headerlink" title="setnx key value"></a>setnx key value</h2><pre><code>返回：key不存时，设置成功，返回1key存在时，设置失败，返回0redis&gt; SETNX mykey &quot;Hello&quot;(integer) 1redis&gt; SETNX mykey &quot;World&quot;(integer) 0redis&gt; GET mykey&quot;Hello&quot;redis&gt; </code></pre><h2 id="setrange-key-offset-value"><a href="#setrange-key-offset-value" class="headerlink" title="setrange key offset value"></a>setrange key offset value</h2><pre><code>作用:把字符串的offset偏移字节,改成valueredis 127.0.0.1:6379&gt; set greet helloOKredis 127.0.0.1:6379&gt; setrange greet 2 x(integer) 5redis 127.0.0.1:6379&gt; get greet&quot;hexlo&quot;注意: 如果偏移量&gt;字符长度, 该字符自动补0x00redis 127.0.0.1:6379&gt; setrange greet 6 !(integer) 7redis 127.0.0.1:6379&gt; get greet&quot;hexlo\x00!&quot;</code></pre><h2 id="strlen-key"><a href="#strlen-key" class="headerlink" title="strlen key"></a>strlen key</h2><pre><code>作用：返回key的value值的长度redis&gt; SET mykey &quot;Hello world&quot;&quot;OK&quot;redis&gt; STRLEN mykey(integer) 11redis&gt; STRLEN nonexisting(integer) 0redis&gt; 返回的是value值的长度，从1开始计数，不存在的key，返回0。</code></pre><hr><h2 id="get-key"><a href="#get-key" class="headerlink" title="get key"></a>get key</h2><pre><code>作用：返回key的value值redis&gt; GET nonexisting(nil)redis&gt; SET mykey &quot;Hello&quot;&quot;OK&quot;redis&gt; GET mykey&quot;Hello&quot;redis&gt;</code></pre><h2 id="get-key-start-end"><a href="#get-key-start-end" class="headerlink" title="get key start end"></a>get key start end</h2><pre><code>作用：返回key的起始与结束之间的value值，包括start与end。序号是从0开始计算的！！！末尾的序号是-1.redis&gt; SET mykey &quot;This is a string&quot;&quot;OK&quot;redis&gt; GETRANGE mykey 0 3&quot;This&quot;redis&gt; GETRANGE mykey -3 -1&quot;ing&quot;redis&gt; GETRANGE mykey 0 -1&quot;This is a string&quot;redis&gt; GETRANGE mykey 10 100&quot;string&quot;redis&gt;注意: 1: start &gt;= length , 则返回空字符串2: end &gt;= length , 则截取至字符串的结尾3: 如果start 所处位置在 end 右边, 返回空字符串</code></pre><h2 id="getset-key-value"><a href="#getset-key-value" class="headerlink" title="getset key value"></a>getset key value</h2><pre><code>作用：返回上次的旧值，并设置新的value值redis&gt; SET mykey &quot;Hello&quot;&quot;OK&quot;redis&gt; GETSET mykey &quot;World&quot;&quot;Hello&quot;redis&gt; GET mykey&quot;World&quot;redis&gt; </code></pre><h2 id="append-key-value"><a href="#append-key-value" class="headerlink" title="append key value"></a>append key value</h2><pre><code>作用：当key存在时，在value后面追加新的value值。当key不存在时，就相当于set，创建一个新的valueredis&gt; EXISTS mykey(integer) 0redis&gt; APPEND mykey &quot;Hello&quot;(integer) 5redis&gt; APPEND mykey &quot; World&quot;(integer) 11redis&gt; GET mykey&quot;Hello World&quot;redis&gt; </code></pre><hr><h2 id="incr-key"><a href="#incr-key" class="headerlink" title="incr key"></a>incr key</h2><pre><code>作用：将key的value值，增加1，前提是key的value值是数字型的字符串redis&gt; SET mykey &quot;10&quot;&quot;OK&quot;redis&gt; INCR mykey(integer) 11redis&gt; GET mykey&quot;11&quot;redis&gt;如果key不存在，incr key，会将key的value赋值为1.这里fff本身不存在。127.0.0.1:6379&gt; incr fff(integer) 1127.0.0.1:6379&gt; get fff&quot;1如果key的value值不是数字型的字符串，就会报错！！！127.0.0.1:6379&gt; set lll fdfdfOK127.0.0.1:6379&gt; get lll&quot;fdfdf&quot;127.0.0.1:6379&gt; incr lll(error) ERR value is not an integer or out of range127.0.0.1:6379&gt;注意:1:不存在的key当成0,再incr操作2: 范围为64有符号</code></pre><h2 id="incrby-key-number"><a href="#incrby-key-number" class="headerlink" title="incrby key number"></a>incrby key number</h2><pre><code>incr key：是将key的value值加1。incrby key number：是将key的value值加number。redis&gt; SET mykey &quot;10&quot;&quot;OK&quot;redis&gt; INCRBY mykey 5(integer) 15redis&gt; </code></pre><h2 id="incrbyfloat-key-floatnumber"><a href="#incrbyfloat-key-floatnumber" class="headerlink" title="incrbyfloat key floatnumber"></a>incrbyfloat key floatnumber</h2><pre><code>incrbyfloat key floatnumber:可以加浮点数127.0.0.1:6379&gt; set num 5OK127.0.0.1:6379&gt; incr num(integer) 6127.0.0.1:6379&gt; get num&quot;6&quot;127.0.0.1:6379&gt; incrbyfloat num 5.5&quot;11.5&quot;127.0.0.1:6379&gt; get num&quot;11.5&quot;=====================================redis&gt; SET mykey 10.50&quot;OK&quot;redis&gt; INCRBYFLOAT mykey 0.1&quot;10.6&quot;redis&gt; INCRBYFLOAT mykey -5&quot;5.6&quot;redis&gt; SET mykey 5.0e3&quot;OK&quot;redis&gt; INCRBYFLOAT mykey 2.0e2&quot;5200&quot;redis&gt;</code></pre><h2 id="decr-key"><a href="#decr-key" class="headerlink" title="decr key"></a>decr key</h2><pre><code>作用：将key的value值减一。redis&gt; SET mykey &quot;10&quot;&quot;OK&quot;redis&gt; DECR mykey(integer) 9redis&gt; SET mykey &quot;234293482390480948029348230948&quot;&quot;OK&quot;redis&gt; DECR mykeyERR ERR value is not an integer or out of rangeredis&gt; ==============================================127.0.0.1:6379&gt; exists number(integer) 0127.0.0.1:6379&gt; decr number(integer) -1127.0.0.1:6379&gt; get number&quot;-1&quot;127.0.0.1:6379&gt; 注意：范围是有符号64位。当key不存在时，derc就是先创建key的value值为0，然后减一为-1。</code></pre><h2 id="decrby-key-decrement"><a href="#decrby-key-decrement" class="headerlink" title="decrby key decrement"></a>decrby key decrement</h2><pre><code>作用：将key的value值，减decrement。redis&gt; SET mykey &quot;10&quot;&quot;OK&quot;redis&gt; DECRBY mykey 3(integer) 7redis&gt; </code></pre><h2 id="mset-key-value-key-value-…"><a href="#mset-key-value-key-value-…" class="headerlink" title="mset key value [key value …]"></a>mset key value [key value …]</h2><pre><code>作用：一次性设置多个key、value值redis&gt; MSET key1 &quot;Hello&quot; key2 &quot;World&quot;&quot;OK&quot;redis&gt; GET key1&quot;Hello&quot;redis&gt; GET key2&quot;World&quot;redis&gt; </code></pre><h2 id="mget-key-key-…"><a href="#mget-key-key-…" class="headerlink" title="mget key [key …]"></a>mget key [key …]</h2><pre><code>作用：一次性获取多个key的value值redis&gt; SET key1 &quot;Hello&quot;&quot;OK&quot;redis&gt; SET key2 &quot;World&quot;&quot;OK&quot;redis&gt; MGET key1 key2 nonexisting1) &quot;Hello&quot;2) &quot;World&quot;3) (nil)redis&gt; </code></pre><h2 id="msetnx-key-value-key-value-…"><a href="#msetnx-key-value-key-value-…" class="headerlink" title="msetnx key value [key value …]"></a>msetnx key value [key value …]</h2><pre><code>作用：一次性设置多个不存在的key的value值，如果有一个key存在就返回0，失败！127.0.0.1:6379&gt; msetnx a 1 b 2(integer) 1127.0.0.1:6379&gt; mget a b1) &quot;1&quot;2) &quot;2&quot;127.0.0.1:6379&gt; msetnx b 3 c 4(integer) 0127.0.0.1:6379&gt; mget a b c1) &quot;1&quot;2) &quot;2&quot;3) (nil)127.0.0.1:6379&gt; </code></pre><hr><h2 id="setbit-key-offset-value"><a href="#setbit-key-offset-value" class="headerlink" title="setbit key offset value"></a>setbit key offset value</h2><pre><code>作用：将key的value中的偏移多少位上的bit值设置为1或0。A: 0100 0001  65a：0110 0001  97偏移量是从0开始。只需要将A的第二位设置为1，就能将大写的A，变成小写的a127.0.0.1:6379&gt; set char AOK127.0.0.1:6379&gt; get char&quot;A&quot;127.0.0.1:6379&gt; setbit char 2 1(integer) 0127.0.0.1:6379&gt; get char&quot;a&quot;127.0.0.1:6379&gt;注意: 1:如果offset过大,则会在中间填充0,2: offset最大大到多少3:offset最大2^32-1,可推出最大的的字符串为512M</code></pre><h2 id="getbit-key-offset"><a href="#getbit-key-offset" class="headerlink" title="getbit key offset"></a>getbit key offset</h2><pre><code>作用:获取值的二进制表示,对应位上的值(从左,从0编号)127.0.0.1:6379&gt; set char AOK127.0.0.1:6379&gt; get char&quot;A&quot;127.0.0.1:6379&gt; getbit char 0(integer) 0127.0.0.1:6379&gt; getbit char 1(integer) 1127.0.0.1:6379&gt; getbit char 2(integer) 0127.0.0.1:6379&gt; getbit char 7(integer) 1127.0.0.1:6379&gt; </code></pre><h2 id="bitop-operation-destkey-key1-key2-…"><a href="#bitop-operation-destkey-key1-key2-…" class="headerlink" title="bitop operation destkey key1 [key2 …]"></a>bitop operation destkey key1 [key2 …]</h2><pre><code>对 key1 , key2 ... keyN 作 operation , 并将结果保存到 destkey 上。operation 可以是 AND 、 OR 、 NOT 、 XORredis 127.0.0.1:6379&gt; setbit lower 2 1(integer) 0redis 127.0.0.1:6379&gt; set char QOKredis 127.0.0.1:6379&gt; get char&quot;Q&quot;redis 127.0.0.1:6379&gt; bitop or char char lower(integer) 1redis 127.0.0.1:6379&gt; get char&quot;q&quot;注意: 对于NOT操作, key不能多个</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的key通用操作</title>
      <link href="/2018/12/22/redis-de-key-tong-yong-cao-zuo/"/>
      <url>/2018/12/22/redis-de-key-tong-yong-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>今天来学习redis的通用操作命名。</p><h2 id="keys-pattern-查询相应的key"><a href="#keys-pattern-查询相应的key" class="headerlink" title="keys pattern 查询相应的key"></a>keys pattern 查询相应的key</h2><pre><code>在redis里,允许模糊查询key有3个通配符 *, ? ,[]*: 通配任意多个字符 (包括0个)?: 通配单个字符（不包括0个）[]: 通配括号内的某1个字符</code></pre><p>启动redis服务器：</p><p><code>./bin/redis-server redis.conf</code></p><p>如果不加后面的配置文件redis.conf,就会找默认的配置文件了。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day02/QQ截图20181222115002.png"></p><p>启动redis的客户端：</p><p><code>./bin/redis-cli</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day02/QQ截图20181222115132.png"></p><p>使用：keys *（查看当前数据库中的所有key）<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day02/QQ截图20181222115320.png"></p><p>使用正则表达式：</p><pre><code>127.0.0.1:6379&gt; KEYS *1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; set agg 20OK127.0.0.1:6379&gt; get agg&quot;20&quot;127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;name&quot;3) &quot;agg&quot;现在，目前有三个key了。127.0.0.1:6379&gt; keys age*1) &quot;age&quot;说明*能匹配0个字符127.0.0.1:6379&gt; keys ag*   1) &quot;age&quot;2) &quot;agg&quot;说明*能匹配一个字符127.0.0.1:6379&gt; set aggg 25OK127.0.0.1:6379&gt; get aggg &quot;25&quot;127.0.0.1:6379&gt; keys ag*1) &quot;age&quot;2) &quot;aggg&quot;3) &quot;agg&quot;说明能*能匹配多个字符=====================================127.0.0.1:6379&gt; keys age?(empty list or set)说明？不能匹配0个字符！！！127.0.0.1:6379&gt; keys ag?1) &quot;age&quot;2) &quot;agg&quot;127.0.0.1:6379&gt; 说明？只能匹配一个字符=====================================127.0.0.1:6379&gt; keys ag[gjer]1) &quot;age&quot;2) &quot;agg&quot;[]:只能匹配[]中的一个字符127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;name&quot;3) &quot;aggg&quot;4) &quot;agg&quot;127.0.0.1:6379&gt; keys ag[aekgllgg]1) &quot;age&quot;2) &quot;agg&quot;[]中有两个gg，但是还是只能匹配一个g。127.0.0.1:6379&gt; keys ag[a-h]1) &quot;age&quot;2) &quot;agg&quot;[a-h]:匹配a到h之间的一个字符</code></pre><h2 id="randomkey-返回随机key"><a href="#randomkey-返回随机key" class="headerlink" title="randomkey 返回随机key"></a>randomkey 返回随机key</h2><pre><code>127.0.0.1:6379&gt; randomkey&quot;name&quot;127.0.0.1:6379&gt; randomkey&quot;agg&quot;127.0.0.1:6379&gt; randomkey&quot;age&quot;127.0.0.1:6379&gt; randomkey&quot;aggg&quot;127.0.0.1:6379&gt; randomkey&quot;name&quot;</code></pre><h2 id="exists-key-判断key是否存在"><a href="#exists-key-判断key是否存在" class="headerlink" title="exists key [判断key是否存在]"></a>exists key [判断key是否存在]</h2><pre><code>127.0.0.1:6379&gt; exists name(integer) 1127.0.0.1:6379&gt; exists nafdjkfjd(integer) 0127.0.0.1:6379&gt; exists age name(integer) 2127.0.0.1:6379&gt; exists age narefdf(integer) 1存在返回1，不存在返0，也可以测试多个key，存在几个key的话，就返回数字几。</code></pre><h2 id="type-key-测试key的类型"><a href="#type-key-测试key的类型" class="headerlink" title="type key [测试key的类型]"></a>type key [测试key的类型]</h2><pre><code>返回key存储的值的类型有string , link , set , order set , hash127.0.0.1:6379&gt; type namestring127.0.0.1:6379&gt; type agestring</code></pre><h2 id="del-key-key-···-删除key"><a href="#del-key-key-···-删除key" class="headerlink" title="del key [key,···] 删除key"></a>del key [key,···] 删除key</h2><pre><code>del key ：删除一个keydel key1 key2 ···:删除多个key127.0.0.1:6379&gt; del aggg(integer) 1127.0.0.1:6379&gt; del aggg(integer) 0删除成功，返回1；删除失败，返回0.===========================================127.0.0.1:6379&gt; set a 1OK127.0.0.1:6379&gt; set b 2OK127.0.0.1:6379&gt; set c 3OK127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;b&quot;3) &quot;name&quot;4) &quot;c&quot;5) &quot;agg&quot;6) &quot;a&quot;删除多个keydel a b c127.0.0.1:6379&gt; del a b c(integer) 3127.0.0.1:6379&gt; del a b c(integer) 0如果要删除的多个key中，有不存在的key的话，就不会删除这个key。删除几个可以成功，就会返回数字几。如果 a b 键存在，c不存在，那么就返回2。127.0.0.1:6379&gt; del a b c(integer) 2</code></pre><h2 id="rename-key-newkey-修改key的名字"><a href="#rename-key-newkey-修改key的名字" class="headerlink" title="rename key newkey [修改key的名字]"></a>rename key newkey [修改key的名字]</h2><pre><code>127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;name&quot;3) &quot;agg&quot;127.0.0.1:6379&gt; 127.0.0.1:6379&gt; rename agg jidanOK127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;jidan&quot;3) &quot;name&quot;127.0.0.1:6379&gt; rename zzz fdfdf(error) ERR no such key修改名字成功，返回ok。修改失败，返回：(error) ERR no such key注意：如果新给的名字存在的话，那么会把已经存在的key的值给覆盖。例如：如果 a 和 b 都存在的话，rename a b 的话，b里面的值就是a里面的值了。127.0.0.1:6379&gt; get a&quot;1&quot;127.0.0.1:6379&gt; get b&quot;2&quot;127.0.0.1:6379&gt; 127.0.0.1:6379&gt; rename a bOK127.0.0.1:6379&gt; get a(nil)127.0.0.1:6379&gt; get b&quot;1&quot;此时，a不存在了，b里面存在的是a以前的值。</code></pre><h2 id="renamenx-key-newkey-newkey存在的话，不覆盖"><a href="#renamenx-key-newkey-newkey存在的话，不覆盖" class="headerlink" title="renamenx key newkey [newkey存在的话，不覆盖]"></a>renamenx key newkey [newkey存在的话，不覆盖]</h2><pre><code>renamenx 与 rename 的作用是一样的。只是当newkey本身已经存在的话，是不会修改成功的。127.0.0.1:6379&gt; get a&quot;1&quot;127.0.0.1:6379&gt; get b&quot;2&quot;127.0.0.1:6379&gt; renamenx a b(integer) 0127.0.0.1:6379&gt; get a&quot;1&quot;127.0.0.1:6379&gt; get b&quot;2&quot;b已经存在了，所以不会修改名字成功。127.0.0.1:6379&gt; get c(nil)127.0.0.1:6379&gt; renamenx a c(integer) 1127.0.0.1:6379&gt; get a(nil)127.0.0.1:6379&gt; get c&quot;1&quot;c不存在，所以修改a的名字为c成功。</code></pre><h2 id="move-key-db-移动key到指定的数据库中"><a href="#move-key-db-移动key到指定的数据库中" class="headerlink" title="move key db [移动key到指定的数据库中]"></a>move key db [移动key到指定的数据库中]</h2><pre><code>前提知识点：redis默认会创建16个数据库。编号是：0~15.默认打开的是编号为0的数据库。</code></pre><p>打开redis.conf配置文件：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day02/QQ截图20181222132858.png"></p><pre><code>127.0.0.1:6379&gt; keys *1) &quot;b&quot;2) &quot;age&quot;3) &quot;jidan&quot;4) &quot;name&quot;5) &quot;c&quot;现在将 c 这个key 移动到数据库编号为1的数据中。move c 1127.0.0.1:6379&gt; move c 1(integer) 1127.0.0.1:6379&gt; get c(nil)切换到编号为1的数据库中：select 1127.0.0.1:6379&gt; select 1OK127.0.0.1:6379[1]&gt; get c&quot;1&quot;切换成功后，在端口号后面有一个数字：[1]。</code></pre><p><strong>注意：</strong>( 一个redis进程,打开了不止一个数据库, 默认打开16个数据库,从0到15编号, 如果想打开更多数据库,可以从配置文件修改)</p><h2 id="ttl-key-查看key的过期时间"><a href="#ttl-key-查看key的过期时间" class="headerlink" title="ttl key [查看key的过期时间]"></a>ttl key [查看key的过期时间]</h2><pre><code>ttl:返回的是key过期时间的单位是秒。127.0.0.1:6379&gt; keys *1) &quot;b&quot;2) &quot;age&quot;3) &quot;jidan&quot;4) &quot;name&quot;127.0.0.1:6379&gt; ttl name(integer) -1注意：如果key存在的话，-1：代表的是没有过期时间，即永久存在；如果key不存在的话，也会返回-1。所以-1会有歧义！！！Redis2.8中,对于不存在的key,返回-2。</code></pre><h2 id="pttl-key"><a href="#pttl-key" class="headerlink" title="pttl key"></a>pttl key</h2><pre><code>pttl 与 ttl一样，都是返回一个key的过期时间，只是单位是毫秒。</code></pre><h2 id="expire-key-整型值-设置key的过期时间"><a href="#expire-key-整型值-设置key的过期时间" class="headerlink" title="expire key 整型值[设置key的过期时间]"></a>expire key 整型值[设置key的过期时间]</h2><pre><code>作用: 设置key的生命周期,以秒为单位127.0.0.1:6379&gt; expire name 5(integer) 1127.0.0.1:6379&gt; get name&quot;zhangsan&quot;127.0.0.1:6379&gt; get name(nil)设置name的这个key的过期时间是：5秒。5秒过后就会删除name这个key。</code></pre><h2 id="pexpire-key-毫秒数"><a href="#pexpire-key-毫秒数" class="headerlink" title="pexpire key 毫秒数"></a>pexpire key 毫秒数</h2><pre><code>作用: 设置key的生命周期,以毫秒为单位127.0.0.1:6379&gt; pexpire age 9000(integer) 1127.0.0.1:6379&gt; ttl age(integer) 6127.0.0.1:6379&gt; ttl age(integer) 5127.0.0.1:6379&gt; ttl age(integer) 4127.0.0.1:6379&gt; ttl age(integer) 3127.0.0.1:6379&gt; ttl age(integer) 1127.0.0.1:6379&gt; ttl age(integer) -2设置age的过期时间为：9000毫秒。</code></pre><h2 id="persist-key-设置key为永久存在"><a href="#persist-key-设置key为永久存在" class="headerlink" title="persist key[设置key为永久存在]"></a>persist key[设置key为永久存在]</h2><pre><code>作用: 把指定key置为永久有效127.0.0.1:6379&gt; expire b 10(integer) 1127.0.0.1:6379&gt; ttl b(integer) 8127.0.0.1:6379&gt; ttl b(integer) 6127.0.0.1:6379&gt; ttl b(integer) 5127.0.0.1:6379&gt; ttl b(integer) 4127.0.0.1:6379&gt; ttl b(integer) 3127.0.0.1:6379&gt; persist b(integer) 1127.0.0.1:6379&gt; ttl b(integer) -1设置b这个key的过期时间为：10秒，当b这个key快要过期的时候，将其设置为永久有效。</code></pre><p>还有更多的通用keys的操作，如看redis的官网：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day02/QQ截图20181222134910.png"></p><p>在图中，可以看到还有：expire<strong>at</strong> key timestamp [设置key的在哪个时间戳过期]、pexpire<strong>at</strong> key milliseconds-timestamp</p><pre><code>redis&gt; SET mykey &quot;Hello&quot;&quot;OK&quot;redis&gt; EXISTS mykey(integer) 1redis&gt; EXPIREAT mykey 1293840000(integer) 1redis&gt; EXISTS mykey(integer) 0redis&gt;======================================redis&gt; SET mykey &quot;Hello&quot;&quot;OK&quot;redis&gt; PEXPIREAT mykey 1555555555005(integer) 1redis&gt; TTL mykey(integer) 10097634redis&gt; PTTL mykey(integer) 10097633581redis&gt; </code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的下载与安装</title>
      <link href="/2018/12/21/redis-de-xia-zai-yu-an-zhuang/"/>
      <url>/2018/12/21/redis-de-xia-zai-yu-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>今天来学习Redis缓存，完成redis的下载与安装。</p><h2 id="Redis的特点"><a href="#Redis的特点" class="headerlink" title="Redis的特点"></a>Redis的特点</h2><p>Redis is an open source, BSD licensed, advanced key-value store. It is often referred to as a data structure server since keys can contain strings, hashes, lists, sets and sorted sets.</p><p>redis是开源,BSD许可,高级的key-value存储系统. 可以用来存储字符串,哈希结构,链表,集合,因此,常用来提供数据结构服务.</p><h3 id="redis和memcached的对比"><a href="#redis和memcached的对比" class="headerlink" title="redis和memcached的对比"></a>redis和memcached的对比</h3><ol><li><p>redis可以用来做存储(storge), 而memcached是用来做缓存(cache)。这个特点主要因为其有<strong>”持久化”</strong>的功能.</p></li><li><p>存储的数据有”结构”,对于memcached来说,存储的数据,只有1种类型–”字符串”,而redis则可以存储字符串,链表,哈希结构,集合,有序集合.</p></li></ol><h2 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h2><h3 id="打开官网：redis-io"><a href="#打开官网：redis-io" class="headerlink" title="打开官网：redis.io"></a>打开官网：redis.io</h3><p>1.打开官网：redis.io。下载最新版本或者最新的稳定版本。</p><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221201926.png"></p><p>点击查看更多的安装版本：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221202252.png"></p><p>往下能看到，官方提供的安装步骤：<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221202341.png"></p><h3 id="打开虚拟机"><a href="#打开虚拟机" class="headerlink" title="打开虚拟机"></a>打开虚拟机</h3><p>2.打开虚拟机</p><p>如果不会使用虚拟机（linux），那么请看我之前的linux教程即可。</p><p>使用Xshell来远程操作linux即可。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221203308.png"></p><h3 id="下载redis的压缩包"><a href="#下载redis的压缩包" class="headerlink" title="下载redis的压缩包"></a>下载redis的压缩包</h3><p>3.下载redis的压缩包</p><p><code>wget http://download.redis.io/releases/redis-5.0.3.tar.gz</code></p><p>先切换目录到：usr/local/src/下，这个目录一般是用来安装下载的软件的。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221203739.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221203856.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221204116.png"></p><h3 id="解压redis压缩包"><a href="#解压redis压缩包" class="headerlink" title="解压redis压缩包"></a>解压redis压缩包</h3><p>4.解压redis压缩包</p><p><code>tar zxvf redis-5.0.3.tar.gz</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221204603.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221204719.png"></p><h3 id="不用configure"><a href="#不用configure" class="headerlink" title="不用configure"></a>不用configure</h3><p>5.<strong>不用configure</strong></p><p>因为下载好的redis压缩包，官方已经帮我们configure过了。</p><h3 id="使用make编译redis"><a href="#使用make编译redis" class="headerlink" title="使用make编译redis"></a>使用make编译redis</h3><p>6.直接make（编译redis）</p><p><code>make</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221204852.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221205123.png"></p><p><strong>注意问题：</strong> make的过程中可能出现的问题，因为官方的redis源码是configure过的，但官方的configure时，生成的文件有时间戳的信息。</p><p>Make只能发生在configure之后，如果你的虚拟机的时间在configure之前，那么就会出现问题，比如，官方configure的时间是2018年12月10号，但是你的虚拟机的时间是2018年12月1号，在10号之前，那么就会出现问题。</p><p>解决：修改虚拟机的时间即可。</p><h3 id="测试编译情况"><a href="#测试编译情况" class="headerlink" title="测试编译情况"></a>测试编译情况</h3><p>7.可选步骤：make test 测试编译情况</p><p>（可能出现：xxx 的版本过低的问题，直接 yum install xxx）</p><h3 id="安装redis到指定的目录中"><a href="#安装redis到指定的目录中" class="headerlink" title="安装redis到指定的目录中"></a>安装redis到指定的目录中</h3><p>8.安装redis到指定的目录中，比如：/usr/local/redis</p><p><code>make PREFIX=/usr/loacl/redis install</code></p><p>注意：PREFIX是大写。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221210034.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221210129.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221210210.png"></p><p>安装后，发现只有bin目录，是正确的。</p><p>会得到以下几个文件：</p><pre><code>redis-benchmark    性能测试工具redis-check-aof    日志文件检测工(比如断电造成日志损坏,可以检测并修复)redis-check-dump   快照文件检测工具,效果类上。redis-cli          客户端redis-server       服务端</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221210353.png"></p><h3 id="复制redis的配置文件到bin目录下"><a href="#复制redis的配置文件到bin目录下" class="headerlink" title="复制redis的配置文件到bin目录下"></a>复制redis的配置文件到bin目录下</h3><p>9.复制redis的配置文件到bin目录下</p><p><code>cp /usr/local/src/redis-5.0.1/redis.conf ./</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221210857.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221211030.png"></p><h3 id="启动redis服务器"><a href="#启动redis服务器" class="headerlink" title="启动redis服务器"></a>启动redis服务器</h3><p>10.启动redis服务器</p><p><code>./bin/redis-server ./redis.conf</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221211225.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221211350.png"></p><p>不要：ctrl+c退出redis服务器端。</p><p>重新开启一个新的linux连接端，启动redis的客户端：</p><p><code>./bin/redis-cli</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221212336.png"></p><h3 id="简单测试redis功能"><a href="#简单测试redis功能" class="headerlink" title="简单测试redis功能"></a>简单测试redis功能</h3><p>11.简单测试redis功能</p><p>往name字符串中存入张三，然后获取张三。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221212541.png"></p><h3 id="让redis以后台进程的形式运行"><a href="#让redis以后台进程的形式运行" class="headerlink" title="让redis以后台进程的形式运行"></a>让redis以后台进程的形式运行</h3><p>12.让redis以后台进程的形式运行</p><p>实际生产中，不能一直开启redis的服务端而不断开，应该是开启一个后台进程运行redis服务器。</p><p>打开redis.conf配置文件。</p><p>将daemonize 改为：yes<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221212956.png"></p><p>再次启动redis的服务端：</p><p><code>./bin/redis-server ./redis.conf</code></p><p>此时不会再出现那个很大的logo图标了。<br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221213130.png"></p><p>检测redis服务端是否成功启动了呢？查找redis相关的进程</p><p><code>ps aux |grep redis</code><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221213435.png"><br><img src="https://gakkil.gitee.io/gakkil-image/redis/day01/QQ截图20181221213537.png"></p><p><strong>注意：</strong>这里的name是上次保存到redis缓存中的，但是这次居然获取成功了，因为新版本的redis，默认配置了持久化操作，上次ctrl+c退出redis服务器后，会自动帮我们持久化数据，在redis目录下面，会发现多了一个<strong>dump.rdb</strong>文件，就是持久化数据后的文件。如果是以前的版本就不会帮我们持久化数据！！！</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题：如何求根号2</title>
      <link href="/2018/12/17/mian-shi-ti-ru-he-qiu-gen-hao-2/"/>
      <url>/2018/12/17/mian-shi-ti-ru-he-qiu-gen-hao-2/</url>
      
        <content type="html"><![CDATA[<p>小L最近找实习的时候，被面试官问了这样一道题：如何求根号2的值？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217184933.png" style="width:80%"><br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217185034.png" style="width:80%"></p><p><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217185312.png" style="width:80%"></p><h3 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h3><p><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217185408.png" style="width:80%"><br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217185548.png" style="width:80%"><br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217185617.png" style="width:80%"><br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217185703.png" style="width:80%"></p><p><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217185734.png" style="width:80%"><br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217185806.png" style="width:80%"><br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217185834.png" style="width:80%"><br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217185905.png" style="width:80%"></p><p><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217185938.png" style="width:80%"><br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217190035.png" style="width:80%"><br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217190117.png" style="width:80%"><br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217190227.png" style="width:80%"><br><img src="https://gakkil.gitee.io/gakkil-image/interview/QQ截图20181217190258.png" style="width:80%"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上介绍了二分法和牛顿迭代法来求解根号2，另外我们还可以通过泰勒公式法来求解。很多朋友可能会问，我们经常调用的Math库中sqrt(x)函数的实现用的是哪种方法呢？为了效率，sqrt(x)函数在底层是用C语言来实现的，实现过程非常巧妙，效率极高，用到了牛顿迭代法的思想，但又不完全是牛顿迭代法，我会将sqrt(x)库函数的代码放于文后，有兴趣可以研究。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="牛顿迭代法（JavaScript）"><a href="#牛顿迭代法（JavaScript）" class="headerlink" title="牛顿迭代法（JavaScript）"></a>牛顿迭代法（JavaScript）</h3><pre><code>//求n的算术平方根，参数n不能为负数function sqrt(n) {    //当n&gt;=1时，从n开始迭代；    //当n&lt;1时，从1开始迭代    let res = n &gt;= 1 ? n : 1;    while(res * res - n &gt; 1e-8)        res = 0.5 * (res + n / res);    return res;}</code></pre><h3 id="C语言实现的库函数（源码）"><a href="#C语言实现的库函数（源码）" class="headerlink" title="C语言实现的库函数（源码）"></a>C语言实现的库函数（源码）</h3><pre><code>//源码中求的是根号x的倒数，参数x必须大于0float invSqrt(float x){    float xhalf = 0.5f * x;    int i = *(int*)&amp;x;    //下面这句是核心，有兴趣可阅读相关论文    i = 0x5f375a86 - (i&gt;&gt;1);     x = *(float*)&amp;i;    //下面使用了三次牛顿迭代     x = x*(1.5f-xhalf*x*x);     x = x*(1.5f-xhalf*x*x);     x = x*(1.5f-xhalf*x*x);    //注：此函数返回的是根号x的倒数    return x;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端:后端,我要与你分手</title>
      <link href="/2018/12/06/qian-duan-hou-duan-wo-yao-yu-ni-fen-shou/"/>
      <url>/2018/12/06/qian-duan-hou-duan-wo-yao-yu-ni-fen-shou/</url>
      
        <content type="html"><![CDATA[<p>本篇文章，将会讲解前端、后端的架构思想。</p><h2 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a>前戏</h2><p>前后端分离已成为互联网项目开发的业界标准使用方式，通过 nginx + tomcat 的方式（也可以中间加一个nodejs）有效的进行解耦，并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。这个步骤是系统架构从猿进化成人的必经之路。</p><p><strong>核心思想</strong>：是前端<strong> html页面 </strong>通过<strong> ajax </strong>调用后端的<strong> restuful api接口 </strong>并使用<strong> json数据 </strong>进行交互。</p><font color="red"><strong>在互联网架构中，名词解释：</strong></font><p>Web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。</p><p>应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有Web服务器好。</p><p>一般都是只有Web服务器才能被外网访问，应用服务器只能内网访问。</p><h2 id="术业有专攻（开发人员分离）"><a href="#术业有专攻（开发人员分离）" class="headerlink" title="术业有专攻（开发人员分离）"></a>术业有专攻（开发人员分离）</h2><p>以前的JavaWeb项目大多数都是java程序员又当爹又当妈，又搞前端，又搞后端。</p><p>随着时代的发展，渐渐的许多大中小公司开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。正所谓术业有专攻，一个人如果什么都会，那么他毕竟什么都不精。</p><p>大中型公司需要专业人才，小公司需要全才，但是对于个人职业发展来说，我建议是分开。</p><p><strong>1) 对于后端java工程师：</strong></p><p>把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构，弹性计算架构，微服务架构，java性能优化，以及相关的项目管理等等。</p><p>后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。</p><p><strong>2) 对于前端工程师：</strong></p><p>把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。</p><p>前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。</p><p>术业有专攻，这样你的核心竞争力才会越来越高，正所谓你往生活中投入什么，生活就会反馈给你什么。并且两端的发展都越来越高深，你想什么都会，那你毕竟什么都不精。</p><p>通过将team分成前后端team，让两边的工程师更加专注各自的领域，独立治理，然后构建出一个全栈式的精益求精的team。</p><h2 id="原始人时代（各种耦合）"><a href="#原始人时代（各种耦合）" class="headerlink" title="原始人时代（各种耦合）"></a>原始人时代（各种耦合）</h2><p>曾几何时，我们的JavaWeb项目都是使用了若干后台框架，springmvc/struts + spring + spring jdbc/hibernate/mybatis 等等。</p><p>大多数项目在java后端都是分了三层，控制层，业务层，持久层。控制层负责接收参数，调用相关业务层，封装数据，以及路由&amp;渲染到jsp页面。然后jsp页面上使用各种标签或者手写java表达式将后台的数据展现出来，玩的是MVC那套思路。</p><p>我们先看这种情况：需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器里，对吧？</p><p>发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，dns等等相关，你的网站就可以访问了（假设你是个网站）。那我们来看，你的前后端代码是不是全都在那个war包里？包括你的js，css，图片，各种第三方的库，对吧？</p><p>好，下面在浏览器中输入你的网站域名<code>（www.xxx.com）</code>，之后发生了什么？（这个问题也是很多公司的面试题）我捡干的说了啊，基础不好的童鞋请自己去搜。</p><p>浏览器在通过域名、通过dns服务器找到你的服务器外网ip,将http请求发送到你的服务器，在tcp3次握手之后（http下面是tcp/ip），通过tcp协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过content-type来解析你返回的内容，呈现给用户。</p><p>那么我们来看，我们先假设你的首页中有100张图片，此时，用户的看似一次http请求，其实并不是一次，用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着请求100次http请求（有人会跟我说http长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建socket来玩tcp传输（消耗你服务器上的计算资源）。</p><p>重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说是单实例服务器），那你的服务器能扛住多少个tcp连接？你的带宽有多大？你的服务器的内存有多大？你的硬盘是高性能的吗？你能抗住多少IO？你给web服务器分的内存有多大？会不会宕机？</p><p>这就是为什么，越是大中型的web应用，他们越是要解耦。理论上你可以把你的数据库+应用服务+消息队列+缓存+用户上传的文件+日志+等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而hung住，那你的整个网站就挂掉了。</p><p>如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。（注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期哟，亲~）</p><p>此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用负载均衡的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低，要知道，本身负载就低的功能or模块是没有必要水平扩展的，在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？</p><p>正常的互联网架构，是都要拆开的，你的web服务器集群，你的应用服务器集群+文件服务器集群+数据库服务器集群+消息队列集群+缓存集群等等。</p><h2 id="JSP的痛点"><a href="#JSP的痛点" class="headerlink" title="JSP的痛点"></a>JSP的痛点</h2><p>以前的javaWeb项目大多数使用jsp作为页面层展示数据给用户，因为流量不高，因此也没有那么苛刻的性能要求，但现在是大数据时代，对于互联网项目的性能要求是越来越高，因此原始的前后端耦合在一起的架构模式已经逐渐不能满足我们，因此我们需要需找一种解耦的方式，来大幅度提升我们的负载能力。</p><p>1、动态资源和静态资源全部耦合在一起，服务器压力大，因为服务器会收到各种http请求，例如css的http请求，js的，图片的等等。一旦服务器出现状况，前后台一起玩完，用户体验极差。</p><p>2、UI出好设计图后，前端工程师只负责将设计图切成html，需要由java工程师来将html套成jsp页面，出错率较高（因为页面中经常会出现大量的js代码），修改问题时需要双方协同开发，效率低下。</p><p>3、jsp必须要在支持java的web服务器里运行（例如tomcat，jetty，resin等），无法使用nginx等（nginx据说单实例http并发高达5w，这个优势要用上），性能提不上来。</p><p>4、第一次请求jsp，必须要在web服务器中编译成servlet，第一次运行会较慢。</p><p>5、每次请求jsp都是访问servlet再用输出流输出的html页面，效率没有直接使用html高（是每次哟，亲~）。</p><p>6、jsp内有较多标签和表达式，前端工程师在修改页面时会捉襟见肘，遇到很多痛点。</p><p>7、如果jsp中的内容很多，页面响应会很慢，因为是同步加载。</p><p>8、需要前端工程师使用java的ide（例如eclipse），以及需要配置各种后端的开发环境，你们有考虑过前端工程师的感受吗。</p><p>基于上述的一些痛点，我们应该把整个项目的开发权重往前移，实现前后端真正的解耦！</p><h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><p>以前老的方式是：</p><p>1、产品经理/领导/客户提出需求</p><p>2、UI做出设计图</p><p>3、前端工程师做html页面</p><p>4、后端工程师将html页面套成jsp页面（前后端强依赖，后端必须要等前端的html做好才能套jsp。如果html发生变更，就更痛了，开发效率低）</p><p>5、集成出现问题</p><p>6、前端返工</p><p>7、后端返工</p><p>8、二次集成</p><p>9、集成成功</p><p>10、交付</p><h2 id="新的方式："><a href="#新的方式：" class="headerlink" title="新的方式："></a>新的方式：</h2><p>1、产品经理/领导/客户提出需求</p><p>2、UI做出设计图</p><p>3、前后端约定接口 &amp; 数据 &amp; 参数</p><p>4、前后端并行开发（无强依赖，可前后端并行开发，如果需求变更，只要接口&amp;参数不变，就不用两边都修改代码，开发效率高）</p><p>5、前后端集成</p><p>6、前端页面调整</p><p>7、集成成功</p><p>8、交付</p><h2 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h2><font color="red"><strong>以前老的方式是：</strong></font><p>1、客户端请求</p><p>2、服务端的servlet或controller接收请求（后端控制路由与渲染页面，整个项目开发的权重大部分在后端）</p><p>3、调用service,dao代码完成业务逻辑</p><p>4、返回jsp</p><p>5、jsp展现一些动态的代码</p><font color="red"><strong>新的方式是：</strong></font><p>1、浏览器发送请求</p><p>2、直接到达html页面（前端控制路由与渲染页面，整个项目开发的权重前移）</p><p>3、html页面负责调用服务端接口产生数据（通过ajax等等，后台返回json格式数据，json数据格式因为简洁高效而取代xml）</p><p>4、填充html，展现动态效果，在页面上进行解析并操作DOM。</p><p><strong>总结一下新的方式的请求步骤：</strong></p><p>大量并发浏览器请求 -→ web服务器集群(nginx) -→ 应用服务器集群(tomcat) -→ 文件/数据库/缓存/消息队列服务器集群。</p><p>同时又可以玩分模块，还可以按业务拆成一个个的小集群，为后面的架构升级做准备。</p><h2 id="前后分离的优势"><a href="#前后分离的优势" class="headerlink" title="前后分离的优势"></a>前后分离的优势</h2><p>1、可以实现真正的前后端解耦，前端服务器使用nginx。前端/WEB服务器放的是css，js，图片等等一系列静态资源（甚至你还可以将css，js，图片等资源放到特定的文件服务器，例如阿里云的oss，并使用cdn加速），前端服务器负责控制页面引用&amp;跳转&amp;路由，前端页面异步调用后端的接口，后端/应用服务器使用tomcat（把tomcat想象成一个数据提供者），加快整体响应速度。（这里需要使用一些前端工程化的框架比如nodejs，react，router，react，redux，webpack）</p><p>2、发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象。页面逻辑，跳转错误，浏览器兼容性问题，脚本错误，页面样式等问题，全部由前端工程师来负责。接口数据出错，数据没有提交成功，应答超时等问题，全部由后端工程师来解决。双方互不干扰，前端与后端是相亲相爱的一家人。</p><p>3、在大并发情况下，我可以同时水平扩展前后端服务器，比如淘宝的一个首页就需要2000+台前端服务器做集群来抗住日均多少亿+的日均pv。（去参加阿里的技术峰会，听他们说他们的web容器都是自己写的，就算他单实例抗10万http并发，2000台是2亿http并发，并且他们还可以根据预知洪峰来无限拓展，很恐怖，就一个首页。。。）</p><p>4、减少后端服务器的并发/负载压力。除了接口以外的其他所有http请求全部转移到前端nginx上，接口的请求调用tomcat，参考nginx反向代理tomcat。且除了第一次页面请求外，浏览器会大量调用本地缓存。</p><p>5、即使后端服务暂时超时或者宕机了，前端页面也会正常访问，只不过数据刷不出来而已。</p><p>6、也许你也需要有微信相关的轻应用，那样你的接口完全可以共用，如果也有app相关的服务，那么只要通过一些代码重构，也可以大量复用接口，提升效率。（多端应用）</p><p>7、页面显示的东西再多也不怕，因为是异步加载。</p><p>8、nginx支持页面热部署，不用重启服务器，前端升级更无缝。</p><p>9、增加代码的维护性&amp;易读性（前后端耦在一起的代码读起来相当费劲）。</p><p>10、提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖。</p><p>11、在nginx中部署证书，外网使用https访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），内网使用http，性能和安全都有保障。</p><p>12、前端大量的组件代码得以复用，组件化，提升开发效率，抽出来！</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、在开需求会议的时候，前后端工程师必须全部参加，并且需要制定好接口文档，后端工程师要写好测试用例（2个维度），不要让前端工程师充当你的专职测试，推荐使用chrome的插件postman或soapui或jmeter，service层的测试用例拿junit写。ps：前端也可以玩单元测试吗？</p><p>2、上述的接口并不是java里的interface，说白了调用接口就是调用你controler里的方法。</p><p>3、加重了前端团队的工作量，减轻了后端团队的工作量，提高了性能和可扩展性。</p><p>4、我们需要一些前端的框架来解决类似于页面嵌套，分页，页面跳转控制等功能。（上面提到的那些前端框架）。</p><p>5、如果你的项目很小，或者是一个单纯的内网项目，那你大可放心，不用任何架构而言，但是如果你的项目是外网项目，呵呵哒。</p><p>6、 以前还有人在使用类似于velocity/freemarker等模板框架来生成静态页面，仁者见仁智者见智。</p><p>7、这篇文章主要的目的是说jsp在大型外网java web项目中被淘汰掉，可没说jsp可以完全不学，对于一些学生朋友来说，jsp/servlet等相关的java web基础还是要掌握牢的，不然你以为springmvc这种框架是基于什么来写的？</p><p>8、如果页面上有一些权限等等相关的校验，那么这些相关的数据也可以通过ajax从接口里拿。</p><p>9、对于既可以前端做也可以后端做的逻辑，我建议是放到前端，为什么？因为你的逻辑需要计算资源进行计算，如果放到后端去run逻辑，则会消耗带宽&amp;内存&amp;cpu等等计算资源，你要记住一点就是服务端的计算资源是有限的，而如果放到前端，使用的是客户端的计算资源，这样你的服务端负载就会下降（高并发场景）。类似于数据校验这种，前后端都需要做！</p><p>10、前端需要有机制应对后端请求超时以及后端服务宕机的情况，友好的展示给用户。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前后端分离并非仅仅只是一种开发模式，而是一种架构模式（前后端分离架构）。千万不要以为只有在撸代码的时候把前端和后端分开就是前后端分离了，需要区分前后端项目。前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署，前端通过ajax来调用http请求调用后端的restful api。前端只需要关注页面的样式与动态数据的解析&amp;渲染，而后端专注于具体业务逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 后端 </tag>
            
            <tag> 分离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之软件的下载与安装</title>
      <link href="/2018/11/30/linux-ji-chu-ru-men-zhi-xia-zai-yu-an-zhuang/"/>
      <url>/2018/11/30/linux-ji-chu-ru-men-zhi-xia-zai-yu-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>本篇讲解Linux系统下软件的安装方式：RPM 与 YUM。</p><h2 id="rpm包管理"><a href="#rpm包管理" class="headerlink" title="rpm包管理"></a>rpm包管理</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一种用于互联网下载包的<strong>打包</strong>及<strong>安装工具</strong>，它包含在某些Linux分发版中。它生成具有<code>.RPM扩展名</code>的文件。RPM是RedHat Package Manager（RedHat软件包管理工具）的缩写，类似于windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。</p><p>Linux的分发版本都有采用（suse,redhat, centos 等等），可以算是公认的行业标准了。</p><p>rpm包管理的缺点：不能处理依赖关系，如你要安装A软件，但是A软件依赖于B、C软件的支持，因此，你必须先安装B和C软件，然后才能安装A软件。</p><h3 id="rpm包的简单查询指令"><a href="#rpm包的简单查询指令" class="headerlink" title="rpm包的简单查询指令"></a>rpm包的简单查询指令</h3><pre><code>查询已安装的rpm列表 :rpm  -qa                #查询所有的rpm软件包rpm  –qa | grep xx      #查询指定的rpm软件包rpm  -qa | grep firefox</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130203440.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130203539.png"></p><h3 id="rpm包名基本格式"><a href="#rpm包名基本格式" class="headerlink" title="rpm包名基本格式"></a>rpm包名基本格式</h3><pre><code>一个rpm包名：firefox-52.7.0-1.el7.centos.x86_64.rpm名称:firefox版本号：52.7.0更新发行的次数：1 适用操作系统: el7.centos.x86_64表示centos7.x的64位系统如果是i686、i386表示32位系统，x86_64表示64位的系统，noarch表示通用。</code></pre><h3 id="rpm包的其它查询指令"><a href="#rpm包的其它查询指令" class="headerlink" title="rpm包的其它查询指令"></a>rpm包的其它查询指令</h3><pre><code>rpm -qa : 查询所安装的所有rpm软件包  rpm -qa | more    rpm -qa | grep X [rpm -qa | grep firefox ]rpm -q 软件包名 : 查询软件包是否安装rpm -q firefoxrpm -qi 软件包名 ：查询软件包信息rpm -qi firefoxrpm -ql 软件包名 : 查询软件包中的文件rpm -ql firefoxrpm -qf 文件全路径名 查询文件所属的软件包rpm -qf /etc/passwdrpm -qf /root/install.log</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130204147.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130204408.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130204547.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130204655.png"></p><h3 id="卸载rpm包"><a href="#卸载rpm包" class="headerlink" title="卸载rpm包"></a>卸载rpm包</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>rpm -e RPM包的名称</code></pre><h4 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h4><p>删除 firefox  软件包</p><p><code>rpm -e firefox</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130211112.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130211228.png"></p><p><strong>细节讨论:</strong></p><p>1) 如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。</p><p>如：  <code>rpm -e  foo</code> </p><p>removing these packages would break dependencies: <strong>foo is needed by bar-1.0-1</strong></p><p>2) 如果我们就是要删除 foo这个rpm包，可以增加参数 <code>--nodeps</code> , 就可以强制删除，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行。</p><p>如： <code>rpm -e --nodeps foo</code>      [小心使用]</p><h3 id="安装rpm包"><a href="#安装rpm包" class="headerlink" title="安装rpm包"></a>安装rpm包</h3><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>rpm -ivh  RPM包全路径名称参数说明i = install 安装v = verbose 提示h = hash    进度条</code></pre><h4 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a>应用案例</h4><p>安装firefox浏览器</p><p><strong>提示：很多的rpm软件包，就在我们的centos安装的镜像文件中</strong></p><p>步骤：</p><p>1）首先要有Firefox的rpm软件包，才能安装。</p><p>一个小知识点，我们的centOS.iso镜像文件中，就有Firefox的rpm软件包。</p><p>挂载我们的centOS.ios镜像光驱。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130210825.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130210930.png"></p><p>光驱一般会在：/media文件夹中：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130211656.png"></p><p>那么就到 /run/media/root/ 中查找：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130211917.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130212025.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130212226.png"></p><p>将找到的Firefox软件包，拷贝到我们制定的目录下面，比如：/opt中：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130212416.png"></p><p>在/opt/中安装，不在光驱中安装。</p><p><code>rpm -ivh firefox.xxx.rpm</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130212634.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130212809.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130212908.png"></p><p>输入：<code>eject</code>：弹出光驱<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130213349.png"></p><h2 id="yum包管理"><a href="#yum包管理" class="headerlink" title="yum包管理"></a>yum包管理</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Yum 是一个Shell 软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以<strong>自动处理依赖性关系</strong>，并且一次安装所有依赖的软件包。</p><p>通过yum工具配合互联网即可实现软件的安装和自动升级。</p><h3 id="yum的安装"><a href="#yum的安装" class="headerlink" title="yum的安装"></a>yum的安装</h3><p>1）查询yum是否已经安装了。</p><p><code>rpm -qa | grep yum</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130214443.png"></p><p>2) 如果没有找到，可以到CentOS镜像中找到，并安装yum软件。</p><p><code>rpm -ivh yum-*.xxx.noarch.rpm</code></p><h3 id="yum的基本指令"><a href="#yum的基本指令" class="headerlink" title="yum的基本指令"></a>yum的基本指令</h3><pre><code>查询yum服务器是否有需要安装的软件yum  list | grep xxx软件  #查询xxx软件安装指定的yum包yum  install  xxx  #下载安装xxx软件</code></pre><h3 id="yum应用实例"><a href="#yum应用实例" class="headerlink" title="yum应用实例"></a>yum应用实例</h3><p>案例：请使用yum的方式来安装firefox指令 (前提是：你能联网！！！)</p><p>1) 查询yum服务器上面是否有Firefox</p><p><code>yum list | grep firefox</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130215425.png"></p><p><code>yum install firefox</code>  //会自动的下载适合你系统的最新版本，并且下载所有的依赖软件。</p><p>原来我们的机器上就有Firefox，所以先卸载：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130215537.png"></p><p>安装Firefox：（速度会慢一些，因为是联网下载）<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130215801.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130215940.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130220008.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day09/QQ截图20181130220108.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之进程管理</title>
      <link href="/2018/11/30/linux-ji-chu-ru-men-zhi-jin-cheng-guan-li/"/>
      <url>/2018/11/30/linux-ji-chu-ru-men-zhi-jin-cheng-guan-li/</url>
      
        <content type="html"><![CDATA[<p>Linux系统的进程管理（重点！！！）</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>1）在Linux系统中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号。</p><p>2）一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器。</p><p>3）每个进程都可能以两种方式存在的: <font color="red">前台 与 后台</font>，所谓<strong>前台进程</strong>就是用户目前的屏幕上可以进行操作的 ; <strong>后台进程</strong>则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行 [sshd , crond]。</p><p>4）一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才会结束。</p><h2 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h2><h3 id="ps基本介绍"><a href="#ps基本介绍" class="headerlink" title="ps基本介绍"></a>ps基本介绍</h3><p>ps命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。（可以不加任何参数）</p><pre><code>ps -a：显示当前终端的所有进程信息ps -u：以用户的格式显示进程的信息ps -x：显示后台进程运行的参数一般使用：ps -aux</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130132958.png"></p><p>如果太多，看不过来的话，使用：| more。</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130133124.png"></p><h3 id="ps详解"><a href="#ps详解" class="headerlink" title="ps详解"></a>ps详解</h3><p>1）指令：ps –aux | grep xxx ，比如我要看有没有sshd服务。</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130133333.png"></p><p>2）指令说明</p><pre><code>System V展示风格USER：用户名称 PID： 进程号 %CPU：进程占用CPU的百分比 %MEM：进程占用物理内存的百分比 VSZ： 进程占用的虚拟内存大小（单位：KB） RSS： 进程占用的物理内存大小（单位：KB） TTY： 终端名称,缩写.STAT：进程状态。其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等。STARTED：进程的启动时间 TIME：   占用CPU的时间，即进程使用CPU的总时间 COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</code></pre><h3 id="查看父进程"><a href="#查看父进程" class="headerlink" title="查看父进程"></a>查看父进程</h3><pre><code>ps -ef：是以全格式显示当前所有的进程-e：显示所有进程-f：全格式</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130133917.png"></p><p>1）查找特定指令的父进程id：<code>ps -ef | grep xxx</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130134150.png"></p><p>2) 详细介绍</p><pre><code>是BSD风格UID： 用户的名字 PID： 进程ID PPID：父进程ID C：   CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高 STIME：进程启动的时间 TTY：  完整的终端名称 TIME： CPU时间 CMD：  启动进程所用的命令和参数</code></pre><h2 id="终止进程kill和killall"><a href="#终止进程kill和killall" class="headerlink" title="终止进程kill和killall"></a>终止进程kill和killall</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code>kill  [选项] 进程号（功能描述：通过进程号杀死进程 -9 强制终止）killall 进程名称    （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）常用选项：-9： 表示强迫进程立即停止-2： 表示结束进程，但不是强制性的。常用的Ctrl+c就是：kill -2 的意思。-15：表示正常结束进程，是kill的默认选项。</code></pre><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>案例1：踢掉某个非法登录用户</p><p>现在使用另一个用户登入我们的linux系统，假装是非法用户，我这里使用的是liuzhuo用户：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130142114.png"></p><p>现在查看liuzhuo用户的进程id，首先我们要知道进程的服务名字，因为是使用Xshell登入的，所以是sshd服务。</p><p><code>ps -aux | grep sshd</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130142341.png"></p><p><code>kill 3519</code> (liuzhuo用户的pid)<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130142618.png"></p><p>案例2: 终止远程登录服务sshd, 在适当时候再次重启sshd服务。</p><p>有些时候，我们的linux系统的管理员需要自己执行一些操作，不让远程用户登入，所以有这样的情况，杀死sshd服务。不再让远程登入用户！</p><p>首先找到sshd服务的pid：<br><code>ps -aux | grep sshd</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130142943.png"></p><p><code>kill 1110</code> （sshd的pid）<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130143119.png"></p><p>现在就只存在root用户了，其他用户想要远程登入linux系统是不能通过的：</p><p>我使用liuzhuo用户登入linux系统：失败<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130143309.png"></p><p>案例3: 终止多个gedit 编辑器。</p><p>kill pid：每次只能杀死一个进程，不能杀死多个进程，有些时候，我们需要一次性杀死多个进程，这个时候就需要使用：<br>killall指令了。</p><p><code>killall 进程名</code>（注意是进程名，不是进程id）<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130143851.png"></p><p>现在，我们一次性杀死多个gedit进程。执行：<code>killall gedit</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130144200.png"></p><p>案例4：强制杀掉一个终端  (对于:bash)</p><p>对于某些重要的进程，直接使用 kill 指令是杀不死的，需要带上参数： -9 ，强制杀死进程。</p><p>终端就是一个重要的进程。</p><p>打开两个终端，隔一段时间，否则无法区分开来的。</p><p>在第二个终端中输入：<code>ps -aux | grep bash</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130144752.png"></p><p>杀死第一个终端：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130144934.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130145124.png"></p><h2 id="查看进程树pstree"><a href="#查看进程树pstree" class="headerlink" title="查看进程树pstree"></a>查看进程树pstree</h2><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code>pstree [选项] (可以更加直观的来看进程信息)常用选项：-p :显示进程的PID-u :显示进程的所属用户</code></pre><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>案例1：请用树状的形式显示进程的pid</p><p><code>pstree -p</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130145605.png"></p><p>案例2：请用树状的形式显示进程的用户id</p><p><code>pstree –u</code>:只显示进程名，并且 合并进程名一样的进程<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130145944.png"></p><p><code>pstree -pu</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130150036.png"></p><h2 id="服务-service-管理"><a href="#服务-service-管理" class="headerlink" title="服务(service)管理"></a>服务(service)管理</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>服务(service) 本质就是进程，但是是运行在<font color="red"><strong>后台</strong></font>的，通常都会监听某个端口，等待其它程序的请求，比如(mysql , sshd , 防火墙等)，因此我们又称为<strong>守护进程</strong>，是Linux中非常重要的知识点。</p><h3 id="service管理指令"><a href="#service管理指令" class="headerlink" title="service管理指令"></a>service管理指令</h3><p>service  服务名 [start | stop | restart | reload | status]</p><p>在CentOS7.0后 不再使用 service , 而是 systemctl.</p><p>systemctl [start | stop | restart | reload | status] 服务名</p><p>centOS/RHEL6 系统中 System V init命令 与 centOS/RHEL7 系统中 Systemctl命令的对比:<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130155106.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130155127.png"></p><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>1) 查看当前防火墙的状况，关闭防火墙和重启防火墙。</p><pre><code>centOS6/RHEL6:service iptables start           # 启动service iptables stop            # 关闭service iptables restart         # 重启service iptables status          # 查看防火墙的状态chkconfig iptables on            # 开机启动chkconfig iptables off           # 取消开机启动--------------------- centOS7/RHEL7:systemctl start firewalld          # 启动systemctl stop firewalld           # 关闭systemctl restart firewalld        # 重启systemctl status firewalld         # 查看防火墙的状态systemctl enable firewalld         # 开机启动systemctl disable firewalld        # 取消开机启动firewall-cmd --list-all            #查看防火墙规则--------------------- </code></pre><p><code>service iptables status</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130153438.png"></p><p>在CentOS7 或 RHEL7 或 Fedora 中 防火墙由<strong> firewalld </strong>来管理.</p><p><code>systemctl status firewalld</code>：查看防火墙状态<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130160617.png"></p><p><code>systemctl stop firewalld</code> : 关闭防火墙<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130161040.png"></p><p><code>systemctl restart firewalld</code>：重启防火墙<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130161200.png"></p><hr><h3 id="CentOS切换为iptables防火墙"><a href="#CentOS切换为iptables防火墙" class="headerlink" title="CentOS切换为iptables防火墙"></a>CentOS切换为iptables防火墙</h3><p>切换到iptables首先应该关掉默认的firewalld，然后安装iptables服务。</p><p>1）关闭firewall</p><pre><code>systemctl stop firewalld          # 关闭systemctl disable firewalld       # 取消开机启动</code></pre><p>2) 安装iptables防火墙</p><pre><code>yum install iptables-services #安装</code></pre><p>3) 编辑iptables防火墙配置</p><pre><code>vi /etc/sysconfig/iptables</code></pre><p>下边是一个完整的配置文件：</p><pre><code>Firewall configuration written by system-config-firewallManual customization of this file is not recommended.*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT</code></pre><p>4）:wq! #保存退出</p><pre><code>service iptables start    #开启防火墙systemctl enable iptables #设置防火墙开机启动</code></pre><p><strong>细节：可以在windows宿主机中，使用 telnet 测试某个端口是否开启。</strong></p><h3 id="查看系统中的服务"><a href="#查看系统中的服务" class="headerlink" title="查看系统中的服务"></a>查看系统中的服务</h3><p>方式一：使用setup -&gt; 系统服务 就可以看到。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130163538.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130163606.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130163652.png"></p><p>服务名前面带有*的，就是开机自启动的：使用空格键来切换是否开启启动，Tab键来切换到确定和取消按钮。</p><p>方式二:   systemctl list-unit-files –type=service</p><p><code>systemctl list-unit-files --type=service</code> : 列出系统有哪些服务<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130164926.png"></p><h3 id="服务的运行级别-runlevel"><a href="#服务的运行级别-runlevel" class="headerlink" title="服务的运行级别(runlevel)"></a>服务的运行级别(runlevel)</h3><p><strong>查看或者修改默认级别：  vi /etc/inittab </strong></p><pre><code>Linux系统有7种运行级别(runlevel)：常用的是级别3和5运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆运行级别2：多用户状态(没有NFS)，不支持网络运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式运行级别4：系统未使用，保留运行级别5：X11控制台，登陆后进入图形GUI模式运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</code></pre><p>CentOS 7 之前的版本是通过 /etc/inittab 文件来定义系统运行级别:</p><pre><code># inittab is only used by upstart for the default runlevel.## ADDING OTHER CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.## System initialization is started by /etc/init/rcS.conf## Individual runlevels are started by /etc/init/rc.conf## Ctrl-Alt-Delete is handled by /etc/init/control-alt-delete.conf## Terminal gettys are handled by /etc/init/tty.conf and /etc/init/serial.conf,# with configuration in /etc/sysconfig/init.## For information on how to write upstart event handlers, or how# upstart works, see init(5), init(8), and initctl(8).## Default runlevel. The runlevels used are:#   0 - halt (Do NOT set initdefault to this)#   1 - Single user mode#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)#   3 - Full multiuser mode#   4 - unused#   5 - X11#   6 - reboot (Do NOT set initdefault to this)# id:5:initdefault:   #这里的数字：5就代表的是运行级别为5。修改成3后，就是多用户命令行的运行级别了。</code></pre><p>CentOS 7 版本不再使用该文件定义系统运行级别,相关运行级别设置无效:</p><pre><code># inittab is no longer used when using systemd.## ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.## Ctrl-Alt-Delete is handled by /etc/systemd/system/ctrl-alt-del.target## systemd uses &#39;targets&#39; instead of runlevels. By default, there are two main targets:## multi-user.target: analogous to runlevel 3# graphical.target: analogous to runlevel 5## To set a default target, run:## ln -sf /lib/systemd/system/&lt;target name&gt;.target /etc/systemd/system/default.target#id:3:initdefault:  #无效,不要在这个配置文件中写这行代码！！！</code></pre><p>新版本的运行级别都定义在 <code>/lib/systemd/system</code>下:</p><pre><code>[root@liuzhuo01 ~]# ls -ltr /lib/systemd/system/runlevel*lrwxrwxrwx. 1 root root 15 11月 27 16:37 /lib/systemd/system/runlevel0.target -&gt; poweroff.targetlrwxrwxrwx. 1 root root 13 11月 27 16:37 /lib/systemd/system/runlevel1.target -&gt; rescue.targetlrwxrwxrwx. 1 root root 17 11月 27 16:37 /lib/systemd/system/runlevel2.target -&gt; multi-user.targetlrwxrwxrwx. 1 root root 17 11月 27 16:37 /lib/systemd/system/runlevel3.target -&gt; multi-user.targetlrwxrwxrwx. 1 root root 17 11月 27 16:37 /lib/systemd/system/runlevel4.target -&gt; multi-user.targetlrwxrwxrwx. 1 root root 16 11月 27 16:37 /lib/systemd/system/runlevel5.target -&gt; graphical.targetlrwxrwxrwx. 1 root root 13 11月 27 16:37 /lib/systemd/system/runlevel6.target -&gt; reboot.target</code></pre><p>新版本的默认运行级别定义在：<code>/etc/systemd/system/default.target</code></p><pre><code>[root@liuzhuo01 ~]# ls -l /etc/systemd/system/default.targetlrwxrwxrwx. 1 root root 36 11月 27 16:50 /etc/systemd/system/default.target -&gt; /lib/systemd/system/graphical.target</code></pre><p>可以针对不同需要设置不同的运行级别:</p><p>如设置命令行级别(init 3)方法:</p><pre><code>ln -sf /lib/systemd/system/runlevel3.target /etc/systemd/system/default.target或ln -sf /lib/systemd/system/multi-user.target /etc/systemd/system/default.target或systemctl set-default multi-user.target</code></pre><p>设置窗口级别(init 5)方法:</p><pre><code>ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target或ln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.target或systemctl set-default graphical.target</code></pre><h3 id="chkconfig指令"><a href="#chkconfig指令" class="headerlink" title="chkconfig指令"></a>chkconfig指令</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍:"></a>介绍:</h4><p>通过chkconfig 命令 可以给<strong>每个服务</strong>的<strong>各个运行级别</strong> 设置自启动/关闭 （<strong>centOS7之前的版本使用的指令！！！</strong>）</p><h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法:"></a>基本语法:</h4><pre><code>1） chkconfig  --list                         #查看所有的服务2)  chkconfig  --list | grep 服务名           #查看指定的服务   3)  chkconfig   服务名   --list               #查看指定的服务4） chkconfig   服务名   on/off               #在所有级别，开启或关闭，指定的服务    iptables 彻底关闭  ：chkconfig  iptables off  [不管是哪个级别都关闭]5)  chkconfig  --level  5   服务名   on/off   #指定某个级别，开启或关闭，指定的服务、    sshd 服务在 1 运行级别 关闭 ： chkconfig --level 1 sshd off</code></pre><h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><p>1) 案例1： 请显示当前系统所有服务的各个运行级别的运行状态</p><p><code>chkconfig --list</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130171923.png"></p><p>2) 案例2 ：请查看sshd服务的运行状态</p><p><code>chkconfig sshd --list</code> 或者 <code>chkconfig --list | grep sshd</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130172752.png"></p><p>3) 案例3： 将sshd 服务在运行级别5下设置为不自动启动，看看有什么效果？</p><p><code>chkconfig –level 5 sshd off</code></p><p>4) 案例4： 当运行级别为5时，关闭防火墙。</p><p><code>chkconfig –level 5 iptables off</code></p><p>5) 案例5： 在所有运行级别下，关闭防火墙</p><p><code>chkconfig iptables off</code></p><p>6) 案例6： 在所有运行级别下，开启防火墙</p><p><code>chkconfig  iptables on</code></p><h4 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h4><p>chkconfig重新设置服务后自启动或关闭，重启机器才会按设置的状态运行。</p><h2 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>top与ps命令很相似。它们都用来显示正在执行的进程。top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的的进程(默认每3秒变化一次)。</p><h3 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code>top [选项]选项说明:-d 秒数            ：指定top命令每隔几秒更新。默认是3秒在top命令的交互模式当中可以执行的命令。-i         ：使用top不显示任何闲置 或者 僵死的进程。-p        ：通过指定监控进程的id来仅仅监控某个进程的状态。</code></pre><h3 id="交互操作说明"><a href="#交互操作说明" class="headerlink" title="交互操作说明"></a>交互操作说明</h3><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130173701.png"></p><h3 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h3><p>案例1.如何监视特定用户</p><p>top：输入此命令，按回车键，查看执行的进程。（默认3秒刷新一次）</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130174826.png"></p><pre><code>1）统计信息top -17:48:19 :表示当前的系统时间up 4:20  ：表示系统已经启动的时间（4小时20分钟）2 user   ：当前登录系统的用户数load average：表示系统的平均负载，3个数字分别表示1分钟、5分钟、15分钟到现在的系统平均负载值Tasks：227 total：表示进程的总数1 running：正在运行的进程数226 sleeping：处于休眠状态的进程数0 stopped：停止的进程数0 zombie：僵死的进程数%Cpu(s)：0.0 us：表示用户进程占用CPU的百分比0.3 sy：系统进程占用CPU的百分比0.0 ni：用户进程空间的内改变过优先级的进程占用CPU的百分比99.7 id：空闲CPU的百分比0.0 wa：等待输入、输出的进程占用CPU的百分比KiB Mem：4046020 total：系统的物理内存大小1950468 free：目前空余内存大小882624 userd：已经使用的物理内存大小1212928 buff/cache：用作内核缓冲区的内存大小KiB Swap：8388604 total：交换分区的内存大小8388604 free：交换分区空闲的内存大小0 used：交换分区已经使用的内存大小2）进程信息区PID：进程的IDUSER：进程所有者的用户名PR：进程的优先级NI：nice值。负值表示高优先级，正值表示低优先级VIRT：进程使用的虚拟内存总量，单位KBSHR：进程使用的、未被换出的物理内存大小，单位KBS：进程的状态，D-表示不可中断的睡眠状态，R-表示正在运行的状态，S-表示睡眠的状态，T-表示跟踪/停止，Z-表示僵死进程%CPU：上次更新到现在的CPU时间占用百分比%MEM：进程占用物理内存的百分比TIME+：进程总计使用的CPU时间，单位为1/100秒COMMAND：正在运行进程的命令名或者命令路径</code></pre><p>u：然后输入“u”回车，再输入用户名，即可。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130181001.png"></p><p>案例2：如何终止指定的进程。</p><p>top：输入此命令，按回车键，查看执行的进程。<br>k：然后输入“k”回车，再输入要结束的进程ID号<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130181123.png"></p><p>案例3:指定系统状态更新的时间(每隔10秒自动更新)：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130181215.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130181233.png"></p><h2 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>查看系统网络情况netstat</p><h3 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code>netstat [选项]选项说明 -an：按一定顺序排列输出-p ：显示哪个进程在调用-r ：显示路由表的信息</code></pre><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><p>1）查看所有服务的监听端口</p><p><code>netstat -anp | more</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130190225.png"></p><p>2) 查看服务名为 sshd 的服务的信息。</p><p><code>netstat -anp | grep sshd</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130190558.png"></p><p>3) 查看路由表的信息</p><p><code>netstat -r</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130190707.png"><br><code>netstat -rn</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130190838.png"></p><p><code>route -n</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day08/QQ截图20181130190948.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之网络设置</title>
      <link href="/2018/11/28/linux-ji-chu-ru-men-zhi-wang-luo-she-zhi/"/>
      <url>/2018/11/28/linux-ji-chu-ru-men-zhi-wang-luo-she-zhi/</url>
      
        <content type="html"><![CDATA[<p>Linux系统的网络设置</p><h2 id="桥接的方式"><a href="#桥接的方式" class="headerlink" title="桥接的方式"></a>桥接的方式</h2><p>之前，我们都是使用桥接的模式来连接虚拟机与宿主机的，桥接模式的缺点，之前我们也讲过了，会占用ip地址，引发ip地址冲突！！！</p><p>好处是，内网中的<strong>其他用户</strong>，也可以直接访问我的虚拟机，与我们的虚拟机通信。</p><p>比如：我宿主机的ip地址是：10.6.11.123。</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129100530.png"></p><p>使用桥接模式下的linux系统会自动帮我们，生成一个同网段下的ip地址：10.6.11.81<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129100614.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129100853.png"></p><p>然后，现在不管是你的宿主机ping虚拟机的ip地址，还是虚拟机ping你的宿主机的ip地址，都能成功。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129101126.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129101401.png"></p><p><strong>注意：你的同事、同学也能ping通你的虚拟机，因为你的宿主机、虚拟机、你的同事都在一个网段里面。</strong></p><p>下面，我使用我同学的Mac机远程登录我的虚拟机，成功：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129101910.png"></p><p><strong>坏处：如果每个人，都在虚拟机中使用桥接模式的话，那么该网段下的ip地址就会用光，某一天，当你开启你的虚拟机的linux系统时，你会听到你的同事说，又是哪个王八羔子抢了我本机的ip地址！！！</strong></p><h2 id="Nat模式"><a href="#Nat模式" class="headerlink" title="Nat模式"></a>Nat模式</h2><p>介绍：NAT网络主要作用是用于虚拟机与外网互通，它是宿主机内部的local网络，只有本主机内部可见，不能跨宿主机。</p><p>好处：虚拟机不占用其他的ip,所以不会ip冲突。</p><p>坏处：内网的其他人宿主机不能和虚拟机通讯。</p><h3 id="单独使用NAT网络"><a href="#单独使用NAT网络" class="headerlink" title="单独使用NAT网络"></a>单独使用NAT网络</h3><p>1）创建NAT网络</p><p>在创建虚拟机并为其指定NAT网络时，会弹出如下图所示的界面，其中包含<strong>网络地址转换（NAT）</strong>与<strong>NAT网络</strong>两个选项，这两个选项有什么区别呢？可以这样理解，网络地址转换（NAT）为VirtualBox内置的已经创建好的NAT网络，其网段为10.0.2.0/24，<strong>这个网络不允许用户管理</strong>，为了直观起见，在本例中创建自己的NAT网络。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129103000.png"></p><p>点击菜单中的管理按键，选择全局设定，再从对话框中选择网络，然后点击界面上的加号图标，弹出NAT网络明细对话框。其中网络名称随意，网络CIDR一栏的地址不能与宿主机所属的任何一个物理网络冲突，也不能与宿主机中已经存在的其它虚拟网络冲突。</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129103626.png"></p><p>现在，新增NAT网络：点击界面上的加号图标。</p><p>下图中，CIDR为10.6.28.0/24，VirtualBox会将10.6.28.1这个IP设置成网关，并且选中支持DHCP选择。这样就创建了网络号为10.6.28、具备DHCP功能、默认网关为10.6.28.1的NAT网络，这些功能都是Virtualbox通过一个服务进程实现的。</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129104140.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129104230.png"></p><p>现在，将我们的centOS_7.5系统的网络模式，改为我们刚刚设置的NAT网络：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129104722.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129104802.png"></p><p>设置完毕后，启动我们的centOS_7.5系统。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129105404.png"></p><p>测试是否能上网 和 与我们的宿主机是否连通：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129105550.png"></p><p><strong>注意：前提是你的宿主机本身能联网。</strong></p><p>虚拟机ping宿主机成功：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129105825.png"></p><p>宿主机ping虚拟机超时：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129161346.png"></p><p><strong>为啥，在使用NAT的模式下，虚拟机能够访问宿主机，能够通过宿主机上网成功，而宿主机却不能连通虚拟机呢？</strong></p><p>在NAT模式下，virtualBox帮我们创建的一个虚拟的内部网络，使用同一个NAT网络的内部虚拟机之间可以互相访问。</p><p>测试：使用virtualBox打开另一台Linux系统并且使用相同的NAT网络。</p><p>第二台的虚拟机的ip地址是：10.6.28.7<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129162644.png"></p><p>第一台的虚拟机的ip应该是10.6.28.4的，但是我重启了系统，现在变成了：10.6.28.6<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129162815.png"></p><p>现在互相ping。</p><p>第二台虚拟机ping第一台虚拟机：（成功）<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129163024.png"></p><p>第一台虚拟机ping第二台虚拟机：（成功）<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129163353.png"></p><p><strong>说明：使用相同的NAT网络，内部的虚拟机之间是可以互相访问的！！！</strong></p><p>到现在还是没有解释，我们的虚拟机能够联网呢？请看下图：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129164646.png"></p><p>首先，VirtualBox为我们创建了一个虚拟的二层交换机，两台虚拟机中的网卡都联接在这台交换机上。同时，此交换机具备DHCP功能，管理10.6.28.0/24的地址池，它的网关地址是10.6.28.1。另外DHCP还负责管理DNS地址，这里的DNS地址的来源是宿主机，VirtualBox从宿主机拿到后设置在这里。当虚拟机启动时，DHCP服务会为它分配IP地址，设置网关，设置DNS服务器地址。</p><p>我们来查看，我们的虚拟机的DNS服务器地址与我们的宿主机的DNS服务器地址是否一致：</p><p>虚拟机的DNS服务的地址：<br><code>cat /etc/resolv.conf</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129164958.png"></p><p>宿主机的DNS服务器的地址：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129165117.png"></p><p>发现是一样的，验证了我们的理论正确！！！</p><p>其次，VirtualBox为创建了一个三层的虚拟路由器，路由器中的路由表来源于宿主机，其实是与宿主机共享路由表。同时，因为创建的是NAT网络，这个路由器除了一般的路由功能，还是一个配置了NAT功能的路由器，实现宿主机IP地址+端口号与虚拟机IP地址+端口号之间的映射，最终实现与外部网络的通信。</p><p>可以看出，已经实现了一个完整的内部网络，包括带DHCP功能的二层交换机与带NAT功能的三层路由器。</p><p>所以，我们的虚拟机能够通过宿主机来访问外网。</p><p>但是，我们的宿主机是不知道虚拟机的存在的，所以宿主机ping不通我们的虚拟机。</p><h3 id="NAT-Host-only-的模式"><a href="#NAT-Host-only-的模式" class="headerlink" title="NAT + Host-only 的模式"></a>NAT + Host-only 的模式</h3><p>单独使用NAT网络的时候，是能很方便的连接外网的，但是宿主机与虚拟机是不能互通的，如果，我们想要互通怎么呢？</p><p>1）增加一个网卡，使用桥接的模式，宿主机与虚拟机通过桥接生成的ip地址互通。</p><p>不知道的话，请看桥接模式即可。</p><p>2）增加一个网卡，使用Host-only网络。</p><p>当你增加Host-only网络时，发现界面名称是：未指定时，需要我们自己来创建一个Host-only网卡。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129170122.png"></p><p>一般，我们下载完VirtualBox后，会自动生成一个Host-only网卡。默认的ip地址是：192.168.56.1</p><p>点击virtualBox的管理，然后点击主机网络管理器，新增一个网卡。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129170734.png"></p><p>此时，我们的宿主机上面，就会多出一个网络：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129170933.png"></p><p>修改我们的centOS网络，添加新的网卡（Host-only）：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129171051.png"></p><p>重新启动我们的centOS系统：</p><p><code>ifconfig 一下：</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129171407.png"></p><p>此时会多出一个网卡：enp0s8：就是我们刚刚设置的Host-only网卡。</p><p>来测试是否能上网：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129171617.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129171645.png"></p><p>来测试，宿主机与虚拟机是否能互通：</p><p>虚拟机ping宿主机：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129171846.png"></p><p>宿主机ping虚拟机：</p><p><strong>注意：这里宿主机是ping那个Host-only生成的ip地址！！！</strong><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129172312.png"></p><p>接下来，我们使用Xshell来连接我们的虚拟机试试：</p><p>新建连接，主机写：虚拟机中的host-only生成的ip地址。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129172946.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129173102.png"></p><p><strong>总结：使用 NAT + Host-only的模式，虚拟机通过NAT来连通外网，通过Host-only来与宿主机互通。</strong></p><h3 id="最佳方案"><a href="#最佳方案" class="headerlink" title="最佳方案"></a>最佳方案</h3><p>上面，我们已经学习了，NAT + Host-only的模式来连通外网，并且宿主机与虚拟机互通。</p><p>但是，上面的方案是DHCP的方式，即自动生成ip地址，这样的话，我们的ip会随时变动的，作为服务器的是不行的，我们需要设置静态的ip地址来作为服务器。</p><p>编辑我们的网卡配置文件：</p><p><code>/etc/sysconfig/network-scripts/</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129174545.png"></p><p>在该目录下，应该有两个配置文件：ifcfg-enp0s3 和 ifcfg-enp0s8</p><p><strong>ifcfg-enp0s3：</strong>就是NAT网络生成的ip地址</p><pre><code>vim ifcfg-enp0s3</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129175402.png"></p><p>ifcfg-enp0s3:动态生成ip地址就行，我们主要设置ifcfg-enp0s8，改为静态分配ip地址。</p><pre><code>vim ifcfg-enp0s8</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129180212.png"></p><p>注意上面的网关地址写错了，应该是：<strong>192.168.69.1</strong>！！！,不然重启网络会失败的。</p><p>保存并退出。</p><p><code>systemctl restart network</code> : 重启我们的网络！！！</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129191233.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129192721.png"></p><p>IP地址修改成功了，改成了静态配置，而且ip地址是我们自己输入的：<strong>192.168.69.200</strong></p><p>如果你重启网络的时候，出现异常，请查看你的Mac地址，网关是否配置有问题！！！</p><p>现在，重新修改我们的Xshell连接的主机ip地址：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129193012.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129193144.png"></p><p>以后，不管我们去哪里连接虚拟机都会成功了，因为现在是静态分配的ip了，不会变了。</p><hr><p>如果，我们是带有图形化界面的linux系统的话，其实可以直接图形化的方式修改ip地址。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129193541.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129193821.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129194101.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129194309.png"></p><p>修改完后，点击应用后，退出到网络设置页面，重新启动一下，就会更新我们的设置了！！！<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129194506.png"></p><p><strong>PS：不建议使用图形化的方式修改ip设置，我们学习，当然是以命令行为基准，图形化只是为了验证我们的配置是否正确而存在的！！！</strong></p><p><strong> NAT + Host-only的方式，是只能我们的宿主机与虚拟网络中的虚拟机互通，在该宿主机网络中的其他同事、同学是不能访问我们的虚拟机的，而桥接模式是可以的，注意两者之间的区别！！！</strong></p><h2 id="网络设置的几个重要配置文件"><a href="#网络设置的几个重要配置文件" class="headerlink" title="网络设置的几个重要配置文件"></a>网络设置的几个重要配置文件</h2><h3 id="网卡的配置文件"><a href="#网卡的配置文件" class="headerlink" title="网卡的配置文件"></a>网卡的配置文件</h3><pre><code>/etc/sysconfig/network-scripts/</code></pre><p>有几个网卡，就应该有几个：ifcfg-enp0s3、ifcfg-enp0s8等配置文件，有几个网卡就有几个配置文件，否则重启网络会出现异常！！！</p><p>配置文件的大概内容：</p><pre><code>DEVICE=enp0s3                  #接口名（设备,网卡的唯一标识，不能乱写的！！！）HWADDR=00:0C:2x:6x:0x:xx       #MAC地址 TYPE=Ethernet                  #网络类型（通常是Ethemet）UUID=926a57ba-92c6-4231-bacb-f27e5e6a9f44  #网卡的唯一标识。（自动生成的，要唯一！！！）ONBOOT=yes                     #系统启动的时候网络接口是否有效（yes/no）# IP的配置方法[none|static|bootp|dhcp]（引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议）BOOTPROTO=static      IPADDR=192.168.69.200          #IP地址PREFIX=24                      #设置子网掩码GATEWAY=192.168.69.1           #网关 DNS1=192.168.69.1              #域名解析器</code></pre><p><strong>PS：在centOS7之后的版本，可以在配置文件中设置多个ip地址，IPADDR0=xxx.xxx.xxx.xxx，IPADDR1=xxx.xxx.xxx.xxx，依次类推。</strong></p><p><strong>PREFIX：子网掩码也是一样的，PREFIX0，PREFIX1，与上面的ip地址对应；24：代表255.255.255.0 , 26：代表255.255.255.192</strong></p><p>GATEWAY:网关，可以在这里配置，也可以在 /etc/sysconfig/network中配置，如果没有在网卡配置文件中设置网关，那么/etc/sysconfig/network中的网关地址会生效。默认情况下，网卡配置文件中的网关配置会覆盖/etc/sysconfig/network中的网关设置。</p><h3 id="网关的配置文件"><a href="#网关的配置文件" class="headerlink" title="网关的配置文件"></a>网关的配置文件</h3><pre><code>/etc/sysconfig/network</code></pre><p>配置文件中的内容：</p><pre><code>GATEWAY=192.168.69.1</code></pre><h3 id="主机名的配置文件"><a href="#主机名的配置文件" class="headerlink" title="主机名的配置文件"></a>主机名的配置文件</h3><pre><code>/etc/hostname</code></pre><p>配合文件中的内容：</p><pre><code>liuzhuo01    #主机名</code></pre><p>查看主机名：直接使用 hostname指令即可。</p><h3 id="ip和主机映射的文件"><a href="#ip和主机映射的文件" class="headerlink" title="ip和主机映射的文件"></a>ip和主机映射的文件</h3><pre><code>/etc/hosts</code></pre><p>配置文件中的内容：</p><pre><code>127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</code></pre><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>有些时候，我们想直接ping主机名来访问，不想ping我们虚拟机的ip地址，不好记。</p><p>现在，我们尝试直接ping主机名：</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129203255.png"></p><p>现在添加新的 ip 与 主机名的映射信息：</p><pre><code>vim /etc/hosts</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129213529.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129213635.png"></p><p>这里，虚拟机自己ping自己的域名没有什么意义，我们想要在windows宿主机也能ping通虚拟机的主机名，该怎么呢？<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129214028.png"></p><p>修改windows下的：</p><pre><code>C:\Windows\System32\drivers\etc\hosts</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129214230.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129214441.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129214543.png"></p><p>现在，使用Xshell的时候，创建一个新的连接，主机：填写你的虚拟机的主机名也可以连接成功。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129214732.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day07/QQ截图20181129214802.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之任务调度与磁盘分区</title>
      <link href="/2018/11/28/linux-ji-chu-ru-men-zhi-ren-wu-diao-du/"/>
      <url>/2018/11/28/linux-ji-chu-ru-men-zhi-ren-wu-diao-du/</url>
      
        <content type="html"><![CDATA[<p>定时任务调度、磁盘分区</p><h2 id="Linux的crond任务调度"><a href="#Linux的crond任务调度" class="headerlink" title="Linux的crond任务调度"></a>Linux的crond任务调度</h2><p>crontab 进行 定时任务的设置。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>任务调度：是指系统在某个时间执行的特定的命令或程序。 </p><p>任务调度分类：</p><p>1.系统工作：有些重要的工作必须周而复始地执行，比如病毒扫描等。<br>2.个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份。</p><h3 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h3><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128131351.png"></p><p>如果，我们需要备份mysql数据，而且是在晚上凌晨两点的时候执行效率才会高，我们不可能每天凌晨两点去执行备份mysql数据的命令，所以可以使用crontab任务调用机制，帮助我们每天凌晨两点自动执行备份mysql数据的命令。</p><p>使用步骤：</p><p>1）编写我们特殊的脚本（shell编程）</p><p>2）使用crontab任务调用我们的脚本执行。</p><p><strong>注意：简单的脚本，可以不用写，直接使用crontab就可以帮助我们执行了。</strong></p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code>crontab [选项]常用选项-e：编辑crontab定时任务-l：查询crontab任务-r：删除当前用户所有的crontab任务</code></pre><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>设置任务调度文件：/etc/crontab<br>设置个人任务调度: 执行 crontab –e 命令。<br>接着输入任务到调度文件：</p><pre><code>如：*/1 * * * * ls –l  /home/ &gt;&gt; /home/tmp/to.txt</code></pre><p>意思是说：当前时间每隔一分钟就执行 ls –l /home/ &gt;&gt; /home/tmp/to.txt命令.</p><p>步骤如下：</p><p>1）crontab -e</p><p>2）输入：<code>*/1 * * * * ls –l  /home/ &gt;&gt; /home/tmp/to.txt</code></p><p>3) 当保存退出后就执行定时任务。</p><p>4）在每一分钟都会自动的调用：ls –l  /home/ &gt;&gt; /home/tmp/to.txt</p><hr><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128133356.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128133518.png"></p><p>保存退出：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128133600.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128133720.png"></p><p>之后每隔一分钟都会往 /home/tmp/to.txt 文件中，追加：ls -l /home/ 的信息。</p><h3 id="参数细节说明"><a href="#参数细节说明" class="headerlink" title="参数细节说明"></a>参数细节说明</h3><p>1）5个占位符的说明<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128134026.png"></p><p>2）特殊符号的说明<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128134119.png"></p><p>3）特定时间执行任务案例<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128134542.png"></p><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>案例1：每隔1分钟，就将当前的日期信息，追加到 /home/tmp/mydate.log 文件中</p><p>1) 在/home下：编写一个文件（shell）mytask1.sh</p><p><code>date &gt;&gt; /home/tmp/mydate.log</code></p><p>2) 给mytask1.sh分配一个可执行的权限</p><p><code>chmod 744 /home/mytask1.sh</code></p><p>3）crontab -e</p><p><code>*/1 * * * *  /home/mytask1.sh</code></p><p>4）保存退出即可。</p><hr><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128138836.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128140946.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128141112.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128141317.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128141248.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128141507.png"></p><p>案例2：每隔1分钟， 将当前日期和日历都追加到 /home/mycal.log 文件中</p><p><code>*/1 * * * *  date &gt;&gt; /home/mycal.log</code><br><code>*/1 * * * *  cal &gt;&gt; /home/mycal.log</code></p><p>案例3: 每天凌晨2:00 将mysql数据库 testdb ，备份到文件中。</p><pre><code>步骤：1， 首先编写一个 脚本 backupdb.sh#!/bin/bash   #备份路径BACKUP=/data/backup/sql/dy#当前时间DATETIME=$(date +%Y-%m-%d_%H%M%S)echo &quot;===备份开始===&quot;echo &quot;备份文件存放于${BACKUP}/$DATETIME.tar.gz&quot;#数据库地址HOST=localhost#数据库用户名DB_USER=root#数据库密码DB_PW=Ces123456#创建备份目录[ ! -d &quot;${BACKUP}/$DATETIME&quot; ] &amp;&amp; mkdir -p &quot;${BACKUP}/$DATETIME&quot;#后台系统数据库DATABASE=dy_backgroundmsmysqldump -u${DB_USER} -p${DB_PW} --host=$HOST -q -R --databases $DATABASE | gzip &gt; ${BACKUP}/$DATETIME/$DATABASE.sql.gz#投入品监管数据库DATABASE=dy_firipmysqldump -u${DB_USER} -p${DB_PW} --host=$HOST -q -R --databases $DATABASE | gzip &gt; ${BACKUP}/$DATETIME/$DATABASE.sql.gz#压缩成tar.gz包cd $BACKUPtar -zcvf $DATETIME.tar.gz $DATETIME#删除备份目录rm -rf ${BACKUP}/$DATETIME#删除30天前备份的数据find $BACKUP -mtime +30 -name &quot;*.tar.gz&quot; -exec rm -rf {} \;echo &quot;===备份成功===&quot;</code></pre><h3 id="crond-相关指令"><a href="#crond-相关指令" class="headerlink" title="crond 相关指令:"></a>crond 相关指令:</h3><pre><code>1) crontab -e：创建任务调度。2) crontab –l：列出当前有那些任务调度。3) conrtab –r：终止任务调度。4) service crond restart ： [重启任务调度]   &lt;=====&gt; systemctl restart crond</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128135000.png"></p><h2 id="Linux的磁盘分区、挂载"><a href="#Linux的磁盘分区、挂载" class="headerlink" title="Linux的磁盘分区、挂载"></a>Linux的磁盘分区、挂载</h2><h3 id="分区基础知识"><a href="#分区基础知识" class="headerlink" title="分区基础知识"></a>分区基础知识</h3><h4 id="分区的方式-知道即可"><a href="#分区的方式-知道即可" class="headerlink" title="分区的方式(知道即可)"></a>分区的方式(知道即可)</h4><p>1) mbr分区:</p><p>1.最多支持四个主分区<br>2.系统只能安装在主分区<br>3.扩展分区要占一个主分区<br>4.MBR最大只支持2TB，但拥有最好的兼容性</p><p>2) gtp分区:</p><p>1.支持无限多个主分区（但操作系统可能会限制，比如 windows下最多128个分区）<br>2.最大支持18EB的大容量（1EB=1024 PB，1PB=1024 TB ）<br>3.windows7 64位以后支持gtp</p><h4 id="windows下的磁盘分区"><a href="#windows下的磁盘分区" class="headerlink" title="windows下的磁盘分区"></a>windows下的磁盘分区</h4><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128144519.png"></p><h4 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h4><p>原理介绍：</p><p>1）对Linux来说无论有几个分区，分给哪一个目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 , Linux中每个分区都是用来组成整个文件系统的一部分。</p><p>2）Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</p><p>3）示意图【分区和文件目录】<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128145010.png"></p><h4 id="Linux硬盘说明"><a href="#Linux硬盘说明" class="headerlink" title="Linux硬盘说明"></a>Linux硬盘说明</h4><p>1）Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是<strong>SCSI硬盘</strong>。</p><p>2）对于IDE硬盘，驱动器标识符为“hdx~”,其中“hd”表明分区所在设备的类型，这里是指IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）,“~”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。</p><p>例如，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区 , hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。 </p><p>3）对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。<br>sdb1 [表示第2块scsi 硬盘的第1个分区]</p><h4 id="查看所有设备挂载情况"><a href="#查看所有设备挂载情况" class="headerlink" title="查看所有设备挂载情况"></a>查看所有设备挂载情况</h4><p>命令：<code>lsblk</code> 或者 <code>lsblk -f</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128150000.png"></p><h3 id="挂载的经典案例"><a href="#挂载的经典案例" class="headerlink" title="挂载的经典案例"></a>挂载的经典案例</h3><p>说明：</p><p>下面我们以增加一块硬盘 2G 为例来熟悉下磁盘的相关指令和深入理解：磁盘分区、挂载、卸载的概念。</p><p>如何增加一块硬盘：</p><pre><code>步骤：1）虚拟机添加硬盘2）分区3）格式化4）挂载5）设置可以自动挂载 。</code></pre><h4 id="增加硬盘"><a href="#增加硬盘" class="headerlink" title="增加硬盘"></a>增加硬盘</h4><p>1）虚拟机增加硬盘</p><p>在虚拟机关闭的情况的下，点击设置，找到存储，点击控制器：SATA右边的第二个加号！<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128165053.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128165215.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128165251.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128165510.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128165619.png"></p><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>2）使用fdisk命令分区</p><p>重启我们的linux系统：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128170120.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128170250.png"></p><p>使用：<code>fdisk /dev/sdb</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128170533.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128170702.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128170851.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128171009.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128171209.png"></p><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>3) 使用 <code>mkfs -t xfs /dev/sdb1</code> [把sdb1格式化为：xfs格式的文件系统]<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128171435.png"></p><p>4）创建挂载点：/home/newdisk<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128171637.png"></p><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>5) 使用 <code>mount /dev/sdb1 /home/newdisk</code> [将sdb1分区，挂载到/home/newdisk中]<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128172131.png"></p><p>此时，就已经完成了，磁盘的分区、格式化、挂载了，就可以使用/home/newdisk来操作硬盘了。但是这种挂载是临时的，当我们重启之后，挂载点就会消失。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128172245.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128172634.png"></p><h4 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h4><p>6）永久性的挂载成功</p><p>通过修改/etc/fstab实现永久性挂载。添加完后，需要执行：<code>mount -a</code>即刻生效！<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128172906.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128173000.png"></p><p><strong>技巧：在正常模式下，yy+p会复制粘贴当前行！！！</strong></p><p>保存修改后，执行：<code>mount -a</code>,即刻生效！<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128173503.png"></p><p>现在，你重启后，也会自动挂载成功！！！</p><h3 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h3><h4 id="查询系统整体磁盘使用情况"><a href="#查询系统整体磁盘使用情况" class="headerlink" title="查询系统整体磁盘使用情况"></a>查询系统整体磁盘使用情况</h4><p>基本语法：</p><pre><code>df -h</code></pre><p>应用实例：</p><p>查询系统整体磁盘使用情况<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128175623.png"></p><h4 id="查询指定目录的磁盘占用情况"><a href="#查询指定目录的磁盘占用情况" class="headerlink" title="查询指定目录的磁盘占用情况"></a>查询指定目录的磁盘占用情况</h4><p>基本语法</p><pre><code>du -h  /目录查询指定目录的磁盘占用情况，默认为当前目录-s 指定目录占用大小汇总-h 带计量单位-a 含文件--max-depth=1  子目录深度-c 列出明细的同时，增加汇总值</code></pre><p>应用实例：</p><p>查询 /usr目录的磁盘占用情况，深度为1。</p><p><code>du  -ach  --max-depth=1  /usr</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128180112.png"></p><h4 id="磁盘情况-工作实用指令"><a href="#磁盘情况-工作实用指令" class="headerlink" title="磁盘情况-工作实用指令"></a>磁盘情况-工作实用指令</h4><p>1) 统计 /home 文件夹下<strong>文件</strong>的个数</p><p><code>ls –l /home/ | grep &quot;^-&quot; | wc -l</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128193317.png"></p><p>2) 统计 /home 文件夹下<strong>目录</strong>的个数。</p><p><code>ls –l /home/ | grep &quot;^d&quot; | wc -l</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128193601.png"></p><p>3) 统计 /home文件夹下文件的个数，包括<strong>子文件夹</strong>里的。</p><p><code>ls –lR /home/ | grep &quot;^-&quot; | wc -l</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128193831.png"><br>4) 统计 /home文件夹下目录的个数，包括子文件夹里的。</p><p><code>ls –lR /home/ | grep &quot;^d&quot; | wc -l</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128193922.png"></p><p>5) 以树状显示：home目录结构。[没有tree指令咋办, 使用yum 来安装]<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128194037.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day06/QQ截图20181128194147.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之权限</title>
      <link href="/2018/11/27/linux-ji-chu-ru-men-zhi-quan-xian/"/>
      <url>/2018/11/27/linux-ji-chu-ru-men-zhi-quan-xian/</url>
      
        <content type="html"><![CDATA[<p>组管理和权限管理</p><h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><h3 id="linux组的基本介绍"><a href="#linux组的基本介绍" class="headerlink" title="linux组的基本介绍"></a>linux组的基本介绍</h3><p>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件都有：所有者、所在组、其它组 的概念。</p><h3 id="文件-目录-所有者"><a href="#文件-目录-所有者" class="headerlink" title="文件/目录 所有者"></a>文件/目录 所有者</h3><p>一般为文件的创建者 ， 谁创建了该文件，就自然的成为该文件的所有者。</p><p>1）查看文件的所有者</p><p>指令：ls –ahl</p><p>应用实例 :创建一个组police,再创建一个用户tom,将tom放在police组 ,然后使用 tom来创建一个文件 ok.txt，看看情况如何？<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127195335.png"></p><p>2）修改文件所有者</p><p>指令：chown 用户名 文件名 </p><p>应用案例要求：使用root 创建一个文件apple.txt ，然后将其所有者修改成 tom。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127195757.png"></p><h3 id="文件-目录-所在组"><a href="#文件-目录-所在组" class="headerlink" title="文件/目录 所在组"></a>文件/目录 所在组</h3><p>当某个用户创建了一个文件后，默认情况下，这个文件的所在组就是该用户所在的组。</p><p>1）查看文件/目录所在组</p><p>基本指令：ls –ahl </p><p>2）修改文件所在的组</p><p>基本指令：</p><p><code>chgrp</code> 组名 文件名</p><p>应用实例：</p><p>使用root用户创建文件 orange.txt ,看看当前这个文件属于哪个组【root】，然后将这个文件所在组，修改到 police组。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127200619.png"></p><h3 id="其它组"><a href="#其它组" class="headerlink" title="其它组"></a>其它组</h3><p>除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</p><h3 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h3><p>在添加用户时，可以指定将该用户添加到哪个组中，同样的，使用root的管理权限可以改变某个用户所在的组。</p><p>1）改变用户所在组</p><pre><code>1) usermod   –g   组名  用户名2) usermod   –d   目录名  用户名  改变该用户登陆的初始目录。</code></pre><p>2) 应用实例</p><p>创建一个土匪组（bandit）将 tom 这个用户从原来所在的police组，修改到 bandit(土匪) 组中。</p><p><code>usermod  -g  bandit  tom</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127201505.png"></p><hr><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><pre><code>ls  -l 中显示的内容如下：-rwxrw-r-- 1 root police 1213 Feb 2 09:39 ok.txt</code></pre><p>0-9位说明:</p><p>1) 第0位确定文件类型(说明: -:普通文件, d:目录，l : 连接文件, c: 字符设备文件[键盘,鼠标] b: 块设备文件[硬盘] )</p><p>2) 第1-3位确定所有者（该文件的所有者）拥有该文件的权限。r: 读 , w : 写权限 , x:  执行权限  </p><p>3) 第4-6位确定所属组（同用户组的）拥有该文件的权限</p><p>4) 第7-9位确定其他用户拥有该文件的权限 </p><p>5) <code>1</code>: 如果是文件，表示硬链接的数目， 如果是目录，则表示有多少个子目录（不包含文件）</p><p>6) 1213： 表示文件大小(字节)，如果是目录，则统一为 4096。</p><p>7）Feb 2 09:39：文件最后的修改时候。</p><h3 id="rwx权限详解"><a href="#rwx权限详解" class="headerlink" title="rwx权限详解"></a>rwx权限详解</h3><h4 id="rwx作用到文件-重要"><a href="#rwx作用到文件-重要" class="headerlink" title="rwx作用到文件(重要)"></a>rwx作用到文件(重要)</h4><p>1) [ r ] 代表可读(read): 可以读取,查看<br>2) [ w ] 代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.<br>3) [ x ] 代表可执行(execute):可以被执行</p><h4 id="rwx作用到目录-重要"><a href="#rwx作用到目录-重要" class="headerlink" title="rwx作用到目录(重要)"></a>rwx作用到目录(重要)</h4><p>1) [ r ] 代表可读(read): 可以读取，ls查看目录内容<br>2) [ w ] 代表可写(write): 可以修改,目录内创建+删除+重命名目录<br>3) [ x ] 代表可执行(execute):可以进入该目录  </p><h4 id="文件及目录权限实际案例"><a href="#文件及目录权限实际案例" class="headerlink" title="文件及目录权限实际案例"></a>文件及目录权限实际案例</h4><p>ls  -l 中显示的内容如下：<br>-<font color="red">rwx</font><font color="blue">rw-</font><code>r--</code>. 1 root root 1213 Feb 2 09:39 abc</p><p>10个字符确定不同用户能对文件的权限：</p><p> 第一个字符代表文件类型： 文件 (-) , 目录(d) , 链接(l)</p><p> 其余字符每3个一组(rwx) 读(r) 写(w) 执行(x)<br> 第一组<font color="red">rwx</font> : 文件拥有者的权限是读、写和执行<br> 第二组<font color="blue">rw-</font> : 与文件所在组的用户的权限是读、写但不能执行<br> 第三组<code>r--</code> :  不与文件拥有者同组的其他用户的权限是读不能写和执行</p><p>可用数字表示为: r=4 , w=2 , x=1 因此 rwx = 4 + 2 + 1 = 7 .</p><p>r: 100 , w: 010 ,  x: 001</p><p>   1        文件：硬连接数 或  目录：子目录数<br>   root          用户<br>   root          组<br>   1213                  文件大小(字节)，如果是目录的话，显示 4096字节<br>   Feb 2 09:39      最后修改日期<br>   abc                    文件名 </p><h3 id="修改权限-chmod"><a href="#修改权限-chmod" class="headerlink" title="修改权限-chmod"></a>修改权限-chmod</h3><p>基本说明：</p><p>通过chmod指令，可以修改文件或者目录的权限。</p><h4 id="第一种方式：-、-、-变更权限"><a href="#第一种方式：-、-、-变更权限" class="headerlink" title="第一种方式：+ 、- 、= 变更权限"></a>第一种方式：+ 、- 、= 变更权限</h4><p> <code>u:所在者</code>  <code>g:所在组</code>  <code>o:其他组</code>  <code>a:所有人</code>(u、g、o的总和)</p><p> 1) chmod   u=rwx , g=rx , o=x　　文件、目录 【表示：给所有者rwx, 给所在组的用户 rx , 给其他人 x】<br> 2) chmod   o+w    文件、目录 【表示：给其它用户增加w 的权限】<br> 3) chmod   a-x    文件、目录    【表示：给所有用户 去掉 x权限】</p><p>案例演示：</p><p>1) 给abc文件的 <strong>所有者</strong>读写执行的权限 ，给<strong>所在组</strong>读执行权限 ，给<strong>其它组</strong>读执行权限。</p><p>chmod  u=rwx , g=rx , o=rx   abc</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127205641.png"><br>2) 给abc文件的 <strong>所有者</strong>除去执行的权限，<strong>所在组</strong>增加写的权限</p><p>chmod  u-x, g+w abc<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127205833.png"></p><p>3) 给abc文件的<strong>所有用户</strong>添加读的权限 </p><p>chmod  a+r  abc<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127205959.png"></p><h4 id="第二种方式：通过数字变更权限"><a href="#第二种方式：通过数字变更权限" class="headerlink" title="第二种方式：通过数字变更权限"></a>第二种方式：通过数字变更权限</h4><p>r=4 w=2 x=1　　　　　rwx=4+2+1=7</p><p>chmod <code>u=rwx , g=rx , o=x</code> 　文件、目录  《==》   chmod   <code>751</code>  文件、目录</p><p>因为 rwx：111=7 ， rx：101=5 ， x：001=1</p><p>案例演示</p><p>要求：将 /home/abc.txt 文件的权限修改成  <code>rwxr-xr-x</code>, 使用给数字的方式实现：</p><p>chmod　　u=rwx , g=xr ,  o=x　　/home/abc.txt<br>chmod　　751　　/home/abc.txt<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127210926.png"></p><h3 id="修改文件所有者-chown"><a href="#修改文件所有者-chown" class="headerlink" title="修改文件所有者-chown"></a>修改文件所有者-chown</h3><p>基本介绍</p><p>chown　newowner　file　　改变文件的所有者</p><p>chown　newowner : newgroup　　file　　改变用户的所有者和所有组</p><p><code>-R</code>  如果是目录 则使其下所有子文件或目录递归生效</p><p>案例演示：</p><p>1) 请将 /home/abc.txt 文件的所有者修改成 tom.</p><p>chown   tom  /home/abc.txt<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127212038.png"></p><p>2) 请将 /home/kkk 目录下所有的文件和目录的所有者都修改成tom.</p><p>chown <code>–R</code> tom  /home/kkk<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127212509.png"></p><p>3) 将/home/aaa下的所有文件和目录的所有者都改成 tom，将所在组改成police.</p><p>chown <code>–R  tom:police</code>   /home/aaa<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127212710.png"></p><h3 id="修改文件所在组-chgrp"><a href="#修改文件所在组-chgrp" class="headerlink" title="修改文件所在组-chgrp"></a>修改文件所在组-chgrp</h3><p>基本介绍</p><p>chgrp newgroup file  改变文件的所有组</p><p>案例演示：</p><p>1) 请将 /home/abc.txt 文件的所在组修改成 bandit (土匪)</p><p>chgrp  bandit  /home/abc.txt<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127213015.png"></p><p>2) 请将 /home/kkk 目录下所有的文件和目录的所在组都修改成 bandit(土匪)</p><p>chgrp  -R  bandit /home/kkk<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127213340.png"></p><h3 id="最佳实践-警察和土匪游戏"><a href="#最佳实践-警察和土匪游戏" class="headerlink" title="最佳实践-警察和土匪游戏"></a>最佳实践-警察和土匪游戏</h3><p>police（警察） ， bandit（土匪） </p><p>jack , jerry: 警察<br>xh , xq: 土匪</p><p>1）创建组 </p><pre><code>[root@liuzhuo01 home]# groupadd police[root@liuzhuo01 home]# groupadd bandit</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127214046.png"><br>2）创建用户 </p><pre><code>[root@liuzhuo01 home]# useradd -g police jack[root@liuzhuo01 home]# useradd -g police jerry[root@liuzhuo01 home]# useradd -g bandit xh[root@liuzhuo01 home]# useradd -g bandit xq</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127215156.png"></p><p>并给四个用户，添加密码。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127215523.png"></p><p>3）jack 创建一个文件，自己可以读写，本组人可以读，其它组没人任何权限</p><p>使用Xshell创建一个新的连接，使用jack登录。然后创建一个jack.txt文件。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127215732.png"></p><p>使用：<code>chmod 640 jack.txt</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127220010.png"></p><p>4）jack 修改该文件，让本组人可以读写 , 其它组人可以读</p><p>使用：<code>chmod g=rw,o=r jack.txt</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127220327.png"></p><p>5）<strong>xh 投靠 警察，看看是否可以读写jack.txt文件（重点）.</strong></p><p>首先使用xh连接，登入到linux系统中：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127220458.png"></p><p>进入jack.txt所在的目录，才能修改jack.txt文件。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127220643.png"></p><p>会发现权限不够，根本不能进入jack目录中，因为jack是police组，xh是bandit，组不同，而jack目录对其他组的权限无。</p><p>题目的要求是让我们把xh改为police组，所以，我们必须让jack对所在组police修改为：rx的权限，xh才能进入到jack目录中，修改jack.txt文件。</p><p>在root用户下，修改xh所在组为police组：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127221209.png"></p><p>在jack用户下，修改jack目录的所在组police有rx的权限：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127221427.png"></p><p>在xh用户下，进入jack目录<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127221545.png"></p><p>发现还是权限不够，我们的理论错了嘛？ 不是的，是需要我们注销，重新登入xh用户。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127221731.png"></p><p>修改jack.txt文件：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127222032.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127221902.png"></p><p>使用jack查看jack.txt文件，看是否修改成功：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day05/QQ截图20181127222225.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之指令</title>
      <link href="/2018/11/25/linux-ji-chu-ru-men-zhi-zhi-ling/"/>
      <url>/2018/11/25/linux-ji-chu-ru-men-zhi-zhi-ling/</url>
      
        <content type="html"><![CDATA[<p>本篇会介绍Linux系统的常用指令</p><h2 id="Linux实操指令"><a href="#Linux实操指令" class="headerlink" title="Linux实操指令"></a>Linux实操指令</h2><p>在我们实际工作中，是不会直接到服务器机房去登录linux系统，然后在上操作的，也不会操作图形化界面。</p><p>所以，我们必须掌握一些实用的指令，通过命令来操作linux系统。</p><h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><p>1）基本介绍</p><p>运行级别说明： </p><p>0 ：关机<br>1 ：单用户  [类似安全模式， 这个模式可以帮助<strong>找回root密码</strong>]<br>2：多用户状态没有网络服务<br><strong>3：多用户状态有网络服务 [字符界面]</strong><br>4：系统未使用保留给用户<br><strong>5：图形界面 </strong><br>6：系统重启  </p><p>常用运行级别是 3 和 5 ，要修改默认的运行级别可改配置文件【/etc/inittab】。</p><p><strong>/etc/inittab</strong> 文件中： <strong>id:5:initdefault: </strong>   //这一行中的数字就是默认的运行级别</p><p>命令：init  [012356]  ：切换运行级别</p><hr><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181125212656.png"></p><p>以上是CentOS 7.x版本之前的系统中使用的。而CentOS 7.x版本中，由于采用了systemd管理体系，因此以前运行级别（runlevel）的概念被新的运行目标（target）所取代，target的命名类似于 “ multi-user.target “ 这种形式.</p><p>比如原来的运行级别：3（runlevel3）对应于新的多用户目标 “ multi-user.target “,运行级别5就对应于” graphical.target “。因为systemd机制中不再使用runlevel的概念，所以/etc/inittab也不再被系统使用。</p><p>在新的systemd管理体系中，默认的target通过软连接来实现的。</p><p>2) 要查看系统的默认target，可以执行如下：</p><pre><code>ll /etc/systemd/system/default.target</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181125220550.png"></p><p>由此可知，现在系统的默认target为 “ graphical.target “ , 相当于 runlevel5.</p><p>3) 修改默认的运行级别为3</p><p>如果要修改默认的target为 “multi-user.target”,可以先删除存在的软链接，然后重新建立软链接指向到 “ multi-user.target “ 即可。</p><p>操作过程如下：<strong>(下面会有更简单的修改方式)</strong></p><pre><code>rm -rf /etc/systemd/system/default.targetln -sf /lib/systemd/system/multi-user.target  /etc/systemd/system/default.targetll /etc/systemd/system/default.target</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181125221432.png"></p><p>重启linux系统，reboot</p><p>你会发现我们的linux系统启动后，直接进入了字符界面，没有图形化界面。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181125221515.png"></p><hr><p>4）查看运行级别与target的对应关系，可以执行</p><pre><code>ll /lib/systemd/system/runlevel*.target</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181125222306.png"></p><p>即：</p><p>poweroff.target 对应 runlevel0：关机模式。</p><p>rescue.target 对应 runlevel1：单用户或救援模式。</p><p>multi-user.target 对应 runlevel2、runlevel3、runlevel4：字符界面多用户模式。</p><p>graphical.target 对应 runlevel5：图形界面多用户模式。</p><p>reboot.target 对应 runlevel6：重启模式。</p><hr><p>以前修改默认的运行级别是，通过修改 /etc/inittab文件来实现的，</p><p>在以前的/etc/inittab文件的最后一行是：</p><p>id:5:initdefault:  //表示默认的运行级别是5，图形界面多用户模式。只需要修改这个数字就可以修改默认的运行级别了。</p><p>而CentOS7.x版本的 /etc/inittab文件为：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181125223455.png"></p><p>只能通过上述修改软链接的方式来修改默认的target。</p><p>现在我们把 “ multi-user.target “ 修改为：” graphical.target “</p><font color="red"><strong>简便的方式：</strong></font><h3 id="查看默认的-target-运行级别-："><a href="#查看默认的-target-运行级别-：" class="headerlink" title="查看默认的 target(运行级别)："></a>查看默认的 target(运行级别)：</h3><pre class=" language-java"><code class="language-java">systemctl get<span class="token operator">-</span><span class="token keyword">default</span></code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图2018112522423.png"></p><h3 id="修改默认的-target-运行级别-："><a href="#修改默认的-target-运行级别-：" class="headerlink" title="修改默认的 target(运行级别)："></a>修改默认的 target(运行级别)：</h3><pre><code>systemctl set-default graphical.target</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181125224511.png"></p><hr><p>以前的版本，使用： init [0213456] 来切换运行级别，现在的版本使用：systemctl isolate xxx.target （以前的init也适用）</p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>在忘记了root的密码的情况下，怎么登入系统，并修改root的密码？</p><p>重启我们的linux系统，首先我们进入开机界面.</p><h4 id="错误操作"><a href="#错误操作" class="headerlink" title="错误操作"></a>错误操作</h4><p>1) 按e进行选择，选择编辑选项启动<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126105206.png"></p><p>看上图的底部，有：Press e 进入编辑界面。</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126102855.png"></p><p>2) 使用键盘上面的向下的按钮，找到：linux16 开头的那行。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126105357.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126110106.png"></p><p>3) 看到上图的底部，使用 Ctrl + x 去开始启动系统。</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126110315.png"></p><p>现在已经进入了系统了，而且是单用户的模式，所以不需要输入密码，就进入root用户了。</p><p>4) 然后使用：passwd root 修改root的密码。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126110507.png"></p><p>5) 修改root密码成功后，退出我们的单用户模式，输入：<code>exec /sbin/init</code> 回车<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126110721.png"></p><p>6）输入我们的修改后的root密码<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126111121.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126111301.png"></p><p>此时，你会发现，你刚刚修改的root密码居然不好使了，其他用户的密码也不好使了，因为上述的操作是在救援模式下的操作，实际上还是改变不了我们实际的linux系统的。</p><h4 id="正确操作"><a href="#正确操作" class="headerlink" title="正确操作"></a>正确操作</h4><p>1）按e进行选择，选择编辑选项启动<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126105206.png"></p><p>2）找到linux16开头的那行：修改 ro 为： rw init=/sysroot/bin/sh<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126112147.png"></p><p>3) Ctrl + x 执行<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126113403.png"></p><p>进入系统后，其实只是进入了一个安全模式下的内存系统，并不是真正的咱们正常使用的linux系统。</p><p><code>ls /sysroot/</code> 下才是我们正常的linux系统里面的文件。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126113642.png"></p><p><strong>4）使用命令 chroot /sysroot 切换到正常系统中</strong><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126113933.png"></p><p>5）使用 passwd root 修改root的密码<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126114105.png"></p><p><strong>6）修改密码成功后，一定要使用 touch /.autorelabel 指令</strong></p><p>如果不使用的话，会导致系统无法正常登陆！！！<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126114406.png"></p><p>7）退出救援模式，ctrl + d</p><p>输入ctrl + d 后，屏幕上会出现：logout<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126114848.png"></p><p>8）重启系统，在屏幕上输入：reboot</p><p>输入新修改的root密码，就能进入linux系统了。</p><p><strong>简单说明一下：</strong></p><p>上面的修改的ro，ro=readonly权限，只要读的权限，所以修改成rw，读和写的功能。</p><p>touch /.autorelabel 这句是为了selinux生效。</p><h4 id="这样进入linux的单用户模式修改密码安全吗？"><a href="#这样进入linux的单用户模式修改密码安全吗？" class="headerlink" title="这样进入linux的单用户模式修改密码安全吗？"></a>这样进入linux的单用户模式修改密码安全吗？</h4><p>大家都说，linux系统的安全意识最强，但是这样就轻易的修改root的密码，安全意识强吗？这样的前提是你能够进入你们公司的服务器机房，然后打开linux系统，在linux系统机器上面直接操作才行，不然你的远程登录linux是进入不了刚刚的画面的，你都能进入服务器机房了，你的权限已经很大了，所有linux开发者认为你有权这样修改root密码。</p><hr><h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><h3 id="man获得帮助信息"><a href="#man获得帮助信息" class="headerlink" title="man获得帮助信息"></a>man获得帮助信息</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>man [命令或配置文件]（功能描述：获得帮助信息）</code></pre><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例：查看ls命令的帮助信息<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126175357.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126175501.png"></p><p>使用回车：Enter，看到更多的内容。</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126175700.png"></p><p>输入q退出查看。</p><h3 id="help指令"><a href="#help指令" class="headerlink" title="help指令"></a>help指令</h3><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>help  命令 （功能描述：获得shell内置命令的帮助信息）</code></pre><h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例：查看cd命令的帮助信息</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126180007.png"></p><h2 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h2><h3 id="pwd-指令"><a href="#pwd-指令" class="headerlink" title="pwd 指令"></a>pwd 指令</h3><h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>pwd (功能描述：显示当前工作目录的绝对路径)</code></pre><h4 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例：显示当前工作目录的绝对路径</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126183105.png"></p><h3 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h3><h4 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code> ls  [选项]  [目录或是文件]常用选项-a  ：显示当前目录所有的文件和目录，包括隐藏的 (文件名以.开头就是隐藏)。-l  ：以列表的方式显示信息-h  : 显示文件大小时，以 k , m,  G单位显示</code></pre><h4 id="应用实例-3"><a href="#应用实例-3" class="headerlink" title="应用实例"></a>应用实例</h4><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126183222.png"></p><h3 id="cd-指令"><a href="#cd-指令" class="headerlink" title="cd 指令"></a>cd 指令</h3><h4 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>cd  [参数] (功能描述：切换到指定目录)常用参数绝对路径【从 / 开始定位】和 相对路径【从当前的位置开始定位】 cd ~   或者 cd     回到自己的家目录cd ..  或者 cd ../ 回到当前目录的上一级目录</code></pre><h4 id="应用实例-4"><a href="#应用实例-4" class="headerlink" title="应用实例"></a>应用实例</h4><p>理解绝对路径和相对路径</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126184038.png"></p><p>案例1：使用绝对路径切换到root目录　　[cd /root]<br>案例2：使用相对路径到/root 目录　　　　[cd ../root]<br>案例3：表示回到当前目录的上一级目录 　[ cd ..]<br>案例4：回到家目录  　[ cd ~ ]</p><h3 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a>mkdir指令</h3><p><strong>说明</strong></p><p>mkdir指令用于创建目录</p><h4 id="基本语法-5"><a href="#基本语法-5" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>mkdir  [选项]  要创建的目录常用选项-p ：创建多级目录</code></pre><h4 id="应用实例-5"><a href="#应用实例-5" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 创建一个目录 /home/dog</p><p><code>mkdir  /home/dog</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126185934.png"></p><p>案例2: 创建多级目录 /home/animal/tiger</p><p><code>mkdir  -p  /home/animal/tiger</code></p><p>注意这里的animal目录是不存在的！！！<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126190302.png"></p><h3 id="rmdir指令"><a href="#rmdir指令" class="headerlink" title="rmdir指令"></a>rmdir指令</h3><p>说明</p><p>rmdir指令删除<strong>空目录</strong></p><h4 id="基本语法-6"><a href="#基本语法-6" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>rmdir  [选项]  要删除的空目录</code></pre><h4 id="应用实例-6"><a href="#应用实例-6" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 删除一个空目录 /home/dog</p><p><code>rmdir  /home/dog</code> [要求 /home/dog 是空目录]<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126191051.png"></p><p>案例2: 删除一个不是空的目录 /home/animal</p><p>animal里面还有一个tiger目录。</p><p>rmdir：只能删除空目录，不能删除非空目录；只能使用rm指令来删除非空目录。</p><p><code>rm -rf /home/animal</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126191512.png"></p><h3 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h3><p>说明</p><p>touch指令创建空文件， 还可以更新文件的访问和修改时间。</p><h4 id="基本语法-7"><a href="#基本语法-7" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>touch [选项] 文件名称常用选项-a 改变文件的访问时间为当前时间-m 改变文件的修改时间为当前时间-c 如果文件不存在，不创建也不提示-d或者-t 使用指定的日期或时间无 创建一个不存在的文件</code></pre><h4 id="应用实例-7"><a href="#应用实例-7" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 创建一个空文件 hello.txt</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126192008.png"></p><p>案例2: 修改一个已存在的文件的时间修改时间<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126193143.png"></p><h3 id="cp指令-重要"><a href="#cp指令-重要" class="headerlink" title="cp指令[重要]"></a>cp指令[重要]</h3><p>说明</p><p>cp 指令：拷贝文件到指定目录</p><h4 id="基本语法-8"><a href="#基本语法-8" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>cp [选项] source【源文件】 dest【目的文件】常用选项-r ：递归复制整个文件夹-a ：在复制目录时使用，它保留所有的信息。包括文件链接、文件属性、并递归地复制目录-d ：复制时保留链接，这样不会失去链接文件-i ：如果已经存在相同文件名的目标文件，则提示用户是否覆盖</code></pre><h4 id="应用实例-8"><a href="#应用实例-8" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 将 /home/aaa.txt 拷贝到  /home/bbb 目录下：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126195012.png"></p><p>案例2：将 /home/text文件，拷贝到 /home/zsf中：</p><p>text文件：里面还有三个文件，a.txt , b.txt , c.txt.<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126200111.png"></p><p><strong>注意细节：当你复制到的目的文件夹中有复制过来的文件时，会提示你是否覆盖，很烦，使用\cp强制复制。</strong><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126200206.png"></p><h3 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h3><p>说明</p><p>rm 指令：移除文件或目录</p><h4 id="基本语法-9"><a href="#基本语法-9" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>rm  [选项]  要删除的文件或目录常用选项-r ：递归删除整个文件夹-f ：强制删除不提示-i : 交互式删除，即在删除之前进行确认</code></pre><h4 id="应用实例-9"><a href="#应用实例-9" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 将 /home/aaa.txt 删除</p><p><code>rm  /home/aaa.txt</code></p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126201427.png"></p><p>案例2: 递归删除整个文件夹 /home/bbb</p><p><code>rm –r  /home/bbb</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126201742.png"></p><p><strong>使用细节</strong></p><p>强制删除不提示的方法：带上 -f 参数即可 <code>rm –rf  /home/bbb</code></p><h3 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h3><p>说明</p><p>mv ：移动文件到目录 或 重命名文件或目录。</p><h4 id="基本语法-10"><a href="#基本语法-10" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>mv  oldNameFile newNameFile     (功能描述：重命名)mv /temp/movefile /targetFolder (功能描述：移动文件或目录)常用选项-i：交互式操作，在对已经存在的文件或目录覆盖时，系统会发出询问。-f：禁止交互，强制覆盖。</code></pre><h4 id="应用实例-10"><a href="#应用实例-10" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 将 /home/aaa.txt 文件 重新命名为 bbb.txt<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126203428.png"></p><p>案例2: 将 /home/text目录 重新命名为 big目录<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126203513.png"></p><p>案例3: 将 /home/bbb.txt文件 移动到 big目录中：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126203846.png"></p><p>思考，能不能将一个目录移动到另一个目录中呢？（可以）<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126204015.png"></p><h3 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h3><p>说明</p><p>cat 查看文件内容（只读），同时也可以合并文件。</p><h4 id="基本语法-11"><a href="#基本语法-11" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>cat  [选项] 要查看的文件     //查看文件的内容cat  文件1  文件2  &gt; 文件3   //将文件1和文件2的内容合并后，存储到文件3中。常用选项-n ：显示行号</code></pre><h4 id="应用实例-11"><a href="#应用实例-11" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1:  查看 /ect/profile  文件内容，并显示行号。</p><p><code>cat /etc/profile</code></p><p>直接查看完毕，跳转到文件的底部。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126205206.png"></p><p><code>cat -n /etc/profile</code> ：显示行号。</p><p>所以，一般配合more指令来分页显示。</p><p><code>cat -n /etc/profile | more</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126205442.png"></p><p>敲击：空格键来翻页。</p><p>案例2:  将a.txt文件和b.txt文件合并，放到f.txt文件中（a和b文件存在，f不存在）</p><p>a.txt文件中的内容：aaaaa<br>b.txt文件中的内容：bbb</p><p><code>cat a.txt b.txt &gt; f.txt</code> ：自动帮我们创建f.txt文件，并把a和b内容合并到f文件中<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126209028.png"></p><p>案例3:  将a.txt文件和b.txt文件合并，放到c.txt文件中</p><p>a、b、c文件都存在，而且里面都有数据。<br>a.txt文件中的内容：aaaaa<br>b.txt文件中的内容：bbb<br>c.txt文件中的内容：ccc</p><p><code>cat a.txt b.txt &gt; c.txt</code> ：c文件中的内容会被覆盖<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126210504.png"></p><p><code>cat a.txt b.txt &gt;&gt; c.txt</code> : c文件中的内容不会被覆盖<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126210728.png"></p><h3 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a>more指令</h3><p>说明</p><p>more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。</p><h4 id="基本语法-12"><a href="#基本语法-12" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>more 要查看的文件</code></pre><h4 id="应用实例-12"><a href="#应用实例-12" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例: 采用more查看文件 /etc/profile</p><p><code>more /etc/profile</code></p><h4 id="快捷键说明"><a href="#快捷键说明" class="headerlink" title="快捷键说明"></a>快捷键说明</h4><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126211914.png"></p><h3 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h3><p>说明</p><p>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，<strong>对于显示大型文件具有较高的效率</strong>。</p><h4 id="基本语法-13"><a href="#基本语法-13" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>less 要查看的文件</code></pre><h4 id="应用实例-13"><a href="#应用实例-13" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例: 采用less查看一个大文件文件(体验一下速度)</p><h4 id="快捷键说明-1"><a href="#快捷键说明-1" class="headerlink" title="快捷键说明"></a>快捷键说明</h4><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126212212.png"></p><h3 id="gt-指令-和-gt-gt-指令"><a href="#gt-指令-和-gt-gt-指令" class="headerlink" title="&gt; 指令 和 &gt;&gt; 指令"></a>&gt; 指令 和 &gt;&gt; 指令</h3><p>说明</p><p><code>&gt; 输出重定向 和 &gt;&gt; 追加</code></p><pre><code>&gt;  输出重定向：就是覆盖的意思&gt;&gt; 追加：在文件末尾追加内容</code></pre><h4 id="基本语法-14"><a href="#基本语法-14" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>1) ls -l &gt;文件       （功能描述：列表的内容写入文件a.txt中（覆盖写））2) ls -al &gt;&gt;文件     （功能描述：列表的内容追加到文件aa.txt的末尾）3) cat 文件1 &gt; 文件2 （功能描述：将文件1的内容覆盖到文件2）4) echo &quot;内容&quot;&gt;&gt; 文件</code></pre><h4 id="应用实例-14"><a href="#应用实例-14" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 将 /home 目录下的文件列表 写入到 /home/info.txt 中</p><p><code>ls –l  /home/   &gt;  /home/info.txt  [如果info.txt文件不存在，则会自动创建]</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126213707.png"></p><p>案例2: 将当前日历信息 追加到  /home/mycal 文件中 </p><p><code>date  &gt;&gt; /home/mycal</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126213830.png"></p><h3 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a>echo指令</h3><p>说明</p><p>echo输出内容到控制台。</p><p>是一种最常用的与广泛使用的内置于Linux的bash和C shell的命令，通常用在脚本语言和批处理文件中来在标准输出或者文件中显示一行文本或者字符串。</p><h4 id="基本语法-15"><a href="#基本语法-15" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>echo  [选项]  [输出内容]1. 输入一行文本并显示在标准输出上# echo Tecmint is a community of Linux Nerds Tecmint is a community of Linux Nerds 2. 输出一个声明的变量值比如，声明变量x并给它赋值为10。# x=10# echo The value of variable x = $x The value of variable x = 103. 使用&#39;\b&#39;选项&#39;-e &#39; 后带上 &#39;\b&#39; 会删除字符间的所有空格。注意： Linux中的选项 &#39;-e&#39; 扮演了转义字符反斜线的翻译器。# echo -e &quot;Tecmint \bis \ba \bcommunity \bof \bLinux \bNerds&quot; TecmintisacommunityofLinuxNerds4. 使用&#39;\n&#39;选项&#39;-e&#39;后面的带上&#39;\n&#39;行会在遇到的地方作为新的一行# echo -e &quot;Tecmint \nis \na \ncommunity \nof \nLinux \nNerds&quot;Tecmint is a community of Linux Nerds 5. 使用&#39;\t&#39;选项&#39;-e&#39;后面跟上&#39;\t&#39;会在空格间加上水平制表符。# echo -e &quot;Tecmint \tis \ta \tcommunity \tof \tLinux \tNerds&quot; Tecmint     is  a   community   of  Linux   Nerds6. &#39;-n&#39;会在echo完后不会输出新行# echo -n &quot;Tecmint is a community of Linux Nerds&quot; Tecmint is a community of Linux Nerds[root@liuzhuo01 home]# </code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127120437.png"></p><h4 id="echo-选项列表"><a href="#echo-选项列表" class="headerlink" title="echo 选项列表"></a>echo 选项列表</h4><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181126221404.png"></p><h4 id="应用实例-15"><a href="#应用实例-15" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例: 使用 echo 指令输出环境变量</p><p><code>echo $PATH</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127122013.png"></p><h3 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h3><p>说明</p><p>head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容。</p><h4 id="基本语法-16"><a href="#基本语法-16" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>head  文件          (功能描述：查看文件头10行内容)head -n 5 文件      (功能描述：查看文件头5行内容，5可以是任意行数)</code></pre><h4 id="应用实例-16"><a href="#应用实例-16" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例: 查看 /etc/profile 的前面5行代码<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127123821.png"></p><h3 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h3><p>说明</p><p>tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容。</p><h4 id="基本语法-17"><a href="#基本语法-17" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>1) tail  文件         (功能描述：查看文件尾10行内容）2) tail  -n 5 文件   （功能描述：查看文件尾5行内容，5可以是任意行数）3) tail  -f  文件    （功能描述：实时追踪该文档的所有更新） 重要！！！</code></pre><h4 id="应用实例-17"><a href="#应用实例-17" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 查看 /etc/profile 最后5行的代码<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127124007.png"></p><p>案例2: 实时监控date.log , 看看文件有变化时，能否看到变化的内容(实时的追加日期)。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127125020.png"></p><h3 id="ln-指令-link"><a href="#ln-指令-link" class="headerlink" title="ln 指令 (link)"></a>ln 指令 (link)</h3><p>说明</p><p>Linux下的链接有两种，一种是硬链接（Hard Link），另一种是软链接（Sysmbolie Link），默认情况下 ln 命令产生的是硬链接。</p><p>硬链接：是指通过文件的inode来进行链接。在Linux的文件系统中，保存在磁盘的所有类型的文件都会分配一个编号，这个编号称为inode号。硬链接的作用是允许一个文件拥有多个有效的路径名，这样用户就可以对一些重要文件建立多个硬链接，以防止误删除操作。只有最后一个硬链接删除，文件才会真正的删除。</p><p>软链接也成为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径。</p><h4 id="基本语法-18"><a href="#基本语法-18" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>ln [选项] [原文件或目录] [链接名] （功能描述：给原文件创建一个链接）常用选项-f：如果在目标位置存在与链接名相同的文件，会删除这个同名的文件-s: 进行软链接不带：硬链接</code></pre><h4 id="应用实例-18"><a href="#应用实例-18" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 在/home 目录下创建一个软链接 linkToRoot，连接到 /root 目录<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127130927.png"></p><p>案例2: 删除软连接 linkToRoot<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127131232.png"></p><p>案例3: 给date.log创建硬链接info.txt , 但是info.txt文件已经存在了。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127131547.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127131622.png"></p><p><strong>细节说明：</strong></p><p>当我们使用pwd指令查看目录时，仍然看到的是软链接所在目录。</p><h3 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a>history指令</h3><p>说明</p><p>查看已经执行过历史命令,也可以执行历史指令。</p><h4 id="基本语法-19"><a href="#基本语法-19" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>history    （功能描述：查看已经执行过历史命令)</code></pre><h4 id="应用实例-19"><a href="#应用实例-19" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 显示所有的历史命令<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127132716.png"></p><p>案例2: 显示最近使用过的10个指令。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127132820.png"></p><p>案例3: <strong>执行</strong>历史编号为474的指令  (!474)<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127133041.png"></p><h2 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h2><h3 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a>date指令</h3><p>说明</p><p>显示当前的日期</p><h4 id="基本语法-20"><a href="#基本语法-20" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>1) date       (功能描述：显示当前时间）2) date +%Y   (功能描述：显示当前年份）3) date +%m   (功能描述：显示当前月份）4) date +%d   (功能描述：显示当前是哪一天）5) date &quot;+%Y-%m-%d %H:%M:%S&quot;      (功能描述：显示年月日时分秒）6) date -s &quot;2018-11-27 11:11:11&quot;  (功能描述：设置年月日时分秒）注意：这里的+是不能掉的，而且：Y m d H M S 年月日时分秒也是固定的写法，除了中间的分隔符可以随意写。</code></pre><h4 id="应用实例-20"><a href="#应用实例-20" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 显示当前时间信息<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127134447.png"><br>案例2: 显示当前时间年月日<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127134736.png"><br>案例3: 显示当前时间年月日时分秒<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127134806.png"></p><p>案例4: 设置系统当前时间 ，比如设置成 2020-11-11 11:22:22<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127135115.png"></p><h3 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h3><p>说明</p><p>查看日历指令</p><h4 id="基本语法-21"><a href="#基本语法-21" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>cal  [选项]   (功能描述：不加选项，显示本月日历）</code></pre><h4 id="应用实例-21"><a href="#应用实例-21" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 显示当前日历<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127135545.png"></p><p>案例2: 显示2020年日历<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127135844.png"></p><h2 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类(!!)"></a>搜索查找类(!!)</h2><h3 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h3><p>说明</p><p>find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</p><h4 id="基本语法-22"><a href="#基本语法-22" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>find  [搜索范围]  [选项]  </code></pre><h4 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h4><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127140046.png"></p><h4 id="应用实例-22"><a href="#应用实例-22" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 按文件名：根据名称查找 /home 目录下的 hello.txt文件</p><p><code>find  /home  -name  hello.txt</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127141106.png"></p><p>案例2：按拥有者：查找/opt目录下，用户名称为 liuzhuo的文件</p><p><code>find  /opt  -user  liuzhuo</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127141250.png"></p><p>案例3：查找整个linux系统下大于20M的文件（+n 大于  -n小于   n等于）</p><p><code>find  /  -size  +20M</code> : 兆：M ，kb：k<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127141538.png"></p><h3 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a>locate指令</h3><p>说明</p><p>locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的<strong>locate数据库</strong>实现快速定位给定的文件。Locate指令无需遍历整个文件系统，<strong>查询速度较快</strong>。为了保证查询结果的准确度，管理员必须<strong>定期更新locate时刻</strong>。</p><h4 id="基本语法-23"><a href="#基本语法-23" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>locate  搜索文件</code></pre><h4 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h4><p>由于locate指令基于数据库进行查询，所以第一次运行前，必须使用<strong>updatedb指令创建locate数据库</strong>。</p><h4 id="应用实例-23"><a href="#应用实例-23" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 请使用locate 指令快速定位 hello.txt 文件所在目录</p><p>updatedb // 创建locate的数据库<br>locate  hello.txt<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127141603.png"></p><h3 id="grep指令和-管道符号"><a href="#grep指令和-管道符号" class="headerlink" title="grep指令和 管道符号 |"></a>grep指令和 管道符号 |</h3><p>说明</p><p>grep 过滤查找 ； 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。</p><h4 id="基本语法-24"><a href="#基本语法-24" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>grep  [选项]  查找内容  源文件常用选项-n：显示匹配行以及行号-i：忽略字母大小写</code></pre><h4 id="应用实例-24"><a href="#应用实例-24" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: 请在 /etc/profile 文件中，查找  “if”  所在行，并且显示行号</p><p>grep –n   if  /etc/profile  [在/etc/profile 中查找 if ,并显示行，区别大小写]<br>grep –ni   if  /etc/profile  [在/etc/profile 中查找 if ,并显示行，不区别大小写]<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127143642.png"></p><p>案例2: 请在 /home/hello.txt 文件中，查找  “yes”  所在行，并且显示行号<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127143926.png"></p><h2 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h2><h3 id="gzip与gunzip"><a href="#gzip与gunzip" class="headerlink" title="gzip与gunzip"></a>gzip与gunzip</h3><p>说明</p><p>gzip 用于压缩文件， gunzip 用于解压的。</p><p><strong>gzip：只能对文件进行压缩，不能压缩目录，即使指定压缩的目录，也只能压缩目录内的所有文件。</strong></p><h4 id="基本语法-25"><a href="#基本语法-25" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>gzip [选项] 文件名 （功能描述：压缩文件，只能将文件压缩为*.gz文件）常用选项-r：递归压缩目录下的文件-d：将压缩文件进行解压   等价于：gunzip 压缩的文件名gunzip 压缩的文件名 （功能描述：解压缩文件命令）</code></pre><h4 id="应用实例-25"><a href="#应用实例-25" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1: gzip压缩， 将 /home下的 hello.txt文件进行压缩。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127145146.png"></p><p>案例2: gunzip解压缩， 将 /home下的 hello.txt.gz 文件进行解压缩。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127145225.png"></p><p>案例3: gzip压缩， 将 /home下的 big 目录进行压缩。（原则上不能进行压缩目录）<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127145707.png"></p><p>案例4: gunzip解压缩， 将 /home下的 big 目录进行解压缩。（原则上不能进行解压缩目录）<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127150135.png"></p><h3 id="zip-unzip-指令"><a href="#zip-unzip-指令" class="headerlink" title="zip/unzip 指令"></a>zip/unzip 指令</h3><p>说明</p><p>zip 用于压缩文件， unzip 用于解压的，<strong>这个在项目打包发布中很有用的。</strong></p><p>将一般的文件或目录进行压缩或者解压，默认生成以 “.zip”为后缀的压缩包。</p><h4 id="基本语法-26"><a href="#基本语法-26" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>zip     [选项]   XXX.zip   需要压缩的内容（功能描述：压缩文件和目录的命令）unzip   [选项]   XXX.zip      (功能描述：解压缩文件）</code></pre><h4 id="zip的选项"><a href="#zip的选项" class="headerlink" title="zip的选项"></a>zip的选项</h4><pre><code>-r：递归压缩目录-m：将文件加入到压缩文件中后，删除原始文件</code></pre><h4 id="unzip的选项"><a href="#unzip的选项" class="headerlink" title="unzip的选项"></a>unzip的选项</h4><pre><code>-d 目录名: 将解压的文件放到指定的目录中-n：解压时不覆盖已经存在的文件-o：解压时覆盖已经存在的文件，并且不要求用户确认</code></pre><h4 id="应用实例-26"><a href="#应用实例-26" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1:  将 /home/big下的 所有文件进行压缩成 mybig.zip</p><p><code>zip  -r  mybig.zip  /home/big</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127151643.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127151916.png"></p><p>案例2:  将 mybig.zip 解压到 /opt/tmp 目录下 [如果/opt/tmp 不存在，会自动创建]</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127152316.png"></p><h3 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h3><p>说明</p><p>tar是linux系统下经常使用的归档工具，对文件或目录进行打包归档，归档成一个文件，但是并不是进行压缩。</p><p>最后打包后的文件是 .tar.gz 的文件。 [可以压缩，和解压]</p><h4 id="基本语法-27"><a href="#基本语法-27" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>tar  [选项]  XXX.tar.gz  要打包的内容/目录   (功能描述：打包目录，压缩后的文件格式.tar.gz)常用选项-c：产生.tar打包文件-v：显示详细信息-f：指定压缩后的文件名，一定是最后的选项-z：打包同时压缩-x：解包.tar文件常用的组合-zcvf：打包压缩-zxvf：解压缩</code></pre><h4 id="应用实例-27"><a href="#应用实例-27" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1:  压缩多个文件，将 /home/a1.txt 和 /home/a2.txt 压缩成  a.tar.gz。    【-zcvf】：打包压缩  【-zxvf】：解压<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127153502.png"></p><p>案例2:  将/home 的文件夹 压缩成 myhome.tar.gz<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127154733.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127154801.png"><br>案例3:   将 a.tar.gz  解压到当前目录<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127154950.png"><br>案例4: 将myhome.tar.gz  解压到 /opt/tmp目录下 【-C】<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127155204.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day04/QQ截图20181127155235.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之用户</title>
      <link href="/2018/11/25/linux-ji-chu-ru-men-zhi-shi-cao/"/>
      <url>/2018/11/25/linux-ji-chu-ru-men-zhi-shi-cao/</url>
      
        <content type="html"><![CDATA[<p>本篇文章，将会讲解Linux的用户管理、实用指令等。</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125135424.png"></p><p>注意：Linux用户需要至少属于一个组。</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>useradd [选项] 用户名useradd  用户名  //默认会在/home下创建同名的家目录useradd -d 新的家目录的路径 用户名  //会在指定的路径下创建家目录，不要提前创建文件夹</code></pre><h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><p>打开，我们的Xshell远程登录我们的centOS系统。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125141201.png"></p><p>现在:<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125141406.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125141558.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125141727.png"></p><p><strong>使用细节</strong></p><p>1) 当创建用户成功后，会自动的创建和用户同名的家目录 【/home/用户名】</p><p>2) 也可以通过 useradd -d   指定目录   新的用户名jack 【给新创建的用户指定新的家目录】</p><p>现在创建一个新的用户jack，并把它的家目录放到 /home/rose下，默认是放在/home/jack文件夹中。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125142852.png"><br>验证jack用户是否创建成功，开启一个新的连接：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125143053.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125143109.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125143433.png"></p><p><strong>此时/home/rose，就是jack的家目录了。</strong></p><h3 id="指定-修改密码"><a href="#指定-修改密码" class="headerlink" title="指定/修改密码"></a>指定/修改密码</h3><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>passwd 用户名         //如果没有带用户名，则是给当前登录的用户修改密码</code></pre><h4 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a>案例演示</h4><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125143821.png"></p><p>将xm用户的密码设置为：xm<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125144013.png"></p><p>创建一个新的连接，或者直接使用虚拟机登入系统，输入用户：xm，密码：xm，即可登入成功；这里就不演示了。</p><p><strong>注意：添加、设置密码、删除用户，都必须是下root用户下才行！！！</strong></p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>userdel   用户名   //不会删除家目录userdel -r 用户名  //会删除家目录</code></pre><h4 id="案例演示-2"><a href="#案例演示-2" class="headerlink" title="案例演示"></a>案例演示</h4><p>1）删除xm用户，但不删除他的家目录【/home/xm】<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125144853.png"></p><p>2）删除jack用户，并且删除他的家目录</p><p>注意这里：我们创建jack用户的时候，将他的家目录修改成了/home/rose，所以删除他的家目录，就是删除/home/rose.<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125145649.png"></p><p><strong>使用细节</strong></p><p>在实际开发中，一般员工离职后，直接删除用户即可，不要删除他的家目录，因为里面会有他写的代码，资源很珍贵的！！！</p><h3 id="查询用户信息"><a href="#查询用户信息" class="headerlink" title="查询用户信息"></a>查询用户信息</h3><h4 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>id 用户名</code></pre><h4 id="案例演示-3"><a href="#案例演示-3" class="headerlink" title="案例演示"></a>案例演示</h4><p>查看root用户的信息<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125150310.png"></p><p>查看不存在的用户<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125150459.png"></p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>介绍</p><p>在操作linux系统时，如果当前用户没有权限的时候，可以通过 su - 指令 ，来切换到高权利的用户，比如：root用户。</p><h4 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>su - 要切换的用户名</code></pre><h4 id="案例演示-4"><a href="#案例演示-4" class="headerlink" title="案例演示"></a>案例演示</h4><p>创建一个zs用户，指定密码，然后切换到root用户。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125151061.png"></p><p><strong>注意细节：</strong></p><p>1）普通用户前面是：$ , 超级用户前面是：# 。</p><p>2）su root 切换root用户时，如果没有带 - 的话，只是会切换到root用户，但是不会加载root用户的环境变量，这样会导致一个命令会 not found。</p><p>3）从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。</p><p>4）当需要返回到原来用户时，使用exit指令。</p><p>5）如果 su – 没有带用户名，则默认切换到root用户</p><h3 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h3><h4 id="基本语法-5"><a href="#基本语法-5" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>whoami/ who am I</code></pre><h4 id="案例演示-5"><a href="#案例演示-5" class="headerlink" title="案例演示"></a>案例演示</h4><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125152055.png"></p><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>类似于角色，系统可以对有共性的多个用户进行统一的管理。</p><h4 id="新增组"><a href="#新增组" class="headerlink" title="新增组"></a>新增组</h4><pre><code>groupadd  组名</code></pre><h4 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h4><pre><code>groupdel 组名</code></pre><p><strong>注意：这里有一个前提，就是这个组没有用户，才能删除。</strong></p><h4 id="添加用户到指定的组"><a href="#添加用户到指定的组" class="headerlink" title="添加用户到指定的组"></a>添加用户到指定的组</h4><pre><code>useradd -g 组名 用户名</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125154110.png"></p><h4 id="修改用户的到其他组"><a href="#修改用户的到其他组" class="headerlink" title="修改用户的到其他组"></a>修改用户的到其他组</h4><pre><code>usermod -g 新的组名 用户名</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125154256.png"></p><h3 id="用户和组的相关文件"><a href="#用户和组的相关文件" class="headerlink" title="用户和组的相关文件"></a>用户和组的相关文件</h3><h4 id="etc-passwd-文件"><a href="#etc-passwd-文件" class="headerlink" title="/etc/passwd 文件"></a>/etc/passwd 文件</h4><p>用户（user）的配置文件，记录用户的各种信息。</p><p>每行的含义：用户名 : 口令 : 用户标识号 : 组标识号 : 注释性描述 : 主目录 : 登录Shell的工具</p><pre><code>vim /etc/passwd</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125155926.png"></p><h4 id="etc-shadow-文件"><a href="#etc-shadow-文件" class="headerlink" title="/etc/shadow 文件"></a>/etc/shadow 文件</h4><p>口令的配置文件</p><p>每行的含义：登录名 : 加密口令 : 最后一次修改时间 : 最小时间间隔 : 最大时间间隔 : 警告时间 : 不活动时间 : 失效时间 : 保留</p><pre><code>vim /etc/shadow</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125160306.png"></p><h4 id="etc-group-文件"><a href="#etc-group-文件" class="headerlink" title="/etc/group 文件"></a>/etc/group 文件</h4><p>组(group)的配置文件，记录Linux包含的组的信息</p><p>每行含义：组名 : 口令 : 组标识号 : 组内用户列表</p><pre><code>vim /etc/group</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day03/QQ截图20181125160725.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之进阶</title>
      <link href="/2018/11/23/linux-ji-chu-ru-men-zhi-jin-jie/"/>
      <url>/2018/11/23/linux-ji-chu-ru-men-zhi-jin-jie/</url>
      
        <content type="html"><![CDATA[<p>Linux基础入门的目录结构、远程登入等</p><h2 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h2><h3 id="Linux的基本介绍"><a href="#Linux的基本介绍" class="headerlink" title="Linux的基本介绍"></a>Linux的基本介绍</h3><p>linux的文件系统是采用级层式的<strong>树状目录结构</strong>，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。</p><p>深刻理解linux树状文件目录是非常重要的，这里我给大家说明一下。</p><p>记住一句经典的话：<font color="red"><strong>在Linux世界里，一切皆文件（即使是一个硬件设备，也是使用文件来标志）</strong></font></p><h3 id="linux的目录结构图"><a href="#linux的目录结构图" class="headerlink" title="linux的目录结构图"></a>linux的目录结构图</h3><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181123210048.png"></p><p>打开我们的centOS虚拟机，点击计算机，也会出现：根目录下的目录结构：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181123210800.png"></p><p><strong>PS：如果你想使用VirtualBox的全屏功能，需要安装增强功能。</strong></p><p>点击设备：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181123211621.png"></p><p>然后点击：安装增强功能：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181123211805.png"></p><p>然后：输入root的密码。</p><p>安装完后，<strong>按下回车键</strong>，就安装成功了。</p><p>如果你的安装失败，是因为你的系统需要安装：gcc, kernel, kernel-devel。</p><p>于是使用yum安装：<code>yum install -y gcc kernel kernel-devel</code></p><p>桌面上面，就会出现一个VBox_GAs_xxx的光盘图标。</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181123212208.png"></p><p>双击那个光盘：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181123213629.png"></p><p>切换成root用户，在终端下面进入那个光盘下面，然后：<code>sh VBoxLinuxAdditions.run</code></p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181123220916.png"></p><p>安装成功后，重启虚拟机就好了：就可以使用全屏的功能了。</p><hr><p>回到我们的Linux目录结构：</p><p>基本介绍：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181123214545.png"></p><h3 id="具体的目录说明"><a href="#具体的目录说明" class="headerlink" title="具体的目录说明"></a>具体的目录说明</h3><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181123214859.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181123215006.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181123215252.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181123215959.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181123220105.png"></p><h3 id="对linux目录结构的小结"><a href="#对linux目录结构的小结" class="headerlink" title="对linux目录结构的小结"></a>对linux目录结构的小结</h3><p>1)在linux中，目录结构 有一个  根目录 / , 其他的目录都是在 / 目录分支。</p><p>2)在linux中，有很多目录，是安装后，自动生成的目录，每个目录都会存放相应的内容，不要去修改.</p><p>3)在linux中，所有的设备都可以通过文件来体现(字符设备文件[比如键盘，鼠标]，块设备文件[硬盘])</p><p>4)<strong>在学习linux时，要尽快的在脑海中，形成一个 目录树</strong></p><h2 id="Linux系统之远程登录与上传下载"><a href="#Linux系统之远程登录与上传下载" class="headerlink" title="Linux系统之远程登录与上传下载"></a>Linux系统之远程登录与上传下载</h2><p>为啥要远程登录呢？我们不能直接在我们的虚拟机上面操作吗？登录账户和密码后，就可以直接操作呀？<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124100504.png"></p><p>那是因为，在我们实际上班的时候，我们不是使用Windows电脑安装虚拟机来操作Linux系统的，linux服务器是在机房里面，我们每个开发人员，不可能每次要操作linux服务器就去机房，那样太麻烦，而且效率极低。所以，我们需要在自己的windows电脑上面远程登录到机房中的linux服务器。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124100938.png"></p><p>常见的远程登录软件有：Xshell、SecureCRT、SmartTTY等等</p><h3 id="远程登录之Xshell"><a href="#远程登录之Xshell" class="headerlink" title="远程登录之Xshell"></a>远程登录之Xshell</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Xshell 是目前最好的远程登录到Linux操作的软件，流畅的速度并且完美解决了<strong>中文乱码</strong>的问题， 是目前程序员首选的软件。</p><p>Xshell 是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及 Microsoft Windows 平台的 TELNET 协议</p><p>Xshell 可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。</p><h4 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h4><p>1）到Xshell官网上面去下载</p><p><code>http://www.netsarang.com/</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124111119.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124111225.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124111343.png"></p><p>2) 安装Xshell软件</p><p>傻瓜式安装即可。</p><p>安装完毕后，双击Xshell软件：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124112122.png"></p><p>点击新建会话：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124112212.png"></p><p>填写相关信息：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124112620.png"></p><p>连接：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124112738.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124124930.png"></p><p>如果出现连接失败的话，看看你的linux的sshd服务是否开启：</p><p>在虚拟机中的终端中输入：setup<br>如果不是root用户，会让你先输入root的密码。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124123720.png"></p><p>选择系统服务后，回车。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124123855.png"></p><p>在其中找到sshd.service,看它的前面是否有 * 号，有的话，说明已经开启了，没有的话，使用<strong>空格</strong>开启。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124124037.png"></p><p>然后使用：tab键进入到确定，然后回车确定即可。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124124357.png"></p><p>然后使用tab键到退出。此时sshd服务就开启了。</p><p>验证sshd服务是否开启：<code>service sshd status</code></p><p>出现：active的绿色字体，说明开启成功！<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124124648.png"></p><p>再次使用Xshell连接我们的虚拟机：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124124930.png"></p><p>发现还是连接失败，这是因为我们的宿主机的ip地址是：10.6.11.123，而我们的linux的ip地址是：10.0.2.15<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124125343.png"></p><p>在宿主机下，ping我们的虚拟机的linux的ip，发现超时，即：宿主机与虚拟机的linux不连通<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124125524.png"></p><p>所以，只要我们的宿主机与虚拟机的linux服务器能够连通的话，Xshell才能连接成功。</p><p>现在修改我们的linux的网络配置，添加网桥模式：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124125734.png"></p><p>重启我们的centOS虚拟机：</p><p>发现，现在我们已经有了两个网卡：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124125911.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124130023.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124130141.png"></p><p>现在使用我们的宿主机 ping 网桥模式下分配的ip地址，我这里就是：10.6.11.104<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124130405.png"></p><p>最后，修改我们的Xshell下的主机的ip地址（网桥模式下的ip地址）<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124130556.png"></p><p>点击确定，连接：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124130641.png"></p><p>然后，会让你输入连接的用户名和密码：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124130728.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124130819.png"></p><p><strong>PS：如果以上还是不能成功，请你关闭防火墙</strong></p><p>systemctl disable 服务名 service    永久关闭防火墙<br>systemctl status firewalld.service    查看防火墙<br>systemctl stop firewalld.service    关闭防火墙<br>systemctl start firewalld service    打开防火墙</p><hr><p>验证我们的远程登录是否有效，在Xshell界面中，进入Desktop，然后创建一个hello文件：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124140900.png"></p><p>然后在我们的root用户的桌面下，就会出现一个hello的文件：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124140951.png"></p><h3 id="远程上传下载之Xftp"><a href="#远程上传下载之Xftp" class="headerlink" title="远程上传下载之Xftp"></a>远程上传下载之Xftp</h3><h4 id="Xftp的简单介绍"><a href="#Xftp的简单介绍" class="headerlink" title="Xftp的简单介绍"></a>Xftp的简单介绍</h4><p>是一个基于 windows 平台的功能强大的 SFTP、FTP 文件传输软件。使用了 Xftp 以后，windows 用户能安全地在 UNIX/Linux 和 Windows PC 之间传输文件。</p><h4 id="Xftp的安装配置"><a href="#Xftp的安装配置" class="headerlink" title="Xftp的安装配置"></a>Xftp的安装配置</h4><p>到官网上面下载：<code>https://www.netsarang.com/products/xfp_overview.html</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124151724.png"></p><p>和Xshell的安装类似，我就不演示了。</p><p>下载完成后：打开Xftp软件：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124153248.png"></p><p>新建我们的会话：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124153555.png"></p><p>连接：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124153720.png"></p><p>输入root的密码：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124153803.png"></p><p>成功后的效果图：（左边windows的桌面，右边linux系统的用户根目录）<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124153946.png"></p><p>如果你的右边的linux系统出现中文乱码的话：点击绿色的小齿轮<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124154117.png"></p><p>然后，点击选项，编码选择utf-8即可：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124154214.png"></p><p>在右边的linux系统中右键刷新后，就不会中文乱码了。</p><h4 id="Xftp的简单使用"><a href="#Xftp的简单使用" class="headerlink" title="Xftp的简单使用"></a>Xftp的简单使用</h4><p>1）从windows系统中，上传图片到linux系统中</p><p>在左边的windows界面下，随便找到一个图片，右键选择<strong>传输</strong>即可。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124154555.png"></p><p>完成后，在右边的linux系统中，就会多出一张图片<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124154724.png"></p><p>打开我们的虚拟机，也能看到那张图片：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124154838.png"></p><p>2）从linux系统下载文件到我们的windows系统中</p><p>一样的操作，在右边的linux系统中，随便上传一个文件即可。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124155039.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124155236.png"></p><p>打开我们的windows桌面：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124155351.png"></p><p><strong>注意：在上传文件的时候，文件上传的目的地就是你现在的打开的目的地的目录，比如你的目的地linux打开在home目下，那么从windows系统下上传的文件就会传输到linux的home目录下</strong></p><p><strong>PS：</strong>当我们在实际工作中，如果需要部署一个项目，则应当先压缩后，再上传，上传后，使用linux的相关的解压缩命令，来解压。</p><h3 id="SecureCRT的安装和使用"><a href="#SecureCRT的安装和使用" class="headerlink" title="SecureCRT的安装和使用"></a>SecureCRT的安装和使用</h3><h4 id="基本的介绍"><a href="#基本的介绍" class="headerlink" title="基本的介绍"></a>基本的介绍</h4><p>是用于远程登录Linux的软件。SecureCRT 也是一款常用的远程登录Linux的软件，在<strong>大数据开发</strong>中使用较多。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>下载绿色安装板即可，直接拷贝整个目录就可以用了。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>打开SecureCRT的运行文件<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124161136.png"></p><p>新建连接：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124161258.png"></p><p>新建会话：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124161419.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124161604.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124161645.png"></p><p>连接：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124161719.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124161741.png"></p><p>输入root密码即可：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124162002.png"></p><p>出现中文乱码问题：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124162055.png"></p><p>解决中文乱码问题：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124162224.png"></p><p>再次连接：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124162521.png"></p><p>测试：</p><p>直接输入：<code>touch hello</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124162827.png"></p><p>打开我们的虚拟机：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124162918.png"></p><h2 id="Vi和Vim编辑器"><a href="#Vi和Vim编辑器" class="headerlink" title="Vi和Vim编辑器"></a>Vi和Vim编辑器</h2><h3 id="vi和vim的简单介绍"><a href="#vi和vim的简单介绍" class="headerlink" title="vi和vim的简单介绍"></a>vi和vim的简单介绍</h3><p>所有的 Linux 系统都会内建 vi 文本编辑器。</p><p>Vim 具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。我们只需要掌握它的基本使用即可。</p><h3 id="vi和vim的三种模式"><a href="#vi和vim的三种模式" class="headerlink" title="vi和vim的三种模式"></a>vi和vim的三种模式</h3><h4 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h4><p>以 vim 打开一个文件就直接进入正常模式了(这是默认的模式)。在这个模式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、贴上』来处理你的文件数据。在正常模式下可以使用快捷键。</p><h4 id="插入模式-编辑模式"><a href="#插入模式-编辑模式" class="headerlink" title="插入模式(编辑模式)"></a>插入模式(编辑模式)</h4><p>按下<strong>i（insert）</strong>, I, o, O, a, A, r, R等任何一个字母之后才会进入编辑模式, 一般来说按<strong>i</strong>即可.</p><h4 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h4><p>在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的！<br>（ Esc + ：进入该模式 ）</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>在linux系统下，编写一个java程序</p><p>打开Xshell软件：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124164946.png"></p><p>此时，桌面上面还没有hello.java文件。</p><p>输入：<code>vim hello.java</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124165113.png"></p><p>此时，就进入了正常模式，你会发现，此时，不管你在键盘上面怎么输入，都不会输入进去。我们需要切换到编辑模式下：输入i</p><p>就会进入插入模式：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124165446.png"></p><p>现在怎么保存退出呢？需要切换到命令行模式下：（ Esc + ：）</p><p>然后输入：wq（保存并退出）<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124165701.png"></p><p>回车后，就回到我们的终端下面，再次输入：ll<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124165845.png"></p><p>查看我们刚刚编写的hello.java文件：（cat hello.java）<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124165954.png"></p><p>说明刚刚的hello.java文件，保存成功！</p><h3 id="vi和vim模式的互相切换"><a href="#vi和vim模式的互相切换" class="headerlink" title="vi和vim模式的互相切换"></a>vi和vim模式的互相切换</h3><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124170148.png"></p><p>：wq 修改保存并退出</p><p>：q  你打开一个文件，然后觉得没有修改的，直接输入q退出即可</p><p>：q！你打开一个文件，然后修改了，但是觉得不想保存修改的内容，那就q！强制退出并不保存之前修改的内容</p><h3 id="vim和vi的快捷键的使用"><a href="#vim和vi的快捷键的使用" class="headerlink" title="vim和vi的快捷键的使用"></a>vim和vi的快捷键的使用</h3><p>常用的快捷键的使用：</p><p>1) 拷贝当前行（yy） , 拷贝当前行向下的5行  （5yy），并粘贴（ p ）。【快捷键在正常模式下使用】</p><p>2) 删除当前行（dd）  , 删除当前行向下的5行 （5dd）。【快捷键在正常模式下使用】</p><p>3) 在文件中查找某个单词 [命令模式下输入 <strong>/关键字</strong> ， 回车 查找 ,  正常模式下输入 n 就是查找下一个 ]</p><p>4) 设置文件的行号，取消文件的行号. [命令行下  : set nu  和  :set nonu]</p><p>5) 编辑 /etc/profile 文件，使用快捷键到底文档的 <strong>最末行[G]</strong>和 <strong>最首行[gg]</strong> 【正常模式下】</p><p>6) 在一个文件中输入 “hello” , 然后又撤销这个动作 u  【正常模式下】</p><p>先是在插入模式下，修改了文件的内容，然后觉得不想修改，那么切换到正常模式下，输入u。</p><p>7) 编辑  /etc/profile 文件，并将光标移动到  20行 shift + g</p><p>先在命令行模式下：set nu，看到行号，然后在正常模式下，输入：20 + shift + g ，就会跳转到第20行号的位置。</p><hr><p>更多快捷键的使用：</p><p>正常模式下：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124173155.png"></p><p>编辑模式下：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124173454.png"></p><p>命令行模式下：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124173621.png"></p><h2 id="开机、重启和用户登录注销"><a href="#开机、重启和用户登录注销" class="headerlink" title="开机、重启和用户登录注销"></a>开机、重启和用户登录注销</h2><h3 id="关机-amp-重启命令"><a href="#关机-amp-重启命令" class="headerlink" title="关机&amp;重启命令"></a>关机&amp;重启命令</h3><p>基本介绍:</p><p>shutdown:</p><pre><code>shutdown    –h    now         立该进行关机  【halt】shudown     -h     1              1分钟后会关机了shutdown    –r     now        现在重新启动计算机  [reboot]</code></pre><p>halt：立即关机</p><p>reboot：现在重新启动计算机</p><p>sync：把内存的数据同步到磁盘.</p><p><strong>注意细节：</strong></p><p>不管是重启系统还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中，防止数据丢失！</p><h3 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1）登录时尽量少用root帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后<br>再用 “su - 用户名” 命令来切换成系统管理员身份.</p><p>2）在提示符下输入 logout 即可注销用户【不同的shell 可能不同(logout  exit)】</p><h4 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h4><p>1) logout 注销指令在图形运行级别(简单提一下：0-6个级别)无效，在运行级别 3下有效.</p><p>即：在我们的图形化界面下的终端，输入：logout 无效。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124175449.png"></p><p>运行级别3：代表的就是远程登录。</p><p>在Xshell下，输入：logout 就退出了<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day02/QQ截图20181124175622.png"></p><p>2) 运行级别这个概念，后面给大家介绍</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门之安装</title>
      <link href="/2018/11/22/linux-ji-chu-ru-men/"/>
      <url>/2018/11/22/linux-ji-chu-ru-men/</url>
      
        <content type="html"><![CDATA[<p>Linux的基础入门篇，帮助大家入门的教程</p><h2 id="Linux的发行版"><a href="#Linux的发行版" class="headerlink" title="Linux的发行版"></a>Linux的发行版</h2><h3 id="常见的Linux发行版"><a href="#常见的Linux发行版" class="headerlink" title="常见的Linux发行版"></a>常见的Linux发行版</h3><p>1）Red Hat Linux</p><p>　　Red Hat Linux 是 Red Hat 最早的发行的个人版本的Linux，其1.0版本于1994年11月3日发行。自从Red Hat 9.0版本发布后，Red Hat公司不再开发桌面版Linux发行版本，Red Hat Linux停止发布，而将全部的力量集中在<strong>服务器版</strong>的发布上面，也就是Red Hat Enterprise Linux版。2004年4月30号，Red Hat公司正式停止Rad Hat Linux的发行套件则与来着开源社区的Fedora进行合并，成为了<strong>Fedora Core</strong> 发行版本。</p><p>　　目前 Red Hat 分为两个系列：由Red Hat 公司提供收费技术支持和更新的 Red Hat Enterprise Linux，以及由社区开发的免费的 Fedora Core。</p><p>2）CentOS</p><p>　　CentOS全名为 “社区企业操作系统”（Community Enterprise Operating System），它由来自于 RHEL 依照开放源代码规定发布的源代码编译而成，由于 RHEL 是商业产品，因此必须将 Red Hat 的所有Logo改成自己的 CentOS标识，这就产生了CentOS操作系统。两者的不同在于，CentOS并不是包含封闭源代码软件。因此，CentOS不但可以自由使用，而且能享受CentOS提供的长期免费升级和更新服务。这是CentOS的一个很大的优势。</p><p>　　在2014年CentOS宣布与Red Hat合作，但CentOS将会在新的委员会下继续运作，并不受RHEL的影响。这个策略表明CentOS后续发展将由Red Hat作为强有力的支持。</p><p>3）SuSE Linux</p><p>　　SUSE 是德国最著名的Linux发行版，也享有很高的声誉，不过命运相当坎坷。据不完全统计，SUSE Linux现在欧洲Linux市场中占有将近80%的份额，大部分关键应用都是建立在SUSE Linux下的。</p><p>4）Ubuntu Linux</p><p>　　Ubuntu(中文谐音为：友邦拓、优般图、乌班图)是一个以桌面应用为主的Linux操作系统，基于Debian GNU/Linux，Ubuntu旨在为一般用户提供一个主要由自由软件构建而成的最新的同时又相当稳定的操作系统。Ubuntu具有庞大的社区力量，用户可以方便地从社区获取帮助。</p><hr><p><strong>总结：</strong></p><p>初学者入门首选：CentOS系列，CentOS系列可以从官网或163开源、SOHU开源、阿里云开源站下载各个版本的安装介质。</p><p>桌面平台首选：Ubuntu Linux。</p><p>企业级应用首选：RHEL/CentOS系列</p><h2 id="虚拟机技术学习Linux"><a href="#虚拟机技术学习Linux" class="headerlink" title="虚拟机技术学习Linux"></a>虚拟机技术学习Linux</h2><h3 id="虚拟机技术"><a href="#虚拟机技术" class="headerlink" title="虚拟机技术"></a>虚拟机技术</h3><p>虚拟机指通过软件模拟的具有完整硬件系统的功能的、运行在一个完全隔离环境中的完整计算机系统。</p><p>虚拟机会生成现有操作系统的全新虚拟机镜像，它与真实系统具有完全一样的功能，进入虚拟机后，所有操作都在这个全新的独立虚拟机系统里面进行，可以独立安装、运行软件，保存数据，拥有自己的独立桌面，这不会对真实的系统产生任何影响，而且能够在现有系统与虚拟机之间灵活切换。</p><h3 id="使用虚拟机的好处"><a href="#使用虚拟机的好处" class="headerlink" title="使用虚拟机的好处"></a>使用虚拟机的好处</h3><p>1）节约成本</p><p>　　如果在一台计算机上安装Linux和Windows系统，而不用虚拟机，有两个方法。一是安装多个硬盘，每个硬盘安装一个操作系统，这个方法的缺点是费用比较昂贵。二是在一个硬盘上安装双系统，这个方法的缺点是不够安全，因为系统的MBR是操作系统的必争之地，Windows更是霸道，每次重新安装系统都要重写系统的MBR，这样，几个操作系统可能会同时崩溃。而使用虚拟机软件既省钱又安全，因此对于新手来说，利用虚拟机学习Linux简直再好不过了。</p><p>2）安全便捷</p><p>　　在虚拟机上面安装Linux系统，不用担心会格式化掉自己的硬盘，甚至可以随意地对虚拟机系统进行任何设置和更新操作，可以格式化虚拟机系统硬盘，还可以重新分区虚拟机系统硬盘等等，因为虚拟机是在真实系统上运行的软件，对虚拟机系统的任何操作都是对软件的操作。</p><p>3）简单高效</p><p>　　利用虚拟机模拟出来的Linux系统和真实的Linux系统是一模一样的。现在各个公司专门的Linux服务器是不会让新生随意操作的，而供测试的Linux服务器一般有很紧缺，如果在自己的电脑上安装虚拟机Linux系统，就可以随意地学习测试，而不受任何环境影响。</p><h3 id="虚拟机的运行环境和硬件需求"><a href="#虚拟机的运行环境和硬件需求" class="headerlink" title="虚拟机的运行环境和硬件需求"></a>虚拟机的运行环境和硬件需求</h3><p>1）运行环境</p><p>流行的虚拟机软件有：VMware、<strong>VirtualBox</strong>，它们都有Windows和Linux两个版本，也就是说，它们可以安装在Windows和Linux两个平台下：在Windows平台可以虚拟出Windows、Linux、UNIX等多个操作系统，同理，在Linux平台上也可以虚拟出Windows、Linux、UNIX等多个操作系统计算机。</p><p><strong>注意：</strong>运行虚拟机软件的操作系统叫做：Host OS，在虚拟机里面运行的操作系统叫做：Guest OS。</p><p>2）硬件需求</p><p>虚拟机软件是将两台以上的计算机的任务集成到一台计算机上来的，因此对硬件的要求比较高，主要涉及的是内存、硬件和CPU。内存要足够大，因为每个虚拟机都会占用一定的内存资源，内存的总大小等于各个虚拟机系统的总和。可喜的是，现在内存已经很便宜，因此就不是问题了。同样，硬盘空间也是每个虚拟机都要占用的，CPU现在都发展到了多核阶段，硬盘也不是问题。</p><h3 id="虚拟机的安装与使用"><a href="#虚拟机的安装与使用" class="headerlink" title="虚拟机的安装与使用"></a>虚拟机的安装与使用</h3><p>1）VirtualBox虚拟机概述</p><p>VirtualBox是一款开源虚拟机软件。最初是由德国Innotek公司开发，由Sun Microsystems公司出品的软件，使用Qt编写，在Sun被Oracle收购后正式更名成Oracle VM VirtualBox。</p><p>VirtualBox可以说是最强大的免费虚拟机软件，它不仅具有丰富的特色，而且性能非常优异，并且简单易用。它可以虚拟的系统有：Windows、Mac OS X、Linux、OpenBSD、Solaris、IBM OS2，甚至Android 4.0等多种操作系统。</p><p>2）虚拟机软件的安装</p><p>VirtualBox 的官方网站是：<code>https://www.virtualbox.org</code>, 可以从此网站下载VirtualBox的稳定版本，目前最新的稳定版本的为：VirtualBox 5.2。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181122114300.png"></p><p>这里，我们下载Windows版本的VirtualBox。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181122114531.png"></p><p>Windows下安装VirtualBox软件很简单，只须要按照Windows常规方法安装方法安装即可完成，这里就不再讲述了。<br>安装完成后：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181122115230.png"></p><h3 id="创建虚拟机系统"><a href="#创建虚拟机系统" class="headerlink" title="创建虚拟机系统"></a>创建虚拟机系统</h3><p>打开：Oracle VM VirtualBox软件，进行虚拟机系统的创建，具体步骤如下：</p><h4 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h4><p>1）按 ctrl + N 快捷键新建虚拟机或者直接点击新建：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181122115614.png"></p><h4 id="填写虚拟机信息"><a href="#填写虚拟机信息" class="headerlink" title="填写虚拟机信息"></a>填写虚拟机信息</h4><p>2）填写虚拟机的名称、虚拟机的类型、虚拟机的版本。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181122135544.png"></p><h4 id="配置虚拟机内存"><a href="#配置虚拟机内存" class="headerlink" title="配置虚拟机内存"></a>配置虚拟机内存</h4><p>3）配置虚拟机内存大小，这里选择：4096M<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181122133837.png"></p><h4 id="添加虚拟硬盘"><a href="#添加虚拟硬盘" class="headerlink" title="添加虚拟硬盘"></a>添加虚拟硬盘</h4><p>4）添加虚拟硬盘</p><p>选择现在创建虚拟硬盘：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181122134311.png"></p><h4 id="设置虚拟硬盘的文件类型"><a href="#设置虚拟硬盘的文件类型" class="headerlink" title="设置虚拟硬盘的文件类型"></a>设置虚拟硬盘的文件类型</h4><p>5）设置虚拟硬盘的文件类型：</p><p>选择VDI类型：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181122134414.png"></p><h4 id="设置虚拟硬盘的空间分配方式"><a href="#设置虚拟硬盘的空间分配方式" class="headerlink" title="设置虚拟硬盘的空间分配方式"></a>设置虚拟硬盘的空间分配方式</h4><p>6）设置虚拟硬盘的空间分配方式</p><p>选择动态分配：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181122134529.png"></p><h4 id="设置虚拟磁盘文件的位置和大小"><a href="#设置虚拟磁盘文件的位置和大小" class="headerlink" title="设置虚拟磁盘文件的位置和大小"></a>设置虚拟磁盘文件的位置和大小</h4><p>7）设置虚拟磁盘文件的位置和大小</p><p>位置：选择自己喜欢的位置<br>大小：选择实际硬盘的合理大小即可<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181122134855.png"></p><p>8）虚拟机系统创建成功后<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181122135649.png"></p><p>单击左侧的虚拟机名称，在右边可以看到此虚拟机的配置属性。</p><p>在设置页面中，可以对虚拟机的常规、系统、显示、存储、声音、网络、串口、USB设置、共享文件夹等多个方面进行设置。</p><h4 id="下载linux系统的ISO镜像"><a href="#下载linux系统的ISO镜像" class="headerlink" title="下载linux系统的ISO镜像"></a>下载linux系统的ISO镜像</h4><p>9）虚拟机上安装linux系统</p><p>在虚拟机上安装Linux系统，常用的方法有两种：光驱安装和ISO镜像文件安装。</p><p>这里，我使用ISO镜像文件安装。</p><p>10）到开源镜像站下载IOS镜像</p><p>推荐163镜像站、阿里云镜像站。</p><p>这里，我使用阿里云镜像站：<code>https://opsx.alibaba.com/mirror</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123100200.png"></p><p>选择：最新的版本，当前最新的是7.5。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123100328.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123100424.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123100604.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123100838.png"></p><p>各个版本的ISO镜像文件说明：</p><p>CentOS-7-x86_64-DVD-1804.iso　　　　　　　　标准安装版（推荐）</p><p>CentOS-7-x86_64-Everything-1804.iso　　　　 　完整版，集成所有软件（以用来补充系统的软件或者填充本地镜像）</p><p>CentOS-7-x86_64-LiveGNOME-1804.iso　　　　GNOME桌面版  </p><p>CentOS-7-x86_64-LiveKDE-1804.iso　　　　　　KDE桌面版  </p><p>CentOS-7-x86_64-Minimal-1804.iso　　　　　　精简版，自带的软件最少</p><p>CentOS-7-x86_64-NetInstall-1804.iso　　　　 　网络安装版（从网络安装或者救援系统）</p><p>这里，下载标准安装版：<strong>CentOS-7-x86_64-DVD-1804.iso</strong></p><hr><h4 id="关联虚拟机与CentOS的ISO镜像文件"><a href="#关联虚拟机与CentOS的ISO镜像文件" class="headerlink" title="关联虚拟机与CentOS的ISO镜像文件"></a>关联虚拟机与CentOS的ISO镜像文件</h4><p>11）将我们下载的CentOS_7 和 我们创建的虚拟机系统关联<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123132843.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123132945.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123133020.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123133116.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123133150.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123133224.png"></p><h4 id="linux系统的安装流程"><a href="#linux系统的安装流程" class="headerlink" title="linux系统的安装流程"></a>linux系统的安装流程</h4><p>12）启动我们的centOS_7.5</p><p>如果出现错误的话，是你的电脑没有开启虚拟机化技术。</p><p>我们需要进入BIOS，将虚拟机化技术打开：</p><p>重启我们的电脑，通常按 F2 或者 F12、Esc等进入BISO界面。选择configuration，再选择Intel virtual technology，将其改为enable即可。</p><p>再次重启电脑后，打开virtualBox，进入Linux的安装流程。</p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123134107.png"></p><p>打开后，会发现centOS7有三个启动流程：Install CentOS7（立即安装），Test this mdia &amp; Install CentOS7（测试安装介质并安装），Troubleshooting（故障修复）。我们选择：<strong>Install CentOS7（立即安装）</strong><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123134640.png"></p><p>选择系统安装过程中的语言，这里选择English选项，当然，你可以选择简体中文，不过建议使用English安装。单击<strong>continue</strong><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123134841.png"></p><p>此时，进入了系统安装的总体浏览界面，从图可以看出，分为三个部分：LOCALIZATION（本地化安装）、SOFTWARE（软件安装）、SYSTEM（系统安装）。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123135407.png"></p><p>进入LOCALIZATION（本地化安装）的 DATE &amp; TIME：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123135942.png"></p><p>设置：Asia（亚洲）、Shanghai（上海）。点击左上角的Done。</p><p>进入LOCALIZATION（本地化安装）的 KEYBOARD（键盘设置）：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123140255.png"></p><p>对于KEYBOARD选项，选择English即可，也可以添加Chinese。</p><p>进入LOCALIZATION（本地化安装）的 LANGUAGE SUPPORT（语言设置）：</p><p>添加English、简体中文。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123140512.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123140544.png"></p><hr><p>接下来，进入：软件安装设置，点击 INSTALLATION SOURCE<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123140817.png"></p><p>点击：SOFTWARE SELECTION（安装软件的配置信息）</p><p>我们知道，Linux系统，一般指的是Linux内核，而一些组织、公司在内核的基础上又进行了封装，即二次开发，就变成了现在的centOS、红帽等产品。这里的选项就是安装除了centOS内核外的软件。</p><ul><li>初学者选择 CNOME Desktop 或 KDE Plasma Workspaces，这两种环境提供了非常友好的、直观的Linux桌面环境。</li><li>如果在Linux上开发，建议选择Development and Creative Workspaces</li><li>如果只是一个Linux环境，选择Minimal Install即可</li><li>如果在Linux上运行虚拟化程序，选择Virtualization Host</li><li>如果是搭建一个Linux服务器，那么建议Server with GUI。</li></ul><p>在我们以后的工作中，一般我们的Linux都是作为服务器来使用的，所以，这里选择：<strong>Server with GUI</strong>。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123142003.png"></p><hr><p><strong>接下来，进入磁盘分区部分，重点！！！</strong><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123142217.png"></p><p>出现了，我们设置虚拟机系统的磁盘空间大小的64G。</p><p>首先选中我们的64G那个的sda盘。然后在左下角会有两个分区的选项，第一个是Automaticlly configure partitioning，表示自动分区；第二个是 <strong>I will configure partitioning</strong>，表示手动分区。如果对分区不太熟的话，直接使用自动分区即可，但是，我们是学习Linux系统，所以，这里选择<strong>手动分区</strong>。</p><p>选择完毕后，单击Done。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123142724.png"></p><p>分区方案：有标准分区 Standard Partition、Btrfs、LVM 和 LVM Thin Provisioning（精简分区）</p><p>这里，选择标准分区即可。</p><p>接下来就要开始创建挂载点了。在此之前，进行一些必要的说明：</p><p>Linux系统下必需的分区为：根分区（/）和 交换分区（swap）。swap分区相当于windows下的虚拟内存，当内存不够的时候，会临时使用swap分区的空间。</p><p>swap分区的大小，一般是你的本机的物理内存的2倍。物理内存小于4G，那么swap：两倍；物理内存：4G~16G，那么swap：等于物理内存；物理内存大于16G，swap：0。一般swap不建议0，设置一定大小的swap还是有一定的作用的。</p><p>虽然Linux系统默认只需要：划分根分区和swap分区就可以了，但是不建议这么做，因为如果只划分了根分区，那么当根分区遭到破坏后，系统可以无法启动，存储在根分区中的资料也有可能丢失，这样很不安全。因此，建议给独立的应用分配独立的分区，这样即使某个分区被破坏，也不影响其他分区的数据。</p><p>以下是建议在安装系统时独立分配的分区</p><p>1）/boot: 存储系统的引导信息和内核等信息</p><p>2）/usr: 存储系统应用软件安装信息</p><p>3）/var: 存储系统日志信息。</p><p>根分区包含Linux系统所有的目录。如果在安装系统时只分配了根分区，那么上面的/boot,/user,/var都包含在根分区中，也就是说，这些分区将占用根分区的空间。如果将/boot,/usr,/var等单独划分，那么这些分区将不再占用根分区的空间。</p><hr><p>先创建<strong>根分区</strong>，根分区空间尽量大点，这里，我选择了20G。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123144507.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123144901.png"></p><p>添加/boot分区：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123145024.png"></p><p>添加/usr分区：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123145218.png"></p><p>添加/var分区：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123145341.png"></p><p>添加<strong>swap交换区</strong><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123145635.png"></p><p>剩下的空间，我们可以再创建一个分区，用来保存用户的数据信息：<br>添加/mydata分区：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123145921.png"></p><p>最终分区分配完毕后的结果：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123150055.png"></p><hr><p>点击左上角的Done。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123150315.png"></p><p>点击：Accept Changes</p><hr><p>进入 SYSTEM ：KDUPM<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123150442.png"></p><p>kdump：主要用来记录系统出错后的信息，用来侦查系统出错的原因，开启后，会占用一定的内存资源。</p><p>这里，我们是学习，我就关闭了，如果是你是上班，开发的话，就将其开启。</p><hr><p>进入 SYSTEM ：NETWORK &amp; HOST NAME<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123150800.png"></p><p>默认情况下，网卡处于断开连接状态，可单击右上角的 ON/OFF（开关）按钮，将网卡激活。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123151058.png"></p><p>激活后，我们看到了网卡自动帮我们配置了ip地址，网关ip地址，DNS服务地址等。</p><p>如果想自己手动配置，可以点击右下角的：Configure。</p><p>进入了设置页面：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123151255.png"></p><p>可以根据连接网络的类型配置：有线、无线、VPN 或 DSL的连接，在这里选择 Automatically connect to this network when it is available 和 All uesrs may connect to this network的复选框，这样就可以实现系统启动后自动连接。</p><p>在网络配置部分，看似很多选项需要配置，其实需要配置的并不多。选择IPV4 Settings。</p><p>在Method选项中：有Automatic DHCP、Manual、Link-Local Only等，这里选择Manual。</p><p>接着就可以添加 IPv4 的ip地址，这里添加的ip地址：192.168.56.101，子网掩码：255.255.255.0，网关：192.168.56.1，然后DNS Server：223.5.5.5.<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123152436.png"></p><p>点save保存。网卡会自动尝试网络连通性，配置完成后的效果：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123152608.png"></p><p><strong>PS：不想手工配合的话，直接开启激化网卡就好，后面的操作不用进行的</strong></p><hr><p>进入 SYSTEM ：SECURITY POLICY</p><p>安全策略，选择标准的策略即可。（不开启安全策略也行）</p><hr><p>到此为止，我们的基本设置已经完成，点击 Begin Installation。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123153830.png"></p><p>在安装的过程中，我们需要设置Linux的管理员账号ROOT的密码，<strong>密码不能过于简单，否则会提示你，让你重新设置。</strong><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123153638.png"></p><p>在安装的过程中，也可以设置普通用户，输入用户名和密码即可。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123153657.png"></p><p><strong>注意：如果要设置root和普通用户，请在安装完成之前进行，否则安装完成后，就不能设置了！！！</strong></p><hr><p>安装完成后，点击Reboot按钮重启系统。<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123155718.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123155902.png"></p><p>选择接受：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123155937.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123160010.png"></p><p>用户登入界面：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123160111.png"><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123160151.png"></p><p>进入开机引导的界面：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123160307.png"></p><p>选择，你自己喜欢的语言，English，汉语等，进行引导安装</p><p>选择，键盘的输入：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123160430.png"></p><p>隐私：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123160520.png"></p><p>选择在线用户，没有就跳过<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123160620.png"></p><p>开始使用Linux系统：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123160723.png"></p><hr><p>到此，Linux系统，终于安装完毕，也看到了我们Linux系统的界面了<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123160817.png"></p><h3 id="Linux系统下的常用指令"><a href="#Linux系统下的常用指令" class="headerlink" title="Linux系统下的常用指令"></a>Linux系统下的常用指令</h3><p>Linux系统由桌面控制台和字符控制台组成，桌面系统其实就是我们安装软件包时的X-Window视窗，而X-Window的实质是在命令行下运行的一个应用程序。字符控制台是Linux系统的核心，大部分操作都是在字符控制台下面完成的，即：终端。</p><p>默认Linux下有6个字符控制台，每个控制台可以独立作业，互不影响，这真正体现了Linux系统下的：多用户、多任务的特性。</p><p>在图形界面下要切换到字符界面时，只需要按：<strong>ctrl+alt+F2~F7组合键</strong>中的任何一个，即可进入字符界面。相反如果要从字符界面切换到图形界面的话，可以在字符界面输入：startx 或者 <strong>ctrl+alt+F1</strong>组合键.</p><p>虚拟机和物理机之间的鼠标和键盘切换问题，默认是通过：<strong>右下角的ctrl键</strong>来切换的。这个右下角的ctrl键也称为：热键或者主机（host）键。</p><p>主机键和其他键组合，可以实现对虚拟机的快捷操作，例如：Host+Del组件键：表示键盘上的ctrl+alt+del组合键，Host+R：表示重启虚拟机，Host+H：表示正常关闭虚拟机。</p><p>Linux系统的关闭过程</p><p>1）shutdown [-fFhknrc参数名称] [-t 秒数] 时间 [警告信息]</p><p>-f: 重新启动时，不执行fsck。 fsck：是Linux下的一个检查和修复文件系统的程序。</p><p>-h：将系统关机，在某种程度上功能与halt命令相当</p><p>-k：只发送信息给所有的用户，但并不会真正关机</p><p>-n：不调用init程序关机，而是由shutdown自己进行（一般关机程序是由shutdown调用init来实现关机动作的），使用此参数关机速度快，不建议</p><p>-r：关机后重启</p><p>-c：取消前一个shutdown命令。</p><p>-t[秒数]：发送警告信息和关机信息之间要延迟多少秒。警告信息将提醒用户保存当前进行的工作。</p><p>[时间]：设置多久时间后执行shutdown命令。时间参数有 hh:mm 或 +m 两种模式。例如： shutdown 16:50 :表示将在16:50关机。</p><p>now：表示立即关机。</p><p>常用指令：</p><p>立即关机</p><pre><code>shutdown -h now</code></pre><p>立即关机重启</p><pre><code>shutdown -r now</code></pre><p>设定5分钟后关机，同时发出警告信息给登录的Linux用户。</p><pre><code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code></pre><hr><h3 id="虚拟机的网络连接是三种方式"><a href="#虚拟机的网络连接是三种方式" class="headerlink" title="虚拟机的网络连接是三种方式"></a>虚拟机的网络连接是三种方式</h3><p>1）桥接模式</p><p>好处：大家都在同一个网段，相互可以通讯。<br>坏处：因为ip地址有限，可能造成ip冲突</p><p>因为桥接模式下的网络，是会帮我们的虚拟机的Linux系统，自动分配一个ip地址，这个ip地址会和我的宿主机在一个网段内，比如：我们的宿主机的ip地址是192.168.14.100 ，那么centOS虚拟机的ip就会是192.168.14.xxx（比如192.168.14.120）。在该网段下的其他宿主机，张三（192.168.14.110）就能直接访问到我的centOS虚拟机。</p><p>如果每个人都使用这种模式来开启虚拟机的网络设置，那么ip地址就不够用了，容易ip地址冲突！！！</p><p>2）Nat [网络地址转换模式]</p><p>好处：虚拟机不占用其他的ip,所以不会ip冲突<br>坏处：内网的其他人不能和虚拟机通讯</p><p>Nat模式下的话，会在我们的宿主机上面创建一个新的ip地址，会和我们的windows宿主机的ip地址不在一个网段上面，比如：我们的是192.168.14.64，那么创建的新的ip地址会是：192.168.102.1。不在一个网段上面，而且也会在centOS虚拟机上面分配一个和新的windows上面ip地址同一个网段的ip地址，比如：192.168.102.128。<br>即：centOS虚拟机ip地址与新的windows的ip地址连通，然后新的windows的ip与我们本身的windows的ip互通，这样就能访问我们的centOS虚拟机了，但是，在该网段下的其他用户，李四：192.168.14.112，就不与我们的centOS虚拟机（192.168.102.128）通信了，不过我们的centOS虚拟机（192.168.102.128）可以与李四通信，因为centOS虚拟机与本机连通，可以通过本机的ip（192.168.14.64）与李四通信，在一个网段下面。</p><p>3）仅主机模式（Host-only）</p><p>意思很明确了，就是单独一台电脑。linux不能访问外网（一般实际生产中，很少用）</p><hr><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123170336.png"></p><h3 id="centOS的终端使用和联网"><a href="#centOS的终端使用和联网" class="headerlink" title="centOS的终端使用和联网"></a>centOS的终端使用和联网</h3><h4 id="终端的使用"><a href="#终端的使用" class="headerlink" title="终端的使用"></a>终端的使用</h4><p>在centOS系统中，右键打开终端：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123173038.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123172554.png"></p><p>会发现是白色的背景，黑色的字体，看着不舒服，我们修改<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123172951.png"><br>选择颜色：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123172854.png"></p><p>修改后：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123173132.png"></p><hr><h4 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h4><p>启动：火狐浏览器<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123173303.png"></p><p>在浏览器中输入：<code>www.baidu.com</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123173520.png"></p><p>发现，连接不上网。</p><p>怎么联网呢？</p><p>我们的虚拟机网络设置的是：NAT[网络地址转换]<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123173701.png"></p><p>根据，上一节的介绍，我们的宿主机应该有两个ip地址：</p><p>打开windows下的终端：home+R：cmd</p><p>输入：ipconfig<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123175311.png"></p><p>能够看到，我们的ip地址。</p><p>现在打开，centOS中的终端：</p><p>在linux系统中，使用 ifconfig 来查看ip地址<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123175508.png"></p><p>发现，根本没有ip地址，所以我们不能联网。</p><p>现在来设置ip地址，点击右上角的声音、电池、亮度的图标<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123175619.png"></p><p>点击有线设置：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123175819.png"></p><p>点击有线连接的上面的齿轮进行具体的设置：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123175927.png"><br>点击IPv4：<br>改为：DHCP（自动设置）<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123180012.png"></p><p>单击：应用<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123180158.png"></p><p>打开有线连接：<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123180252.png"></p><p>进入终端：ifconfig<br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123180417.png"></p><p>现在已经帮我们自动配合了，IP地址了，这里是：10.0.2.15</p><p>再次打开：火狐浏览器输入：<code>www.baidu.com</code><br><img src="https://gakkil.gitee.io/gakkil-image/linux/day01/QQ截图20181123181048.png"></p><p>联网成功，只要你的宿主机能够联网，那么centOS虚拟机也就能够联网了。</p><p><strong>注意：我使用的是virtualBox，照理说NAT模式下，应该会有一个新的windows的ip地址，而且是不同的网段，但是这里在windows下ipconfig，看不到那个新产生的ip地址，在centOS下的自动生成的ip地址应该会和新生成的windows的ip在同一个网络，这里也看不出来，但是，如果你使用的是VMWare虚拟机的话，就能发现。至于什么原因，我也不清楚，以后解决了，会留言告诉大家！！！</strong></p><p><strong>PS：这里使用的是DHCP：动态帮我们配置的ip地址，每次启动都会变动，以后我们会学习静态ip分配</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与监控管理</title>
      <link href="/2018/11/21/spring-boot-yu-jian-kong-guan-li/"/>
      <url>/2018/11/21/spring-boot-yu-jian-kong-guan-li/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot与监控管理</p><h2 id="监控管理"><a href="#监控管理" class="headerlink" title="监控管理"></a>监控管理</h2><p>通过引入spring-boot-starter-actuator，可以使用Spring Boot为我们提供的准生产环境下的应用监控和管理功能。我们可以通过HTTP，JMX，SSH协议来进行操作，自动得到审计、健康及指标信息等.</p><p>步骤：</p><p>– 引入spring-boot-starter-actuator<br>– 通过http方式访问监控端点<br>– 可进行shutdown（POST 提交，此端点默认关闭）</p><h2 id="监控和管理端点"><a href="#监控和管理端点" class="headerlink" title="监控和管理端点:"></a>监控和管理端点:</h2><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121155804.png"></p><p>1) 创建新的Springboot项目：</p><p>添加：DevTools、Web、Actuator模块：</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121160723.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121160747.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121160816.png"></p><p>2）直接运行应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121160955.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121161042.png"></p><p>发现：多了很多映射的url。</p><p>这些url都是因为加入:<code>spring-boot-starter-actuator</code> 依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>3）访问这些url映射：</p><p>随便访问一个：比如：/beans<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121161305.png"></p><p>发现：没有权限访问！！！</p><p>4）关闭安全监测</p><p>在application配置文件中：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121161735.png"></p><pre><code>#关闭安全管理检测management.security.enabled=false</code></pre><p>ctrl+F9:即可，不需要重启应用。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121161833.png"></p><p>其他的监控信息：请看<strong>监控和管理端点</strong>的图片，执行测试即可。</p><h2 id="定制端点信息"><a href="#定制端点信息" class="headerlink" title="定制端点信息"></a>定制端点信息</h2><p>– 定制端点一般通过endpoints+端点名+属性名来设置。</p><p>– 修改端点id（endpoints.beans.id=mybeans）</p><p>– 开启远程应用关闭功能（endpoints.shutdown.enabled=true）</p><p>– 关闭端点（endpoints.beans.enabled=false）</p><p>– 开启所需端点<br>• endpoints.enabled=false<br>• endpoints.beans.enabled=true</p><p>– 定制端点访问根路径<br>• management.context-path=/manage</p><p>– 关闭http端点<br>• management.port=-1</p><hr><p>测试：</p><p>1）在application配置文件中：</p><pre><code>#定制端点信息endpoints.beans.id=mybeans</code></pre><p>现在，beans的访问端点就不行了，必须是mybeans了。（修改了默认的访问名）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121162813.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121162844.png"></p><p>2）在application配置文件中：</p><pre><code>#定制端点信息endpoints.beans.id=mybeansendpoints.beans.path=/b</code></pre><p>此时的beans的访问路径，就变成了/b. 默认的 /beans 和 /mybeans 都不好使了。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121163113.png"></p><p>3）在application配置文件中：</p><pre><code>#定制端点信息endpoints.beans.id=mybeansendpoints.beans.path=/b#关闭了beans的端点endpoints.beans.enabled=false</code></pre><p>此时，就会把beans端点给关闭了。不管访问 /beans 和 /mybeans 和 /b 都不好使了。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121163338.png"></p><p>但是其他端点好使：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121163416.png"></p><p>4）如果想关闭所有的，但是只留一些端点开放：</p><pre><code>#关闭所有的端点endpoints.enabled=false#开启部分端点(beans)endpoints.beans.enabled=true</code></pre><p>其他端点都不好使了。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121163647.png"><br>只要beans端点好使：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121163733.png"></p><p>5）定制端点访问根路径</p><pre><code>#设置访问端点的根路径management.context-path=/manager</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121163931.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121164012.png"></p><p>6) 定制端点访问的端口号</p><pre><code>#设置访问端点的根路径management.context-path=/managermanagement.port=8081</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121164156.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121164226.png"></p><p>7) 关闭http端点</p><pre><code>#设置访问端点的根路径management.context-path=/managermanagement.port=-1</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/jiankong/QQ截图20181121164352.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 监控管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 监控管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与开发热部署</title>
      <link href="/2018/11/21/spring-boot-yu-kai-fa-re-bu-shu/"/>
      <url>/2018/11/21/spring-boot-yu-kai-fa-re-bu-shu/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot中的热部署</p><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><p>在开发中我们修改一个Java文件后想看到效果不得不重启应用，这导致大量时间花费，我们希望不重启应用的情况下，程序可以自动部署（热部署）。有以下四种情况，如何能实现热部署。</p><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>– 在Spring Boot中开发情况下禁用模板引擎的cache<br>– 页面模板改变ctrl+F9可以重新编译当前页面并生效</p><h3 id="Spring-Loaded"><a href="#Spring-Loaded" class="headerlink" title="Spring Loaded"></a>Spring Loaded</h3><p>Spring官方提供的热部署程序，实现修改类文件的热部署<br>– 下载Spring Loaded（项目地址<a href="https://github.com/spring-projects/spring-loaded）" target="_blank" rel="noopener">https://github.com/spring-projects/spring-loaded）</a><br>– 添加运行时参数: -javaagent:C:/springloaded-1.2.5.RELEASE.jar -noverify</p><h3 id="JRebel"><a href="#JRebel" class="headerlink" title="JRebel"></a>JRebel</h3><p>– 收费的一个热部署软件<br>– 安装插件使用即可</p><h3 id="Spring-Boot-Devtools（推荐）"><a href="#Spring-Boot-Devtools（推荐）" class="headerlink" title="Spring Boot Devtools（推荐）"></a>Spring Boot Devtools（推荐）</h3><p>引入依赖:</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="演示Spring-Boot-Devtools"><a href="#演示Spring-Boot-Devtools" class="headerlink" title="演示Spring Boot Devtools"></a>演示Spring Boot Devtools</h2><p>1）创建一个Thymeleaf的Springboot的项目：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121143729.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121144641.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121143827.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121143851.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121144815.png"></p><p>2) 在templates下，创建一个hello.html文件<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121144956.png"></p><p>3）在controller包下，创建HelloWorldController：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121145141.png"></p><p>4）启动Springboot应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121145251.png"></p><p>在浏览器中输入：<code>http://localhost:8080/</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121145323.png"></p><p>5) 现在修改映射url：</p><p>不要关闭应用！！！<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121145426.png"></p><p>访问：<code>http://localhost:8080/hello</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121145529.png"></p><p>说明，根本没有热部署功能！</p><p>现在：打开target包下的：HelloWorldController：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121145705.png"></p><p>说明：我们的编译后的class文件，根本没有改过。</p><p>现在，在我们的src下的HelloWorldController类中：<strong>ctrl+F9</strong></p><p>然后再次打开target下的HelloWorldController类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121145916.png"></p><p>发现，我们改变的HelloWorldController类已经改变了。</p><p>再次在浏览器中输入：<code>http://localhost:8080/hello</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121145529.png"></p><p>还是不行，这是我们需要导入spring-boot-devtools依赖：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121150337.png"></p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><p>此时，我们重启Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/hello</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121150510.png"></p><p>在把映射的url修改回来：</p><p>不停止应用！！！<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121150606.png"></p><p>然后：ctrl+F9</p><p>在浏览器中输入：<code>http://localhost:8080/</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121153657.png"></p><p>热部署成功！</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>引入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><p>– IDEA 使用 : ctrl+F9<br>– 或做一些小调整<br>Intellij IEDA和Eclipse不同，Eclipse设置了自动编译之后，修改类它会自动编译，而IDEA在非RUN或DEBUG情况下<br>才会自动编译（前提是你已经设置了Auto-Compile）。</p><hr><p>• 设置自动编译（settings-compiler-make project automatically）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121154016.png"></p><p>• ctrl+shift+alt+/（maintenance）<br>• 勾选compiler.automake.allow.when.app.running</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121154100.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/hotLoad/QQ截图20181121154123.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 热部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 热部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与分布式</title>
      <link href="/2018/11/19/spring-boot-yu-fen-bu-shi/"/>
      <url>/2018/11/19/spring-boot-yu-fen-bu-shi/</url>
      
        <content type="html"><![CDATA[<p>分步式、Dubbo/Zookeeper、SpringBoot/Cloud</p><h2 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h2><p>在分布式系统中，国内常用zookeeper+dubbo组合，而SpringBoot推荐使用全栈的Spring，Spring Boot+Spring Cloud。</p><ul><li><p>单一应用架构<br>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p></li><li><p>垂直应用架构<br>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p></li><li><p>分布式服务架构<br>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时,用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p></li><li><p>流动计算架构<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p></li></ul><h2 id="Zookeeper和Dubbo"><a href="#Zookeeper和Dubbo" class="headerlink" title="Zookeeper和Dubbo"></a>Zookeeper和Dubbo</h2><ul><li>ZooKeeper</li></ul><p>ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><ul><li>Dubbo</li></ul><p>Dubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出 <strong>服务提供方（Provider）</strong>和 <strong>服务消费方（Consumer）</strong>两个角色。</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119102607.png"></p><p>步骤：<br>• 1、安装zookeeper作为注册中心<br>• 2、编写服务提供者<br>• 3、编写服务消费者<br>• 4、整合dubbo</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="下载zookeeper镜像"><a href="#下载zookeeper镜像" class="headerlink" title="下载zookeeper镜像"></a>下载zookeeper镜像</h3><p>1）打开我们的虚拟机，下载zookeeper镜像：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119111308.png"></p><pre><code>docker pull registry.docker-cn.com/library/zookeeper</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119112101.png"></p><p>查看zookeeper的docker官网，看怎么运行？<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119112223.png"></p><p>发现：会暴露三个端口号，2181,2888,3888。我们只需要暴露2181即可，因为我们不做集群。</p><pre><code>docker run --name zk01 -p 2181:2181 --restart always -d zookeeper的imageId </code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119113528.png"></p><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>2) 创建两个工程，一个服务提供者 和 一个服务消费者</p><p>打开idea，创建一个空项目，为了方便演示而已：</p><p>这个空项目里面：会包括服务提供者和服务消费者<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119115031.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119115245.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119115341.png"></p><p>在这个空项目中，添加 服务提供者 和 服务消费者 工程：</p><p>服务提供者工程：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119115531.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119115559.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119115833.png"><br>选中Web模块，1.x.x的版本<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119115913.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119120004.png"><br>创建完成后：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119120056.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119120144.png"></p><p>服务消费者工程：</p><p>类似：只是工程名字为：consume-ticket<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119120418.png"></p><p>最后，两个工程生成完毕后：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119123653.png"></p><h3 id="编写提供者和消费者"><a href="#编写提供者和消费者" class="headerlink" title="编写提供者和消费者"></a>编写提供者和消费者</h3><p>打开dubbo官网：<a href="http://dubbo.apache.org/en-us/" target="_blank" rel="noopener">http://dubbo.apache.org/en-us/</a><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119124046.png"></p><p>可以学习相关的知识。</p><h4 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h4><p>3.1.1）在服务提供者项目中：导入dubbo的spring-boot-starter：</p><pre><code>&lt;!-- https://mvnrepository.com/artifact/com.alibaba.boot/dubbo-spring-boot-starter --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;0.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>3.1.2）导入zookeeper的相关依赖：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;    &lt;artifactId&gt;zkclient&lt;/artifactId&gt;    &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119125517.png"></p><p>3.1.3) 编写服务提供者的售票服务：</p><p>在service包下，创建TickerService接口：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119125831.png"></p><p>在service包下，创建创建TickerService接口的实现类：TickerServiceImpl：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119130029.png"></p><p>3.1.4）将我们编写的服务注册到注册中心：</p><p>在application配置文件中，配置zookeeper的信息：</p><p>dubbo是阿里提供的RPC：开源的远程调用服务，帮助我们将服务注册到Zookeeper注册中心中。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119130712.png"></p><pre><code>#注册服务到zookeeper注册中心中的服务名字dubbo.application.name=provide-ticket#ip地址是你的虚拟机的ip地址，记住zookeeper服务是启动的状态dubbo.registry.address=zookeeper://10.6.11.17:2181# 扫描包，将该包下的使用的dubbo的@Service注解的类注册到注册中心中dubbo.scan.base-packages=com.liuzhuo.ticket.service</code></pre><p>3.1.5) 给我们的服务添加上<strong>dubbo的@Service</strong>注解</p><p><strong>注意：这里的@Service注解是dubbo的，不是Spring的@Service注解。</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119131152.png"></p><p>3.6）启动服务提供者的Springboot应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119131324.png"></p><p>启动失败的？<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119131548.png"></p><p>这里是因为：版本依赖的问题，Springboot 1.x 要导入：0.1.x的dubbo。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119131649.png"></p><p>修改application的配置文件：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;0.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119132013.png"></p><p>重启服务提供者的应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119134051.png"></p><p>启动成功！！！</p><hr><h4 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h4><p>3.2.1）导入dubbo和Zookeeper的相关依赖：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119134412.png"></p><p>3.2.2）配置application文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119134615.png"></p><p>3.2.3）编写消费的代码：</p><p>在user/service包下，创建UserService类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119135241.png"></p><p>3.2.4）引入服务提供者的服务：</p><p><strong>关键：在服务消费者的工程下，创建服务提供者一模一样的类名的接口：TickerService</strong></p><p>即：将服务提供者的：TickerService的全类名拷贝到服务消费者中：（只要TickerService接口即可）</p><p>这就是为啥，我在创建两个项目的时候，项目的包名都是一样的原因！！！（都是com.liuzhuo.ticket）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119135557.png"></p><p>3.2.5) 在UserService类中注入服务提供者的TickerService：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119140053.png"></p><p>3.2.6）在测试类中，测试是否能调用到服务提供者的售票服务：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119140231.png"></p><p>启动测试：</p><p><strong>注意：此时的服务提供者的Springboot应用不要停，也要一直启动！！！</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119140404.png"></p><p>远程调用成功！！！</p><hr><h2 id="SpringBoot和SpringCloud"><a href="#SpringBoot和SpringCloud" class="headerlink" title="SpringBoot和SpringCloud"></a>SpringBoot和SpringCloud</h2><p><strong>Spring Cloud</strong><br>Spring Cloud是一个分布式的整体解决方案。Spring Cloud 为开发者提供了在<strong>分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全局琐，leader选举，分布式session，集群状态）中快速构建的工具</strong>，使用Spring Cloud的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。</p><p><strong>SpringCloud分布式开发五大常用组件</strong></p><ul><li><p>服务发现——Netflix Eureka</p></li><li><p>客服端负载均衡——Netflix Ribbon</p></li><li><p>断路器——Netflix Hystrix</p></li><li><p>服务网关——Netflix Zuul</p></li><li><p>分布式配置——Spring Cloud Config</p></li></ul><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119143127.png"></p><p>微服务原文：<a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">https://martinfowler.com/articles/microservices.html</a></p><p>Spring Cloud 入门</p><p>1、创建provider<br>2、创建consumer<br>3、引入Spring Cloud<br>4、引入Eureka注册中心<br>5、引入Ribbon进行客户端负载均衡</p><hr><h3 id="创建空的工程"><a href="#创建空的工程" class="headerlink" title="创建空的工程"></a>创建空的工程</h3><p>1）创建空的工程：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119143436.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119143545.png"></p><h3 id="创建三个工程"><a href="#创建三个工程" class="headerlink" title="创建三个工程"></a>创建三个工程</h3><p>2）添加三个工程：</p><p>Eureka注册中心工程、服务提供者工程、服务消费者工程。</p><h4 id="创建Eureka注册中心"><a href="#创建Eureka注册中心" class="headerlink" title="创建Eureka注册中心"></a>创建Eureka注册中心</h4><p>2.1）创建Eureka注册中心<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119144149.png"></p><p>添加：Eureka Server模块（因为是注册模块）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119144408.png"></p><h4 id="创建服务提供者"><a href="#创建服务提供者" class="headerlink" title="创建服务提供者"></a>创建服务提供者</h4><p>2.2）创建服务提供者<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119144658.png"></p><p>添加：Eureka Discovery模块（发现服务的模块）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119144840.png"></p><h4 id="创建服务消费者"><a href="#创建服务消费者" class="headerlink" title="创建服务消费者"></a>创建服务消费者</h4><p>2.3）创建服务消费者<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119145013.png"></p><p>添加：Eureka Discovery模块（发现服务的模块）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119144840.png"></p><p>最后三个工程都创建完毕后：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119145128.png"></p><hr><h3 id="配置Eureka-server模块："><a href="#配置Eureka-server模块：" class="headerlink" title="配置Eureka server模块："></a>配置Eureka server模块：</h3><p>在eureka-server工程中，配置Application文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119153233.png"></p><pre><code>#配置服务的端口号：server:  port: 8761#配置eureka信息eureka:  instance:    hostname: eureka-server  # eureka实例的主机名  client:    register-with-eureka: false # 不注册自己到eureka上    fetch-registry: false # 不从eureka上面获取服务的注册信息    service-url:     # 是一个map结构      defaultZone: http://localhost:8761/eureka/  # 注册中心的地址</code></pre><p>在在eureka-server工程中的启动类上，添加Eureka的注解启动功能：@EnableEurekaServer<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119153514.png"></p><p>启动Eureka-Server项目：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119153754.png"></p><p><strong>启动成功后，就不要关闭了。</strong></p><p>在浏览器中输入：<code>http://localhost:8761/</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119153920.png"></p><p>到目前为止，我们的Eureka服务注册中心启动成功！</p><hr><h3 id="配置服务提供者模块："><a href="#配置服务提供者模块：" class="headerlink" title="配置服务提供者模块："></a>配置服务提供者模块：</h3><p>在privoder-ticket项目中：</p><p>在service包下，创建TicketService服务:<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119154409.png"></p><p>在controller包下，创建TicketController：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119154648.png"></p><p>将我们的服务注册到服务中心中：</p><p>编写privoder-ticket项目中的Application配置文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119155034.png"></p><pre><code>#项目的端口号server:  port: 8001#项目的名字spring:  application:    name: provider-ticket#配置eureka信息eureka:  instance:    prefer-ip-address: true # 注册服务到Eureka服务中心的时候，使用ip地址  client:    service-url:     # 是一个map结构      defaultZone: http://localhost:8761/eureka/  # 注册中心的地址</code></pre><p>启动privoder-ticket项目：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119155314.png"></p><p>在浏览器中输入：<code>http://localhost:8001/ticket</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119155415.png"></p><p>服务启动成功！</p><p>打开 <code>http://localhost:8761/</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119155524.png"></p><p>在Eureka服务注册中心中，发现了我们的注册的服务提供者：privoder-ticket。</p><p>以上就是，注册服务到服务中心中。</p><hr><p>一个项目，我们可以注册多个服务到服务中心中。</p><p>现在，停止我们的：privoder-ticket 项目。改用：java - jar 的方式来启动应用。</p><p>现在，将我们的项目打包成jar包：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119155930.png"></p><p>双击：package<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119160049.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119160213.png"></p><p>将target中的打包成功的jar包，保存到桌面的service文件夹中：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119160333.png"></p><p>将jar包的名字后面加上了8001，是为了区分。</p><hr><p>现在，将privoder-ticket 项目中的Application配置文件中的端口号，改为8002，然后打成jar包。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119160559.png"></p><p>然后，使用 java -jar 的形式来启动这两个jar包：</p><pre><code>java -jar privoder-ticket-0.0.1-SNAPSHOT-8001.jar和java -jar privoder-ticket-0.0.1-SNAPSHOT-8002.jar</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119160914.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119161158.png"></p><p><strong>注意：这里是开启两个windows的终端窗口！！！</strong></p><p>验证：</p><p>分别在浏览器中输入：<code>http://localhost:8001/ticket</code> 和 <code>http://localhost:8002/ticket</code></p><p>出现：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119161615.png"></p><p>而且在 <code>http://localhost:8761/</code> 中：</p><p>会发现，两个privoder-ticket服务。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119161750.png"></p><hr><h3 id="配置服务消费者模块："><a href="#配置服务消费者模块：" class="headerlink" title="配置服务消费者模块："></a>配置服务消费者模块：</h3><p>配置application文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119162326.png"></p><pre><code>#项目的端口号server:  port: 8200#项目的名字spring:  application:    name: consume-user#配置eureka信息eureka:  instance:    prefer-ip-address: true # 注册服务到Eureka服务中心的时候，使用ip地址  client:    service-url:     # 是一个map结构      defaultZone: http://localhost:8761/eureka/  # 注册中心的地址</code></pre><p>在启动类上，添加@EnableDiscoveryClient注解：开启发现服务的功能。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119162555.png"></p><p>因为Springcloud是用restful的形式来发现、调用服务的。 所以，我们需要注入一个RestTemplate类来操作发送http请求。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119162917.png"></p><p><strong>@LoadBalanced：发送http请求时，起到负载均衡的作用</strong></p><p>配置消费功能：</p><p>在controller包下，创建UserController类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119163401.png"></p><pre><code>@RestControllerpublic class UserController {    @Autowired    private RestTemplate restTemplate;    @GetMapping(&quot;/buy&quot;)    public String buyTicket(String name){        /**         * 第一个参数：http的请求地址：PROVIDER-TICKET 服务中心中的服务名字         * 第二个参数：返回值的类型         */        String ticket = restTemplate.getForObject(&quot;http://PROVIDER-TICKET/ticket&quot;, String.class);        return name+&quot;:购买了：ticket&quot;;    }}</code></pre><p>PROVIDER-TICKET: 是Eureka服务中心的服务的名字：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119163555.png"></p><p><code>http://PROVIDER-TICKET/ticket</code>   就是调用服务中心中PROVIDER-TICKET的项目，发送/ticket请求，就会获取电影票的功能。</p><p>启动consume-user项目：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119163858.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119163955.png"></p><p>在 <code>http://localhost:8761/</code> 中：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119164036.png"></p><hr><p>现在，在浏览器中输入：<code>http://localhost:8200/buy?name=zhangsan</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119164317.png"></p><p>成功：我们的 consume-user项目 通过http请求，调用Eureka服务中心中的 PROVIDER-TICKET 项目，获取到了《你的名字》的电影票。</p><p><strong>PS：我们的服务提供者还是负载均衡的，因为我们有两个PROVIDER-TICKET，加上@LoadBalanced</strong></p><p>刷新 <code>http://localhost:8200/buy?name=zhangsan</code> 页面 ：</p><p>服务中心，会帮我们轮询调用PROVIDER-TICKET服务，这里，我们没有在privoder-ticket项目中的TicketService方法中，添加输出语句，所以看不到效果。</p><p>不信的话，你添加输出语句就会看到效果了。</p><pre><code>@Servicepublic class TicketService {    public String ticketService(){        System.out.println(&quot;8001端口的privoder-ticket服务&quot;);        return &quot;《你的名字》&quot;;    }}和@Servicepublic class TicketService {    public String ticketService(){        System.out.println(&quot;8002端口的privoder-ticket服务&quot;);        return &quot;《你的名字》&quot;;    }}</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/dubbo/QQ截图20181119165751.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与安全</title>
      <link href="/2018/11/18/spring-boot-yu-an-quan/"/>
      <url>/2018/11/18/spring-boot-yu-an-quan/</url>
      
        <content type="html"><![CDATA[<p>安全、Spring Security. 比如身份认证，用户权限等，市面上有两大主流安全框架：第一个是Apache的 <strong>Shiro</strong>，第二个就是Spring的<strong>Security</strong>。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p><strong>Spring Security</strong>是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型。他可以实现强大的web安全控制。对于安全控制，我们仅需引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理。</p><p>几个类：</p><ul><li>WebSecurityConfigurerAdapter：自定义Security策略</li><li>AuthenticationManagerBuilder：自定义认证策略</li><li>@EnableWebSecurity：开启WebSecurity模式</li></ul><p>应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两个主要区域是Spring Security 的两个目标。</p><p>• “认证”（Authentication），是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统）。</p><p>• “授权”（Authorization）指确定一个主体是否允许在你的应用程序执行一个动作的过程。为了抵达需要授权的店，主体的身份已经有认证过程建立。</p><p>• 这个概念是通用的而不只在Spring Security中。</p><p>1) 创建新的Springboot项目，添加Web、Themleaf模块：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118110926.png"></p><p>2) 在resources中书写页面：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118111136.png"></p><p>3）书写一个java类：(KungfuController)<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118111658.png"></p><pre><code>@Controllerpublic class KungfuController {    private final String PREFIX = &quot;pages/&quot;;    /**     * 欢迎页     *     * @return     */    @GetMapping(&quot;/&quot;)    public String index() {        return &quot;welcome&quot;;    }    /**     * 登陆页     *     * @return     */    @GetMapping(&quot;/userlogin&quot;)    public String loginPage() {        return PREFIX + &quot;login&quot;;    }    /**     * level1页面映射     *     * @param path     * @return     */    @GetMapping(&quot;/level1/{path}&quot;)    public String level1(@PathVariable(&quot;path&quot;) String path) {        return PREFIX + &quot;level1/&quot; + path;    }    /**     * level2页面映射     *     * @param path     * @return     */    @GetMapping(&quot;/level2/{path}&quot;)    public String level2(@PathVariable(&quot;path&quot;) String path) {        return PREFIX + &quot;level2/&quot; + path;    }    /**     * level3页面映射     *     * @param path     * @return     */    @GetMapping(&quot;/level3/{path}&quot;)    public String level3(@PathVariable(&quot;path&quot;) String path) {        return PREFIX + &quot;level3/&quot; + path;    }}</code></pre><p>这里，大家可以有自己的页面，和controller类，只是简单的访问页面而已，没有什么业务逻辑。</p><p>4）启动Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118112006.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118112040.png"></p><p>这里是，thymeleaf的版本比较低。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118112604.png"></p><p>我们要切换成3版本以上的。切换thymeleaf的时候，不要忘记thymeleaf-layout的版本。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118113001.png"></p><p>5）重启Springboot应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118113131.png"></p><p>页面解析成功。</p><hr><p>上面，是没有使用Spring Security的功能，页面上的所有超链接都能访问。</p><h3 id="整合Spring-Security模块"><a href="#整合Spring-Security模块" class="headerlink" title="整合Spring Security模块"></a>整合Spring Security模块</h3><p>现在，我们加入Spring Security模块。</p><p>1）导入：spring-boot-starter-security<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118122302.png"></p><p>2）打开Spring的官网，找到Spring Security模块：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118122433.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118122802.png"></p><p><a href="https://docs.spring.io/spring-security/site/docs/4.2.8.RELEASE/guides/html5/helloworld-boot.html" target="_blank" rel="noopener">官方参考文档</a></p><p>说明，第一步，我们需要写一个Spring Security的配置类，标记@EnableWebSecurity注解，并且继承 WebSecurityConfigurerAdapter</p><p>在我们的项目中，添加config包，并创建MySecurityConfig类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118140618.png"></p><pre><code>@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter {    //设置访问权限的    @Override    protected void configure(HttpSecurity http) throws Exception {        //super.configure(http);        http.authorizeRequests().mvcMatchers(&quot;/&quot;).permitAll()                .mvcMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;)                .mvcMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;)                .mvcMatchers(&quot;/level3/**&quot;).hasRole(&quot;VIP3&quot;);    }}</code></pre><p>以上的方法的，就是访问”/“: 所有的人都可以访问，而访问”/level1/**”下的请求，必须是”VIP1”用户，其他类似。</p><p>现在重启Springboot应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118140836.png"></p><p>访问普通武功秘籍下的超链接：罗汉拳、武当长拳、全真剑法其中的任意一个。</p><p><strong>PS：普通武功秘籍是level1，高级武功秘籍是level2，绝世武功秘籍是level3</strong></p><p>比如访问：罗汉拳(/level1/1)<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118141225.png"></p><p>现在出现了，403：拒绝访问，即没有访问权限！</p><p>接下来，我们配置授权的用户：</p><p>修改configure方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118141803.png"></p><p>此时重启，访问罗汉拳的话，会重定向到/login请求，请求登入：(Spring Security 自动帮我们配合的)<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118141855.png"></p><p>此时，还没有配置用户信息，在MySecurityConfig类：添加新的方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118142152.png"></p><pre><code>    @Autowired    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {        auth.inMemoryAuthentication()                .withUser(&quot;zhangsan&quot;).password(&quot;123456&quot;).roles(&quot;VIP1&quot;,&quot;VIP2&quot;)                .and()                .withUser(&quot;lisi&quot;).password(&quot;123456&quot;).roles(&quot;VIP2&quot;,&quot;VIP3&quot;)                .and()                .withUser(&quot;wangwu&quot;).password(&quot;123456&quot;).roles(&quot;VIP1&quot;,&quot;VIP3&quot;);    }</code></pre><p><strong>注意：</strong>使用inMemoryAuthentication：是在内存中配合用户的信息，这里是简单起见，我们一般需要将配置保存到数据库中。</p><p>这里，配置了用户名：zhangsan，密码：123456，用户的角色是:VIP1,VIP2. 其他类似。</p><p>重启应用，访问罗汉拳：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118142453.png"><br>登入用户和密码：zhangsan，123456<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118142545.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118142639.png"><br>访问成功，有level1的权限。</p><p>点击返回，访问<strong>普通武功秘籍</strong> 和 <strong>高级武功秘籍</strong> 下的，<strong>其他秘籍</strong>，此时都不会被拦截了。</p><p>因为张三用户，有level1 和 level2 的访问权限。如果访问 <strong>绝世武功秘籍(level3)</strong>，就会出现403.</p><h3 id="注销登入"><a href="#注销登入" class="headerlink" title="注销登入"></a>注销登入</h3><p>现在，我们只能登入用户，还不能注销，怎么注销用户呢？</p><p>1）修改MySecurityConfig的：configure(HttpSecurity http)<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118144712.png"></p><pre><code>    //设置访问权限的    @Override    protected void configure(HttpSecurity http) throws Exception {        //super.configure(http);        http.authorizeRequests().mvcMatchers(&quot;/&quot;).permitAll()                .mvcMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;)                .mvcMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;)                .mvcMatchers(&quot;/level3/**&quot;).hasRole(&quot;VIP3&quot;)                .and()                //自动配置了授权的,当没有权限的时候，会让你登入                //自动重定向到/login请求，请求登陆。                .formLogin();        //自动帮我们注销登入。        //1.需要在页面发一个/logout的post请求        //2.注销成功后，会重定向到：login?logout，会让你重新登入。        http.logout();    }</code></pre><p>2）在welcome页面中，添加注销的按钮：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118144334.png"></p><p>3）启动程序</p><p>先登入用户成功，访问能访问的权限，都可以！然后点击注销按钮：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118144520.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118144648.png"></p><p>注销成功。</p><p>如果，我们不想让注销成功后，返回登入页面呢？那可以修改配置：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118144937.png"></p><p>此时，注销成功后会跳转到主页了。</p><h3 id="完成我们的security模块"><a href="#完成我们的security模块" class="headerlink" title="完成我们的security模块"></a>完成我们的security模块</h3><p>现在，我们想让登入成功后，显示XX登入成功，给他看见能够访问的页面信息，不能访问的就不显示出来。</p><p>1）这里我们需要thymeleaf提供的安全的标签功能，需要导入相关的模块：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118150104.png"></p><p>2）在我们的welcome页面中。添加安全的命名空间：</p><pre><code>xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity4&quot;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118150442.png"></p><p>接下来：我们就可以使用 sec 前缀的标签了。</p><p>给 登入 和 注销 添加 div 然后判断是否有权限：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118150837.png"></p><p>给三大武功秘籍，添加用户权限：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118151321.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118151330.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118151342.png"></p><p>重启应用：</p><p>观察我们的应用效果！</p><h3 id="记住我"><a href="#记住我" class="headerlink" title="记住我"></a>记住我</h3><p>只要在：MySecurityConfig 类中的：configure(HttpSecurity http)方法中：</p><pre><code>http.rememberMe();</code></pre><p>这样的话，spring Security就会记住密码，下次不需要登入，直接进入。原理就是发了一个remember-me的cookie而已。</p><hr><p>如果，想要修改登入界面，使用我们自己定义的登入页面：</p><pre><code>http.formLogin().loginPage(&quot;/userlogin&quot;);</code></pre><p>这样的话，就是发送这个/userlogin请求，跳转到我们自定义的页面，然后：使用 post请求的：/userlogin来登入。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118164447.png"></p><p>这里的 用户名 和 密码的 name属性怎么设置呢？</p><p>使用：usernameParameter 和 passwordParameter 来修改。</p><p>默认是：username 和 password</p><p>即：不配置的话<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118164712.png"></p><p>配置的话：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118164847.png"></p><pre><code>        //自动配置了授权的,当没有权限的时候，会让你登入        //自动重定向到/login请求，请求登陆。        http.formLogin().loginPage(&quot;/userlogin&quot;)                        .usernameParameter(&quot;uName&quot;)                        .passwordParameter(&quot;pName&quot;);</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/security/QQ截图20181118164936.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与任务</title>
      <link href="/2018/11/17/spring-boot-yu-ren-wu/"/>
      <url>/2018/11/17/spring-boot-yu-ren-wu/</url>
      
        <content type="html"><![CDATA[<p>异步任务、定时任务、邮件任务</p><h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>异步任务，是Spring帮我们开启线程池，创建一个新的线程来执行我们的方法，就不会有卡顿的现象。</p><p>在Java应用中，绝大多数情况下都是通过同步的方式来实现交互处理的；但是在处理与第三方系统交互的时候，容易造成响应迟缓的情况，之前大部分都是使用多线程来完成此类任务，其实，在Spring 3.x之后，就已经内置了@Async来完美解决这个问题。</p><p><font color="red"><strong>两个注解：</strong></font><br>@EnableAysnc、@Aysnc</p><p>1）创建Springboot项目，添加Web模块。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117105809.png"></p><p>2) 创建service、controller模块<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117110232.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117110258.png"></p><p>3）启动Springboot应用</p><p>在浏览器中输入：<code>http://localhost:8080/async</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117110457.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117110539.png"></p><p>4) 修改成异步执行</p><p>添加@Async注解：表示是异步方法。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117110723.png"></p><p>在启动类上，添加@EnableAsync注解<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117110835.png"></p><p>5）重启应用</p><p>在浏览器中输入：<code>http://localhost:8080/async</code></p><p>会发现，页面会瞬速响应，而控制台的执行任务的输出会停顿三秒。起到了异步的效果！</p><hr><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>项目开发中经常需要执行一些定时任务，比如需要在每天凌晨时候，分析一次前一天的日志信息。Spring为我们提供了异步执行任务调度的方式，提供<strong>TaskExecutor 、TaskScheduler 接口</strong>。</p><p><font color="red"><strong>两个注解</strong>：</font><strong>@EnableScheduling、@Scheduled</strong></p><p><strong>cron表达式：</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117111444.png" style="width:50%"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117111511.png" style="width:50%"></p><p>1）在service包：创建ScheduledService：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117113534.png"></p><pre><code>@Servicepublic class ScheduledService {    /**     * second(秒) , minute(分), hour(时), day of month(日), month(月) , day of week.(周几)     * 例子：[0 * * * * MON-SAT]:代表每月，每日，每时，每分每秒的周一到周六的0秒执行     */    @Scheduled(cron =&quot;0 * * * * MON-SAT&quot;)    public void hello(){        System.out.println(&quot;hello ···&quot;);    }}</code></pre><p>2）在启动类上，添加@EnableScheduling：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117113223.png"></p><p>3）启动应用<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117113757.png"></p><p>更多写法：参考上面的<strong>cron表达式</strong></p><pre><code>,(逗号)：枚举的意思，[0,1,2,3,4 * * * * *]:就是0、1、2、3、4秒执行一次-(减号):区间的意思，[0-4 * * * * *] : 和上面的意思一样/(斜杆):步长的意思，[0/4 * * * * *]:就是0秒开始执行，每隔4秒执行一次当每日与周几冲突时，请使用 ？代替 *。</code></pre><p>案例：</p><pre><code>[0 0/5 14,18 * * ?]:每天14整点，和18整点，每隔5分钟执行一次。[0 15 10 ? * 1-6]: 每个月的周一到周六10:15:00执行一次[0 0 2 ？* 6L]:每个月的最后一个周六凌晨两点执行一次[0 0 2 LW * ?]:每个月的最后一个工作日凌晨两点执行一次[0 0 2-4 ? * 1#1]:每一个月的第一个周一凌晨2点到4点期间，每个整点，整秒执行一次。（ps：1#4 就是每个月的第四个周一）</code></pre><hr><h2 id="邮件任务"><a href="#邮件任务" class="headerlink" title="邮件任务"></a>邮件任务</h2><p>• 邮件发送需要引入spring-boot-starter-mail<br>• Spring Boot 自动配置MailSenderAutoConfiguration<br>• 定义MailProperties内容，配置在application.yml中<br>• 自动装配JavaMailSender<br>• 测试邮件发送</p><p>接下来，我们演示：使用QQ邮箱给163邮箱发送邮件的案例</p><p>1）导入spring-boot-starter-mail依赖：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117120605.png"></p><p>2）配置邮件的信息：</p><p>spring.mail.username：设置发送者的邮箱的用户名</p><p>spring.mail.password：不是登入邮箱的密码，而是你的邮箱的服务器的生成的密码。</p><p>如果使用的是qq邮箱的话，打开qq邮箱，点击设置：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117121032.png"></p><p>然后点击<strong>账号</strong>，找到POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117121208.png"></p><p>将POP3/SMTP服务开启，点击开启：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117121406.png"></p><p>发送短信：点击我已发送：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117121551.png"></p><p>看到下面的密码了，就是你的设置密码了。</p><p>spring.mail.password=eaqltjcbbababcje</p><p>spring.mail.host：配置的是你的邮箱服务器的SMTP地址<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117121909.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117121941.png"></p><p>spring.mail.host=smtp.qq.com</p><p>完整的application配置文件内容：</p><pre><code>#qq邮箱的用户名spring.mail.username=575920824@qq.com#你的服务器生成的POP3安全密码spring.mail.password=eaqltjcbbababcje#配置的是你的邮箱服务器的SMTPspring.mail.host=smtp.qq.com</code></pre><p>3) 在测试类下，编写发送邮件的测试方法<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117123107.png"></p><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot04TaskApplicationTests {    @Autowired    private JavaMailSenderImpl javaMailSender;    @Test    public void sendSimpleMail(){        SimpleMailMessage mailMessage = new SimpleMailMessage();        //设置主题        mailMessage.setSubject(&quot;今天下午7点到9点开会&quot;);        //设置正文        mailMessage.setText(&quot;关于XXX的会议&quot;);        //设置接受者：你的163邮箱的账号        mailMessage.setTo(&quot;18896991176@163.com&quot;);        //设置发送者        mailMessage.setFrom(&quot;575920824@qq.com&quot;);        javaMailSender.send(mailMessage);    }}</code></pre><p>4) 测试运行：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117123236.png"></p><p>发送成功：如果你的出现异常，请在application配置文件中：</p><p>添加：spring.mail.properties.mail.smtp.sst.enable=true</p><p>打开你的163邮箱：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117123535.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117123558.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117123648.png"></p><p>以上就是发送简单邮箱的方法，现在我们来发送复杂邮件，携带附件的邮箱：</p><pre><code>    @Test    public void sendMail() throws Exception{        //创建复杂邮件        MimeMessage mimeMessage = javaMailSender.createMimeMessage();         //new一个复杂邮件的工具类        //第二个参数：true，表示发送附件的邮箱        MimeMessageHelper message = new MimeMessageHelper(mimeMessage,true);        //设置主题        message.setSubject(&quot;今天下午7点到9点开会&quot;);        //设置正文,第二个参数：表示发送的是html的文本        message.setText(&quot;&lt;b style=&#39;color:red&#39;&gt;关于XXX的会议&lt;/b&gt;&quot;,true);        //设置接受者        message.setTo(&quot;18896991176@163.com&quot;);        //设置发送者        message.setFrom(&quot;575920824@qq.com&quot;);        //上传附件        message.addAttachment(&quot;1.jpg&quot;,new File(&quot;C:\\Users\\liuzhuo\\Pictures\\Saved Pictures\\123.jpg&quot;));        message.addAttachment(&quot;2.jpg&quot;,new File(&quot;C:\\Users\\liuzhuo\\Pictures\\Saved Pictures\\gakki.jpg&quot;));        //发送邮件        javaMailSender.send(mimeMessage);    }</code></pre><p>测试：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117125016.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117125041.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/renwu/QQ截图20181117125238.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与检索</title>
      <link href="/2018/11/16/spring-boot-yu-jian-suo/"/>
      <url>/2018/11/16/spring-boot-yu-jian-suo/</url>
      
        <content type="html"><![CDATA[<p>ElasticSearch</p><h2 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h2><p>我们的应用经常需要添加检索功能，开源的 ElasticSearch 是目前全文搜索引擎的首选。他可以快速的存储、搜索和分析海量数据。Spring Boot通过整合SpringData ElasticSearch为我们提供了非常便捷的检索功能支持；</p><p>Elasticsearch是一个分布式搜索服务，提供Restful API，底层基于Lucene，采用多shard（分片）的方式保证数据安全，并且提供自动resharding的功能，github等大型的站点也是采用了ElasticSearch作为其搜索服务。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>以 <font color="red"><strong>员工文档</strong></font> 的形式存储为例：一个<font color="red"><strong>文档</strong></font>代表一个员工数据。存储数据到ElasticSearch 的行为叫做 <font color="red"><strong>索引</strong></font> ，但在索引一个文档之前，需要确定将文档存储在哪里。</p><p>一个 ElasticSearch 集群可以 包含多个 <font color="red"><strong>索引</strong></font> ，相应的每个索引可以包含多个 <font color="red"><strong>类型</strong></font> 。 这些不同的类型存储着多个 <font color="red"><strong>文档</strong> </font>，每个文档又有 多个 <font color="red"><strong>属性</strong> </font></p><p>类似关系：<br>– 索引-数据库<br>– 类型-表<br>– 文档-表中的记录<br>– 属性-列</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116154034.png"></p><p>打开官网 <a href="https://www.elastic.co/cn/products/elasticsearch" target="_blank" rel="noopener">ElasticSearch</a><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116155202.png"></p><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener">《Elasticsearch: 权威指南》中文版</a></p><h2 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h2><p>打开我们的虚拟机，下载ElasticSearch镜像</p><pre><code>docker pull registry.docker-cn.com/library/elasticsearch</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116161527.png"></p><p>elasticsearch:默认是使用2g的堆内存，直接启动的话，我们的虚拟机有可能不够，所以，我们需要设置elasticsearch的堆内存的大小：</p><p>使用 -e ES_JAVA_OPTS=”-Xms256m -Xmx256m” 来设置堆的最大、最小都是256兆。</p><p>完整的启动命令：<br>elasticsearch的默认端口号是9200，和分布式的节点之间通信的端口号：9300</p><pre><code>docker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -d -p 9200:9200 -p 9300:9300 --name ESO1 elasticsearch的镜像id</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116161744.png"></p><p>打开浏览器，输入：<code>http://10.6.11.17:9200/</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116162123.png"></p><p>以上，说明ElasticSearch启动成功！</p><hr><h2 id="ElasticSearch简单操作"><a href="#ElasticSearch简单操作" class="headerlink" title="ElasticSearch简单操作"></a>ElasticSearch简单操作</h2><p>ElasticSearch：使用 RESTful API 通过端口 9200 进行通信，使用 JavaScript Object Notation 或者 JSON 作为文档的序列化格式。</p><p>考虑一下这个 JSON 文档，它代表了一个 user 对象：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116162822.png"></p><hr><p>打开我们的postman工具<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116162539.png"></p><p>在Elasticsearch: 权威指南的基础入门中：适应新环境</p><p>例子为：创建一个雇员目录<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116163020.png"></p><p>对于雇员目录，我们将做如下操作：</p><ul><li><p>每个雇员索引一个文档，包含该雇员的所有信息。</p></li><li><p>每个文档都将是 employee 类型 。</p></li><li><p>该类型位于 索引 megacorp 内。</p></li><li><p>该索引保存在我们的 Elasticsearch 集群中。</p></li></ul><p>实践中这非常简单（尽管看起来有很多步骤），我们可以通过一条命令完成所有这些动作：</p><h3 id="创建雇员信息"><a href="#创建雇员信息" class="headerlink" title="创建雇员信息"></a>创建雇员信息</h3><p>在postman中：输入 <code>10.6.11.17:9200/megacorp/employee/1</code></p><p>选择：PUT请求 –&gt; Body –&gt; raw –&gt; JSON:</p><pre><code>{    &quot;first_name&quot; : &quot;John&quot;,    &quot;last_name&quot; :  &quot;Smith&quot;,    &quot;age&quot; :        25,    &quot;about&quot; :      &quot;I love to go rock climbing&quot;,    &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]}</code></pre><p>点击Send发送：<br>响应数据：</p><pre><code>{    &quot;_index&quot;: &quot;megacorp&quot;,    &quot;_type&quot;: &quot;employee&quot;,    &quot;_id&quot;: &quot;1&quot;,    &quot;_version&quot;: 1,    &quot;result&quot;: &quot;created&quot;,    &quot;_shards&quot;: {        &quot;total&quot;: 2,        &quot;successful&quot;: 1,        &quot;failed&quot;: 0    },    &quot;created&quot;: true}</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116163804.png"></p><p>以上：我们就插入数据成功了。</p><p>注意，路径 /megacorp/employee/1 包含了三部分的信息：</p><p>megacorp：索引名称</p><p>employee：类型名称</p><p>1：特定雇员的ID</p><p>请求体 —— JSON 文档 —— 包含了这位员工的所有详细信息，他的名字叫 John Smith ，今年 25 岁，喜欢攀岩。</p><p>很简单！无需进行执行管理任务，如创建一个索引或指定每个属性的数据类型之类的，可以直接只索引一个文档。Elasticsearch 默认地完成其他一切，因此所有必需的管理任务都在后台使用默认设置完成。</p><p>进行下一步前，让我们增加更多的员工信息到目录中：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116164222.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116164537.png"></p><hr><h3 id="简单检索"><a href="#简单检索" class="headerlink" title="简单检索"></a>简单检索</h3><p>目前我们已经在 Elasticsearch 中存储了一些数据， 接下来就能专注于实现应用的业务需求了。第一个需求是可以检索到单个雇员的数据。</p><p>这在 Elasticsearch 中很简单。简单地执行 一个 HTTP GET 请求并指定文档的地址——索引库、类型和ID。 使用这三个信息可以返回原始的 JSON 文档：</p><p>GET /megacorp/employee/1<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116164722.png"></p><p>返回结果包含了文档的一些元数据，以及 _source 属性，内容是 John Smith 雇员的原始 JSON 文档：</p><pre><code>{  &quot;_index&quot; :   &quot;megacorp&quot;,  &quot;_type&quot; :    &quot;employee&quot;,  &quot;_id&quot; :      &quot;1&quot;,  &quot;_version&quot; : 1,  &quot;found&quot; :    true,  &quot;_source&quot; :  {      &quot;first_name&quot; :  &quot;John&quot;,      &quot;last_name&quot; :   &quot;Smith&quot;,      &quot;age&quot; :         25,      &quot;about&quot; :       &quot;I love to go rock climbing&quot;,      &quot;interests&quot;:  [ &quot;sports&quot;, &quot;music&quot; ]  }}</code></pre><p><strong>PS:将 HTTP 命令由 PUT 改为 GET 可以用来检索文档，同样的，可以使用 DELETE 命令来删除文档，以及使用 HEAD 指令来检查文档是否存在。如果想更新已存在的文档，只需再次 PUT 。</strong></p><h3 id="轻量检索"><a href="#轻量检索" class="headerlink" title="轻量检索"></a>轻量检索</h3><p>一个 GET 是相当简单的，可以直接得到指定的文档。 现在尝试点儿稍微高级的功能，比如一个简单的搜索！</p><p>第一个尝试的几乎是最简单的搜索了。我们使用下列请求来搜索所有雇员：</p><p>GET /megacorp/employee/_search</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116165326.png"></p><p>可以看到，我们仍然使用索引库 megacorp 以及类型 employee，但与指定一个文档 ID 不同，这次使用 _search 。返回结果包括了所有三个文档，放在数组 hits 中。一个搜索默认返回十条结果。</p><p>注意：返回结果不仅告知匹配了哪些文档，还包含了整个文档本身：显示搜索结果给最终用户所需的全部信息。</p><p>接下来，尝试下搜索姓氏为 <code>Smith</code> 的雇员。为此，我们将使用一个 高亮 搜索，很容易通过命令行完成。这个方法一般涉及到一个 查询字符串 （<em>query-string</em>） 搜索，因为我们通过一个URL参数来传递查询信息给搜索接口：</p><p>GET /megacorp/employee/_search?q=last_name:Smith</p><p>我们仍然在请求路径中使用 _search 端点，并将查询本身赋值给参数 q= 。返回结果给出了所有的 Smith：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116165612.png"></p><hr><h3 id="使用查询表达式搜索"><a href="#使用查询表达式搜索" class="headerlink" title="使用查询表达式搜索"></a>使用查询表达式搜索</h3><p>Query-string 搜索通过命令非常方便地进行临时性的即席搜索 ，但它有自身的局限性（参见 轻量 搜索 ）。Elasticsearch 提供一个丰富灵活的查询语言叫做 查询表达式 ， 它支持构建更加复杂和健壮的查询。</p><p>领域特定语言 （DSL）， 指定了使用一个 JSON 请求。我们可以像这样重写之前的查询所有 Smith 的搜索 </p><pre><code>GET /megacorp/employee/_search{    &quot;query&quot; : {        &quot;match&quot; : {            &quot;last_name&quot; : &quot;Smith&quot;        }    }}</code></pre><p>因为 GET请求，无法带这样格式的json请求参数，所以我们使用POST请求即可：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116170032.png"></p><p>返回结果与之前的查询一样，但还是可以看到有一些变化。其中之一是，不再使用 query-string 参数，而是一个请求体替代。这个请求使用 JSON 构造，并使用了一个 match 查询（属于查询类型之一，后续将会了解）。</p><p><strong>更多的查询操作，请看ElasticSearch的官方文档即可</strong>：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a></p><h2 id="整合Springboot与ElasticSearch"><a href="#整合Springboot与ElasticSearch" class="headerlink" title="整合Springboot与ElasticSearch"></a>整合Springboot与ElasticSearch</h2><p>1）创建Springboot的项目，添加web、ElasticSearch模块：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116170704.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116170735.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116172604.png"></p><p>2）在autoconfig包下：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116172848.png" style="width:50%"></p><p>发现有两处ElasticSearch：</p><ol><li><p>data包下，有一个ElasticSearch</p></li><li><p>直接在ElasticSearch包，有一个jest包</p></li></ol><p>即：Springboot提供了两种方式来使用ElasticSearch。</p><p>data包下的ElasticSearch是Springboot默认提供的。 </p><p>jest默认不支持的，需要jest的工具包(io.searchbox.client.JestClient)</p><h3 id="使用jest"><a href="#使用jest" class="headerlink" title="使用jest"></a>使用jest</h3><p>1）注释掉:spring-boot-starter-data-elasticsearch</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>添加jest的依赖包：<br>在mave中央仓库：搜索：jest<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116173628.png"></p><p>因为我的ElasticSearch的版本是：5.6.12<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116173725.png"></p><p>所以，jest的版本选择5.x.x的即可：</p><pre><code>&lt;!-- https://mvnrepository.com/artifact/io.searchbox/jest --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.searchbox&lt;/groupId&gt;    &lt;artifactId&gt;jest&lt;/artifactId&gt;    &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116173907.png"></p><p>2) 打开：JestAutoConfiguration类<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116174005.png"></p><p>导入了一个：jestClient类</p><pre><code>    @Bean(destroyMethod = &quot;shutdownClient&quot;)    @ConditionalOnMissingBean    public JestClient jestClient() {        JestClientFactory factory = new JestClientFactory();        factory.setHttpClientConfig(createHttpClientConfig());        return factory.getObject();    }</code></pre><p>3）给application配置文件中，添加ElasticSearch的相关配置：</p><p>查看JestProperties类，了解需要配置哪些信息：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116174251.png"></p><p>application：</p><pre><code>#ElasticSearch的相关配置spring.elasticsearch.jest.uris=http://10.6.11.17:9200  #虚拟机的ip地址</code></pre><p>4) 启动Springboot应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116174615.png"></p><p>5）在测试类中测试：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116174851.png"></p><p>6）编写一个POJO类：</p><p>在bean包，创建一个Article类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116175201.png"></p><pre><code>public class Article {    //标记id为ElasticSearch中的id    @JestId    private Integer id;    private String author;    private String title;    private String content;    set 和 get 方法}</code></pre><p>7）创建一个测试方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116175854.png"></p><pre><code>    @Test    public void testInsert(){        Article article = new Article();        article.setId(1);        article.setAuthor(&quot;zhangsan&quot;);        article.setTitle(&quot;好消息&quot;);        article.setContent(&quot;Hello world!&quot;);        //创建一个：索引：liuzhuo , 类型：news ,id：使用了@JestId标记了id，这里可以不用设置了        Index index = new Index.Builder(article).index(&quot;liuzhuo&quot;).type(&quot;news&quot;).build();        try {            //执行            jestClient.execute(index);        } catch (IOException e) {            e.printStackTrace();        }    }</code></pre><p>执行testInsert()方法后：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116184113.png"></p><p>在浏览器中，输入：<code>http://10.6.11.17:9200/liuzhuo/news/1</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116184216.png"></p><p>插入数据成功！</p><hr><p>现在，测试搜索功能：</p><p>使用：搜索content内容为：hello</p><pre><code>{    &quot;query&quot; : {        &quot;match&quot; : {            &quot;content&quot; : &quot;hello&quot;        }    }}</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116185001.png"></p><pre><code>    @Test    public void search(){        String json =&quot;{\n&quot; +                &quot;    \&quot;query\&quot; : {\n&quot; +                &quot;        \&quot;match\&quot; : {\n&quot; +                &quot;            \&quot;content\&quot; : \&quot;hello\&quot;\n&quot; +                &quot;        }\n&quot; +                &quot;    }\n&quot; +                &quot;}&quot;;        //构建搜索功能        Search search = new Search.Builder(json).addIndex(&quot;liuzhuo&quot;).addType(&quot;news&quot;).build();        try {            SearchResult result = jestClient.execute(search);            System.out.println(result.getJsonString());        } catch (IOException e) {            e.printStackTrace();        }    }</code></pre><p>运行测试：search()方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116185155.png"></p><p>更多：jest的操作，可以看jest的文档。</p><p>打开github的官网，搜索 jest<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116185510.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116185604.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116185712.png"></p><h3 id="使用SpringData"><a href="#使用SpringData" class="headerlink" title="使用SpringData"></a>使用SpringData</h3><p>1）在pom文件中：放开spring-boot-starter-data-elasticsearch的注释</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>打开：ElasticsearchAutoConfiguration类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116190656.png"></p><p>再看：ElasticsearchDataAutoConfiguration类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116190900.png"></p><p>导入了一个：ElasticsearchTemplate 来操作ElasticSearch的模板类</p><p>使用：ElasticsearchProperties 来配置相关信息：</p><p>Client：节点的信息 clusterName：名字，clusterNodes：操作的节点ip地址</p><p>编写了一个ElasticSearchRepository的子接口来操作ES。</p><p>2）在application配置文件中：添加SpringData的ES信息<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116195934.png"></p><pre><code>#使用SprigData的ES配置信息spring.data.elasticsearch.cluster-name=elasticsearch #默认也elasticsearch#使用9300端口通信，与jest不同！！！spring.data.elasticsearch.cluster-nodes=10.6.11.17:9300</code></pre><p>spring.data.elasticsearch.cluster-name:怎么确定的呢？</p><p>在浏览器中输入：<code>http://10.6.11.17:9200/</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116191639.png"></p><p>3) 启动Springboot应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116200034.png"></p><p>出现了异常！！！异常错误，连接超时！！！</p><p>why？ 这是因为我们的ElasticSearch是5.6.12，而导入的SpringData的ElasticSearch依赖是2.4.6<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116192036.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116192001.png" style="width:50%"></p><p>版本不一致产生的异常。</p><p>怎样确定 SpringData-ElasticSearch 与 ElasticSearch 的版本对应关系呢？</p><p>打开Spring的官网，找到Spring data模块<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116193409.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116193435.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116193714.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116193935.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116194020.png"></p><p>所以，现在有两种方案：</p><p>1）升级Springboot的版本，将Springboot升级到3.0.x以后。</p><p>2）下载2.x.x的ElasticSearc</p><p>我这里选择下载第二种方案：</p><p>打开docker的hub仓库，搜索ElasticSearch<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116194312.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116194414.png"></p><p>打开虚拟机的客户端：</p><p>输入：</p><pre><code>docker pull registry.docker-cn.com/library/elasticsearch:2.4.6</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116194702.png"></p><p>启动 2.4.6 版本的ElasticSearch。</p><p>因为 9200 和 9300 的docker端口号已经被 5版本的ElasticSearch占领了，所以选择 9201 和 9301端口号</p><pre><code>docker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -d -p 9201:9200 -p 9301:9300 --name ESO2 elasticsearch的镜像id</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116195123.png"></p><p>在浏览器中输入：<code>http://10.6.11.17:9201/</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116195248.png"></p><p>以上，2.4.6 的ElasticSearch启动成功。</p><p>4）修改application配置文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116200335.png"></p><pre><code>#ElasticSearch的相关配置spring.elasticsearch.jest.uris=http://10.6.11.17:9200#使用SprigData的ES配置信息spring.data.elasticsearch.cluster-name=elasticsearch#使用9300端口通信，与jest不同！！！spring.data.elasticsearch.cluster-nodes=10.6.11.17:9301</code></pre><p>5）启动Springboot应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116200556.png"></p><p>两种使用ElasticSearch的配置，都启动成功了。现在我们只使用SpringData操作ElasticSearch的方式。</p><p>SpringData：提供了两种方式来操作ElasticSearc：</p><p>1）使用 ElasticsearchRepository</p><p>2）使用 ElasticsearchTemplate</p><hr><p>6）使用 ElasticsearchRepository</p><p>在bean包下，创建Book类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116200928.png"></p><p>在repository包下，创建bookRepository接口，继承ElasticsearchRepository：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116201218.png"></p><p>在test类下，注入bookRepository<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116201453.png"></p><p>但是，发现index方法，没法设置 索引，类型，id。其实我们需要在Book类上，添加@Document注解，来设置索引和类型</p><pre><code>@Document(indexName = &quot;liuzhuo&quot;,type = &quot;book&quot;)public class Book {</code></pre><p>启动测试方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116201909.png"></p><p>在浏览器中输入：<code>http://10.6.11.17:9201/liuzhuo/book/_search</code> 查询索引是liuzhuo，类型是book的所有数据：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116202042.png"></p><p>修改测试方法：</p><pre><code>    @Test    public void test() {        Book book = new Book();        book.setId(1);        book.setBookName(&quot;西游记&quot;);        book.setAuthor(&quot;罗贯中&quot;);        bookRepository.index(book);    }</code></pre><p>运行测试方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116202244.png"></p><p>我们还有可以直接在BookRepository接口中，编写接口，就和JPA一样：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116202524.png"></p><pre><code>//泛型上面的参数：查找的类型 和 id的类型public interface BookRepository extends ElasticsearchRepository&lt;Book,Integer&gt; {    //根据book的名字来模糊匹配所有的book    public List&lt;Book&gt; findByBookNameLike(String bookName);}</code></pre><pre><code>    @Test    public void searchBook(){        List&lt;Book&gt; bookList = bookRepository.findByBookNameLike(&quot;游&quot;);        for (Book book : bookList) {            System.out.println(book);        }    }</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116202952.png"></p><p>更多用法：请看官方文档：<a href="https://docs.spring.io/spring-data/elasticsearch/docs/2.1.16.RELEASE/reference/html/" target="_blank" rel="noopener">https://docs.spring.io/spring-data/elasticsearch/docs/2.1.16.RELEASE/reference/html/</a><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116203116.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/search/QQ截图20181116203245.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 检索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与消息</title>
      <link href="/2018/11/15/spring-boot-yu-xiao-xi/"/>
      <url>/2018/11/15/spring-boot-yu-xiao-xi/</url>
      
        <content type="html"><![CDATA[<p>JMS、AMQP、RabbitMQ的消息处理机制</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>1）大多应用中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力</p><p>2）消息服务中两个重要概念：<font color="red">消息代理（message broker）</font> 和 <font color="red">目的地（destination）</font></p><p>　 当消息发送者发送消息以后，将由消息代理接管，消息代理保存消息并且传递消息到指定目的地。</p><p>3）消息队列主要有两种形式的目的地</p><p>　　1）<font color="red">队列</font>：点对点消息通信（point-to-point）<br>　　2）<font color="red">主题</font>：发布（publish）/订阅（subscribe）消息通信</p><p>4）点对点式</p><p>　　消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列<br>　　<strong>消息只有唯一的发送者和接受者，但并不是说只能有一个接收者。</strong></p><p>5）发布订阅式</p><p>　　发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息。</p><p>6）JMS（Java Message Service）JAVA消息服务</p><p>　　基于JVM消息代理的规范。<strong>ActiveMQ</strong>、HornetMQ是JMS实现。</p><p>7）AMQP（Advanced Message Queuing Protocol）</p><p>　　高级消息队列协议，也是一个消息代理的规范，兼容JMS。<strong>RabbitMQ</strong>是AMQP的实现。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115131013.png"></p><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115131131.png"></p><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115131347.png"></p><h2 id="JMS与AMQP的区别"><a href="#JMS与AMQP的区别" class="headerlink" title="JMS与AMQP的区别"></a>JMS与AMQP的区别</h2><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115131921.png"></p><p>主要区别：JMS是基于javaEE规范的，所以不跨语言，不跨平台，如果你的系统都是基于java开发的，那么使用JMS没有问题。<br>AMQP：跨语言，跨平台。</p><hr><h2 id="Spring支持消息服务"><a href="#Spring支持消息服务" class="headerlink" title="Spring支持消息服务"></a>Spring支持消息服务</h2><p>　　spring-jms提供了对JMS的支持</p><p>　　spring-rabbit提供了对AMQP的支持</p><p>　　需要ConnectionFactory的实现来连接消息代理</p><p>　　<strong>提供JmsTemplate、RabbitTemplate来发送消息</strong></p><p>　　<strong>@JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息</strong></p><p>　　<strong>@EnableJms、@EnableRabbit开启支持</strong></p><h2 id="Springboot自动配置消息服务"><a href="#Springboot自动配置消息服务" class="headerlink" title="Springboot自动配置消息服务"></a>Springboot自动配置消息服务</h2><p>　　<strong>JmsAutoConfiguration</strong></p><p>　　<strong>RabbitAutoConfiguration</strong></p><h2 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h2><p><strong>RabbitMQ简介：</strong></p><p>RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。</p><p><strong>核心概念</strong></p><p><font color="blue">Message：</font><br>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><p><font color="blue">Publisher:</font><br>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p><p><font color="blue">Exchange:</font><br>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别.</p><p><font color="blue">Queue：</font><br>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><p><font color="blue">Binding：</font><br>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由。Exchange 和Queue的绑定可以是多对多的关系。</p><p><font color="blue">Connection：</font><br>网络连接，比如一个TCP连接。</p><p><font color="blue">Channel：</font><br>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><p><font color="blue">Consumer：</font><br>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><p><font color="blue">Virtual Host：</font><br>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><p><font color="blue">Broker：</font><br>表示消息队列服务器实体。</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115133357.png"></p><h2 id="RabbitMQ运行机制"><a href="#RabbitMQ运行机制" class="headerlink" title="RabbitMQ运行机制"></a>RabbitMQ运行机制</h2><p>AMQP 中的消息路由：</p><p>　　AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了<strong>Exchange</strong> 和 <strong>Binding</strong> 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115135917.png"></p><p>Exchange 类型：</p><p>　　 Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：<strong>direct、fanout、topic</strong>、headers 。headers 匹配 AMQP 消息的 header，而不是路由键， headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：</p><h3 id="direct："><a href="#direct：" class="headerlink" title="direct："></a>direct：</h3><p>消息中的路由键（routing key）如果和 Binding 中的 bindingkey 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。<strong>它是完全匹配、单播的模式。</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115140202.png"></p><h3 id="fanout："><a href="#fanout：" class="headerlink" title="fanout："></a>fanout：</h3><p>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网<strong>广播</strong>，每台子网内的主机都获得了一份复制的消息。<strong>fanout 类型转发消息是最快的。</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115140400.png"></p><h3 id="topic："><a href="#topic：" class="headerlink" title="topic："></a>topic：</h3><p>topic 交换器通过<strong>模式匹配</strong>分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些 单词之间用点隔开。它同样也会识别两个通配符：符号“ <code>#</code> ”和符号“ <code>*</code> ”。 # 匹配 0 个或多个单词， * 匹配一个单词。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115140644.png"></p><h2 id="RabbitMQ整合"><a href="#RabbitMQ整合" class="headerlink" title="RabbitMQ整合"></a>RabbitMQ整合</h2><p>全局整合步骤：</p><ol><li><p><strong>引入 spring-boot-starter-amqp</strong></p></li><li><p><strong>application.yml配置</strong></p></li><li><p><strong>测试RabbitMQ</strong></p><ol><li><p>AmqpAdmin：管理组件</p></li><li><p>RabbitTemplate：消息发送处理组件</p></li></ol></li></ol><hr><h3 id="安装rabbitmq：docker镜像"><a href="#安装rabbitmq：docker镜像" class="headerlink" title="安装rabbitmq：docker镜像"></a>安装rabbitmq：docker镜像</h3><p>打开虚拟机，连接虚拟机：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115143023.png"></p><p>在docker hub中：搜索rabbitmq：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115143549.png"></p><p>点击tags：选择带有manager的标签，因为这样的rabbitmq会带有管理消息队列的界面。</p><p>我这里就选择：3.6-management<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115143811.png"></p><p>在虚拟机客户端：输入 <code>docker pull registry.docker-cn.com/library/rabbitmq:3.6-management</code></p><p>前缀：registry.docker-cn.com/library/   是加速的功能！！！</p><p>下载完成：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115144251.png"></p><p>运行rabbitmq镜像：</p><p>输入：<code>docker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq registry.docker-cn.com/library/rabbitmq:3.6-management</code></p><p><strong>注意：这里有两个端口号，5672是rabbitmq的默认端口号，15672是rabbitmq的界面管理的端口号</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115175455.png"></p><p>验证是否启动成功：</p><p>在浏览器中输入：<code>http://10.6.11.17:15672/</code> 这里的ip地址是你的虚拟机的ip地址。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115145020.png"></p><p>用户名和密码都是：guest<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115145130.png"></p><p>这里，我们主要关注 Exchanges 和 Queues。</p><p>现在我们来根据下图的 Exchange 和 Queue 来设置、验证。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115145557.png"></p><p>图中，我们有三个类型的Exchange：</p><p>exchange.direct ：direct类型的Exchange</p><p>exchange.fanout：fanout类型的Exchange</p><p>exchange.topic：topic类型的Exchange</p><p>四个Queue：</p><p>liuzhuo、liuzhuo.news、liuzhuo.emps、gakki.news</p><hr><p>现在，我们在rabbitmq管理界面中，添加上诉的 Exchange 和 Queue</p><p>点击：Exchanges，然后点击：Add a new exchange<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115150037.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115150358.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115150454.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115150521.png"></p><p>三个类型的Exchange添加成功后：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115150616.png"></p><hr><p>点击：Queues，然后点击：Add a new queue<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115150740.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115150835.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115150916.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115150941.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115151007.png"></p><p>四个queue添加成功后：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115151047.png"></p><hr><p>现在，将Exchange和queue绑定在一起：</p><p>点击：exchange.direct，再点击Bindings：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115151512.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115151546.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115151612.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115151639.png"></p><p>exchange.direct 绑定四个队列成功后：</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115151828.png"></p><p>现在，在exchange.direct下，发送消息：（点击Publish message）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115152200.png"></p><p>direct类型的Exchange，是一对一的形式，虽然exchange.direct绑定了四个队列，但是只要liuzhuo路由键的队列才能收到消息：</p><p>点击Queues<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115152416.png"><br>点击liuzhuo队列，查看具体的消息<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115152548.png"></p><hr><p>给 exchange.fanout 也绑定 四个队列：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115152858.png"><br>类推：四个队列绑定成功后：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115153100.png"></p><p>现在，在exchange.fanout下，发送消息：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115153320.png"></p><p>发送消息之后，四个消息队列都会收到消息：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115153426.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115153536.png"></p><hr><p>给 exchange.topic 绑定模式匹配的消息队列：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115153958.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115154107.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115154137.png"></p><p>最后：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115154227.png"></p><p>在 exchange.topic 下 ，发送消息：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115154442.png"></p><p>查看消息队列：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115154546.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115154656.png"></p><p><strong>大家有可能看不到topic的消息，因为你们没有移除消息，看到都是第一条消息，看不到后面的消息。</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115155028.png"></p><p>改为false后，点击Get Message(s)后，会 <strong>获取当前消息</strong> 并 <strong>移除当前消息</strong>。</p><h3 id="整合rabbitmq到Springboot中"><a href="#整合rabbitmq到Springboot中" class="headerlink" title="整合rabbitmq到Springboot中"></a>整合rabbitmq到Springboot中</h3><p>1）创建新的Springboot工程：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115163556.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115163639.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115170221.png"></p><p>只要导入了amqp的starter，Springboot就会自动帮我们配置rabbitmq。</p><p>原理：</p><p>打开：RabbitAutoConfiguration<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115170518.png"></p><ol><li>帮我们创建了RabbitConnectionFactoryCreator：rabbitmq的工厂连接器。</li><li><p>使用RabbitProperties类，来配置rabbitmq。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115170755.png"></p></li><li><p>创建rabbitTemplate来操作rabbitmq<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115170904.png"></p></li><li><p>创建了AmqpAdmin：来管理rabbitmq的组件<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115171113.png"></p></li></ol><hr><p>现在，我们来使用Springboot帮我们注入的rabbitTemplate来操作rabbitmq：</p><p>在application配置文件中：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115172810.png"></p><pre><code>#配置rabbitmq的信息spring.rabbitmq.host=10.6.11.17spring.rabbitmq.username=guestspring.rabbitmq.password=guest#spring.rabbitmq.port=5672        //默认就是5672，可以不配置#spring.rabbitmq.virtual-host=/   //默认就是/的虚拟主机，可以不配置</code></pre><p>在test包下，测试我们的rabbitTemplate：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115171844.png"></p><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot02AmqpApplicationTests {    @Autowired    private RabbitTemplate rabbitTemplate;    @Test    public void test01(){                //exchange:Exchange交换机        //routingKey:路由键        //message:消息体，需要自己实现。        //rabbitTemplate.send(exchange,routingKey,message);        //object:消息的内容，我们不需要自己写消息头，消息体了，自动帮我们        //解析。所以一般我们使用：convertAndSend        //rabbitTemplate.convertAndSend(exchange,routingKey,object);        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;id&quot;,&quot;1&quot;);        map.put(&quot;name&quot;,&quot;zhangsan&quot;);        rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;,&quot;liuzhuo.news&quot;,map);    }    @Test    public void contextLoads() {    }}</code></pre><p>清空，我们消息队列中的消息：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115172310.png"></p><p>执行test01：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115175833.png"></p><p>打开：Queues<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115180117.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115180249.png"></p><p>消息发送成功，只是是以jdk序列化的形式序列化消息的。</p><p>从消息队列中，获取消息：</p><p>再写一个测试方法：</p><pre><code>@Testpublic void test02(){    //参数：队列的名字    Object o = rabbitTemplate.receiveAndConvert(&quot;liuzhuo.news&quot;);    System.out.println(o.getClass());    System.out.println(o);}</code></pre><p>执行该测试方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115180643.png"></p><hr><p>现在，我们修改一下，序列化的方式：</p><p>默认的序列化的是：</p><pre><code>private volatile MessageConverter messageConverter = new SimpleMessageConverter();</code></pre><p>在config下：创建RabbitmqConfig配置类：</p><p>配置：json的序列化器：<br>org.springframework.amqp.support.converter.MessageConverter<br>在MessageConverter上，ctrl+H：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115184655.png" style="width:50%"><br>Springboot已经帮我们，创建好了json的序列化器。</p><p>直接注册到容器即可：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115184554.png"></p><p>现在，容器就会使用Jackson2JsonMessageConverter()，不会使用默认的new SimpleMessageConverter()。</p><hr><p>再次运行test01():<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115185107.png"></p><p>再次运行test02():<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115185214.png"></p><hr><p>在bean包下，创建person类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115185350.png"></p><p><strong>注意：提供get和set方法</strong></p><p>修改test01方法：</p><pre><code>    @Test    public void test01(){        Person person = new Person(&quot;dengjie&quot;,18);        rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;,&quot;liuzhuo.news&quot;,person);    }</code></pre><p>修改test02方法：</p><pre><code>@Testpublic void test02(){    //参数：队列的名字    Person person = (Person) rabbitTemplate.receiveAndConvert(&quot;liuzhuo.news&quot;);    System.out.println(person.getClass());    System.out.println(person);}</code></pre><p>运行test01：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115190126.png"></p><p>运行test02：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115190228.png"></p><p>json序列化成功！！！</p><hr><p>以上都是我们发送消息，然后手动获取消息。现在我们使用rabbitmq的注解监听器来自动帮我们获取消息队列中的消息。</p><p>在service包下，创建PersonService：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115191858.png"></p><p>在启动类中，开启rabbitmq的注解启动功能：<br>@EnableRabbit<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115191955.png"></p><p>启动Springboot应用：</p><p>然后运行test01：给liuzhuo.news队列中，发送一个消息。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115192156.png"></p><p>打开控制台：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115192236.png"></p><p>监听liuzhuo.news队列成功。</p><p>如果，我们想要获取消息的更多信息，比如消息头、消息体。</p><p>在PersonService中：(使用Message参数)</p><pre><code>    //监听liuzhuo队列中的消息    @RabbitListener(queues = &quot;liuzhuo&quot;)    public void messager(Message message){        //获取消息头的信息        System.out.println(message.getMessageProperties());        //获取消息体的内容        System.out.println(message.getBody());    }</code></pre><p>打开queues的界面:(查看liuzhuo队列)<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115192855.png"></p><p>里面已经有两个数据了，现在我们重启Springboot应用：<br>在启动的过程中：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115193013.png"></p><hr><p>以上的操作，都是基于：Exchange 和 queue 存在的情况下。这么组件的创建都是基于rabbitmq的界面操作，如果我们想要在代码中创建呢？</p><p>这样，我们可以使用Springboot帮自动注入的AmqpAdmin组件，AmqpAdmin可以创建、删除、绑定：Exchange 和 queue。</p><p>在test包下的测试类中：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115194641.png"></p><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot02AmqpApplicationTests {    @Autowired    private RabbitTemplate rabbitTemplate;    @Autowired    private AmqpAdmin rabbitAmqpAdmin;    @Test    public void testRabbitAdmin(){        //创建exchange        rabbitAmqpAdmin.declareExchange(new DirectExchange(&quot;amqp.exchange&quot;));        //创建queue        rabbitAmqpAdmin.declareQueue(new Queue(&quot;amqp.queue&quot;));    }    ····}</code></pre><p>运行测试方法：testRabbitAdmin()<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115194827.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115194855.png"></p><p>test:</p><pre><code>    @Test    public void bing(){        //绑定exchange与queue        rabbitAmqpAdmin.declareBinding(new Binding(&quot;amqp.queue&quot;, Binding.DestinationType.QUEUE,&quot;amqp.exchange&quot;,&quot;amqp.key&quot;,null));    }</code></pre><p>运行该测试方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/mq/QQ截图20181115195315.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 消息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 消息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与缓存</title>
      <link href="/2018/11/13/spring-boot-yu-huan-cun/"/>
      <url>/2018/11/13/spring-boot-yu-huan-cun/</url>
      
        <content type="html"><![CDATA[<p>JSR-107、Spring缓存抽象、整合Redis<br><a id="more"></a></p><h2 id="JSR107"><a href="#JSR107" class="headerlink" title="JSR107"></a>JSR107</h2><p>Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。</p><ol><li><p>CachingProvider：定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可<br>以在运行期访问多个CachingProvider。</p></li><li><p>CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache<br>存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。</p></li><li><p>Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个<br>CacheManager所拥有。</p></li><li><p>Entry 是一个存储在Cache中的key-value对。</p></li><li><p>Expiry 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期<br>的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。</p></li></ol><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113103324.png"></p><p>JSR107:定义的缓存规范，比较复杂，一般我们很少使用，接下来我们看看Spring的缓存抽象。</p><h2 id="Spring缓存抽象"><a href="#Spring缓存抽象" class="headerlink" title="Spring缓存抽象"></a>Spring缓存抽象</h2><p>Spring从3.1开始定义了org.springframework.cache.<strong>Cache</strong>和org.springframework.cache.<strong>CacheManager</strong>接口来统一不同的缓存技术；并支持使用JCache（JSR-107）<strong>注解</strong>简化我们开发；</p><ul><li><p>Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；</p></li><li><p>Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache,ConcurrentMapCache等；</p></li><li><p>每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。</p></li><li><p>使用Spring缓存抽象时我们需要关注以下两点；</p></li></ul><p>　　1.确定方法需要被缓存以及他们的缓存策略</p><p>　　2.从缓存中读取之前缓存存储的数据</p><hr><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113103919.png"></p><h2 id="几个重要概念-amp-缓存注解"><a href="#几个重要概念-amp-缓存注解" class="headerlink" title="几个重要概念&amp;缓存注解"></a>几个重要概念&amp;缓存注解</h2><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113104138.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113104254.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113104630.png"></p><h2 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h2><ol><li><p>引入spring-boot-starter-cache模块</p></li><li><p>@EnableCaching开启缓存</p></li><li><p>使用缓存注解</p></li><li><p>切换为其他缓存</p></li></ol><hr><h3 id="搭建基本环境"><a href="#搭建基本环境" class="headerlink" title="搭建基本环境"></a>搭建基本环境</h3><p>1）导入数据库文件，创建出department和employee表：</p><p>打开Navicat：mysql客户端。创建本地的数据库spring_cache</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113114130.png"></p><p>将spring_cache.sql文件导入到spring_cache数据库中</p><p>spring_cache.sql:</p><pre><code>SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for department-- ----------------------------DROP TABLE IF EXISTS `department`;CREATE TABLE `department` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `departmentName` varchar(255) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Table structure for employee-- ----------------------------DROP TABLE IF EXISTS `employee`;CREATE TABLE `employee` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `lastName` varchar(255) DEFAULT NULL,  `email` varchar(255) DEFAULT NULL,  `gender` int(2) DEFAULT NULL,  `d_id` int(11) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><p>导入成功后，会生成 department和employee表。（大家实在不会，手动创建也行）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113114431.png"></p><p>2）打开idea创建Springboot项目。选择cache、web、mysql、mybatis模块<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113115000.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113115035.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113115102.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113115139.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113150553.png"></p><p>3）创建对应的 javaBean对象：（ department 和 employee ）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113150738.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113150806.png"></p><p>4）配置数据库信息</p><p>在application配置文件中：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113151529.png"></p><pre><code>#数据库连接spring.datasource.url=jdbc:mysql://localhost:3306/spring_cachespring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driver#mybatis的驼峰命令:dId=d_idmybatis.configuration.map-underscore-to-camel-case=true</code></pre><p>5) 整合mybatis</p><p>创建mapper包：并创建 DepartmentMapper 和 EmployeeMapper</p><p>如果不清楚Mybatis与Springboot的整合，去看Springboot的基础里面的数据部分。<a href="https://gakkil.top/2018/11/11/SpringBoot-day-08/#%E6%95%B4%E5%90%88MyBatis" target="_blank" rel="noopener">Mybatis整合</a></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113152057.png"></p><pre><code>@Mapperpublic interface EmployeeMapper {    //获取Employee对象    @Select(&quot;select * from employee where id =#{id}&quot;)    public Employee getEmployeeById(Integer id);    //更新Employee对象    @Update(&quot;update employee set lastName=#{lastName},email=#{email},gender=#{gender},d_id=#{dId} where id=#{id}&quot;)    public Employee updateEmployee(Employee employee);    //删除employee对象    @Delete(&quot;delete from employee where id=#{id}&quot;)    public void deleteEmployeeById(Integer id);    //增加employee对象    @Insert(&quot;insert into employee(lastName,email,gender,d_id) values(#{lastName},#{email},#{gender},#{dId})&quot;)    public void insertEmployee(Employee employee);}</code></pre><p>6) 编写service和controller层：</p><p>EmployeeService：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113153826.png"></p><p>EmployeeController：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113154057.png"></p><p>7）启动应用，验证我们的应用是否成功：</p><p>然后在我们的数据库中，随便手动插入一条数据：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113155237.png"></p><p>在浏览器中输入：<code>http://localhost:8080/empl/1</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113155303.png"></p><p><strong>PS：如果控制台出现Establishing SSL警告</strong>：是因为在MYSQL5.5.45+, 5.6.26+ and 5.7.6+版本中需要携带服务器身份验证的SSL连接。<br>解决办法：<br>1）在数据库连接的url中添加useSSL=false;（不使用ssl连接）<br>2）url中添加useSSL=true，并且提供服务器的验证证书。</p><p>我们这里就直接不使用了，在url后面加上？useSSL=false即可。<br><code>spring.datasource.url=jdbc:mysql://localhost:3306/spring_cache?useSSL=false</code></p><h3 id="缓存的快速体验"><a href="#缓存的快速体验" class="headerlink" title="缓存的快速体验"></a>缓存的快速体验</h3><p>步骤：</p><p>1）开启缓存的注解，@EnableCaching<br>2）使用缓存的注解来添加缓存的功能</p><hr><p>在没有使用缓存的时候，每次发送请求都会到数据库中，查询数据：<br>现在，给EmployeeService添加输出语句：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113162215.png"><br>修改日志的级别：<br>logging.level.com.liuzhuo.cache=debug</p><p>启动Springboot应用：在浏览器中输入：<code>http://localhost:8080/empl/1</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113162510.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113162536.png"></p><p>刷新页面，还是会打印出 输出语句 和 sql的查询信息。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113162657.png"></p><hr><p>使用缓存：</p><p>1）给启动类上面，加上@EnableCaching<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113162019.png"></p><p>2）给 EmployeeService 中 findEmployeeById 方法添加缓存的注解:( @Cacheable ）</p><pre><code>@Servicepublic class EmployeeService {    @Autowired    private EmployeeMapper employeeMapper;    //获取Employee对象    /**     *  Cacheable:查询时候缓存，第一次会到数据库中查询数据，以后都只会到     *  缓存中获取数据。     *  几个重要的属性：     *   1）cacheName/value: 指定缓存组件的名字。     *   2）key：缓存数据使用的key。默认是使用方法参数的值，比如这里id=1的话，默认key=1     *           可以使用SpEl表达式：#id获取的参数的值，#a0 #p0都是获取第一个参数的值     *           #root.args[0]:也是获取第一个参数的值     *   3）keyGenerator:key的生成器，可以自己指定key的生成器的组件的id     *            key或keyGenerator：二选一     *   4) cacheManager:指定缓存管理器     *   5) cacheResolver:指定缓存解析器。和cacheManager二选一     *   6) condition:指定符合条件的情况下，才缓存数据.     *             可以使用SpEl表达式：condition=&quot;#id&gt;5&quot;     *   7) unless:否定缓存，与condition作用相反     *   8) sync:是否使用异步模式     */    @Cacheable    public Employee findEmployeeById(Integer id) {        System.out.println(&quot;查询:&quot;+id+&quot;号的信息&quot;);        return employeeMapper.getEmployeeById(id);    }}</code></pre><p>3）启动SpringBoot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/empl/1</code></p><p>只有第一次会打印 输出语句。之后都不会打印输出语句，说明数据已经被缓存到缓存当中了。</p><hr><h3 id="SpringBoot的缓存原理："><a href="#SpringBoot的缓存原理：" class="headerlink" title="SpringBoot的缓存原理："></a>SpringBoot的缓存原理：</h3><p>1）打开CacheAutoConfiguration：</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113171128.png"></p><p>2）观察导入@Import(CacheConfigurationImportSelector.class)<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113171308.png"></p><p>3）CacheConfigurationImportSelector帮我们缓存了哪些类呢？</p><p>打上断点，debug一下：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113171503.png"></p><pre><code>org.springframework.boot.autoconfigure.cache.GenericCacheConfigurationorg.springframework.boot.autoconfigure.cache.JCacheCacheConfigurationorg.springframework.boot.autoconfigure.cache.EhCacheCacheConfigurationorg.springframework.boot.autoconfigure.cache.HazelcastCacheConfigurationorg.springframework.boot.autoconfigure.cache.InfinispanCacheConfigurationorg.springframework.boot.autoconfigure.cache.CouchbaseCacheConfigurationorg.springframework.boot.autoconfigure.cache.RedisCacheConfigurationorg.springframework.boot.autoconfigure.cache.CaffeineCacheConfigurationorg.springframework.boot.autoconfigure.cache.GuavaCacheConfigurationorg.springframework.boot.autoconfigure.cache.SimpleCacheConfigurationorg.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration</code></pre><p>4)而注入的这里类，哪些会生效呢？</p><p>Application配置：debug=true.</p><p>发现：只有 SimpleCacheConfiguration 生效。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113171946.png"></p><p>5）SimpleCacheConfiguration给容器中注入了一个cacheManager：ConcurrentMapCacheManager<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113172101.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113172457.png"></p><p>6）ConcurrentMapCacheManager：实质上就是一个ConcurrentHashMap。</p><p>然后使用ConcurrentMapCache（实质ConcurrentMap）将数据保存在ConcurrentMap中。</p><hr><h3 id="缓存的运行流程"><a href="#缓存的运行流程" class="headerlink" title="缓存的运行流程"></a>缓存的运行流程</h3><p>给 EmployeeService 的 findEmployeeById 方法 打上断点：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113173709.png"></p><p>给 ConcurrentMapCacheManager getCache 方法 打上断点：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113173817.png"></p><p>给 ConcurrentMapCache 的lookup、get、set 打上断点：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113173929.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113173941.png"></p><p>debug运行一下：</p><p>在浏览器中输入：<code>http://localhost:8080/empl/1</code></p><p>进入断点处：</p><p>当首次进入该方法时，不会执行该方法，会先进入缓存中获取数据<br>根据 cacheNames/value 来获取cache。<br>这里 cacheNames=’empl’<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113183208.png"></p><p>第一次查询，名称为empl的’cache’一定是null，所以会创建名称为’empl’的cache<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113183458.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113183641.png"></p><p>创建’empl’的cache成功后，这里的cache就是ConcurrentMapCache，放到ConcurrentMapCacheManager中。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113183804.png"></p><p>然后在ConcurrentMapCache中，寻找key等于我们默认参数值的value值：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113184208.png"></p><p>没有找key=1的缓存值，所以执行 findEmployeeById 方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113184329.png"></p><p>从数据库中获取数据，将数据放到缓存当中。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113184515.png"></p><hr><p>当再次，刷新页面时。</p><p>name=’empl’的cache已经存在了<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113184712.png"></p><p>然后在name=’empl’的cache中寻找key=1的缓存：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113184920.png"></p><p>然后直接就找到了key=1的缓存了，直接返回对象，不在执行 findEmployeeById 方法了。</p><p>直接来了到控制层，return语句，返回视图。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113185435.png"></p><p><strong>总结：@cacheable标注的方法执行之前，先来检查缓存中有么有我们的定义的name的cache缓存，按照默认的key生成策略的值去查询对应的缓存，如果没有就运行该方法，并放入缓存中。以后调用就直接使用缓存中的数据。</strong></p><p>核心：</p><p>1）使用cacheManager[ConcurrentMapCacheManager]按照名字name来获取cache[ConcurrentMapCache]组件</p><p>2）key使用keyGenerator生成的，默认是SimpleGenerator。</p><p>3）cache使用生成的key来获取缓存或者放入缓存当中。</p><h3 id="Cacheable属性的使用"><a href="#Cacheable属性的使用" class="headerlink" title="@Cacheable属性的使用"></a>@Cacheable属性的使用</h3><p>1）cacheNames/value: 指定缓存组件的名字。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113192119.png"></p><p>是数组的属性，所以是花括号的形式：cacheNames = {“empl”} 或 value={“empl”}</p><p>2）key：缓存数据使用的key。</p><p>默认是使用方法参数的值，比如这里id的值为1的话，key就等于1<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113192337.png"></p><p>多个参数的话，key默认就是 SimpleKey [参数值1，参数值2]</p><p>SimpleKey [1,jack]<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113192725.png"></p><p>还可以使用SpEl表达式：</p><p><code>#id获取的参数的值。id就是参数的名字</code>：key=1.</p><p><code>#a0、#p0 都是获取第一个参数的值，#a1 就是获取第二参数的值</code></p><p> <code>#root.args[0]:也是获取第一个参数的值</code></p><p>举例：如果想要生成 方法名+参数值 的 key。比如这里的 findEmployeeById[1]</p><p>key = “#root.methodName+’[‘+#id+’]’”<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113193620.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113193828.png"></p><p>3）keyGenerator: key的生成器，可以自己指定key的生成器的组件的id</p><p><strong>key 或 keyGenerator：二选一</strong></p><p>现在在config下，创建CacheConfig类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113194259.png"></p><pre><code>@Configurationpublic class CacheConfig {    @Bean(&quot;myKeyGenerator&quot;)    public KeyGenerator keyGenerator(){        return new KeyGenerator() {            @Override            public Object generate(Object o, Method method, Object... objects) {                return method.getName()+&quot;[&quot;+ Arrays.asList(objects)+&quot;]&quot;;            }        };    }}</code></pre><p>注意这里的 KeyGenerator：org.springframework.cache.interceptor.KeyGenerator</p><p>然后，在 keyGenerator = “myKeyGenerator” ：填写key的生成器的bean的id<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113194347.png"></p><p>debug下：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113194813.png"></p><p>4) cacheManager:指定缓存管理器</p><p> 以后整合其他缓存框架时，使用。</p><p>5) cacheResolver:指定缓存解析器。和cacheManager二选一</p><p>6) condition:指定符合条件的情况下，才缓存数据.</p><p>可以使用SpEl表达式：condition=”#id&gt;5”. 当参数值大于5时，才会缓存数据。</p><p>7) unless:否定缓存，<strong>与condition作用相反</strong></p><p>unless = “#id&lt;2” 的话，就是参数值小于2时，不缓存</p><p>8) sync:是否使用异步模式</p><p>不过，当使用sync的话，unless是不能使用的。</p><h3 id="CachePut的使用"><a href="#CachePut的使用" class="headerlink" title="@CachePut的使用"></a>@CachePut的使用</h3><p>@CachePut：是用来更新缓存的，始终是先执行方法，然后更新缓存。</p><p>1）在 EmployeeService 添加 更新employee的方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113204129.png"></p><p>2）在 EmployeeController 添加 更新employee的映射方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113203603.png"></p><p>3）启动程序。</p><p>首先：输入：<code>http://localhost:8080/empl/1</code> : 查询1号员工的信息<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113203724.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113203745.png"></p><p>再次，访问1号员工的信息：</p><p>控制台，什么也不打印，但是界面有数据，说明，我们缓存数据成功！</p><p>现在，我们修改1号员工的信息：输入：<code>http://localhost:8080/empl?id=1&amp;lastName=zhangsan&amp;gender=0</code></p><p>我们就修改了性别，从1变成0.<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113204245.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113204305.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113204337.png"></p><p>更新成功！！！</p><hr><p>现在，我们再次，访问1号员工的信息，是从缓存中取？还是从数据库中取呢？如果从缓存中取，是旧的数据，还是新的数据？</p><p>反正，我们的最终目的是现在获取更新后的1号员工的信息。</p><p>我们来，测试一下，访问1号员工的信息：<code>http://localhost:8080/empl/1</code></p><p>发现，控制台没有打印输出语句，说明现在还是从缓存中取数据。但是好像返回的数据是旧的？<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113204707.png"></p><p>这是为啥呢？ 因为，虽然我们的获取缓存的名字 和 更新缓存的缓存的名字 都是empl。但是key不同呀！！！<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113204927.png"></p><p>所以，现在名字为’empl’的cache中，有两个缓存，一个是key=1的缓存，另一个key=employee值的缓存。所以现在获取的是key=1的缓存(旧的数据)</p><p><strong>要想达到我们想要的效果，必须key一致！！！</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113205251.png"></p><p><strong>注意：@Cacheable的key，不能使用#result，因为@Cacheable是先执行缓存，再执行方法，而@CachePut总是先执行方法，再执行缓存。</strong></p><hr><p>重启应用，再次测试一次：</p><p>先访问1号员工：<code>http://localhost:8080/empl/1</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113205902.png"></p><p>再修改1号员工：<code>http://localhost:8080/empl?id=1&amp;lastName=张三&amp;gender=0&amp;email=zhangsan@qq.com</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113205710.png"></p><p>再次访问1号员工：<code>http://localhost:8080/empl/1</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113205937.png"></p><p>到达，我们的效果！！！</p><p><strong>注意：这里我们的缓存的name是一致的，都是’empl’才行，如果你更改了name，不一致的话，效果就达不到了，原因， 你懂的</strong></p><p><strong>PS：如果张三在数据库中看是乱码的话，需要在数据库连接中添加 &amp;characterEncoding=utf-8：</strong></p><p><strong>spring.datasource.url=jdbc:mysql://localhost:3306/spring_cache?useSSL=false&amp;characterEncoding=utf-8</strong></p><h3 id="CacheEvict的使用"><a href="#CacheEvict的使用" class="headerlink" title="@CacheEvict的使用"></a>@CacheEvict的使用</h3><p>@CacheEvict：是用来删除缓存的。</p><p>通过key：来删除指定的缓存。</p><p>allEntries = true. 删除所有的缓存，默认是为false。<br>当allEntries = true，就不用指定key了。</p><p>beforeInvocation = true。先清空缓存，再执行方法。默认是为false。<br>作用：默认情况下，当方法出现异常，缓存就不会清除。当beforeInvocation = true时，不管方法是否出现异常，都会清除缓存。 </p><h3 id="Caching的使用"><a href="#Caching的使用" class="headerlink" title="@Caching的使用"></a>@Caching的使用</h3><p>@Caching：组合注解：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113213321.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113213634.png"></p><h3 id="CacheConfig的使用"><a href="#CacheConfig的使用" class="headerlink" title="@CacheConfig的使用"></a>@CacheConfig的使用</h3><p>@CacheConfig：是作用在<strong>类上面的</strong>，相当于全局配置。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181113213950.png"></p><p>此时，就不需要在每个方法上的缓存注解中，写cacheNames=’empl’. 如果写了，就使用方法上面的cacheNames。</p><h2 id="整合Redis缓存"><a href="#整合Redis缓存" class="headerlink" title="整合Redis缓存"></a>整合Redis缓存</h2><h3 id="搭建redis环境"><a href="#搭建redis环境" class="headerlink" title="搭建redis环境"></a>搭建redis环境</h3><p>1）使用我们安装的虚拟机工具安装Redis</p><p>如果不清楚的话，看之前的SpringBoot基础篇，<a href="https://gakkil.top/2018/11/09/SpringBoot-day-07/#%E5%AE%89%E8%A3%85linux%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">docker学习</a></p><p>打开虚拟机：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114100415.png"></p><p>打开连接虚拟机的客户端：SmarTTY<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114100537.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114100653.png"></p><p>在docker hub中搜索Redis的镜像<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114101037.png"></p><p>docker官方的镜像在国外，下载镜像会很慢，所以使用国内的docker镜像：<a href="https://www.docker-cn.com/" target="_blank" rel="noopener">https://www.docker-cn.com/</a><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114101241.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114101523.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114101749.png"></p><p>运行我们下载的redis镜像：</p><pre><code>docker run -d -p 6379:6379 --name myredis registry.docker-cn.com/library/redis</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114102027.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114102152.png"></p><p>2) 打开redis的客户端：RedisDesktopManager（自行下载）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114102449.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114102754.png"></p><p>默认redis：16个数据库<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114102848.png"></p><p>3）简单试试redis的命令</p><p>在myredis上面，右键选择：Console<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114103104.png"></p><p>打开redis中文网：<a href="http://www.redis.cn/" target="_blank" rel="noopener">http://www.redis.cn/</a><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114103332.png"></p><p>以String类型为例：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114103450.png"></p><p>其他命令，请读者自行学习啦~</p><h3 id="整合redis"><a href="#整合redis" class="headerlink" title="整合redis"></a>整合redis</h3><p>SpringBoot，默认的配置类是：SimpleCacheConfiguration</p><p>默认使用的CacheManager：ConcurrentMapCacheManager</p><p>默认使用的Cache：ConcurrentMapCache</p><p>现在，整合redis到SpringBoot中。</p><p>1）导入redis的stars依赖</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>2) 在Application配置文件中，添加redis的连接</p><pre><code>#设置redis的连接spring.redis.host=10.6.11.17</code></pre><p>这里的 host: 写你自己的虚拟机的ip地址。</p><p>3）打开RedisAutoConfiguration<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114115036.png"></p><p>发现：导入了两个模板类，方便我们操作。</p><p>4）在SpringBoot01CacheApplicationTests类中：</p><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot01CacheApplicationTests {    @Autowired    private EmployeeMapper employeeMapper;    @Autowired    private RedisTemplate redisTemplate;  //操作k-v，都是对象的    @Autowired    private StringRedisTemplate stringRedisTemplate; //操作k-v：k是字符串的    /**     * redis:5种数据结构：     * 字符串String，list（列表），hash（哈希），set（集合），ZSet（有序集合）     * opsForValue()：String     * opsForList():list     * opsForHash():hash     * opsForSet():set     * opsForZSet():ZSet     */    @Test    public void test01(){        stringRedisTemplate.opsForValue().append(&quot;mgs&quot;,&quot;hello&quot;);    }    @Test    public void contextLoads() {    }}</code></pre><p>清空：redis中的数据。执行test01<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114115954.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114120032.png"></p><p>其他命令，自行执行测试。</p><p>现在测试RedisTemplate：</p><pre><code>    @Test    public void test02() {        Employee employee = employeeMapper.getEmployeeById(1);        //将对象放入到redis中        redisTemplate.opsForValue().set(&quot;empl&quot;, employee);    }</code></pre><p>运行测试方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114125203.png"></p><p>出现无法序列化异常，因为对象保存到redis中，是以序列化的形式。而我们的Employee没有实现序列化。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114125342.png"></p><p>再次运行：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114125447.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114125504.png"></p><p>虽然成功了，但是是序列化的形式，看着不爽。</p><p>默认是jdk的序列化形式：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114125648.png"></p><p>我们可以自定义自己的序列化方式：</p><p>使用我们自己的redis模板，设置自己的json的序列化形式：</p><p>在config包下：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114130144.png"></p><pre><code>@Configurationpublic class RedisConfig {    @Bean(&quot;myRedisTemplate&quot;)    public RedisTemplate&lt;Object, Employee&gt; redisTemplate(            RedisConnectionFactory redisConnectionFactory)            throws UnknownHostException {        RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;();        template.setConnectionFactory(redisConnectionFactory);        //使用json的序列化        Jackson2JsonRedisSerializer&lt;Employee&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);        template.setDefaultSerializer(redisSerializer);        return template;    }}</code></pre><p>使用自己的redis模板：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114130400.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114130459.png"></p><p>运行test03方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114130554.png"></p><p>以上我们的redis已经整合成功了。</p><hr><h3 id="使用redis缓存"><a href="#使用redis缓存" class="headerlink" title="使用redis缓存"></a>使用redis缓存</h3><p>我们知道，SpringBoot默认使用：SimpleCacheConfiguration</p><p>导入redis-starter后，就会使用 RedisAutoConfiguration。</p><p>然后默认使用：RedisTemplate模板。</p><p>现在直接启动SpringBoot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/empl/1</code></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114133854.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114133941.png"></p><p>再次输入：<code>http://localhost:8080/empl/1</code></p><p>会从缓存中获取数据，控制台不会打印sql语句。</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114134141.png"></p><p>不是我们想要的序列化形式：</p><p>我们需要自己配置RedisCacheManager：</p><p>打开：RedisCacheConfiguration类：</p><p>发现默认的RedisCacheManager：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114194646.png"></p><p>现在在我们的RedisConfig类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114195041.png"></p><pre><code>@Configurationpublic class RedisConfig {    @Bean(&quot;employeeRedisTemplate&quot;)    public RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate(            RedisConnectionFactory redisConnectionFactory)            throws UnknownHostException {        RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;();        template.setConnectionFactory(redisConnectionFactory);        Jackson2JsonRedisSerializer&lt;Employee&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);        template.setDefaultSerializer(redisSerializer);        return template;    }    @Bean    public RedisCacheManager cacheManager(RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(employeeRedisTemplate);        //设置是否使用前缀，前缀就是cacheNames。        cacheManager.setUsePrefix(true);        return cacheManager;    }}</code></pre><p>我们配置了自己的RedisCacheManager，默认的就会失效，因为：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114200708.png"></p><p>现在，我们使用department来测试：编写departmentMapper，departmentService，departmentController：</p><p>DepartmentMapper：</p><pre><code>@Mapperpublic interface DepartmentMapper {    @Select(&quot;select * from department where id=#{id}&quot;)    public Department getDeptById(Integer id);}</code></pre><p>DepartmentService:</p><pre><code>@Servicepublic class DepartmentService {    @Autowired    private DepartmentMapper departmentMapper;    @Cacheable(cacheNames = &quot;dept&quot;)    public Department getDeptById(Integer id){        return departmentMapper.getDeptById(id);    }}</code></pre><p>DepartmentController:</p><pre><code>@RestControllerpublic class DepartmentController {    @Autowired    private DepartmentService departmentService;    @GetMapping(&quot;/dept/{id}&quot;)    public Department getDeptById(@PathVariable(&quot;id&quot;) Integer id) {        return departmentService.getDeptById(id);    }}</code></pre><p>启动应用：</p><p>清空redis数据库。</p><p>在浏览器中输入：<code>http://localhost:8080/empl/1</code></p><p>第一次查询，会从数据库中查询数据，然后放到缓存中。</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114200147.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114200157.png"></p><p>此时redis数据库中，是以json啦来序列化的。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114200358.png"></p><p>再次：访问<code>http://localhost:8080/empl/1</code>，控制台不会打印sql语句，说明是从缓存中取的。</p><p>现在，我们来测试department。在mysql客户端中，自己手动插入一条数据：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114201053.png"></p><p>在浏览器中输入：<code>http://localhost:8080/dept/1</code></p><p>第一次，会从数据库中获取数据。控制台打印sql语句。将数据放到redis缓存中。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114201003.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114201147.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114201226.png"></p><p>当再次访问：<code>http://localhost:8080/dept/1</code>，照理应该会把department的json数据反序列化到前端，不到mysql数据库中查找。</p><p>但是出错了！！！<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114201422.png"></p><p>看出错的异常，是我们居然是把department的json数据反序列化到employee对象上面，当然出错呀！</p><p>打开我们的cacheConfig类：</p><pre><code>@Configurationpublic class RedisConfig {    @Bean(&quot;employeeRedisTemplate&quot;)    public RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate(            RedisConnectionFactory redisConnectionFactory)            throws UnknownHostException {        RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;();        template.setConnectionFactory(redisConnectionFactory);        Jackson2JsonRedisSerializer&lt;Employee&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);        template.setDefaultSerializer(redisSerializer);        return template;    }    @Bean    public RedisCacheManager cacheManager(RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(employeeRedisTemplate);        //设置是否使用前缀，前缀就是cacheNames。        cacheManager.setUsePrefix(true);        return cacheManager;    }}</code></pre><p>我们的序列化泛型就是Employee对象，所以只能对Employee反序列化成功。</p><p>现在添加新的 RedisCacheManager 和 RedisTemplate</p><pre><code>@Configurationpublic class RedisConfig {    @Bean(&quot;employeeRedisTemplate&quot;)    public RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate(            RedisConnectionFactory redisConnectionFactory)            throws UnknownHostException {        RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;();        template.setConnectionFactory(redisConnectionFactory);        Jackson2JsonRedisSerializer&lt;Employee&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);        template.setDefaultSerializer(redisSerializer);        return template;    }    @Bean(&quot;departmentRedisTemplate&quot;)    public RedisTemplate&lt;Object, Department&gt; departmentRedisTemplate(            RedisConnectionFactory redisConnectionFactory)            throws UnknownHostException {        RedisTemplate&lt;Object, Department&gt; template = new RedisTemplate&lt;Object, Department&gt;();        template.setConnectionFactory(redisConnectionFactory);        Jackson2JsonRedisSerializer&lt;Department&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Department&gt;(Department.class);        template.setDefaultSerializer(redisSerializer);        return template;    }    @Bean(&quot;employeeCacheManager&quot;)    public RedisCacheManager employeeCacheManager(RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(employeeRedisTemplate);        //设置是否使用前缀，前缀就是cacheNames。        cacheManager.setUsePrefix(true);        return cacheManager;    }    @Bean(&quot;departmentCacheManager&quot;)    public RedisCacheManager departmentCacheManager(RedisTemplate&lt;Object, Department&gt; departmentRedisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(departmentRedisTemplate);        //设置是否使用前缀，前缀就是cacheNames。        cacheManager.setUsePrefix(true);        return cacheManager;    }}</code></pre><p>现在在EmployeeService中，设置CacheManager：</p><p>在类上面的，@CacheConfig中设置统一的CacheManager<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114202147.png"></p><p>在DepartmentService：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114202330.png"></p><p>这样，Employee 和 Department 就会使用各自的CacheManager。</p><p>删除Redis中的所有数据。再次测试一下，启动应用。</p><p>启动应用的过程中，出错了！你敢信，我们看看<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114202538.png"></p><p>原来是，我们设置了两个CacheManager，需要确定一个默认的CacheManager。所以我们使用默认的CacheManager当做默认的。</p><p>在redisConfig中：</p><pre><code>@Configurationpublic class RedisConfig {    @Bean(&quot;employeeRedisTemplate&quot;)    public RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate(            RedisConnectionFactory redisConnectionFactory)            throws UnknownHostException {        RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;();        template.setConnectionFactory(redisConnectionFactory);        Jackson2JsonRedisSerializer&lt;Employee&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);        template.setDefaultSerializer(redisSerializer);        return template;    }    @Bean(&quot;departmentRedisTemplate&quot;)    public RedisTemplate&lt;Object, Department&gt; departmentRedisTemplate(            RedisConnectionFactory redisConnectionFactory)            throws UnknownHostException {        RedisTemplate&lt;Object, Department&gt; template = new RedisTemplate&lt;Object, Department&gt;();        template.setConnectionFactory(redisConnectionFactory);        Jackson2JsonRedisSerializer&lt;Department&gt; redisSerializer = new Jackson2JsonRedisSerializer&lt;Department&gt;(Department.class);        template.setDefaultSerializer(redisSerializer);        return template;    }    @Bean(&quot;employeeCacheManager&quot;)    public RedisCacheManager employeeCacheManager(RedisTemplate&lt;Object, Employee&gt; employeeRedisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(employeeRedisTemplate);        //设置是否使用前缀，前缀就是cacheNames。        cacheManager.setUsePrefix(true);        return cacheManager;    }    @Bean(&quot;departmentCacheManager&quot;)    public RedisCacheManager departmentCacheManager(RedisTemplate&lt;Object, Department&gt; departmentRedisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(departmentRedisTemplate);        //设置是否使用前缀，前缀就是cacheNames。        cacheManager.setUsePrefix(true);        return cacheManager;    }    //默认的CacheManager,设置优先级最高    //即，当不配置cacheManager=&quot;xxxx&quot;的时候，就使用这个缓存管理器    @Primary    @Bean    public RedisCacheManager cacheManager(RedisTemplate&lt;Object, Object&gt; redisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate);        cacheManager.setUsePrefix(true);        return cacheManager;    }}</code></pre><p>重启应用：</p><p>应用启动成功，没有出错。</p><p>在浏览器中输入：<code>http://localhost:8080/empl/1</code></p><p>控制台打印sql语句，是到mysql数据库查询数据<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114203139.png"></p><p>再次访问：<code>http://localhost:8080/empl/1</code></p><p>控制台不打印sql语句，是从redis缓存中取数据。</p><p>在浏览器中输入：<code>http://localhost:8080/dept/1</code></p><p>控制台输出sql语句，是到mysql数据库中查询数据<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114203418.png"></p><p>再次访问：<code>http://localhost:8080/dept/1</code></p><p>不报错了，控制台不输出sql语句，是在redi数据库中获取数据。</p><p>以上就是整合 redis 到 SpringBoot 中。</p><hr><h3 id="使用编码的方式来使用Redis"><a href="#使用编码的方式来使用Redis" class="headerlink" title="使用编码的方式来使用Redis"></a>使用编码的方式来使用Redis</h3><p>以上都是使用注解的方式来使用缓存，现在我们来使用编码的方式来操作缓存。</p><pre><code>//@CacheConfig(cacheManager = &quot;departmentCacheManager&quot;)@Servicepublic class DepartmentService {    @Autowired    private DepartmentMapper departmentMapper;    @Autowired    private RedisTemplate departmentRedisTemplate;    //@Cacheable(cacheNames = &quot;dept&quot;)    public Department getDeptById(Integer id){        Department department = departmentMapper.getDeptById(id);        departmentRedisTemplate.opsForValue().set(&quot;dept&quot;+id,&quot;department&quot;);        return department;    }}</code></pre><p>将cahce的注解都注释掉，然后注入departmentRedisTemplate。</p><p>自己手动操作缓存。</p><p>重启应用，在浏览器中输入：<code>http://localhost:8080/dept/1</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/cache/QQ截图20181114204406.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_09</title>
      <link href="/2018/11/12/springboot-day-09/"/>
      <url>/2018/11/12/springboot-day-09/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot启动配置原理：启动原理、运行流程、自动配置原理。<br><a id="more"></a></p><p>几个重要的事件回调机制</p><p>配置在META-INF/spring.factories</p><p><strong>ApplicationContextInitializer</strong></p><p><strong>SpringApplicationRunListener</strong></p><p>只需要放在ioc容器中</p><p><strong>ApplicationRunner</strong></p><p><strong>CommandLineRunner</strong></p><hr><p>启动流程：</p><p>首先创建一个web的Springboot项目：</p><p>然后给主main方法打上断点。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112105657.png"></p><p>开始debug运行。</p><h3 id="创建SpringApplication对象"><a href="#创建SpringApplication对象" class="headerlink" title="创建SpringApplication对象"></a>创建SpringApplication对象</h3><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112105900.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112110020.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112110059.png"></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> sources<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//保存主配置类</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sources <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> sources<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>sources<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//判断当前是否一个web应用</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>webEnvironment <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deduceWebEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从类路径下找到META‐INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setInitializers</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span>ApplicationContextInitializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从类路径下找到ETA‐INF/spring.factories配置的所有ApplicationListener</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setListeners</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span>ApplicationListener<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从多个配置类中找到有main方法的主配置类</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deduceMainApplicationClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>6个ApplicationContextInitializer：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112111101.png" style="width:50%"></p><p>10个ApplicationListener：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112111247.png" style="width:50%"></p><h3 id="运行run方法"><a href="#运行run方法" class="headerlink" title="运行run方法"></a>运行run方法</h3><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112111412.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112113232.png"></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> ConfigurableApplicationContext <span class="token function">run</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StopWatch stopWatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ConfigurableApplicationContext context <span class="token operator">=</span> null<span class="token punctuation">;</span>        FailureAnalyzers analyzers <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token function">configureHeadlessProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//获取SpringApplicationRunListeners；从类路径下META‐INF/spring.factories</span>        SpringApplicationRunListeners listeners <span class="token operator">=</span> <span class="token function">getRunListeners</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//回调所有的获取SpringApplicationRunListener.starting()方法</span>        listeners<span class="token punctuation">.</span><span class="token function">starting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//封装命令行参数</span>           ApplicationArguments applicationArguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultApplicationArguments</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//准备环境：创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成</span>           ConfigurableEnvironment environment <span class="token operator">=</span> <span class="token function">prepareEnvironment</span><span class="token punctuation">(</span>listeners<span class="token punctuation">,</span>applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//打印Spring的banner</span>           Banner printedBanner <span class="token operator">=</span> <span class="token function">printBanner</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//创建ApplicationContext；决定创建web的ioc还是普通的ioc</span>           context <span class="token operator">=</span> <span class="token function">createApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           analyzers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FailureAnalyzers</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//准备上下文环境;将environment保存到ioc中；而且applyInitializers()；</span>           <span class="token comment" spellcheck="true">//applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法</span>           <span class="token comment" spellcheck="true">//回调所有的SpringApplicationRunListener的contextPrepared()；</span>           <span class="token function">prepareContext</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> environment<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">,</span>printedBanner<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded()</span>           <span class="token comment" spellcheck="true">//刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解博客中有完整的流程</span>           <span class="token comment" spellcheck="true">//扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）</span>           <span class="token function">refreshContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调</span>           <span class="token comment" spellcheck="true">//ApplicationRunner先回调，CommandLineRunner再回调</span>           <span class="token function">afterRefresh</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//所有的SpringApplicationRunListener回调finished方法</span>           listeners<span class="token punctuation">.</span><span class="token function">finished</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>           stopWatch<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logStartupInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token keyword">new</span> <span class="token class-name">StartupInfoLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span>                       <span class="token punctuation">.</span><span class="token function">logStarted</span><span class="token punctuation">(</span><span class="token function">getApplicationLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stopWatch<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token comment" spellcheck="true">//整个SpringBoot应用启动完成以后返回启动的ioc容器</span>           <span class="token keyword">return</span> context<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> analyzers<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h3><p>上面我们已经了解了SpringBoot的启动原理，重点是里面的几个监听器：</p><p>ApplicationContextInitializer、SpringApplicationRunListener、ApplicationRunner、CommandLineRunner</p><p>现在，我们来自定义这几个监听器：</p><p>在根目录包下，创建listener包，并创建这几个接口的实现类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112130130.png"></p><p>ApplicationContextInitializer：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyApplicationContextInitializer</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextInitializer</span><span class="token operator">&lt;</span>ConfigurableApplicationContext<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span>ConfigurableApplicationContext configurableApplicationContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyApplicationContextInitializer---initialize"</span> <span class="token operator">+</span> configurableApplicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>SpringApplicationRunListener:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MySpringApplicationRunListener</span> <span class="token keyword">implements</span> <span class="token class-name">SpringApplicationRunListener</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">starting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SpringApplicationRunListener...starting..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">environmentPrepared</span><span class="token punctuation">(</span>ConfigurableEnvironment environment<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object o <span class="token operator">=</span> environment<span class="token punctuation">.</span><span class="token function">getSystemProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"os.name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SpringApplicationRunListener...environmentPrepared.."</span> <span class="token operator">+</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextPrepared</span><span class="token punctuation">(</span>ConfigurableApplicationContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SpringApplicationRunListener...contextPrepared..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextLoaded</span><span class="token punctuation">(</span>ConfigurableApplicationContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SpringApplicationRunListener...contextLoaded..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">finished</span><span class="token punctuation">(</span>ConfigurableApplicationContext context<span class="token punctuation">,</span> Throwable exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SpringApplicationRunListener...finished..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>ApplicationRunner:</p><pre><code>public class MyApplicationRunner implements ApplicationRunner {    @Override    public void run(ApplicationArguments args) throws Exception {        System.out.println(&quot;ApplicationRunner...run....&quot;);    }}</code></pre><p>CommandLineRunner:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCommandLineRunner</span> <span class="token keyword">implements</span> <span class="token class-name">CommandLineRunner</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"CommandLineRunner...run..."</span> <span class="token operator">+</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><p><strong>要想使以上的监听器起作用：</strong></p><p>ApplicationContextInitializer 和 SpringApplicationRunListener需要<strong>配置在META-INF/spring.factories</strong></p><p>在resources下：创建META-INF包，并创建spring.factories文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112131010.png"></p><p>spring.factories文件：</p><pre class=" language-java"><code class="language-java"># Initializersorg<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationContextInitializer<span class="token operator">=</span>\com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>listener<span class="token punctuation">.</span>MyApplicationContextInitializer# SpringApplicationRunListene Listenersorg<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplicationRunListener<span class="token operator">=</span>\com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>springboot<span class="token punctuation">.</span>listener<span class="token punctuation">.</span>MySpringApplicationRunListener</code></pre><p>如果不会写，随便打开一个SpringBoot的jar包，打开一个META-INF/spring.factories，照着写就行了。</p><p>ApplicationRunner 和 CommandLineRunner 只需要放到IOC容器中就行，即加上@Component即可。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112131311.png"></p><hr><p>启动SpringBoot应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112131418.png"></p><p>出现异常：</p><pre class=" language-java"><code class="language-java">MySpringApplicationRunListener<span class="token punctuation">.</span>&lt;init<span class="token operator">></span><span class="token punctuation">(</span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">,</span> <span class="token punctuation">[</span>Ljava<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span></code></pre><p>说明SpringApplicationRunListener，需要有一个有参的构造函数，第一个参数是SpringApplication，第二个是String类型。</p><p>不会写的话，随便打开一个SpringApplicationRunListener的实现类：</p><p>双击：SpringApplicationRunListener，然后Ctrl + H ：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112131719.png" style="width:50%"><br>点击：EventPublishingRunListener<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112131822.png"></p><p>现在给我们的MySpringApplicationRunListener，添加有参的构造函数：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112132043.png"></p><p>再次启动SpringBoot应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112132142.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112132207.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112132228.png"></p><h3 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h3><p>starter：</p><p>1、这个场景需要使用到的依赖是什么？</p><p>2、如何编写自动配置</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>  <span class="token comment" spellcheck="true">//指定这个类是一个配置类</span><span class="token annotation punctuation">@ConditionalOnXXX</span>  <span class="token comment" spellcheck="true">//在指定条件成立的情况下自动配置类生效</span><span class="token annotation punctuation">@AutoConfigureAfter</span>  <span class="token comment" spellcheck="true">//指定自动配置类的顺序</span><span class="token annotation punctuation">@Bean</span>  <span class="token comment" spellcheck="true">//给容器中添加组件</span><span class="token annotation punctuation">@ConfigurationPropertie</span>结合相关xxxProperties类来绑定相关的配置<span class="token annotation punctuation">@EnableConfigurationProperties</span> <span class="token comment" spellcheck="true">//让xxxProperties生效加入到容器中</span>自动配置类要能加载将需要启动就加载的自动配置类，配置在META‐INF<span class="token operator">/</span>spring<span class="token punctuation">.</span>factoriesorg<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>EnableAutoConfiguration<span class="token operator">=</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>admin<span class="token punctuation">.</span>SpringApplicationAdminJmxAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>aop<span class="token punctuation">.</span>AopAutoConfiguration<span class="token punctuation">,</span>\</code></pre><p>3、模式：</p><p>启动器只用来做依赖导入；</p><p>专门来写一个自动配置模块；</p><p>启动器依赖自动配置；别人只需要引入启动器（starter）</p><p>mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter</p><p>步骤：</p><p>前提准备：</p><p>创建一个空项目：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112140556.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112140721.png"></p><p>添加我们的模块：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112140815.png"></p><p>1) 创建启动器模块：</p><p>选择Maven项目：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112140952.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112141139.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112141310.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112141356.png"></p><p>2）创建自动配置模块<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112141500.png"></p><p>选择Spring Initializr：（只是为了方便快速创建模块）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112141625.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112143117.png"><br>选择web模块：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112143217.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112143246.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112143326.png"></p><p>3）在启动器pom文件中，引入自动配置的依赖：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112143647.png"></p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span>project xmlns<span class="token operator">=</span><span class="token string">"http://maven.apache.org/POM/4.0.0"</span>         xmlns<span class="token operator">:</span>xsi<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/XMLSchema-instance"</span>         xsi<span class="token operator">:</span>schemaLocation<span class="token operator">=</span><span class="token string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>modelVersion<span class="token operator">></span><span class="token number">4.0</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token operator">&lt;</span><span class="token operator">/</span>modelVersion<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>spring<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>liuzhuo<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>starter<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">1.0</span><span class="token operator">-</span>SNAPSHOT<span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>启动器<span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>dependencies<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>引入自动配置模块<span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>starter<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>liuzhuo<span class="token operator">-</span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>autoconfigure<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">0.0</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">-</span>SNAPSHOT<span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>dependencies<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>project<span class="token operator">></span></code></pre><p>4) 编写自动配置模块：</p><p>删除不需要的文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112143924.png" style="width:50%"><br>pom文件：删除test的依赖 和 插件的依赖:</p><pre class=" language-java"><code class="language-java">        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>test<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>scope<span class="token operator">></span>test<span class="token operator">&lt;</span><span class="token operator">/</span>scope<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>build<span class="token operator">></span>        <span class="token operator">&lt;</span>plugins<span class="token operator">></span>            <span class="token operator">&lt;</span>plugin<span class="token operator">></span>                <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>                <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>maven<span class="token operator">-</span>plugin<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>plugin<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>plugins<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>build<span class="token operator">></span></code></pre><p>启动类也删除：<br>最终：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112144248.png" style="width:50%"></p><p>在starter包下：创建HelloService<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112144726.png"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloService</span> <span class="token punctuation">{</span>    HelloProperties helloProperties<span class="token punctuation">;</span>    <span class="token keyword">public</span> HelloProperties <span class="token function">getHelloProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> helloProperties<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setHelloProperties</span><span class="token punctuation">(</span>HelloProperties helloProperties<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>helloProperties <span class="token operator">=</span> helloProperties<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">sayHelloLiuzhuo</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> helloProperties<span class="token punctuation">.</span><span class="token function">getPrefix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> helloProperties<span class="token punctuation">.</span><span class="token function">getSuffix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在starter包下：创建HelloProperties:<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112144829.png"></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"liuzhuo.hello"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloProperties</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String prefix<span class="token punctuation">;</span>    <span class="token keyword">private</span> String suffix<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getPrefix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> prefix<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPrefix</span><span class="token punctuation">(</span>String prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>prefix <span class="token operator">=</span> prefix<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getSuffix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> suffix<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSuffix</span><span class="token punctuation">(</span>String suffix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>suffix <span class="token operator">=</span> suffix<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在starter包下：创建HelloServiceAutoConfiguration:<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112145420.png"></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnWebApplication</span>    <span class="token comment" spellcheck="true">//web应用才生效</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span>HelloProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServiceAutoConfiguration</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> HelloProperties helloProperties<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> HelloService <span class="token function">helloService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        HelloService helloService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HelloService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        helloService<span class="token punctuation">.</span><span class="token function">setHelloProperties</span><span class="token punctuation">(</span>helloProperties<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> helloService<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在resources下：创建META-INF/spring.factories文件<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112145629.png" style="width:50%"></p><p>spring.factories：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112145807.png"></p><pre class=" language-java"><code class="language-java"># Auto Configureorg<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>EnableAutoConfiguration<span class="token operator">=</span>\com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>starter<span class="token punctuation">.</span>HelloServiceAutoConfiguration</code></pre><hr><p>5) 将这两个模块，导入到本地maven仓库中：</p><p>首先导入liuzhuo-spring-boot-starter-autoconfigure的依赖</p><p>因为liuzhuo-spring-boot-starter依赖于liuzhuo-spring-boot-starter-autoconfigure。</p><p>打开maven的工具窗口，点击liuzhuo-spring-boot-starter-autoconfigure模块，找到生命周期中的install。双击<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112150929.png"></p><p>liuzhuo-spring-boot-starter的导入本地仓库，类似。</p><p>6）创建新的SpringBoot的web项目，导入我们的liuzhuo-spring-boot-starter依赖，测试。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112152031.png"></p><p>导入：liuzhuo-spring-boot-starter依赖<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112152435.png"></p><pre class=" language-java"><code class="language-java">        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>导入我们的启动依赖<span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>starter<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>liuzhuo<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>starter<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">1.0</span><span class="token operator">-</span>SNAPSHOT<span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112152557.png" style="width:50%"></p><p>创建：HelloController<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112152719.png"></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    HelloService helloService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> helloService<span class="token punctuation">.</span><span class="token function">sayHelloLiuzhuo</span><span class="token punctuation">(</span><span class="token string">"jackLoveDj"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在配置文件中：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112153251.png"></p><pre class=" language-java"><code class="language-java">liuzhuo<span class="token punctuation">.</span>hello<span class="token punctuation">.</span>prefix<span class="token operator">=</span>欢迎liuzhuo<span class="token punctuation">.</span>hello<span class="token punctuation">.</span>suffix<span class="token operator">=</span>到来</code></pre><p>启动我们的应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112153346.png"></p><p>没有报错，说明我们的自动配置成功了。</p><p>在浏览器中输入：<code>http://localhost:8080/hello</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day09/QQ截图20181112153439.png"></p><hr><h3 id="更多SpringBoot整合示例"><a href="#更多SpringBoot整合示例" class="headerlink" title="更多SpringBoot整合示例"></a>更多SpringBoot整合示例</h3><p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples" target="_blank" rel="noopener">官方给出的样例代码</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_08</title>
      <link href="/2018/11/11/springboot-day-08/"/>
      <url>/2018/11/11/springboot-day-08/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot与数据访问<br><a id="more"></a></p><h2 id="JDBC-默认支持的数据源"><a href="#JDBC-默认支持的数据源" class="headerlink" title="JDBC(默认支持的数据源)"></a>JDBC(默认支持的数据源)</h2><p>1）创建新的Springboot项目，添加web模块、mysql模块、jdbc模块<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111110045.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111110143.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111110336.png"></p><p>2) 连接我们的数据库：</p><p>打开我们的虚拟机，然后启动mysql的容器<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111110542.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111110735.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111110811.png"></p><p>3）在我们的项目中，添加数据源的配置信息。</p><p>这里使用yml文件，properties文件也一样。<br>在resources下：创建application.yml文件。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111111923.png"></p><pre><code>spring:  datasource:    username: root    password: 123456    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://10.6.11.17:3306/jdbc</code></pre><p>在mysql的客户端上面，创建jdbc数据库：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111111412.png"></p><p>4）测试数据源是否配置成功<br>在test包下：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111112125.png"></p><p>效果：</p><p>默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源</p><p>数据源的相关配置都在DataSourceProperties里面。</p><pre><code>@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)public class DataSourceProperties        implements BeanClassLoaderAware, EnvironmentAware, InitializingBean {</code></pre><p>5) 自动配置的原理</p><p>org.springframework.boot.autoconfigure.jdbc：</p><p>1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用<br>spring.datasource.type指定自定义的数据源类型；</p><p>2、SpringBoot默认支持的数据源：</p><pre><code>org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource</code></pre><p>3、自定义数据源类型</p><pre><code>    /**     * Generic DataSource configuration.     */    @ConditionalOnMissingBean(DataSource.class)    @ConditionalOnProperty(name = &quot;spring.datasource.type&quot;)    static class Generic {        @Bean        public DataSource dataSource(DataSourceProperties properties) {            return properties.initializeDataSourceBuilder().build();        }    }</code></pre><p>4、自动运行sql语句的原理</p><p>DataSourceAutoConfiguration:中有一个<strong>DataSourceInitializer</strong>对象。</p><pre><code>@Configuration@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })@EnableConfigurationProperties(DataSourceProperties.class)@Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })public class DataSourceAutoConfiguration {    @Bean    @ConditionalOnMissingBean    public DataSourceInitializer dataSourceInitializer(DataSourceProperties properties,            ApplicationContext applicationContext) {        return new DataSourceInitializer(properties, applicationContext);    }  ···}</code></pre><p><strong>DataSourceInitializer：ApplicationListener</strong></p><pre><code>class DataSourceInitializer implements ApplicationListener</code></pre><p>作用：<br>1）、runSchemaScripts();运行建表语句；</p><p>2）、runDataScripts();运行插入数据的sql语句；</p><p>默认只需要将文件命名为：</p><pre><code>schema‐*.sql、data‐*.sql默认规则：schema.sql，schema‐all.sql；自定义名字：在配置文件中：   schema:      ‐ classpath:department.sql      指定位置</code></pre><p>验证：<br>在resources下：创建默认命名规则的：schema-all.sql文件：</p><pre><code>SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for department-- ----------------------------DROP TABLE IF EXISTS `department`;CREATE TABLE `department` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `departmentName` varchar(255) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111113520.png"></p><p>现在jdbc中还没有department表：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111113648.png"></p><p>运行我们的Springboot项目：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111113737.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111113833.png"></p><p>刷新jdbc数据库：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111113923.png"></p><hr><p>使用自定义的命名规则：<br>修改schema-all.sql 的名字为：department.sql<br>在application.yml文件中：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111114934.png"></p><p>删除jdbc中的department表，然后再次启动Springboot项目：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111115013.png"></p><p>5、操作数据库：Springboot自动配置了JdbcTemplate操作数据库<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111115134.png" style="width:50%"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111115401.png"></p><p>说明Springboot已经帮我们配置好了JdbcTemplate模板引擎，我们可以直接使用：<br>创建HelloController：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111120407.png"></p><pre><code>@Controllerpublic class HelloController {    @Autowired    private JdbcTemplate jdbcTemplate;    @ResponseBody    @RequestMapping(&quot;/query&quot;)    public Map&lt;String, Object&gt; queryDepartment() {        List&lt;Map&lt;String, Object&gt;&gt; mapList = jdbcTemplate.queryForList(&quot;select * from department&quot;);        //返回第一条数据        return mapList.get(0);    }}</code></pre><p>启动应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111120130.png"></p><p>打开mysql的客户端：<br>添加一条数据：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111120217.png"></p><p>打开浏览器：输入：<code>http://localhost:8080/query</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111120509.png"></p><hr><h2 id="整合Druid数据源-阿里的数据源连接池"><a href="#整合Druid数据源-阿里的数据源连接池" class="headerlink" title="整合Druid数据源(阿里的数据源连接池)"></a>整合Druid数据源(阿里的数据源连接池)</h2><p>1）导入druid的依赖</p><pre><code>        &lt;!--导入druid的数据源--&gt;        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.10&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>2) 切换数据源：<br>使用type来切换数据源<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111123613.png"></p><pre><code>spring:  datasource:    username: root    password: 123456    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://10.6.11.17:3306/jdbc    type: com.alibaba.druid.pool.DruidDataSource#    schema:#      - classpath:department.sql</code></pre><p>3) 运行测试类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111123753.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111123907.png"><br>数据源切换成功。</p><p>4）添加druid的独有配置</p><pre><code>spring:  datasource:    username: root    password: 123456    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://10.6.11.17:3306/jdbc    type: com.alibaba.druid.pool.DruidDataSource    #数据源其他配置    initialSize: 5    minIdle: 5    maxActive: 20    maxWait: 60000    timeBetweenEvictionRunsMillis: 60000    minEvictableIdleTimeMillis: 300000    validationQuery: SELECT 1 FROM DUAL    testWhileIdle: true    testOnBorrow: false    testOnReturn: false    poolPreparedStatements: true    #配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙    filters: stat,wall,log4j    maxPoolPreparedStatementPerConnectionSize: 20    useGlobalDataSourceStat: true    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500#    schema:#      - classpath:department.sql</code></pre><p>dubug一下，看是否是其他属性配置成功：</p><p>给contextLoads中的System.out.println(dataSource);打上断点<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111124326.png"></p><p>dubug运行该测试方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111124538.png"></p><p>因为我们在application配置文件中配置的：spring-datasource:开头的配置信息，都是DataSourceProperties中的</p><pre><code>@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)public class DataSourceProperties</code></pre><p>而DataSourceProperties类中，根本没有druid那些独有的配置信息：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111124846.png"></p><p>5）自己配置druid数据源</p><p>在config包下，创建MyDruidConfig类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111125255.png"></p><p>这样就能将application配置文件中的druid的独有配置信息调入到我们的druid数据源当中了。</p><p>如果没有添加@ConfigurationProperties(prefix = “spring.datasource”)的话：<br>需要自己手动一个一个的配置</p><pre><code>    @Bean    DataSource druid() {        DruidDataSource druidDataSource = new DruidDataSource();        druidDataSource.setInitialSize(5);        druidDataSource.setMaxActive(10);        ···        return druidDataSource;    }</code></pre><p>再次dubug测试方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111125737.png"></p><p>6）配置druid的监控</p><p>在MyDruidConfig类中：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//配置Druid的监控</span>    <span class="token comment" spellcheck="true">//1、配置一个管理后台的Servlet</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> ServletRegistrationBean <span class="token function">statViewServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ServletRegistrationBean bean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletRegistrationBean</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StatViewServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"/druid/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> initParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        initParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"loginUsername"</span><span class="token punctuation">,</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        initParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"loginPassword"</span><span class="token punctuation">,</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        initParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"allow"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//默认就是允许所有访问</span>        initParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"deny"</span><span class="token punctuation">,</span><span class="token string">"192.168.15.21"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不然访问</span>        bean<span class="token punctuation">.</span><span class="token function">setInitParameters</span><span class="token punctuation">(</span>initParams<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//2、配置一个web监控的filter</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> FilterRegistrationBean <span class="token function">webStatFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        FilterRegistrationBean bean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterRegistrationBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bean<span class="token punctuation">.</span><span class="token function">setFilter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WebStatFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> initParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        initParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"exclusions"</span><span class="token punctuation">,</span><span class="token string">"*.js,*.css,/druid/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//排除静态资源</span>        bean<span class="token punctuation">.</span><span class="token function">setInitParameters</span><span class="token punctuation">(</span>initParams<span class="token punctuation">)</span><span class="token punctuation">;</span>        bean<span class="token punctuation">.</span><span class="token function">setUrlPatterns</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"/*"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>启动Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/druid</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111130651.png"></p><p>输入自己配置的用户名与密码：</p><pre><code>        initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;);        initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;);</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111130816.png"></p><p>在浏览器中输入：<code>http://localhost:8080/query</code></p><p>然后点击SQL监控：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111131006.png"></p><p>点击Web应用：就是我们的配置WebAppStat List过滤器<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111131202.png"></p><p>监控成功！！！</p><hr><h2 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h2><h3 id="前期准备阶段"><a href="#前期准备阶段" class="headerlink" title="前期准备阶段"></a>前期准备阶段</h3><p>1）创建新的项目，添加web、mysql、mybatis模块：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111141702.png"></p><p>导入druid依赖：</p><pre><code>        &lt;!--导入druid的数据源--&gt;        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.10&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>2）创建application.yml文件：</p><pre class=" language-java"><code class="language-java">spring<span class="token operator">:</span>  datasource<span class="token operator">:</span>    username<span class="token operator">:</span> root    password<span class="token operator">:</span> <span class="token number">123456</span>    driver<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">-</span>name<span class="token operator">:</span> com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driver    url<span class="token operator">:</span> jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">10.6</span><span class="token punctuation">.</span><span class="token number">11.17</span><span class="token operator">:</span><span class="token number">3306</span><span class="token operator">/</span>mybatis    type<span class="token operator">:</span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DruidDataSource    #数据源其他配置    initialSize<span class="token operator">:</span> <span class="token number">5</span>    minIdle<span class="token operator">:</span> <span class="token number">5</span>    maxActive<span class="token operator">:</span> <span class="token number">20</span>    maxWait<span class="token operator">:</span> <span class="token number">60000</span>    timeBetweenEvictionRunsMillis<span class="token operator">:</span> <span class="token number">60000</span>    minEvictableIdleTimeMillis<span class="token operator">:</span> <span class="token number">300000</span>    validationQuery<span class="token operator">:</span> SELECT <span class="token number">1</span> FROM DUAL    testWhileIdle<span class="token operator">:</span> <span class="token boolean">true</span>    testOnBorrow<span class="token operator">:</span> <span class="token boolean">false</span>    testOnReturn<span class="token operator">:</span> <span class="token boolean">false</span>    poolPreparedStatements<span class="token operator">:</span> <span class="token boolean">true</span>    #配置监控统计拦截的filters，去掉后监控界面sql无法统计，<span class="token string">'wall'</span>用于防火墙    filters<span class="token operator">:</span> stat<span class="token punctuation">,</span>wall<span class="token punctuation">,</span>log4j    maxPoolPreparedStatementPerConnectionSize<span class="token operator">:</span> <span class="token number">20</span>    useGlobalDataSourceStat<span class="token operator">:</span> <span class="token boolean">true</span>    connectionProperties<span class="token operator">:</span> druid<span class="token punctuation">.</span>stat<span class="token punctuation">.</span>mergeSql<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>druid<span class="token punctuation">.</span>stat<span class="token punctuation">.</span>slowSqlMillis<span class="token operator">=</span><span class="token number">500</span>    schema<span class="token operator">:</span>      <span class="token operator">-</span> classpath<span class="token operator">:</span>sql<span class="token operator">/</span>department<span class="token punctuation">.</span>sql      <span class="token operator">-</span> classpath<span class="token operator">:</span>sql<span class="token operator">/</span>employee<span class="token punctuation">.</span>sql</code></pre><p>3) 创建新的数据库mybatis：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111142149.png"></p><p>4）在resours下：参加过sql文件夹<br>里面放入：department.sql 和 employee.sql文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111142335.png" style="width:50%"></p><p>department.sql:</p><pre><code>/*Navicat MySQL Data TransferSource Server         : 本地Source Server Version : 50528Source Host           : 127.0.0.1:3306Source Database       : restful_crudTarget Server Type    : MYSQLTarget Server Version : 50528File Encoding         : 65001Date: 2018-03-05 10:41:40*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for department-- ----------------------------DROP TABLE IF EXISTS `department`;CREATE TABLE `department` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `departmentName` varchar(255) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p>employee.sql文件:</p><pre><code>/*Navicat MySQL Data TransferSource Server         : 本地Source Server Version : 50528Source Host           : 127.0.0.1:3306Source Database       : restful_crudTarget Server Type    : MYSQLTarget Server Version : 50528File Encoding         : 65001Date: 2018-03-05 10:41:58*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for employee-- ----------------------------DROP TABLE IF EXISTS `employee`;CREATE TABLE `employee` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `lastName` varchar(255) DEFAULT NULL,  `email` varchar(255) DEFAULT NULL,  `gender` int(2) DEFAULT NULL,  `d_id` int(11) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p>5) 创建config：DruidConfig配置类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111142702.png"></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DruidConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.datasource"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Bean</span>    DataSource <span class="token function">druid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DruidDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//配置Druid的监控</span>    <span class="token comment" spellcheck="true">//1、配置一个管理后台的Servlet</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> ServletRegistrationBean <span class="token function">statViewServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ServletRegistrationBean bean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletRegistrationBean</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StatViewServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"/druid/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> initParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        initParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"loginUsername"</span><span class="token punctuation">,</span> <span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        initParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"loginPassword"</span><span class="token punctuation">,</span> <span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        initParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"allow"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//默认就是允许所有访问</span>        initParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"deny"</span><span class="token punctuation">,</span> <span class="token string">"192.168.15.21"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不然访问</span>        bean<span class="token punctuation">.</span><span class="token function">setInitParameters</span><span class="token punctuation">(</span>initParams<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//2、配置一个web监控的filter</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> FilterRegistrationBean <span class="token function">webStatFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        FilterRegistrationBean bean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterRegistrationBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bean<span class="token punctuation">.</span><span class="token function">setFilter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WebStatFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> initParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        initParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"exclusions"</span><span class="token punctuation">,</span> <span class="token string">"*.js,*.css,/druid/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//排除静态资源</span>        bean<span class="token punctuation">.</span><span class="token function">setInitParameters</span><span class="token punctuation">(</span>initParams<span class="token punctuation">)</span><span class="token punctuation">;</span>        bean<span class="token punctuation">.</span><span class="token function">setUrlPatterns</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"/*"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>6) 启动Springboot应用：</p><p>打开mysql的客户端：生成了两个表：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111142926.png"></p><p>注释掉，application配置文件中的schema：(防止再次启动应用，表又归零！)</p><pre><code>#    schema:#      - classpath:sql/department.sql#      - classpath:sql/employee.sql</code></pre><p>7）创建bean对象：</p><p>根据数据库mybatis中的两个表，创建对应的JavaBean对象。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111143428.png"></p><p>Employee：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer gender<span class="token punctuation">;</span>    <span class="token keyword">private</span> String email<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer dId<span class="token punctuation">;</span>   ··· get和set方法<span class="token punctuation">}</span></code></pre><p>Department:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Department</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String departmentName<span class="token punctuation">;</span>    ··· get和set方法<span class="token punctuation">}</span></code></pre><hr><h3 id="mybatis的使用"><a href="#mybatis的使用" class="headerlink" title="mybatis的使用"></a>mybatis的使用</h3><h4 id="注解版"><a href="#注解版" class="headerlink" title="注解版"></a>注解版</h4><p>1）创建mapper文件夹：DepartmentMapper（接口）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111145746.png"></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Mapper</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DepartmentMapper</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"select * from department where id=#{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Department <span class="token function">getDeptById</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Delete</span><span class="token punctuation">(</span><span class="token string">"delete from department where id=#{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">deleteDeptById</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//回显主键的id。</span>    <span class="token annotation punctuation">@Options</span><span class="token punctuation">(</span>useGeneratedKeys <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> keyProperty <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Insert</span><span class="token punctuation">(</span><span class="token string">"insert into department(departmentName) values(#{departmentName})"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">insertDept</span><span class="token punctuation">(</span>Department department<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Update</span><span class="token punctuation">(</span><span class="token string">"update department set departmentName=#{departmentName} where id=#{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">updateDept</span><span class="token punctuation">(</span>Department department<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2) 创建一个DepartmentController：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111150310.png"></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DepartmentController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> DepartmentMapper departmentMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/dept/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Department <span class="token function">findDepartmentById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> departmentMapper<span class="token punctuation">.</span><span class="token function">getDeptById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/dept"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Department <span class="token function">addDepartment</span><span class="token punctuation">(</span>Department department<span class="token punctuation">)</span> <span class="token punctuation">{</span>        departmentMapper<span class="token punctuation">.</span><span class="token function">insertDept</span><span class="token punctuation">(</span>department<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> department<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3) 启动Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/dept/1</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111151409.png"></p><p>在浏览器中输入：<code>http://localhost:8080/dept?departmentName=aa</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111151555.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111151633.png"></p><p>问题：</p><p>我们将mysql中的departmentName改为：department_name.<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111151808.png"></p><p>修改我们的DepartmentMapper中的departmentName为：department_name。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111151946.png"></p><p>再次启动Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/dept?departmentName=bb</code></p><p>如果你的mybat的依赖版本的1.3.2以上，会执行成功，因为默认支持驼峰命名了。如果失败的话，我们需要自定义mybatis的规则：</p><p>创建MybatisConfig配置类:<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111152708.png"></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MybatisConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> ConfigurationCustomizer <span class="token function">customizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConfigurationCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">customize</span><span class="token punctuation">(</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span>Configuration configuration<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//使用驼峰命名规则</span>                configuration<span class="token punctuation">.</span><span class="token function">setMapUnderscoreToCamelCase</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>或者使用在配置文件中，配置驼峰命名规则。</p><hr><p>4）扫描多个mapper类：</p><p>在配合类上面加上：<br>@MapperScan(value = “com.liuzhuo.springboot.mapper”)</p><pre class=" language-java"><code class="language-java">使用MapperScan批量扫描所有的Mapper接口；<span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"com.liuzhuo.springboot.mapper"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringBoot06DataMybatisApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>          SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>SpringBoot06DataMybatisApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>这样，我们就不必须要在每个mapper类上，加@Mapper注解了</p><h4 id="配置文件版"><a href="#配置文件版" class="headerlink" title="配置文件版"></a>配置文件版</h4><p>1）创建EmployeeMapper接口：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111154909.png"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//必须使用@Mapper或者@MapperScan。二者其一即可</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EmployeeMapper</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Employee <span class="token function">findEmplById</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertEmpl</span><span class="token punctuation">(</span>Employee employee<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2) 创建mybatis的全局配置文件：</p><p>在resours下创建mybatis/mapper文件夹：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111155138.png" style="width:50%"></p><p>在mybatis文件夹下，创建mybatis的全局配置文件：<br>不会写的话，看mybatis的官网文档，mybatis已经被整合到github上面：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111155348.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111155424.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111155456.png"></p><p><a href="http://www.mybatis.org/mybatis-3/" target="_blank" rel="noopener">mybatis-3的官方文档</a></p><p>其中的什么数据源，mapper的文件扫描，我们全部删除，我们已经使用application.yml文件配置了。</p><p>最终mybatis-config.xml：</p><p>就设置了一个使用驼峰命名法</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span> <span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE configuration        PUBLIC <span class="token string">"-//mybatis.org//DTD Config 3.0//EN"</span>        <span class="token string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span><span class="token operator">></span><span class="token operator">&lt;</span>configuration<span class="token operator">></span><span class="token operator">&lt;</span>settings<span class="token operator">></span>    <span class="token operator">&lt;</span>setting name<span class="token operator">=</span><span class="token string">"mapUnderscoreToCamelCase"</span> value<span class="token operator">=</span><span class="token string">"true"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>settings<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>configuration<span class="token operator">></span></code></pre><p>3）创建mapper.xml文件：</p><p>在mapper文件夹下，创建employee-mapper.xml<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111160017.png" style="width:50%"></p><p>文件不会写，看官方文档：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111160123.png"></p><p>最终employee-mapper.xml：</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span> <span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE mapper        PUBLIC <span class="token string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>        <span class="token string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span><span class="token operator">></span><span class="token operator">&lt;</span>mapper namespace<span class="token operator">=</span><span class="token string">"com.liuzhuo.springboot.mapper.EmployeeMapper"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>        <span class="token keyword">public</span> Employee <span class="token function">findEmplById</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> Employee <span class="token function">insertEmpl</span><span class="token punctuation">(</span>Employee employee<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">"findEmplById"</span> resultType<span class="token operator">=</span><span class="token string">"com.liuzhuo.springboot.bean.Employee"</span><span class="token operator">></span>        select <span class="token operator">*</span> from employee where id <span class="token operator">=</span> #<span class="token punctuation">{</span>id<span class="token punctuation">}</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">></span>    <span class="token operator">&lt;</span>insert id<span class="token operator">=</span><span class="token string">"insertEmpl"</span> <span class="token operator">></span>        INSERT INTO <span class="token function">employee</span><span class="token punctuation">(</span>lastName<span class="token punctuation">,</span>email<span class="token punctuation">,</span>gender<span class="token punctuation">,</span>d_id<span class="token punctuation">)</span> <span class="token function">VALUES</span> <span class="token punctuation">(</span>#<span class="token punctuation">{</span>lastName<span class="token punctuation">}</span><span class="token punctuation">,</span>#<span class="token punctuation">{</span>email<span class="token punctuation">}</span><span class="token punctuation">,</span>#<span class="token punctuation">{</span>gender<span class="token punctuation">}</span><span class="token punctuation">,</span>#<span class="token punctuation">{</span>dId<span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>insert<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>mapper<span class="token operator">></span></code></pre><p>4) 在application.yml文件中，制定全局mybatis.xml和mapper.xml的映射：</p><pre class=" language-java"><code class="language-java">mybatis<span class="token operator">:</span>  config<span class="token operator">-</span>location<span class="token operator">:</span> classpath<span class="token operator">:</span>mybatis<span class="token operator">/</span>mybatis<span class="token operator">-</span>config<span class="token punctuation">.</span>xml 指定全局配置文件的位置  mapper<span class="token operator">-</span>locations<span class="token operator">:</span> classpath<span class="token operator">:</span>mybatis<span class="token operator">/</span>mapper<span class="token operator">/</span><span class="token operator">*</span><span class="token punctuation">.</span>xml 指定sql映射文件的位置</code></pre><p>5) 创建EmployeeController：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111161700.png"></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmployeeController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> EmployeeMapper employeeMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/empl/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Employee <span class="token function">findEmplById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> employeeMapper<span class="token punctuation">.</span><span class="token function">findEmplById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/empl"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Employee <span class="token function">insertEmpl</span><span class="token punctuation">(</span>Employee employee<span class="token punctuation">)</span> <span class="token punctuation">{</span>        employeeMapper<span class="token punctuation">.</span><span class="token function">insertEmpl</span><span class="token punctuation">(</span>employee<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> employee<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>6) 启动Springboot应用</p><p>在浏览器中输入：<code>http://localhost:8080/empl/1</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111161941.png"></p><p>在浏览器中输入：<code>http://localhost:8080/empl?lastName=jack&amp;&amp;email=4324324@qq.com&amp;&amp;gender=1&amp;&amp;dId=2</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111163225.png"></p><p>再次浏览器中输入：<code>http://localhost:8080/empl/1</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111163307.png"></p><p>最主要的就是在application配置文件中：</p><pre class=" language-java"><code class="language-java">mybatis<span class="token operator">:</span>  config<span class="token operator">-</span>location<span class="token operator">:</span> classpath<span class="token operator">:</span>mybatis<span class="token operator">/</span>mybatis<span class="token operator">-</span>config<span class="token punctuation">.</span>xml  mapper<span class="token operator">-</span>locations<span class="token operator">:</span> classpath<span class="token operator">:</span>mybatis<span class="token operator">/</span>mapper<span class="token operator">/</span><span class="token operator">*</span><span class="token punctuation">.</span>xml</code></pre><p>更多使用参照:<br><a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">mybatis-spring-boot-autoconfigure</a></p><hr><h2 id="整合SpringData-JPA"><a href="#整合SpringData-JPA" class="headerlink" title="整合SpringData JPA"></a>整合SpringData JPA</h2><h3 id="SpringData简介"><a href="#SpringData简介" class="headerlink" title="SpringData简介"></a>SpringData简介</h3><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111165834.png"></p><h3 id="整合SpringData-JPA-1"><a href="#整合SpringData-JPA-1" class="headerlink" title="整合SpringData JPA"></a>整合SpringData JPA</h3><p>JPA:ORM（Object Relational Mapping）</p><p>1）创建新的Springboot项目，添加web、mysql、jpa模块：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111170202.png"></p><p>2）在application.yml配置文件中：</p><pre class=" language-java"><code class="language-java">spring<span class="token operator">:</span>  datasource<span class="token operator">:</span>    username<span class="token operator">:</span> root    password<span class="token operator">:</span> <span class="token number">123456</span>    driver<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">-</span>name<span class="token operator">:</span> com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driver    url<span class="token operator">:</span> jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">10.6</span><span class="token punctuation">.</span><span class="token number">11.17</span><span class="token operator">:</span><span class="token number">3306</span><span class="token operator">/</span>jpa  jpa<span class="token operator">:</span>#  自动创建数据库的表    hibernate<span class="token operator">:</span>      ddl<span class="token operator">-</span>auto<span class="token operator">:</span> update#  显示sql语句    show<span class="token operator">-</span>sql<span class="token operator">:</span> <span class="token boolean">true</span></code></pre><p>3) 在mysql客户端中创建jpa数据库：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111170624.png"></p><p>4）<strong>编写一个实体类（bean）和数据表进行映射，并且配置好映射关系</strong></p><p>在bean包下，创建User类:<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111171609.png"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//使用JPA注解配置映射关系</span><span class="token annotation punctuation">@Entity</span>  <span class="token comment" spellcheck="true">//表明是一个实体与数据库中的某个表对应的注解</span><span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"t_user"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//表示User类与t_user表对象，不写的话，默认就类名小写的表名</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span> <span class="token comment" spellcheck="true">//这是一个主键：javax.persistence.Id;</span>    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> GenerationType<span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//自增主键</span>    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"last_name"</span><span class="token punctuation">,</span> length <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//这是和数据表对应的一个列</span>    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Column</span> <span class="token comment" spellcheck="true">//省略默认列名就是属性名</span>    <span class="token keyword">private</span> String email<span class="token punctuation">;</span>   ····get和set方法<span class="token punctuation">}</span></code></pre><p>5）编写一个Dao接口来操作实体类对应的数据表（Repository）：</p><p>继承JpaRepository类就行：&lt;T,U&gt;: T : 实体类， U : 主键类型<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111171846.png"></p><p>6）基本的配置（JpaProperties）</p><pre class=" language-java"><code class="language-java">spring<span class="token operator">:</span>  jpa<span class="token operator">:</span>    hibernate<span class="token operator">:</span>#     更新或者创建数据表结构      ddl‐auto<span class="token operator">:</span> update#    控制台显示SQL    show‐sql<span class="token operator">:</span> <span class="token boolean">true</span></code></pre><p>7) 编写UserController类<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111172435.png"></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserRepository userRepository<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> User <span class="token function">findUserById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> userRepository<span class="token punctuation">.</span><span class="token function">findOne</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> user<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> User <span class="token function">insertUser</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        User save <span class="token operator">=</span> userRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> save<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>8) 启动Springboot应用：<br>打开mysql的客户端：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111172613.png"><br>自动帮我们创建了t_user表</p><p>在浏览器中输入：<code>http://localhost:8080/user/1</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111172801.png"></p><p>在浏览器中输入：<code>http://localhost:8080/user?lastName=zhangsan&amp;email=89028394@qq.com</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111172917.png"></p><p>控制台：（打印出了sql语句）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111173008.png"></p><p>mysql客户端：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day08/QQ截图20181111173129.png"></p><p>其他博客：</p><p><a href="https://blog.csdn.net/oChangWen/article/details/52788274?locationNum=3" target="_blank" rel="noopener">https://blog.csdn.net/oChangWen/article/details/52788274?locationNum=3</a></p><p><a href="https://blog.csdn.net/suo082407128/article/details/60963161" target="_blank" rel="noopener">https://blog.csdn.net/suo082407128/article/details/60963161</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_07</title>
      <link href="/2018/11/09/springboot-day-07/"/>
      <url>/2018/11/09/springboot-day-07/</url>
      
        <content type="html"><![CDATA[<p>今天，学习Docker的相关知识，后续会出Docker的完整讲解教程。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Docker</strong>是一个开源的应用容器引擎；是一个轻量级容器技术；</p><p>Docker支持将软件编译成一个镜像；然后在镜像中将各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；</p><p>运行中的这个镜像称为容器，容器启动是非常快速的。</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109095615.png" style="width:50%;heigth:50%"></p><hr><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109095947.png"></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；</p><p>docker客户端(Client)：连接docker主机进行操作；</p><p>docker仓库(Registry)：用来保存各种打包好的软件镜像；</p><p>docker镜像(Images)：软件打包好的镜像；放在docker仓库中；</p><p>docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109100109.png"></p><p>使用Docker的步骤：</p><p>1）、安装Docker</p><p>2）、去Docker仓库找到这个软件对应的镜像；</p><p>3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；</p><p>4）、对容器的启动停止就是对软件的启动停止；</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><h3 id="安装linux虚拟机"><a href="#安装linux虚拟机" class="headerlink" title="安装linux虚拟机"></a>安装linux虚拟机</h3><p>因为，以后的服务器都是部署在linux上面的，所以我们需要使用linux虚拟机来学习Docker</p><p>1）VMWare、VirtualBox（安装）。</p><p>VMWare虚拟机：比较重量级，而且是收费的，可以破解。</p><p>VirtualBox：轻量级，免费。</p><p>大家，如果没有，提供一个软件的百度云给大家。<a href="https://pan.baidu.com/s/1K8J6ThB1ecpDoZU5IYRGDQ" target="_blank" rel="noopener">软件安装</a>，密码：0zeo</p><p>下载之后，打开<strong>软件</strong>的目录：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109101823.png"></p><p>双击VirtualBox-5.1.26-117224-Win.exe.(安装linux虚拟机)</p><p>2）导入虚拟机文件centos7-atguigu.ova</p><p>打开虚拟机界面，点击管理：导入虚拟电脑。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109102440.png" style="width:50%"><br><strong>一定要 勾选重新初始化所有的网卡的MAC地址</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109102555.png" style="width:50%"><br>导入成功后：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109102748.png"></p><p>3）双击启动linux虚拟机;使用 root/ 123456登陆</p><p>会出现未能启动虚拟电脑，由于物理网卡未找到：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109103253.png" style="width:50%"></p><p>点击更改网络设置：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109103407.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109103712.png"></p><p>设置完毕后，虚拟机自动启动：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109103900.png"></p><p>输入用户名：root，密码：123456<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109104044.png"></p><p>此时，已经登入成功了。</p><p>4）使用客户端连接linux服务器进行命令操作</p><p>为了操作方便，我们可以使用linux的客户端来远程操作linux虚拟机。</p><p>安装软件目录下的：SmarTTY-2.2.msi<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109104240.png"></p><p>安装完毕后，启动程序：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109104615.png"></p><p>点击创建新的SSH连接：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109104656.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109104916.png"></p><p>虚拟机的ip地址：<br>在虚拟机中输入：</p><pre><code>ip addr</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109105352.png"></p><p>查看本地的ip地址：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109105439.png"></p><p><strong>发现是在一个网络里面，正确！！！</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109105639.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109105717.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181109105735.png"></p><p>到此，linux客户端连接成功，此时注意不要关闭linux的服务器。</p><h3 id="在linux虚拟机上安装docker"><a href="#在linux虚拟机上安装docker" class="headerlink" title="在linux虚拟机上安装docker"></a>在linux虚拟机上安装docker</h3><p>首先启动虚拟机：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110095216.png"><br>输入用户名和密码：root/123456<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110095348.png"><br>查看ip地址：<br><code>ip addr</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110095509.png"><br>ip地址没有变的话，直接使用我们的linux客户端连接：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110095639.png"><br>输入密码：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110095732.png"><br>连接成功：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110095759.png"></p><hr><p><strong>现在开始在linux上安装docker。</strong></p><p>步骤：</p><p>1）检查虚拟机的内核版本，必须是3.10及以上<br><code>uname ‐r</code></p><pre><code>[root@localhost ~]# uname -r3.10.0-327.el7.x86_64[root@localhost ~]# </code></pre><p>我当前的版本是：3.10.0-327.el7.x86_64</p><p>如果你的不是，那就必须升级内核：<br><code>yum update</code></p><p>2) 安装docker(必须联网)<br><code>yum install docker</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110100256.png"></p><p>3）输入y确认安装<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110100405.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110101217.png"><br><strong>出现Complete，表示安装完成！</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110101347.png"></p><p>4）启动docker<br><code>systemctl start docker</code></p><pre><code>[root@localhost ~]# systemctl start docker</code></pre><p>查看docker的版本：<br><code>docker -v</code></p><pre><code>[root@localhost ~]# docker -vDocker version 1.13.1, build 8633870/1.13.1</code></pre><p>5) linux开机就启动docker<br><code>systemctl enable docker</code></p><pre><code>[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</code></pre><p>6) 停止docker<br><code>systemctl stop docker</code></p><h2 id="Docker常用命令-amp-操作"><a href="#Docker常用命令-amp-操作" class="headerlink" title="Docker常用命令&amp;操作"></a>Docker常用命令&amp;操作</h2><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110102850.png"></p><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">官方的docker仓库</a></p><p><font color="red"><strong>如果在启动的时候，出现问题</strong></font></p><pre><code>[root@localhost ~]# systemctl start dockerJob for docker.service failed because the control process exited with error code. See &quot;systemctl status docker.service&quot; and &quot;journalctl -xe&quot; for details.</code></pre><p>然后根据提示进行systemctl status docker.service，打印出相关的日志：</p><pre><code>[root@localhost ~]# systemctl status docker.service● docker.service - Docker Application Container Engine   Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)   Active: failed (Result: exit-code) since Fri 2018-04-27 21:25:13 EDT; 3min 32s ago     Docs: http://docs.docker.com  Process: 2390 ExecStart=/usr/bin/dockerd-current --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current --default-runtime=docker-runc --exec-opt native.cgroupdriver=systemd --userland-proxy-path=/usr/libexec/docker/docker-proxy-current --seccomp-profile=/etc/docker/seccomp.json $OPTIONS $DOCKER_STORAGE_OPTIONS $DOCKER_NETWORK_OPTIONS $ADD_REGISTRY $BLOCK_REGISTRY $INSECURE_REGISTRY $REGISTRIES (code=exited, status=1/FAILURE) Main PID: 2390 (code=exited, status=1/FAILURE)Apr 27 21:25:12 localhost.localdomain systemd[1]: Starting Docker Application Container Engine...Apr 27 21:25:12 localhost.localdomain dockerd-current[2390]: time=&quot;2018-04-27T21:25:12.286650644-04:00&quot; level=warning msg=&quot;could no...ound&quot;Apr 27 21:25:12 localhost.localdomain dockerd-current[2390]: time=&quot;2018-04-27T21:25:12.295209148-04:00&quot; level=info msg=&quot;libcontaine...2395&quot;Apr 27 21:25:13 localhost.localdomain dockerd-current[2390]: time=&quot;2018-04-27T21:25:13.310268309-04:00&quot; level=warning msg=&quot;overlay2: the...Apr 27 21:25:13 localhost.localdomain dockerd-current[2390]: Error starting daemon: SELinux is not supported with the overlay2 grap...alseApr 27 21:25:13 localhost.localdomain systemd[1]: docker.service: main process exited, code=exited, status=1/FAILUREApr 27 21:25:13 localhost.localdomain systemd[1]: Failed to start Docker Application Container Engine.Apr 27 21:25:13 localhost.localdomain systemd[1]: Unit docker.service entered failed state.Apr 27 21:25:13 localhost.localdomain systemd[1]: docker.service failed.Hint: Some lines were ellipsized, use -l to show in full.</code></pre><p>其中：<code>Error starting daemon: SELinux is not supported with the overlay2 grap...alse</code></p><p>这是由于overlay2不支持造成的，所以我们要关闭它。</p><p>重新编辑docker配置文件：</p><p><code>vi /etc/sysconfig/docker</code></p><p>可以进行以下配置：</p><p>OPTIONS=’–selinux-enabled<strong>=false</strong>  –log-driver=journald –signature-verification=false’</p><p>将–selinux-enabled后面添加 =false 即可。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110112203.png"></p><p>vi编辑器，使用i进入编辑状态，修改后：Esc，然后冒号：wq，保存退出。</p><p>然后进行重启操作：</p><p><code>systemctl  restart  docker</code></p><p>自此，Docker启动成功！</p><hr><p>我们以mysql为例：</p><p>1）查询mysql的镜像：<code>docker search mysql</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110112521.png"></p><p>INDEX：代表镜像的索引</p><p>NAME：镜像的名字</p><p>DESCRIPTION：镜像的描述信息</p><p>STARS：镜像被采纳的次数</p><p>OFFICIAL：是否官方（[OK]：官方，不写：非官方）</p><p>AUTOMATED：是否自动配置（[OK]：自动配置，不写：非自动配置）</p><p>这里搜索的镜像和官方<code>https://hub.docker.com/</code>上面搜索的一样：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110112948.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110113105.png"></p><p>2）下载mysql镜像：<code>docker pull mysql</code>(默认下载最近的版本)<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110115418.png"></p><p>如果下载镜像很慢，可以使用阿里云的镜像加速度：<br><a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">登入阿里云</a><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110115602.png"></p><p>将其中的加速器地址，配置到/etc/docker/daemon.json中，然后重启docker</p><p>vi /etc/docker/daemon.json<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110115926.png"><br>重启docker：systemctl restart docker<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110120138.png"></p><hr><p>如果后面没有加tag，默认是下载最新的版本：latest。</p><p>如果想要下载其他版本，在官网上面查看自己想要下载的版本的tag：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110114140.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110114057.png"><br>比如想要下载5.6版本的mysql：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110114239.png"></p><p><code>docker pull mysql:5.6</code></p><p>3) 查看本地的镜像：<code>docker images</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110192115.png"><br>能发现，我们刚刚下载好的两个版本的mysql镜像</p><p>4) 删除镜像：<code>docker rmi image_id</code></p><p>其中的image_id：镜像的唯一id.</p><p>删除mysql：5.6的镜像：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110194611.png"><br>查看剩余的镜像：（只剩下最新版本的mysql镜像）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110194728.png"></p><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p>软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）；<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110194920.png"><br><a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">更多命令</a></p><p>现在，我们以Tomcat为例来操作演示：</p><p>1）搜索镜像</p><pre><code>[root@localhost ~]# docker search tomcat</code></pre><p>2) 拉取镜像</p><pre><code>[root@localhost ~]# docker pull tomcat</code></pre><p>3) 根据镜像启动容器(第一次启动)</p><p><code>docker run ‐‐name mytomcat ‐d tomcat:latest</code></p><pre><code>--name:自己定义的容器名字，随便写。-d:后台运行</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110200332.png"></p><p>4）查看<strong>运行中</strong>的容器</p><p><code>docker ps</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110200655.png"></p><p>5) 停止运行中的容器</p><p><code>docker stop  容器的id或自定义的名字</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110200858.png"></p><p>6) 查看所有的容器（运行或者不运行）</p><p><code>docker ps ‐a</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110201121.png"></p><p>7) 启动（暂停的）容器</p><p><code>docker start 容器id</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110201246.png"></p><p>8）删除一个容器</p><p><code>docker rm 容器id</code></p><p>注意删除镜像是 ：rmi</p><p><strong>而且删除容器之前，先要停止容器的运行！！！</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110201454.png"></p><p>9）启动一个做了端口映射的tomcat</p><p><code>docker run ‐d ‐p 8888:8080 tomcat:latest</code></p><p>-d：后台运行<br>-p：将主机的端口映射到容器中的一个端口　　主机端口：容器内部的端口</p><p>为了演示简单关闭了linux的防火墙。</p><p>service firewalld status ：查看防火墙状态</p><p>service firewalld stop：关闭防火墙</p><p>如果不映射端口号的话，启动容器，访问Tomcat的主页，是没有作用的：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110201808.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110202000.png"></p><p>发现无法访问Tomcat，因为我们只能访问到虚拟机上面的docker，不能直接访问到docker中的Tomcat，所以需要端口号映射。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110202325.png"></p><p>在浏览器中访问：<code>http://10.6.11.17:8888/</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110202506.png"></p><p>Tomcat访问成功！！！</p><p>我们也可以使用一个Tomcat镜像，开启多个Tomcat容器。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110202657.png"><br>又开启了，8887和8889端口号映射的Tomcat容器。</p><p>在浏览器中输入：<code>http://10.6.11.17:8887/</code> 和 <code>http://10.6.11.17:8889/</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110202836.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110202848.png"></p><p>10）查看容器的日志</p><p><code>docker logs container_name/container_id</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110203052.png"></p><hr><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>安装以后学习时，需要的镜像。</p><h3 id="安装MySQL示例"><a href="#安装MySQL示例" class="headerlink" title="安装MySQL示例"></a>安装MySQL示例</h3><pre><code>docker pull mysql</code></pre><p>错误的启动:</p><pre><code>[root@localhost ~]# docker run ‐‐name mysql01 ‐d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps ‐aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS          NAMES42f09819908b        mysql               &quot;docker‐entrypoint.sh&quot;   34 seconds ago      Exited(1) 33 seconds ago                   mysql01//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD andMYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个</code></pre><p>查看官网：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110205133.png"></p><p>正确的启动：</p><pre><code>[root@localhost ~]# docker run ‐‐name mysql01 ‐e MYSQL_ROOT_PASSWORD=123456 ‐d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS             PORTS               NAMESb874c56bec49        mysql               &quot;docker‐entrypoint.sh&quot;   4 seconds ago       Up 3seconds        3306/tcp            mysql01</code></pre><p>打开mysql的客户端（navicat）：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110205647.png"><br>点击：连接测试：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110205718.png"></p><p>这是因为，我们没有做端口号映射：(‐p 3306:3306)</p><pre><code>[root@localhost ~]# docker run ‐p 3306:3306 ‐‐name mysql02 ‐e MYSQL_ROOT_PASSWORD=123456 ‐d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS             PORTS                    NAMESad10e4bc5c6a        mysql               &quot;docker‐entrypoint.sh&quot;   4 seconds ago       Up 2seconds        0.0.0.0:3306‐&gt;3306/tcp   mysql02</code></pre><p>这里将虚拟机linux的3306端口映射到docker容器的3306端口。</p><p>再次尝试：mysql的客户端打开，连接我们的mysql。</p><p>如果你是mysql安装的是8.0以上的版本：会出现2059 - authentication plugin ‘caching_sha2_password’ -navicat连接异常。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110213957.png"></p><p>这个错误的原因是由于MySQL8.0之后的加密规则为caching_sha2_password.而在此之前的加密规则为mysql_native_password。</p><p>可以将加密规则改成mysql_native_password来。</p><p>解决方案：</p><p>1）进入mysql容器</p><pre><code>docker exec -it 容器的id或容器的名字 /bin/bash</code></pre><p>必须在mysql启动的时候：输入上面的命令。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110214454.png"></p><p>2）进入mysql：</p><pre><code>mysql -u用户名 -p密码比如：mysql -uroot -p123456</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110214906.png"></p><p>3）修改密码的加密方式：</p><pre><code>ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;这里的password：写你自己想要定制的密码：比如：ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110215258.png"></p><p>4）执行命令flush privileges使权限配置项立即生效</p><pre><code>flush privileges;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110215401.png"></p><p>以上就修改密码的加密方式。</p><hr><p>再次测试我们的mysql客户端连接：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day07/QQ截图20181110215450.png"></p><p>现在退出我们的容器：<br>使用：Ctrl+p+q</p><hr><p>几个其他的高级操作：(官网上面都有介绍)</p><pre><code>docker run ‐‐name mysql03 ‐v /conf/mysql:/etc/mysql/conf.d ‐e MYSQL_ROOT_PASSWORD=my‐secret‐pw ‐d mysql:tag把主机的/conf/mysql文件夹挂载到  mysqldocker容器的/etc/mysql/conf.d文件夹里面该mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run ‐‐name some‐mysql ‐e MYSQL_ROOT_PASSWORD=my‐secret‐pw ‐d mysql:tag ‐‐character‐set‐server=utf8mb4 ‐‐collation‐server=utf8mb4_unicode_ci指定mysql的一些配置参数：utf-8的编码</code></pre><h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><p>自行完成</p><h3 id="安装rabbitmq"><a href="#安装rabbitmq" class="headerlink" title="安装rabbitmq"></a>安装rabbitmq</h3><p>自行完成</p><h3 id="安装elasticsearch"><a href="#安装elasticsearch" class="headerlink" title="安装elasticsearch"></a>安装elasticsearch</h3><p>自行完成</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_06</title>
      <link href="/2018/11/08/springboot-day-06/"/>
      <url>/2018/11/08/springboot-day-06/</url>
      
        <content type="html"><![CDATA[<p>今天，继续Web的开发，错误处理机制、配置嵌入式Servlet容器、使用外置的Servlet容器。</p><h2 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h2><h3 id="SpringBoot默认的错误处理机制"><a href="#SpringBoot默认的错误处理机制" class="headerlink" title="SpringBoot默认的错误处理机制"></a>SpringBoot默认的错误处理机制</h3><p>默认效果：</p><p>1）浏览器，返回一个默认的错误页面</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108101934.png"></p><p>浏览器发送请求的请求头:</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108102024.png"></p><p>2) 如果是其他客户端，默认响应一个json数据</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108102057.png"></p><p>其他客户端发送请求的请求头:</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108102135.png"></p><p><strong>原理：</strong></p><p>可以参照 <strong>ErrorMvcAutoConfiguration</strong> ：错误处理的自动配置.</p><p>给容器中添加了以下组件:</p><p>1、DefaultErrorAttributes：</p><pre class=" language-java"><code class="language-java">帮我们在页面共享信息；<span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">getErrorAttributes</span><span class="token punctuation">(</span>RequestAttributes requestAttributes<span class="token punctuation">,</span>    <span class="token keyword">boolean</span> includeStackTrace<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> errorAttributes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            errorAttributes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"timestamp"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">addStatus</span><span class="token punctuation">(</span>errorAttributes<span class="token punctuation">,</span> requestAttributes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">addErrorDetails</span><span class="token punctuation">(</span>errorAttributes<span class="token punctuation">,</span> requestAttributes<span class="token punctuation">,</span> includeStackTrace<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">addPath</span><span class="token punctuation">(</span>errorAttributes<span class="token punctuation">,</span> requestAttributes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> errorAttributes<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>2、BasicErrorController：处理默认/error请求</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"${server.error.path:${error.path:/error}}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BasicErrorController</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractErrorController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>produces <span class="token operator">=</span> <span class="token string">"text/html"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//产生html类型的数据；浏览器发送的请求来到这个方法处理</span>    <span class="token keyword">public</span> ModelAndView <span class="token function">errorHtml</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span>HttpServletResponse response<span class="token punctuation">)</span> <span class="token punctuation">{</span>                  HttpStatus status <span class="token operator">=</span> <span class="token function">getStatus</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>                Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> model <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">unmodifiableMap</span><span class="token punctuation">(</span><span class="token function">getErrorAttributes</span><span class="token punctuation">(</span>                request<span class="token punctuation">,</span> <span class="token function">isIncludeStackTrace</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> MediaType<span class="token punctuation">.</span>TEXT_HTML<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//去哪个页面作为错误页面；包含页面地址和页面内容</span>        ModelAndView modelAndView <span class="token operator">=</span> <span class="token function">resolveErrorView</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> status<span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span>modelAndView <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span> <span class="token operator">:</span> modelAndView<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token annotation punctuation">@RequestMapping</span>        <span class="token annotation punctuation">@ResponseBody</span>    <span class="token comment" spellcheck="true">//产生json数据，其他客户端来到这个方法处理；</span>    <span class="token keyword">public</span> ResponseEntity<span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">>></span> <span class="token function">error</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> body <span class="token operator">=</span> <span class="token function">getErrorAttributes</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span>                <span class="token function">isIncludeStackTrace</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> MediaType<span class="token punctuation">.</span>ALL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        HttpStatus status <span class="token operator">=</span> <span class="token function">getStatus</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">>></span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> </code></pre><p>3、ErrorPageCustomizer：发送默认/error请求</p><pre class=" language-java"><code class="language-java"><span class="token function">Value</span><span class="token punctuation">(</span><span class="token string">"${error.path:/error}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String path <span class="token operator">=</span> <span class="token string">"/error"</span><span class="token punctuation">;</span>  系统出现错误以后，来到error请求进行处理；（web<span class="token punctuation">.</span>xml注册的错误页面规则）</code></pre><p>4、DefaultErrorViewResolver：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> ModelAndView <span class="token function">resolveErrorView</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpStatus status<span class="token punctuation">,</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> model<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    ModelAndView modelAndView <span class="token operator">=</span> <span class="token function">resolve</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>modelAndView <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> SERIES_VIEWS<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">series</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                modelAndView <span class="token operator">=</span> <span class="token function">resolve</span><span class="token punctuation">(</span>SERIES_VIEWS<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">series</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token keyword">return</span> modelAndView<span class="token punctuation">;</span>             <span class="token punctuation">}</span>     <span class="token keyword">private</span> ModelAndView <span class="token function">resolve</span><span class="token punctuation">(</span>String viewName<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> model<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//默认SpringBoot可以去找到一个页面？  error/404</span>        String errorViewName <span class="token operator">=</span> <span class="token string">"error/"</span> <span class="token operator">+</span> viewName<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//模板引擎可以解析这个页面地址就用模板引擎解析</span>        TemplateAvailabilityProvider provider <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>templateAvailabilityProviders                <span class="token punctuation">.</span><span class="token function">getProvider</span><span class="token punctuation">(</span>errorViewName<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>provider <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//模板引擎可用的情况下返回到errorViewName指定的视图地址</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span>errorViewName<span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面   error/404.html</span>        <span class="token keyword">return</span> <span class="token function">resolveResource</span><span class="token punctuation">(</span>errorViewName<span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span></code></pre><p><strong>步骤：</strong></p><p>一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error<br>请求；就会被BasicErrorController处理；</p><p>响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> ModelAndView <span class="token function">resolveErrorView</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span>      HttpServletResponse response<span class="token punctuation">,</span> HttpStatus status<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> model<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//所有的ErrorViewResolver得到ModelAndView</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ErrorViewResolver resolver <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>errorViewResolvers<span class="token punctuation">)</span> <span class="token punctuation">{</span>      ModelAndView modelAndView <span class="token operator">=</span> resolver<span class="token punctuation">.</span><span class="token function">resolveErrorView</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> status<span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>modelAndView <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> modelAndView<span class="token punctuation">;</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="如果定制错误响应"><a href="#如果定制错误响应" class="headerlink" title="如果定制错误响应"></a>如果定制错误响应</h3><h4 id="如何定制错误的页面"><a href="#如何定制错误的页面" class="headerlink" title="如何定制错误的页面"></a>如何定制错误的页面</h4><p>1) <strong>有模板引擎的情况下</strong></p><p>将错误页面命名为 : 错误状态码.html , 放在模板引擎文件夹里面的error文件夹下，发生此状态码的错误就会来到 对应的页面；</p><p>我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）；</p><p>页面能获取的信息:</p><ol><li>timestamp：时间戳</li><li>status：状态码</li><li>error：错误提示</li><li>exception：异常对象</li><li>message：异常消息</li><li>errors：JSR303数据校验的错误都在这里</li></ol><p>2) 没有模板引擎（模板引擎找不到这个错误页面），在静态资源文件夹下找</p><p>3) 以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面</p><pre><code>        private final SpelView defaultErrorView = new SpelView(                &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;&quot;                        + &quot;&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;&quot;                        + &quot;&lt;div id=&#39;created&#39;&gt;${timestamp}&lt;/div&gt;&quot;                        + &quot;&lt;div&gt;There was an unexpected error (type=${error}, status=${status}).&lt;/div&gt;&quot;                        + &quot;&lt;div&gt;${message}&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;);        @Bean(name = &quot;error&quot;)        @ConditionalOnMissingBean(name = &quot;error&quot;)        public View defaultErrorView() {            return this.defaultErrorView;        }</code></pre><h4 id="如何定制错误的json数据"><a href="#如何定制错误的json数据" class="headerlink" title="如何定制错误的json数据"></a>如何定制错误的json数据</h4><p>1) 自定义异常处理&amp;返回定制json数据</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ControllerAdvice</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyExceptionHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>UserNotExistException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> <span class="token function">handleException</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"code"</span><span class="token punctuation">,</span><span class="token string">"user.notexist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">,</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> map<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//没有自适应效果...</span><span class="token comment" spellcheck="true">//即：浏览器和手机客户端都会返回json数据了</span></code></pre><p>2）转发到/error进行自适应响应效果处理</p><pre class=" language-java"><code class="language-java">　　<span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>UserNotExistException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">handleException</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">,</span> HttpServletRequest request<span class="token punctuation">)</span><span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程</span>        <span class="token comment" spellcheck="true">/**         * Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");         */</span>        request<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"javax.servlet.error.status_code"</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"code"</span><span class="token punctuation">,</span><span class="token string">"user.notexist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">,</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　　　<span class="token comment" spellcheck="true">//将我们自己定义的数据放到request域中</span>　　　　request<span class="token punctuation">.</span><span class="token function">setAttributes</span><span class="token punctuation">(</span><span class="token string">"ext"</span><span class="token punctuation">,</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//转发到/error</span>        <span class="token keyword">return</span> <span class="token string">"forward:/error"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>3) 将我们的定制数据携带出去</strong></p><p>出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由<br>getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）</p><p>1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中。</p><p>2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到</p><p>容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的。</p><p>自定义ErrorAttributes：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给容器中加入我们自己定义的ErrorAttributes</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyErrorAttributes</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultErrorAttributes</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">getErrorAttributes</span><span class="token punctuation">(</span>RequestAttributes requestAttributes<span class="token punctuation">,</span><span class="token keyword">boolean</span> includeStackTrace<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getErrorAttributes</span><span class="token punctuation">(</span>requestAttributes<span class="token punctuation">,</span>includeStackTrace<span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"company"</span><span class="token punctuation">,</span><span class="token string">"atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从request域中获取我们自己定义的数据，0：代表request域</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> ext <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span><span class="token punctuation">)</span>requestAttributes<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"ext"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//放入要展示的map当中</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"ext"</span><span class="token punctuation">,</span>ext<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> map<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108111151.png"></p><h2 id="配置嵌入式Servlet容器"><a href="#配置嵌入式Servlet容器" class="headerlink" title="配置嵌入式Servlet容器"></a>配置嵌入式Servlet容器</h2><p>SpringBoot默认使用Tomcat作为嵌入式的Servlet容器<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108113617.png"></p><p>问题？</p><h3 id="如何定制和修改Servlet容器的相关配置"><a href="#如何定制和修改Servlet容器的相关配置" class="headerlink" title="如何定制和修改Servlet容器的相关配置"></a>如何定制和修改Servlet容器的相关配置</h3><p>1、修改与server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）</p><pre><code>server.port=8081server.context‐path=/crudserver.tomcat.uri‐encoding=UTF‐8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx</code></pre><p>2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span>  <span class="token comment" spellcheck="true">//一定要将这个定制器加入到容器中</span><span class="token keyword">public</span> EmbeddedServletContainerCustomizer <span class="token function">embeddedServletContainerCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">EmbeddedServletContainerCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//定制嵌入式的Servlet容器相关的规则</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">customize</span><span class="token punctuation">(</span>ConfigurableEmbeddedServletContainer container<span class="token punctuation">)</span> <span class="token punctuation">{</span>            container<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">8083</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="注册Servlet三大组件【Servlet、Filter、Listener】"><a href="#注册Servlet三大组件【Servlet、Filter、Listener】" class="headerlink" title="注册Servlet三大组件【Servlet、Filter、Listener】"></a>注册Servlet三大组件【Servlet、Filter、Listener】</h3><p>由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件.</p><p>注册三大组件用以下方式:</p><p>1) ServletRegistrationBean</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> ServletRegistrationBean <span class="token function">myServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    ServletRegistrationBean registrationBean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletRegistrationBean</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"/myServlet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> registrationBean<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2) FilterRegistrationBean</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> FilterRegistrationBean <span class="token function">myFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    FilterRegistrationBean registrationBean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterRegistrationBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    registrationBean<span class="token punctuation">.</span><span class="token function">setFilter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    registrationBean<span class="token punctuation">.</span><span class="token function">setUrlPatterns</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span><span class="token string">"/myServlet"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> registrationBean<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>3) ServletListenerRegistrationBean</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> ServletListenerRegistrationBean <span class="token function">myListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    ServletListenerRegistrationBean<span class="token operator">&lt;</span>MyListener<span class="token operator">></span> registrationBean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletListenerRegistrationBean</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> registrationBean<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>SpringBoot帮我们自动配置SpringMVC的时候，自动的注册SpringMVC的前端控制器；DispatcherServlet；</p><p>DispatcherServletAutoConfiguration中：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME<span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnBean</span><span class="token punctuation">(</span>value <span class="token operator">=</span> DispatcherServlet<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> name <span class="token operator">=</span>DEFAULT_DISPATCHER_SERVLET_BEAN_NAME<span class="token punctuation">)</span><span class="token keyword">public</span> ServletRegistrationBean <span class="token function">dispatcherServletRegistration</span><span class="token punctuation">(</span>      DispatcherServlet dispatcherServlet<span class="token punctuation">)</span> <span class="token punctuation">{</span>   ServletRegistrationBean registration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletRegistrationBean</span><span class="token punctuation">(</span>         dispatcherServlet<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>serverProperties<span class="token punctuation">.</span><span class="token function">getServletMapping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp</span>    <span class="token comment" spellcheck="true">//可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径</span>   registration<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>DEFAULT_DISPATCHER_SERVLET_BEAN_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>   registration<span class="token punctuation">.</span><span class="token function">setLoadOnStartup</span><span class="token punctuation">(</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>webMvcProperties<span class="token punctuation">.</span><span class="token function">getServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLoadOnStartup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>multipartConfig <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      registration<span class="token punctuation">.</span><span class="token function">setMultipartConfig</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>multipartConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> registration<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="替换为其他嵌入式Servlet容器"><a href="#替换为其他嵌入式Servlet容器" class="headerlink" title="替换为其他嵌入式Servlet容器"></a>替换为其他嵌入式Servlet容器</h3><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108114843.png" style="width:50%"></p><p>默认支持：</p><p>Tomcat（默认使用）</p><pre><code>&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt;</code></pre><p>Jetty</p><pre><code>&lt;!‐‐ 引入web模块 ‐‐&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;   &lt;exclusions&gt;      &lt;exclusion&gt;         &lt;artifactId&gt;spring‐boot‐starter‐tomcat&lt;/artifactId&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;/exclusion&gt;   &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!‐‐引入其他的Servlet容器‐‐&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring‐boot‐starter‐jetty&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>Undertow</p><pre><code>&lt;!‐‐ 引入web模块 ‐‐&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;   &lt;exclusions&gt;      &lt;exclusion&gt;         &lt;artifactId&gt;spring‐boot‐starter‐tomcat&lt;/artifactId&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;/exclusion&gt;   &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!‐‐引入其他的Servlet容器‐‐&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring‐boot‐starter‐undertow&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="嵌入式Servlet容器自动配置原理"><a href="#嵌入式Servlet容器自动配置原理" class="headerlink" title="嵌入式Servlet容器自动配置原理"></a>嵌入式Servlet容器自动配置原理</h3><p><strong>EmbeddedServletContainerAutoConfiguration</strong>：嵌入式的Servlet容器自动配置</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@AutoConfigureOrder</span><span class="token punctuation">(</span>Ordered<span class="token punctuation">.</span>HIGHEST_PRECEDENCE<span class="token punctuation">)</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnWebApplication</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>BeanPostProcessorsRegistrar<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件</span><span class="token comment" spellcheck="true">//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：</span><span class="token comment" spellcheck="true">//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmbeddedServletContainerAutoConfiguration</span> <span class="token punctuation">{</span>　　 <span class="token annotation punctuation">@Configuration</span>    <span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span> Servlet<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> Tomcat<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断当前是否引入了Tomcat依赖；    </span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>value <span class="token operator">=</span> EmbeddedServletContainerFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> search <span class="token operator">=</span>    SearchStrategy<span class="token punctuation">.</span>CURRENT<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：</span>    <span class="token comment" spellcheck="true">//嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">EmbeddedTomcat</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Bean</span>            <span class="token keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="token function">tomcatEmbeddedServletContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TomcatEmbeddedServletContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**     * Nested configuration if Jetty is being used.         */</span>        <span class="token annotation punctuation">@Configuration</span>        <span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span> Servlet<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> Server<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> Loader<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>        WebAppContext<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>value <span class="token operator">=</span> EmbeddedServletContainerFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> search <span class="token operator">=</span>    SearchStrategy<span class="token punctuation">.</span>CURRENT<span class="token punctuation">)</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">EmbeddedJetty</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Bean</span>        <span class="token keyword">public</span> JettyEmbeddedServletContainerFactory <span class="token function">jettyEmbeddedServletContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JettyEmbeddedServletContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>            <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">/**         * Nested configuration if Undertow is being used.         */</span>        <span class="token annotation punctuation">@Configuration</span>        <span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span> Servlet<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> Undertow<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> SslClientAuthMode<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>value <span class="token operator">=</span> EmbeddedServletContainerFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> search <span class="token operator">=</span>    SearchStrategy<span class="token punctuation">.</span>CURRENT<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">EmbeddedUndertow</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Bean</span>            <span class="token keyword">public</span> UndertowEmbeddedServletContainerFactory    <span class="token function">undertowEmbeddedServletContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UndertowEmbeddedServletContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>          <span class="token punctuation">}</span> </code></pre><p>1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EmbeddedServletContainerFactory</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//获取嵌入式的Servlet容器</span>   EmbeddedServletContainer <span class="token function">getEmbeddedServletContainer</span><span class="token punctuation">(</span>         ServletContextInitializer<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> initializers<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108130503.png" style="width:50%"></p><p>2）、EmbeddedServletContainer：（嵌入式的Servlet容器）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108130718.png" style="width:50%"></p><p>3）、<strong>以TomcatEmbeddedServletContainerFactory为例</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> EmbeddedServletContainer <span class="token function">getEmbeddedServletContainer</span><span class="token punctuation">(</span>      ServletContextInitializer<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> initializers<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//创建一个Tomcat</span>   Tomcat tomcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tomcat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//配置Tomcat的基本环节</span>   File baseDir <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>baseDirectory <span class="token operator">!=</span> null <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>baseDirectory         <span class="token operator">:</span> <span class="token function">createTempDir</span><span class="token punctuation">(</span><span class="token string">"tomcat"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   tomcat<span class="token punctuation">.</span><span class="token function">setBaseDir</span><span class="token punctuation">(</span>baseDir<span class="token punctuation">.</span><span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   Connector connector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Connector</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>   tomcat<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addConnector</span><span class="token punctuation">(</span>connector<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">customizeConnector</span><span class="token punctuation">(</span>connector<span class="token punctuation">)</span><span class="token punctuation">;</span>   tomcat<span class="token punctuation">.</span><span class="token function">setConnector</span><span class="token punctuation">(</span>connector<span class="token punctuation">)</span><span class="token punctuation">;</span>   tomcat<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAutoDeploy</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">configureEngine</span><span class="token punctuation">(</span>tomcat<span class="token punctuation">.</span><span class="token function">getEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span>Connector additionalConnector <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>additionalTomcatConnectors<span class="token punctuation">)</span> <span class="token punctuation">{</span>      tomcat<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addConnector</span><span class="token punctuation">(</span>additionalConnector<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token function">prepareContext</span><span class="token punctuation">(</span>tomcat<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> initializers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器</span>   <span class="token keyword">return</span> <span class="token function">getTomcatEmbeddedServletContainer</span><span class="token punctuation">(</span>tomcat<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>4）、我们对嵌入式容器的配置修改是怎么生效？</p><pre><code>ServerProperties、EmbeddedServletContainerCustomizer</code></pre><p><strong>EmbeddedServletContainerCustomizer</strong>：定制器帮我们修改了Servlet容器的配置？</p><p>怎么修改的原理？</p><p>5) 容器中导入了<strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//初始化之前</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Object <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span>      <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">ConfigurableEmbeddedServletContainer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//</span>      <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ConfigurableEmbeddedServletContainer<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> bean<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span>ConfigurableEmbeddedServletContainer bean<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>EmbeddedServletContainerCustomizer customizer <span class="token operator">:</span> <span class="token function">getCustomizers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        customizer<span class="token punctuation">.</span><span class="token function">customize</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> Collection<span class="token operator">&lt;</span>EmbeddedServletContainerCustomizer<span class="token operator">></span> <span class="token function">getCustomizers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>customizers <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Look up does not include the parent context</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>customizers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>EmbeddedServletContainerCustomizer<span class="token operator">></span><span class="token punctuation">(</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory            <span class="token comment" spellcheck="true">//从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer</span>            <span class="token comment" spellcheck="true">//定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件</span>            <span class="token punctuation">.</span><span class="token function">getBeansOfType</span><span class="token punctuation">(</span>EmbeddedServletContainerCustomizer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>                            <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>customizers<span class="token punctuation">,</span> AnnotationAwareOrderComparator<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>customizers <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">unmodifiableList</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>customizers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>customizers<span class="token punctuation">;</span><span class="token punctuation">}</span>ServerProperties也是定制器</code></pre><p>步骤：</p><p>1）、SpringBoot根据导入的嵌入式容器依赖情况，给容器中添加相应的<br>EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p><p>2）、容器中某个组件要创建对象就会惊动后置处理器；<br>EmbeddedServletContainerCustomizerBeanPostProcessor；<br>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</p><p>3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法。</p><h3 id="嵌入式Servlet容器启动原理"><a href="#嵌入式Servlet容器启动原理" class="headerlink" title="嵌入式Servlet容器启动原理"></a>嵌入式Servlet容器启动原理</h3><p>什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；</p><p>获取嵌入式的Servlet容器工厂：</p><p>1）、SpringBoot应用启动运行run方法</p><p>2）、refreshContext(context); SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一<br>个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：<br>AnnotationConfigApplicationContext</p><p>3）、refresh(context);<strong>刷新刚才创建好的ioc容器；</strong></p><pre><code>public void refresh() throws BeansException, IllegalStateException {   synchronized (this.startupShutdownMonitor) {      // Prepare this context for refreshing.      prepareRefresh();      // Tell the subclass to refresh the internal bean factory.      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();      // Prepare the bean factory for use in this context.      prepareBeanFactory(beanFactory);      try {         // Allows post‐processing of the bean factory in context subclasses.         postProcessBeanFactory(beanFactory);         // Invoke factory processors registered as beans in the context.         invokeBeanFactoryPostProcessors(beanFactory);         // Register bean processors that intercept bean creation.         registerBeanPostProcessors(beanFactory);         // Initialize message source for this context.         initMessageSource();         // Initialize event multicaster for this context.         initApplicationEventMulticaster();         // Initialize other special beans in specific context subclasses.         onRefresh();         // Check for listener beans and register them.         registerListeners();         // Instantiate all remaining (non‐lazy‐init) singletons.         finishBeanFactoryInitialization(beanFactory);         // Last step: publish corresponding event.         finishRefresh();      }      catch (BeansException ex) {         if (logger.isWarnEnabled()) {            logger.warn(&quot;Exception encountered during context initialization ‐ &quot; +                  &quot;cancelling refresh attempt: &quot; + ex);         }         // Destroy already created singletons to avoid dangling resources.         destroyBeans();         // Reset &#39;active&#39; flag.         cancelRefresh(ex);         // Propagate exception to caller.         throw ex;      }      finally {         // Reset common introspection caches in Spring&#39;s core, since we         // might not ever need metadata for singleton beans anymore...         resetCommonCaches();      }   }}</code></pre><p>4）、 onRefresh(); web的ioc容器重写了onRefresh方法</p><p>5）、webIoC容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer();</strong></p><p>6）、<strong>获取嵌入式的Servlet容器工厂</strong>：</p><p>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</p><p>从ioc容器中获取EmbeddedServletContainerFactory 组件；<strong>TomcatEmbeddedServletContainerFactory</strong>创建<br>对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；</p><p>7）、<strong>使用容器工厂获取嵌入式的Servlet容器</strong>：</p><p>this.embeddedServletContainer = containerFactory.getEmbeddedServletContainer(getSelfInitializer());</p><p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器</p><p><strong>先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来</strong></p><p><b>IOC容器启动创建嵌入式的Servlet容器</b></p><hr><h3 id="使用外置的Servlet容器"><a href="#使用外置的Servlet容器" class="headerlink" title="使用外置的Servlet容器"></a>使用外置的Servlet容器</h3><p>嵌入式Servlet容器：应用打成可执行的jar</p><p>优点：简单、便携</p><p>缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】<br>自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；</p><p>外置的Servlet容器：外面安装Tomcat—应用war包的方式打包.</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1）创建一个War工程：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108141118.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108141218.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108141327.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108141425.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108141535.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108141805.png"></p><p>2）将项目结构构<strong>造成War的目录结构</strong></p><p>打开项目的结构设置：（点击Web）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108141932.png"></p><p><strong>添加webapp目录 和 web.xml文件</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108142443.png"></p><p>完成后：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108142615.png" style="width:50%"></p><p>打开pom.xml文件</p><p>检查是不是war：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108142726.png"></p><p><strong>检查tomcat的依赖的scope是不是provided</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108142816.png"></p><p>3）添加外部的Tomcat的容器<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108143051.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108143152.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108143441.png"></p><p>发现上面一个警告，因为还没有配置部署的项目：点击Deployment<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108143551.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108143640.png"></p><p>4）启动外部的Tomcat容器：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108143747.png"></p><p>启动完成后：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108143904.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108143941.png"></p><p>5）添加jsp页面，看看是否能成功</p><p>在webapp下面，直接创建index.jsp页面</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108144117.png"></p><p>启动应用，在浏览器中输入：<code>http://localhost:8080/</code> 或者 <code>http://localhost:8080/index.jsp</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108144330.png"></p><p>6) 编写控制器层：</p><p>一般我们的jsp.xml页面放置在WEB-INF下面，因为这样可以屏蔽直接在浏览器中输入地址直接访问我们的页面。</p><p>不信的话，我们在WEB-INF下面放置一个success.jsp页面：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108144634.png"></p><p>重启应用，在浏览器中输入：<code>http://localhost:8080/WEB-INF/success.jsp</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108144754.png"></p><p>WEB-INF下面的资源，必须靠容器来帮我们访问，即：用控制层的重定向或者转发来寻找资源。</p><p>修改index.jsp页面：<br>添加一个a标签，发送/success的get请求：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108150427.png"></p><p>创建controller包，并创建HelloController类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108150437.png"></p><p>重启应用，点击success的超链接<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108150447.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108150604.png"></p><p>出现500，/success请求路径解析异常，因为我们没有配置视图解析器，return “success” 又会重新执行</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/success"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">success</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>该方法，就会循环调用，出现异常。</p><p>所以，需要在配置文件中，配置view的前缀路径，和后缀名。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108151153.png"></p><p>重启应用，点击success超链接：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108151253.png"></p><p>以上就是使用Springboot打包成war包的开发流程：</p><p><strong>注意：此时不能使用Springboot的主类应用启动方式，只能使用Tomcat容器的启动方式！！！</strong></p><hr><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；</p><p>war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器；</p><p>war包的启动原理，还是要归结于servlet3.0标准。</p><p>如果大家不清楚的话，看我的另一篇<a href="/2018/10/28/Servlet3-0/">serlvet3.0</a>里面有详细的过程。</p><p>规则：</p><p>1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：</p><p>2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为<br>javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名</p><p>3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；</p><p>流程：</p><p>1）、启动Tomcat</p><p>2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-<br>INF\services\javax.servlet.ServletContainerInitializer：</p><p>Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108154339.png"></p><p>3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型<br>的类都传入到onStartup方法的Set集合中；为这些WebApplicationInitializer类型的类创建实例；</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@HandlesTypes</span><span class="token punctuation">(</span>WebApplicationInitializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringServletContainerInitializer</span></code></pre><p>4）、每一个WebApplicationInitializer都调用自己的onStartup；</p><pre class=" language-java"><code class="language-java">        <span class="token keyword">for</span> <span class="token punctuation">(</span>WebApplicationInitializer initializer <span class="token operator">:</span> initializers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            initializer<span class="token punctuation">.</span><span class="token function">onStartup</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>WebApplicationInitializer继承树：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108155531.png"></p><p>我们发现了SpringBootServletInitializer是WebApplicationInitializer一个实现类。</p><p>5）我们项目中的ServletInitializer继承了SpringBootServletInitializer：(idea自己帮我们创建的一个类，名字无所谓，继承SpringBootServletInitializer即可)<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day06/QQ%E6%88%AA%E5%9B%BE20181108155741.png"></p><p>所以服务启动的时候，会创建ServletInitializer实例并调用onStartup方法。我们没有重写onStartup方法，所以会调用父类SpringBootServletInitializer的onStartup方法。</p><p>6）SpringBootServletInitializer执行onStartup的时候会调用createRootApplicationContext：创建容器</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> WebApplicationContext <span class="token function">createRootApplicationContext</span><span class="token punctuation">(</span>      ServletContext servletContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1、创建SpringApplicationBuilder</span>   SpringApplicationBuilder builder <span class="token operator">=</span> <span class="token function">createSpringApplicationBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   StandardServletEnvironment environment <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardServletEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   environment<span class="token punctuation">.</span><span class="token function">initPropertySources</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>   builder<span class="token punctuation">.</span><span class="token function">environment</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>   builder<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   ApplicationContext parent <span class="token operator">=</span> <span class="token function">getExistingRootWebApplicationContext</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Root context already created (using as parent)."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      servletContext<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>            WebApplicationContext<span class="token punctuation">.</span>ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>      builder<span class="token punctuation">.</span><span class="token function">initializers</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ParentContextApplicationContextInitializer</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   builder<span class="token punctuation">.</span><span class="token function">initializers</span><span class="token punctuation">(</span>         <span class="token keyword">new</span> <span class="token class-name">ServletContextApplicationContextInitializer</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   builder<span class="token punctuation">.</span><span class="token function">contextClass</span><span class="token punctuation">(</span>AnnotationConfigEmbeddedWebApplicationContext<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2.调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来</span>   builder <span class="token operator">=</span> <span class="token function">configure</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3.使用builder创建一个Spring应用</span>   SpringApplication application <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>application<span class="token punctuation">.</span><span class="token function">getSources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> AnnotationUtils         <span class="token punctuation">.</span><span class="token function">findAnnotation</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Configuration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      application<span class="token punctuation">.</span><span class="token function">getSources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   Assert<span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span><span class="token operator">!</span>application<span class="token punctuation">.</span><span class="token function">getSources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         <span class="token string">"No SpringApplication sources have been defined. Either override the "</span>               <span class="token operator">+</span> <span class="token string">"configure method or add an @Configuration annotation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Ensure error pages are registered</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>registerErrorPageFilter<span class="token punctuation">)</span> <span class="token punctuation">{</span>      application<span class="token punctuation">.</span><span class="token function">getSources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ErrorPageFilterConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//4.启动Spring应用</span>   <span class="token keyword">return</span> <span class="token function">run</span><span class="token punctuation">(</span>application<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>7） Spring的应用就启动并且创建IOC容器</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ConfigurableApplicationContext <span class="token function">run</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>   StopWatch stopWatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   ConfigurableApplicationContext context <span class="token operator">=</span> null<span class="token punctuation">;</span>   FailureAnalyzers analyzers <span class="token operator">=</span> null<span class="token punctuation">;</span>   <span class="token function">configureHeadlessProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   SpringApplicationRunListeners listeners <span class="token operator">=</span> <span class="token function">getRunListeners</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>   listeners<span class="token punctuation">.</span><span class="token function">starting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">try</span> <span class="token punctuation">{</span>      ApplicationArguments applicationArguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultApplicationArguments</span><span class="token punctuation">(</span>            args<span class="token punctuation">)</span><span class="token punctuation">;</span>      ConfigurableEnvironment environment <span class="token operator">=</span> <span class="token function">prepareEnvironment</span><span class="token punctuation">(</span>listeners<span class="token punctuation">,</span>            applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>      Banner printedBanner <span class="token operator">=</span> <span class="token function">printBanner</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>      context <span class="token operator">=</span> <span class="token function">createApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      analyzers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FailureAnalyzers</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">prepareContext</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> environment<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">,</span>            printedBanner<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//刷新IOC容器</span>      <span class="token function">refreshContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">afterRefresh</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>      listeners<span class="token punctuation">.</span><span class="token function">finished</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>      stopWatch<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logStartupInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">new</span> <span class="token class-name">StartupInfoLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">logStarted</span><span class="token punctuation">(</span><span class="token function">getApplicationLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stopWatch<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> context<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> analyzers<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><font color="#EE2C2C"><strong>总结：启动Servlet容器，再启动SpringBoot应用</strong></font>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_05</title>
      <link href="/2018/11/06/springboot-day-05/"/>
      <url>/2018/11/06/springboot-day-05/</url>
      
        <content type="html"><![CDATA[<p>今天，学习Springboot中的SpringMVC的自动配置原理</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications" target="_blank" rel="noopener">Springboot的官方参考文档</a></p><h2 id="Spring-MVC-auto-configuration"><a href="#Spring-MVC-auto-configuration" class="headerlink" title="Spring MVC auto-configuration"></a>Spring MVC auto-configuration</h2><p>Spring Boot 自动配置好了SpringMVC</p><p>以下是SpringBoot对SpringMVC的默认配置:（<strong>WebMvcAutoConfiguration</strong>）</p><h3 id="ContentNegotiatingViewResolver-and-BeanNameViewResolver"><a href="#ContentNegotiatingViewResolver-and-BeanNameViewResolver" class="headerlink" title="ContentNegotiatingViewResolver and  BeanNameViewResolver"></a>ContentNegotiatingViewResolver and  BeanNameViewResolver</h3><pre class=" language-java"><code class="language-java">        <span class="token annotation punctuation">@Bean</span>        <span class="token annotation punctuation">@ConditionalOnBean</span><span class="token punctuation">(</span>View<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>        <span class="token annotation punctuation">@ConditionalOnMissingBean</span>        <span class="token keyword">public</span> BeanNameViewResolver <span class="token function">beanNameViewResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            BeanNameViewResolver resolver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanNameViewResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            resolver<span class="token punctuation">.</span><span class="token function">setOrder</span><span class="token punctuation">(</span>Ordered<span class="token punctuation">.</span>LOWEST_PRECEDENCE <span class="token operator">-</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> resolver<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Bean</span>        <span class="token annotation punctuation">@ConditionalOnBean</span><span class="token punctuation">(</span>ViewResolver<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>        <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"viewResolver"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> ContentNegotiatingViewResolver<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>        <span class="token keyword">public</span> ContentNegotiatingViewResolver <span class="token function">viewResolver</span><span class="token punctuation">(</span>BeanFactory beanFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ContentNegotiatingViewResolver resolver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContentNegotiatingViewResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            resolver<span class="token punctuation">.</span><span class="token function">setContentNegotiationManager</span><span class="token punctuation">(</span>                    beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>ContentNegotiationManager<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// ContentNegotiatingViewResolver uses all the other view resolvers to locate</span>            <span class="token comment" spellcheck="true">// a view so it should have a high precedence</span>            resolver<span class="token punctuation">.</span><span class="token function">setOrder</span><span class="token punctuation">(</span>Ordered<span class="token punctuation">.</span>HIGHEST_PRECEDENCE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> resolver<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>　　1) 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何<br>　　渲染（转发？重定向？））</p><p>　　2) ContentNegotiatingViewResolver：组合所有的视图解析器的；</p><p>　　3) 如何定制：<font color="#FF3E96"><strong>我们可以自己给容器中添加一个视图解析器；ContentNegotiatingViewResolver会自动将其组合进来；</strong></font></p><h3 id="Support-for-serving-static-resources-including-support-for-WebJars"><a href="#Support-for-serving-static-resources-including-support-for-WebJars" class="headerlink" title="Support for serving static resources, including support for WebJars"></a>Support for serving static resources, including support for WebJars</h3><p>　　静态资源文件夹路径,webjars（上一天，我们已经学过了）</p><h3 id="Static-index-html-support"><a href="#Static-index-html-support" class="headerlink" title="Static  index.html support"></a>Static  index.html support</h3><p>　　静态首页index.html访问.</p><h3 id="Custom-Favicon-support"><a href="#Custom-Favicon-support" class="headerlink" title="Custom  Favicon support"></a>Custom  Favicon support</h3><p>　　favicon.ico图标的访问。</p><h3 id="自动注册了-Converter、GenericConverter、Formatter-beans"><a href="#自动注册了-Converter、GenericConverter、Formatter-beans" class="headerlink" title="自动注册了 Converter、GenericConverter、Formatter beans."></a>自动注册了 Converter、GenericConverter、Formatter beans.</h3><p>　　1）Converter：转换器； public String hello(User user)：类型转换使用Converter。</p><p>　　2）Formatter：格式化器； 2017.12.17===Date。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span>        <span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.mvc"</span><span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">"date‐format"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//在文件中配置日期格式化的规则</span><span class="token keyword">public</span> Formatter<span class="token operator">&lt;</span>Date<span class="token operator">></span> <span class="token function">dateFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DateFormatter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties<span class="token punctuation">.</span><span class="token function">getDateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//日期格式化组件            </span><span class="token punctuation">}</span> </code></pre><p>　　3）<font color="#FF3E96"><strong>自己添加的格式化器转换器，我们只需要放在容器中即可.</strong></font></p><h3 id="HttpMessageConverters"><a href="#HttpMessageConverters" class="headerlink" title="HttpMessageConverters"></a>HttpMessageConverters</h3><p>　　1) HttpMessageConverter: SpringMVC用来转换Http请求和响应的；User—Json；</p><p>　　2) HttpMessageConverters:是从容器中获取所有的HttpMessageConverter；</p><p>　　3) <font color="#FF3E96"><strong>自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）</strong></font></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyConfiguration</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> HttpMessageConverters <span class="token function">customConverters</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        HttpMessageConverter<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> additional <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        HttpMessageConverter<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> another <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HttpMessageConverters</span><span class="token punctuation">(</span>additional<span class="token punctuation">,</span> another<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//多参数</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="MessageCodesResolver"><a href="#MessageCodesResolver" class="headerlink" title="MessageCodesResolver"></a>MessageCodesResolver</h3><p>　　定义错误代码生成规则 (参考官方文档)</p><h3 id="ConfigurableWebBindingInitializer"><a href="#ConfigurableWebBindingInitializer" class="headerlink" title="ConfigurableWebBindingInitializer"></a>ConfigurableWebBindingInitializer</h3><p>　　1）数据绑定的功能</p><p>　　2）<font color="#FF3E96"><strong>我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）</strong></font></p><pre><code>初始化WebDataBinder；请求数据=====JavaBean；</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><font color="red"><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></font><p><strong>如果，你想使用Springboot的默认配置的Web功能，然后添加自己额外的Web组件，就：添加一个@Configuration的配置类，然后继承WebMvcConfigurerAdapter抽象类。（不能添加@EnableWebMvc注解）</strong></p><p><strong>如果，你不想使用Springboot的默认Web功能，那么，就：添加一个@Configuration的配置类，并且加上@EnableWebMvc注解，那么就你完全自定义SpringMVC组件。</strong></p><p>官网文档中，这么说明的：</p><pre><code>If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration(interceptors, formatters, view controllers etc.) you can add your own  @Configuration class of typeWebMvcConfigurerAdapter , but without  @EnableWebMvc . If you wish to provide custom instances ofRequestMappingHandlerMapping ,  RequestMappingHandlerAdapter or  ExceptionHandlerExceptionResolveryou can declare a  WebMvcRegistrationsAdapter instance providing such components.If you want to take complete control of Spring MVC, you can add your own  @Configuration annotated with@EnableWebMvc .</code></pre><hr><h2 id="扩展SpringMVC"><a href="#扩展SpringMVC" class="headerlink" title="扩展SpringMVC"></a>扩展SpringMVC</h2><p>我们以前开发SpringMVC的时候，都会在xml中配置如下设置（自定义配置）：</p><pre><code>   &lt;mvc:view‐controller path=&quot;/hello&quot; view‐name=&quot;success&quot;/&gt;   &lt;mvc:interceptors&gt;            &lt;mvc:interceptor&gt;                &lt;mvc:mapping path=&quot;/hello&quot;/&gt;                &lt;bean&gt;&lt;/bean&gt;            &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;</code></pre><p>那么现在呢？</p><font color="#FF3E96">编写一个配置类（@Configuration），继承WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc;</font><p>既保留了所有的Springboot自动配置，也能用我们扩展的配置；</p><p>在我们的昨天的项目中，在com.liuzhuo.springboot包下，创建config包，并且创建Myconfig类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Myconfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebMvcConfigurerAdapter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addViewControllers</span><span class="token punctuation">(</span>ViewControllerRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//super.addViewControllers(registry);</span>        <span class="token comment" spellcheck="true">//浏览器发送 /liuzhuo 请求来到 success</span>        registry<span class="token punctuation">.</span><span class="token function">addViewController</span><span class="token punctuation">(</span><span class="token string">"/liuzhuo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"sucess"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后在resources下的templates中：创建sucess.html文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106141537.png"></p><p>启动Springboot应用：</p><p>在浏览器中输入：<code>http://localhost:8080/liuzhuo</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106141651.png"></p><p>说明：我们自己配置的映射url成功。</p><p>此时，我们不仅可以使用Springboot的默认Web的配置，还能使用自己额外添加的控制器映射。</p><hr><p>为什么，此时我们既能使用Springboot的默认配置，又能使用自己的配置呢？</p><p><strong>原理：</strong></p><p>1）查看WebMvcAutoConfiguration是SpringMVC的自动配置类</p><p>2）在WebMvcAutoConfiguration中，能发现一个静态内部类：WebMvcAutoConfigurationAdapter</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Defined as a nested config to ensure WebMvcConfigurerAdapter is not read when not</span>    <span class="token comment" spellcheck="true">// on the classpath</span>    <span class="token annotation punctuation">@Configuration</span>    <span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>EnableWebMvcConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token punctuation">{</span> WebMvcProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> ResourceProperties<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WebMvcAutoConfigurationAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">WebMvcConfigurerAdapter</span> <span class="token punctuation">{</span></code></pre><p>该类上面有一个注解：@Import(EnableWebMvcConfiguration.class)。说明导入了EnableWebMvcConfiguration类。</p><p>3）打开EnableWebMvcConfiguration类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">EnableWebMvcConfiguration</span> <span class="token keyword">extends</span> <span class="token class-name">DelegatingWebMvcConfiguration</span> </code></pre><p>继承了DelegatingWebMvcConfiguration类，打开DelegatingWebMvcConfiguration类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelegatingWebMvcConfiguration</span> <span class="token keyword">extends</span> <span class="token class-name">WebMvcConfigurationSupport</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">final</span> WebMvcConfigurerComposite configurers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebMvcConfigurerComposite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//从容器中获取所有的WebMvcConfigurer    </span>      <span class="token annotation punctuation">@Autowired</span><span class="token punctuation">(</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setConfigurers</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>WebMvcConfigurer<span class="token operator">></span> configurers<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>configurers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>configurers<span class="token punctuation">.</span><span class="token function">addWebMvcConfigurers</span><span class="token punctuation">(</span>configurers<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；      </span>             <span class="token annotation punctuation">@Override</span>                 <span class="token comment" spellcheck="true">// public void addViewControllers(ViewControllerRegistry registry) {</span>              <span class="token comment" spellcheck="true">//    for (WebMvcConfigurer delegate : this.delegates) {</span>               <span class="token comment" spellcheck="true">//       delegate.addViewControllers(registry);</span>               <span class="token comment" spellcheck="true">//   }</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span><span class="token punctuation">}</span> </code></pre><p>4) 容器中所有的WebMvcConfigurer都会一起起作用</p><p>5) 我们的配置类也会被调用</p><p>效果：SpringMVC的自动配置和我们的扩展配置都会起作用</p><h2 id="全面接管SpringMVC"><a href="#全面接管SpringMVC" class="headerlink" title="全面接管SpringMVC"></a>全面接管SpringMVC</h2><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p><p><strong>我们需要在配置类中添加@EnableWebMvc即可</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><span class="token annotation punctuation">@EnableWebMvc</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMvcConfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebMvcConfigurerAdapter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addViewControllers</span><span class="token punctuation">(</span>ViewControllerRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// super.addViewControllers(registry);</span>        <span class="token comment" spellcheck="true">//浏览器发送 /atguigu 请求来到 success</span>        registry<span class="token punctuation">.</span><span class="token function">addViewController</span><span class="token punctuation">(</span><span class="token string">"/atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>直接启动我们的应用：<br>在浏览器中输入：<code>http://localhost:8080/</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106143304.png"></p><p>默认的静态主页失效了。去掉@EnableWebMvc，静态主页映射就会成功。</p><p>静态主页映射：META-INF/resources、resourcs、static、public下的 index.html 都会映射：/**</p><hr><p>为啥配置了@EnableWebMvc注解，SpringBoot的默认配置会失效呢？</p><p><strong>原理：</strong></p><p>1）打开@EnableWebMvc注解：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>DelegatingWebMvcConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableWebMvc</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>导入了DelegatingWebMvcConfiguration类。</p><p>2）打开DelegatingWebMvcConfiguration类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelegatingWebMvcConfiguration</span> <span class="token keyword">extends</span> <span class="token class-name">WebMvcConfigurationSupport</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> WebMvcConfigurerComposite configurers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebMvcConfigurerComposite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span><span class="token punctuation">(</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setConfigurers</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>WebMvcConfigurer<span class="token operator">></span> configurers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>configurers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>configurers<span class="token punctuation">.</span><span class="token function">addWebMvcConfigurers</span><span class="token punctuation">(</span>configurers<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>   ···｝</code></pre><p>DelegatingWebMvcConfiguration类：配置了SpringMVC的基本设置。</p><p>3）打开WebMvcAutoConfiguration：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnWebApplication</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span> Servlet<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> DispatcherServlet<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>        WebMvcConfigurerAdapter<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//容器中没有这个组件的时候，这个自动配置类才生效</span><span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>WebMvcConfigurationSupport<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@AutoConfigureOrder</span><span class="token punctuation">(</span>Ordered<span class="token punctuation">.</span>HIGHEST_PRECEDENCE <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token annotation punctuation">@AutoConfigureAfter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> DispatcherServletAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>        ValidationAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebMvcAutoConfiguration</span> <span class="token punctuation">{</span></code></pre><p>上面的一个条件注解：@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</p><p>当没有WebMvcConfigurationSupport存在时，WebMvcAutoConfiguration自动配置才会生效。</p><p>而DelegatingWebMvcConfiguration就是WebMvcConfigurationSupport。</p><p>所以@EnableWebMvc将WebMvcConfigurationSupport组件导入进来，从而使WebMvcAutoConfiguration自动配置失效。</p><hr><p><strong>总结：</strong></p><p>推荐我们使用 SpringBoot的默认配置 + 自定义的配置，即：<strong>@Configuration + 继承WebMvcConfigurerAdapter </strong>的配置类的形式。</p><p>我们完全自定义的模式：适合于简单、不负责的Web应用。</p><h2 id="如何修改SpringBoot的默认配置"><a href="#如何修改SpringBoot的默认配置" class="headerlink" title="如何修改SpringBoot的默认配置"></a>如何修改SpringBoot的默认配置</h2><p>模式：</p><p>1）、 SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）<br>　　　如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）, 则将用户<br>　　　配置的和自己默认的组合起来；</p><p>2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p><p>3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</p><h2 id="CRUD-restful实战"><a href="#CRUD-restful实战" class="headerlink" title="CRUD-restful实战"></a>CRUD-restful实战</h2><p><a href="https://pan.baidu.com/s/1_H3h5Vsw47R30mjldS68bA" target="_blank" rel="noopener">下载资料</a></p><p>下载完毕后。找到文档中的restful-crud-实验<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106150457.png"></p><h3 id="默认访问首页"><a href="#默认访问首页" class="headerlink" title="默认访问首页"></a>默认访问首页</h3><p>1）首先将目录下的静态页面，xxx.html导入到我们的项目中的template目录下：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106150713.png" style="width:50%"></p><p>2）asserts目录放到static目录下：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106150756.png" style="width:50%"></p><p>3) 将dao、entities放到com.liuzhuo.springboot包下：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106151100.png" style="width:50%"></p><p>然后点击DepartmentDao、EmployeeDao，重写导入我们的Department、Employee的包名。</p><hr><p>4）启动应用：</p><p>在浏览器中输入：<code>http://localhost:8080/</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106151352.png"></p><p>发现出现的页面是：static下的index.html页面，而不是template下的index.html页面。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106151609.png" style="width:50%"></p><p>因为静态主页会加载：META-INF/resources、resourcs、static、public下的 index.html</p><p>此时，我们不必要重新映射我们的主页，在我们的config下的Myconfig配置中：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Myconfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebMvcConfigurerAdapter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addViewControllers</span><span class="token punctuation">(</span>ViewControllerRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//super.addViewControllers(registry);</span>        registry<span class="token punctuation">.</span><span class="token function">addViewController</span><span class="token punctuation">(</span><span class="token string">"/liuzhuo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"sucess"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//添加主页的映射</span>        registry<span class="token punctuation">.</span><span class="token function">addViewController</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"login"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registry<span class="token punctuation">.</span><span class="token function">addViewController</span><span class="token punctuation">(</span><span class="token string">"/index.html"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"login"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registry<span class="token punctuation">.</span><span class="token function">addViewController</span><span class="token punctuation">(</span><span class="token string">"/login.html"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"login"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，将templates下的index.html 改为 login.html</p><p>重新启动应用：</p><p>在浏览器中输入：<br><code>http://localhost:8080/</code><br><code>http://localhost:8080/login.html</code><br><code>http://localhost:8080/index.html</code></p><p>都是以下的页面：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106152941.png"></p><p>5）因为我们使用 <strong>thymeleaf</strong>，所以需要在每个页面头部添加命名空间：</p><p>   <code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code></p><pre><code>&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; &gt;</code></pre><p>6) 在我们的静态页面中使用了bootstrap，所以需要bootstrap的webjar：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106153622.png"></p><pre><code>        &lt;!--bootstrap的jar包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.webjars&lt;/groupId&gt;            &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;            &lt;version&gt;4.0.0&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>在我们的login.html页面的中。找到引用bootstrap的地方：</p><p>th:href=”@{/webjars/bootstrap/4.0.0/css/bootstrap.css}”</p><pre><code>    &lt;!-- Bootstrap core CSS --&gt;    &lt;link href=&quot;asserts/css/bootstrap.min.css&quot; th:href=&quot;@{/webjars/bootstrap/4.0.0/css/bootstrap.css}&quot; rel=&quot;stylesheet&quot;&gt;</code></pre><p>查看有么有配置对？ctrl + 鼠标左键：能跳转到该文件处。</p><p>使用thymeleaf的th:href=”@{}”的好处：当我们给项目添加根目录时，也能自动帮我们添加上跟目录。</p><p>在application.properties中：</p><pre><code>server.context-path=/curd</code></pre><p>启动应用：<br>浏览器中输入：<code>http://localhost:8080/</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106154552.png"></p><p>输入：<code>http://localhost:8080/curd</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106154631.png"></p><p>右键审查元素：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106154730.png"></p><p><strong>能看到：link 中 href：自动帮我们添加上了curd的根目录</strong></p><p>7）修改我们的css配置路径：</p><p>在login.html中：<br>th:href=”@{/asserts/css/signin.css}”</p><pre><code>    &lt;!-- Custom styles for this template --&gt;    &lt;link href=&quot;asserts/css/signin.css&quot; th:href=&quot;@{/asserts/css/signin.css}&quot; rel=&quot;stylesheet&quot;&gt;</code></pre><p>页面中的其他引入资源，依次类推改写完毕即可。</p><hr><h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>以前，我们在SpringMVC中编写国际化时的步骤：</p><p>1）<strong>编写国际化配置文件</strong></p><p>2）使用ResourceBundleMessageSource管理国际化资源文件</p><p>3） 在页面使用fmt:message取出国际化内容（jsp引擎）</p><p>现在，使用Springboot开发的国际化的步骤：</p><p>1） 编写国际化配置文件，抽取页面需要显示的国际化消息</p><p>在resources下创建i18n文件来放置我们的国际化的配置文件。（国际化文件只能是properties）</p><p>然后创建login.properties（默认的国际化配置）、login_en_US.properties。</p><p>idea会帮我们自动生成 Resource Bundle ‘login’ 文件夹：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106161921.png" style="width:50%"></p><p>然后，我们在 Resource Bundle ‘login’ 上面右键：new<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106162042.png"></p><p>点击加号：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106162131.png" style="width:50%"></p><p>填写: 语言_国家（en_US）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106162648.png" style="width:50%"></p><p>最后生成的效果：有三个国家化的配置文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106162810.png" style="width:50%"></p><p>填写我们需要国际化的部分：</p><p>观察login页面，发现，我们需要五次国家化的部分。</p><p>login.tip (登入的标题)<br>login.username （用户名）<br>login.password （密码）<br>login.remembear （记住密码）<br>login.bt （登入按钮）</p><p>然后，随便点击一个国家化文件。在下角处切换视图：<strong>Resource Bund</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106163314.png"></p><p>点击在该视图模式下的，左上角的加号：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106163455.png"></p><p>填写key：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106163605.png"></p><p>填写value：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106165518.png"></p><p>依次类推：把<br>login.username （用户名）<br>login.password （密码）<br>login.remembear （记住密码）<br>login.bt （登入按钮）</p><p>添加上。</p><hr><p>2） SpringBoot自动配置好了管理国际化资源文件的组件(<strong>MessageSourceAutoConfiguration</strong>)</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.messages"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageSourceAutoConfiguration</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Comma‐separated list of basenames (essentially a fully‐qualified classpath         * location), each following the ResourceBundle convention with relaxed support for         * slash based locations. If it doesn't contain a package qualifier (such as         * "org.mypackage"), it will be resolved from the classpath root.         */</span>        <span class="token keyword">private</span> String basename <span class="token operator">=</span> <span class="token string">"messages"</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//我们的配置文件可以直接放在类路径下叫messages.properties；</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> MessageSource <span class="token function">messageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ResourceBundleMessageSource messageSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ResourceBundleMessageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>basename<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                     <span class="token comment" spellcheck="true">//设置国际化资源文件的基础名（去掉语言国家代码的）</span>            messageSource<span class="token punctuation">.</span><span class="token function">setBasenames</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">commaDelimitedListToStringArray</span><span class="token punctuation">(</span>                        StringUtils<span class="token punctuation">.</span><span class="token function">trimAllWhitespace</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>basename<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>encoding <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   messageSource<span class="token punctuation">.</span><span class="token function">setDefaultEncoding</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>encoding<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                messageSource<span class="token punctuation">.</span><span class="token function">setFallbackToSystemLocale</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>fallbackToSystemLocale<span class="token punctuation">)</span><span class="token punctuation">;</span>                messageSource<span class="token punctuation">.</span><span class="token function">setCacheSeconds</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cacheSeconds<span class="token punctuation">)</span><span class="token punctuation">;</span>                messageSource<span class="token punctuation">.</span><span class="token function">setAlwaysUseMessageFormat</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>alwaysUseMessageFormat<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> messageSource<span class="token punctuation">;</span>            <span class="token punctuation">}</span></code></pre><p>如果，我们的国际化文件的名字就是messages的话，而放在类路径下的话，我们直接就可以使用了。</p><p>但是，现在我们使用了i18n文件，所以，我们需要在application.properties配置文件中：配置国际化的信息：</p><pre class=" language-java"><code class="language-java">spring<span class="token punctuation">.</span>messages<span class="token punctuation">.</span>basename<span class="token operator">=</span>i18n<span class="token punctuation">.</span>login</code></pre><p>i18n文件夹，login是文件的名字。</p><p>3）修改login.html中的需要国际化的部分</p><p>我们从thymeleaf的官方文档中，看到了如果使用国际化的话，使用 <strong>#{}</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106171830.png"></p><p>4）启动应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106172121.png"></p><p>切换我们的地域语言：打开浏览器的设置（我使用的谷歌浏览器）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106172353.png"></p><p>刷新浏览器：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106172433.png"></p><p>以上为止，我们的国际化就搞定成功了。</p><p>效果：根据浏览器语言设置的信息切换了国际化。</p><hr><p><strong>原理：</strong></p><p>国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）；</p><p>打开WebMvcAutoConfiguration类：寻找与国际化有关的类：</p><pre class=" language-java"><code class="language-java">        <span class="token annotation punctuation">@Bean</span>        <span class="token annotation punctuation">@ConditionalOnMissingBean</span>        <span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.mvc"</span><span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">"locale"</span><span class="token punctuation">)</span>        <span class="token keyword">public</span> LocaleResolver <span class="token function">localeResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties                    <span class="token punctuation">.</span><span class="token function">getLocaleResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> WebMvcProperties<span class="token punctuation">.</span>LocaleResolver<span class="token punctuation">.</span>FIXED<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FixedLocaleResolver</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties<span class="token punctuation">.</span><span class="token function">getLocale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            AcceptHeaderLocaleResolver localeResolver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AcceptHeaderLocaleResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            localeResolver<span class="token punctuation">.</span><span class="token function">setDefaultLocale</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties<span class="token punctuation">.</span><span class="token function">getLocale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> localeResolver<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>通过此类：我们能发现，Springboot给我们配置的默认的国家化Locale的是一个AcceptHeaderLocaleResolver。</p><p>AcceptHeaderLocaleResolver：是通过每次请求时，在请求头在获取请求的语言来进行国际化识别的。</p><p>启动我们的应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106174300.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106174349.png" style="width:50%"></p><p>我们发现了Accept-Language：<strong>zh-CN.</strong></p><p>修改我们的浏览器的语言：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106174539.png"></p><p>再次访问我们的登入页面：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106174658.png" style="width:50%"><br>我们发现了Accept-Language：en-US.</p><p>这就是Springboot的默认的国际化原理。</p><hr><p>我们想要自己自定义国际化配置，该怎么办呢？</p><p>Springboot的默认国际化：localeResolver上面有一个注解：@ConditionalOnMissingBean</p><p>意思就是：当我们的容器中不存在localeResolver，才会使用默认的AcceptHeaderLocaleResolver。</p><p>所以，我们只需要向容器中，添加我们的localeResolver即可，默认的localeResolver就会失效。</p><hr><p>1）在component包下：创建MyLocaleResolver类(实现LocaleResolver)：</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106175524.png"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyLocaleResolver</span> <span class="token keyword">implements</span> <span class="token class-name">LocaleResolver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Locale <span class="token function">resolveLocale</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取请求的参数信息</span>        String language <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"language"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取默认的地域信息。</span>        Locale locale <span class="token operator">=</span> Locale<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>language<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String<span class="token punctuation">[</span><span class="token punctuation">]</span> split <span class="token operator">=</span> language<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//第一个参数：语言信息</span>            <span class="token comment" spellcheck="true">//第二个参数：国家信息</span>            locale <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Locale</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> split<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> locale<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLocale</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Locale locale<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2）将我们的LocaleResolver添加到容器中：</p><p>在Myconfig类中：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> LocaleResolver <span class="token function">localeResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyLocaleResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>3）修改login.html页面：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106180204.png"></p><p>4）启动应用：</p><p>点击底下的：中文<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106180248.png"></p><p>点击底下的：English<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106180353.png"></p><p>我们自定义的国际化解析器成功！</p><hr><p><strong>发现：在此时，不管我们将浏览器中的语言设置什么，我们的默认登入都是中文的</strong></p><p>因为，此时：我们使用的是自己的LocaleResovler：</p><p>当获取的language：String language = request.getParameter(“language”);<br>为空时，我们的Locale locale = Locale.getDefault();是获取的是本地的，我们这里就是中文。<br>不再是使用请求头中的那种方式了。</p><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>1）修改我们的登入页面：login.html</p><pre><code>&lt;form class=&quot;form-signin&quot; action=&quot;dashboard.html&quot; th:action=&quot;@{/user/login}&quot; method=&quot;post&quot;&gt;</code></pre><p>登入的action改为：/user/login。请求方式：post。</p><p>2）在controller包下，创建LoginController：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginController</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//@RequestMapping(value = "/user/login",method = RequestMethod.POST)</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/user/login"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">login</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span> String username<span class="token punctuation">,</span>                        <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span> String password<span class="token punctuation">,</span>                        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token string">"admin"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token string">"123456"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//登入成功！</span>            <span class="token keyword">return</span> <span class="token string">"dashboard"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//登入失败！</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"登入用户名或密码错误！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token string">"login"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3) 启动项目：</p><p>输入用户名和密码<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106213523.png"></p><p>报错了：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106213554.png"></p><p>原来是我们的login.html页面，没有给username和password添加name属性！<br>现在添加上：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106213732.png"></p><p>重启项目，并添加正确的用户名和密码（admin，123456）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106213924.png"></p><p><strong>注意：</strong></p><p>1）此时有可能还是刚刚的错误，因为thymeleaf默认是开启缓存功能的，所以我们开发的时候，要记住关闭缓存的功能<br>在配置文件中：</p><pre class=" language-java"><code class="language-java">spring<span class="token punctuation">.</span>thymeleaf<span class="token punctuation">.</span>cache<span class="token operator">=</span><span class="token boolean">false</span></code></pre><p>2）我们在项目已经启动的时候，修改页面后，直接刷新页面，还是不会变的，要在修改后的页面处：<strong>ctrl+F9</strong>（重新编译页面）</p><p>使用（1）和（2）之后，就可以在项目已经启动的时候，直接修改页面也能得到最新的体验了。</p><hr><p>现在，我们输入错误的用户名和密码：不会出现错误的信息。</p><p>怎么添加错误的信息在页面上呢？</p><p>给login.html页面添加一个</p><p>标签<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106214738.png"></p><p>当msg不为空时，才会出现错误的<code>&lt;p&gt;标签。</code></p><p>重启项目：输入错误的用户名和密码<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106214945.png"></p><p>现在错误提示也完成了，再次输入正确的用户名和密码，<strong>现在一不小心按了F5，刷新了页面</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106215200.png"></p><p>发现出现了是否重新提交表单的情况，因为我们的后端是<strong>转发</strong>到登入成功页面的，地址栏还是之前的登入页面的地址，所以刷新会出现这种情况。</p><p>现在修改后端的代码，将其改为<strong>重定向。</strong></p><p>在LoginController中：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106215826.png"><br>在Myconfig中：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181106215831.png"></p><p>重启我们的应用：输入正确的用户名和密码<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107095619.png"></p><p>什么？404？main.html没有找到？why？</p><p>当我们看到地址栏时，发现我们重定向时：是在/user下重定向的，所以找不到main.html。</p><p><strong>所以，在控制器Controller中：<code>return &quot;redirect:main.html&quot;;</code> main的前面不加<code>/</code>的话<br>会在@PostMapping(value = “/user/login”)中去掉最后一个路径下重定向，即在/user下重定向。<br>如果是@PostMapping(value = “/user/liuzhuo/login”)的话，就在/user/liuzhuo下重定向。</strong></p><p>怎样在我们的根路径下重定向呢？即在我们的<code>/crud</code>根路径下重定向。只需在main的前面加<code>/</code>即可：<br><code>return &quot;redirect:/main.html&quot;;</code></p><p>修改完毕后，重启我们的应用：输入正确的用户名和密码：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107100653.png"></p><p>发现样式也正确了。因为是重定向而来的。<strong>此时刷新页面，也不会重发请求了。</strong></p><h3 id="拦截器进行登陆检查"><a href="#拦截器进行登陆检查" class="headerlink" title="拦截器进行登陆检查"></a>拦截器进行登陆检查</h3><p>此时，我们在另一个浏览器中：直接输入<code>http://localhost:8080/curd/main.html</code>.<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107101109.png"></p><p>发现，没有登入就直接进来了，这是因为<strong>没有加拦截器</strong>的缘故。</p><p>1）在component包下：创建 <strong>LoginHandleInterceptor </strong>：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginHandleInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//在方法执行之前，调用。</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//从session中获取是否有loginUser属性的值</span>        Object loginUser <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"loginUser"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>loginUser<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//没有成功登入过。</span>            <span class="token comment" spellcheck="true">//转发登入页面</span>            request<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span><span class="token string">"/login.html"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//成功登入过</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">,</span> ModelAndView modelAndView<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">,</span> Exception ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2）将我们自己定义的拦截器添加到拦截器链中：</p><p>　　在Myconfig类中：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span>InterceptorRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//super.addInterceptors(registry);</span>        <span class="token comment" spellcheck="true">//添加拦截器我们自定义的拦截器</span>        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoginHandleInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">"/**"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//拦截路径：/**:拦截所有的请求</span>                <span class="token punctuation">.</span><span class="token function">excludePathPatterns</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span><span class="token string">"/index.html"</span><span class="token punctuation">,</span><span class="token string">"/login.html"</span><span class="token punctuation">,</span><span class="token string">"/user/login"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//排除登入和登入请求的拦截路径</span>    <span class="token punctuation">}</span></code></pre><p><b><code>这里虽然是拦截了所有的请求（/**），但是静态资源是不会被拦截的，Springboot已经帮我们排除掉了，所以放心使用.</code></b></p><p>3) 在我们的登入控制器LoginController中添加session的操作：</p><pre class=" language-java"><code class="language-java">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token string">"admin"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token string">"123456"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//登入成功！</span>            <span class="token comment" spellcheck="true">//将用户名放入到session当中</span>            session<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"loginUser"</span><span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//重定向到我们指定的登入成功的页面</span>            <span class="token keyword">return</span> <span class="token string">"redirect:/main.html"</span><span class="token punctuation">;</span></code></pre><p>4) 重启我们的应用。</p><p>在谷歌浏览器中，成功登入成功后，直接输入：<code>http://localhost:8080/curd/main.html</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107103005.png"></p><p>发现，可以直接直接访问，因为已经成功登入过了，在session中已经保存了我们的用户信息。</p><p>在另外的浏览器中，直接输入：<code>http://localhost:8080/curd/main.html</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107103240.png"></p><p>会转发到我们的登入页面，因为是转发，所以地址栏不变。</p><hr><h3 id="CRUD-员工列表"><a href="#CRUD-员工列表" class="headerlink" title="CRUD-员工列表"></a>CRUD-员工列表</h3><p>实验要求：</p><p>1) RestfulCRUD：CRUD满足Rest风格</p><p>URI： /资源名称/资源标识 　HTTP请求方式区分对资源CRUD操作<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107114154.png"></p><p>2) 实验的请求架构<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107114230.png"></p><p>3) 员工列表：</p><p><strong>thymeleaf公共页面元素抽取</strong></p><pre><code>1、抽取公共片段&lt;div th:fragment=&quot;copy&quot;&gt;   &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert=&quot;~{footer :: copy}&quot;&gt;&lt;/div&gt;~{templatename::selector}：模板名::选择器~{templatename::fragmentname}:模板名::片段名模板名就是：aaa.html中的aaa片段名就是：th:fragment=&quot;bbb&quot;中的bbb选择器就是：id选择器，class选择器等3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~{}：行内写法必须加上：[[~{}]] ：不转义特殊字符（/n） 、  [(~{})] ：转义特殊字符</code></pre><p>三种引入公共片段的th属性：</p><p>th:insert：将公共片段整个插入到声明引入的元素中</p><p>th:replace：将声明引入的元素替换为公共片段</p><p>th:include：将被引入的片段的内容包含进这个标签中</p><pre><code>&lt;footer th:fragment=&quot;copy&quot;&gt;    &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式:&lt;div th:insert=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;效果:&lt;div&gt;    &lt;footer&gt;        &amp;copy; 2011 The Good Thymes Virtual Grocery    &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;    &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;    &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;</code></pre><p>1) 将登入成功后的dashboard.html页面中的顶部和左边的侧单栏抽取出来：</p><p>在templates下：创建page文件夹，并创建两个html页面：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107154114.png" style="width:50%"></p><p>top.html页面：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;nav th:fragment=&quot;top&quot; class=&quot;navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0&quot;&gt;        &lt;a class=&quot;navbar-brand col-sm-3 col-md-2 mr-0&quot; href=&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;&gt;[[${session.loginUser}]]&lt;/a&gt;        &lt;input class=&quot;form-control form-control-dark w-100&quot; type=&quot;text&quot; placeholder=&quot;Search&quot; aria-label=&quot;Search&quot;&gt;        &lt;ul class=&quot;navbar-nav px-3&quot;&gt;            &lt;li class=&quot;nav-item text-nowrap&quot;&gt;                &lt;a class=&quot;nav-link&quot; href=&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;&gt;退出&lt;/a&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/nav&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>主要是其中的<code>&lt;nav&gt;&lt;/nav&gt;</code>片段，这个片段是dashboard.html中的顶部的片段复制过来的。</p><p>其中主要是在<code>&lt;nav&gt;</code>中加入了<strong>th:fragment=”top”</strong>属性</p><p>slide.html页面：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107154633.png"></p><p>其中的<code>&lt;nav&gt;</code>片段：是dashboard.html中的左边的侧单栏的部分复制过来的。</p><p>其中，主要加入了：<strong>id：slide</strong> 的属性。</p><p>2）修改dashboard.html页面的顶部与左边部分：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107155129.png"></p><p>3）启动应用，运行发现顶部与左部运行完好。</p><hr><p>现在，我们开始完成员工信息的部分；即：左单栏的Customer部分。</p><p>1）将templates下的list.html页面放到empl目录下，这样分文件夹管理更加合理<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107155615.png" style="width:50%"></p><p>2）修改dashboard.html中的Customer部分的action属性：<br>因为左部已经抽取到slide.html页面，所以到slide.html页面中修改：</p><p>修改之前：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107155857.png"></p><p>修改之后：将Customer改为员工信息，修改a标签的href<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107160209.png"></p><p>3）controller包下，创建EmployeeController：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmployeeController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> EmployeeDao employeeDao<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/emp"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">list</span><span class="token punctuation">(</span>Model model<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Collection<span class="token operator">&lt;</span>Employee<span class="token operator">></span> employees <span class="token operator">=</span> employeeDao<span class="token punctuation">.</span><span class="token function">getAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"employees"</span><span class="token punctuation">,</span> employees<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"empl/list"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>4) 启动应用<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107160734.png"></p><p>点击：员工信息</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107160813.png"></p><p>此时员工信息里面还是Customer，因为没有抽取出公共部分。</p><p>修改list.html的顶部与左部，与dashboard.html类似。自己完成。</p><p>完成后的效果：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107161524.png"></p><p>但是，我们发现此时<strong>左部的高亮部分还是Dashboard</strong></p><p>5）怎么修改高亮为员工信息呢？</p><p>thymeleaf模板引擎中，查看官方文档，发现可以有参数化的片段布局：8.2 Parameterizable fragment signatures<br><a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#parameterizable-fragment-signatures" target="_blank" rel="noopener">官方参考</a></p><p>引入片段的时候传入参数：</p><p><code>&lt;div th:replace=&quot;commons/bar::#sidebar(activeUri=&#39;emps&#39;)&quot;&gt;&lt;/div&gt;</code></p><p>即：就是在我们引入的同时，在后面加一个括号，里面填写：key=value。</p><p>修改dashboard.html页面：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107164137.png"></p><p>修改list.html页面：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107164221.png"></p><p>修改slide.html页面：</p><p>在Dashboard处：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107164336.png"></p><p>在员工信息处：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107164425.png"></p><p>重启我们的应用：</p><p>点击Dashboard，Dashboard高亮。</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107164640.png"></p><p>点击员工信息，员工信息高亮。</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107164704.png"></p><hr><p>6）将员工信息换成我们的后端传递过来的数据：</p><p>在list页面中：</p><pre class=" language-java"><code class="language-java">        <span class="token operator">&lt;</span>main role<span class="token operator">=</span><span class="token string">"main"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"col-md-9 ml-sm-auto col-lg-10 pt-3 px-4"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>h2<span class="token operator">></span><span class="token operator">&lt;</span>button <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"btn btn-sm btn-success"</span><span class="token operator">></span>员工添加<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>            <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"table-responsive"</span><span class="token operator">></span>                <span class="token operator">&lt;</span>table <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"table table-striped table-sm"</span><span class="token operator">></span>                    <span class="token operator">&lt;</span>thead<span class="token operator">></span>                    <span class="token operator">&lt;</span>tr<span class="token operator">></span>                        <span class="token operator">&lt;</span>th<span class="token operator">></span>id<span class="token operator">&lt;</span><span class="token operator">/</span>th<span class="token operator">></span>                        <span class="token operator">&lt;</span>th<span class="token operator">></span>lastName<span class="token operator">&lt;</span><span class="token operator">/</span>th<span class="token operator">></span>                        <span class="token operator">&lt;</span>th<span class="token operator">></span>email<span class="token operator">&lt;</span><span class="token operator">/</span>th<span class="token operator">></span>                        <span class="token operator">&lt;</span>th<span class="token operator">></span>gender<span class="token operator">&lt;</span><span class="token operator">/</span>th<span class="token operator">></span>                        <span class="token operator">&lt;</span>th<span class="token operator">></span>department<span class="token operator">&lt;</span><span class="token operator">/</span>th<span class="token operator">></span>                        <span class="token operator">&lt;</span>th<span class="token operator">></span>birth<span class="token operator">&lt;</span><span class="token operator">/</span>th<span class="token operator">></span>                        <span class="token operator">&lt;</span>th<span class="token operator">></span>操作<span class="token operator">&lt;</span><span class="token operator">/</span>th<span class="token operator">></span>                    <span class="token operator">&lt;</span><span class="token operator">/</span>tr<span class="token operator">></span>                    <span class="token operator">&lt;</span><span class="token operator">/</span>thead<span class="token operator">></span>                    <span class="token operator">&lt;</span>tbody<span class="token operator">></span>                    <span class="token operator">&lt;</span>tr th<span class="token operator">:</span>each<span class="token operator">=</span><span class="token string">"empl:${employees}"</span><span class="token operator">></span>                        <span class="token operator">&lt;</span>td th<span class="token operator">:</span>text<span class="token operator">=</span><span class="token string">"${empl.id}"</span><span class="token operator">></span><span class="token number">1001</span><span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">></span>                        <span class="token operator">&lt;</span>td<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">[</span>$<span class="token punctuation">{</span>empl<span class="token punctuation">.</span>lastName<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">></span>                        <span class="token operator">&lt;</span>td th<span class="token operator">:</span>text<span class="token operator">=</span><span class="token string">"${empl.email}"</span><span class="token operator">></span><span class="token number">5589584</span><span class="token annotation punctuation">@qq</span><span class="token punctuation">.</span>com<span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">></span>                        <span class="token operator">&lt;</span>td th<span class="token operator">:</span>text<span class="token operator">=</span><span class="token string">"${empl.gender}=='0'?'女':'男'"</span><span class="token operator">></span>男<span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">></span>                        <span class="token operator">&lt;</span>td th<span class="token operator">:</span>text<span class="token operator">=</span><span class="token string">"${empl.department.departmentName}"</span><span class="token operator">></span>商业提升部<span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">></span>                        <span class="token operator">&lt;</span>td th<span class="token operator">:</span>text<span class="token operator">=</span><span class="token string">"${#dates.format(empl.birth, 'yyyy-MM-dd HH:mm:ss')}"</span><span class="token operator">></span><span class="token number">2018</span><span class="token operator">/</span><span class="token number">11</span><span class="token operator">/</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">></span>                        <span class="token operator">&lt;</span>td<span class="token operator">></span>                            <span class="token operator">&lt;</span>button <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"btn btn-sm btn-primary"</span><span class="token operator">></span>编辑<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>                            <span class="token operator">&lt;</span>button <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"btn btn-sm btn-danger"</span><span class="token operator">></span>删除<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>                        <span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">></span>                    <span class="token operator">&lt;</span><span class="token operator">/</span>tr<span class="token operator">></span>                    <span class="token operator">&lt;</span><span class="token operator">/</span>tbody<span class="token operator">></span>                <span class="token operator">&lt;</span><span class="token operator">/</span>table<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>main<span class="token operator">></span></code></pre><p>ctrl+F9:<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107170503.png"></p><h3 id="员工列表的添加"><a href="#员工列表的添加" class="headerlink" title="员工列表的添加"></a>员工列表的添加</h3><p>首先将员工信息的url换成 <strong>/empls </strong>:代表获取所有的员工信息，而 <strong>/empl </strong>：代表添加员工的信息。</p><p>1.将员工添加的按钮换成a标签：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107172030.png"></p><p>2.在EmployeeController中：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> DepartmentDao departmentDao<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/empl"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">add</span><span class="token punctuation">(</span>Model model<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取所有的部门信息：</span>        Collection<span class="token operator">&lt;</span>Department<span class="token operator">></span> departments <span class="token operator">=</span> departmentDao<span class="token punctuation">.</span><span class="token function">getDepartments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"departments"</span><span class="token punctuation">,</span> departments<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"empl/employee"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>3.在templates下的empl中添加employee.html页面：</p><p>首先，直接复制list.html为employee.html。</p><p>然后，修改其中的main标签部分：</p><pre><code>        &lt;main role=&quot;main&quot; class=&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;&gt;            &lt;form&gt;                &lt;div class=&quot;form‐group&quot;&gt;                    &lt;label&gt;LastName&lt;/label&gt;                    &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                     &lt;label&gt;Email&lt;/label&gt;                     &lt;input type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot;&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                    &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt;                    &lt;div class=&quot;form‐check form‐check‐inline&quot;&gt;                         &lt;input class=&quot;form‐check‐input&quot; type=&quot;radio&quot; name=&quot;gender&quot;   value=&quot;1&quot;&gt;                         &lt;label class=&quot;form‐check‐label&quot;&gt;男&lt;/label&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form‐check form‐check‐inline&quot;&gt;                         &lt;input class=&quot;form‐check‐input&quot; type=&quot;radio&quot; name=&quot;gender&quot;   value=&quot;0&quot;&gt;                         &lt;label class=&quot;form‐check‐label&quot;&gt;女&lt;/label&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                     &lt;label&gt;department&lt;/label&gt;                     &lt;select class=&quot;form-control&quot;&gt;                        &lt;option&gt;1&lt;/option&gt;                        &lt;option&gt;2&lt;/option&gt;                        &lt;option&gt;3&lt;/option&gt;                        &lt;option&gt;4&lt;/option&gt;                        &lt;option&gt;5&lt;/option&gt;                     &lt;/select&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                     &lt;label&gt;Birth&lt;/label&gt;                     &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;button type=&quot;submit&quot; class=&quot;btn btn-sm btn-primary&quot;&gt;添加&lt;/button&gt;            &lt;/form&gt;        &lt;/main&gt;</code></pre><p>4.重启应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107174348.png"></p><p>5.此时的department部分还是死数据：</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"form‐group"</span><span class="token operator">></span>     <span class="token operator">&lt;</span>label<span class="token operator">></span>department<span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">></span>     <span class="token operator">&lt;</span>select <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"form-control"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>option th<span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">"${dept.id}"</span> th<span class="token operator">:</span>text<span class="token operator">=</span><span class="token string">"${dept.departmentName}"</span> th<span class="token operator">:</span>each<span class="token operator">=</span><span class="token string">"dept:${departments}"</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>option<span class="token operator">></span>     <span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></code></pre><p>刷新页面：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107174754.png"></p><p>6.给form表单添加action和method属性：</p><pre><code> &lt;form th:action=&quot;@{/empl}&quot; method=&quot;post&quot;&gt;</code></pre><p>7.书写添加员工的控制器</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//添加员工</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/empl"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">addEmployee</span><span class="token punctuation">(</span>Employee employee<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>employee<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//添加员工</span>        employeeDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>employee<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"redirect:/empls"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>8.重启应用，点击添加：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107183750.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107183847.png"></p><p>添加失败？因为我们的表单里面木有给属性添加name。<br>现在全部加上。</p><pre><code>   &lt;input type=&quot;text&quot; th:name=&quot;lastName&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;   &lt;input type=&quot;email&quot; th:name=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot;&gt;   &lt;select class=&quot;form-control&quot; th:name=&quot;department.id&quot;&gt;    &lt;input type=&quot;text&quot; th:name=&quot;birth&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;</code></pre><p>然后再次尝试添加：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107184848.png"></p><p>添加成功！！！</p><p><strong>注意：这里填写生日的格式必须是 xxxx/xx/xx 的形式。其他形式就会出错，因为Springboot默认格式化的日期格式就是xxxx/xx/xx 的形式</strong></p><p>如果，我们想改日期的格式呢？</p><p>打开WebMvcAutoConfiguration类：</p><pre><code>        @Bean        @ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date-format&quot;)        public Formatter&lt;Date&gt; dateFormatter() {            return new DateFormatter(this.mvcProperties.getDateFormat());        }</code></pre><p>默认帮我们配置好的时间格式转化器。</p><p>点击：getDateFormat()：</p><pre><code>    public String getDateFormat() {        return this.dateFormat;    }</code></pre><p>再点击：this.dateFormat</p><pre><code>    /**     * Date format to use (e.g. dd/MM/yyyy).     */    private String dateFormat;</code></pre><p>说明默认的确实是：dd/MM/yyyy的形式。</p><p>想要修改默认的格式：只需要在application.properties文件中修改spring.mvc.date-format=xxxx即可：</p><pre><code>#修改日期的格式spring.mvc.date-format=yyyy-MM-dd</code></pre><hr><h3 id="员工列表的编辑"><a href="#员工列表的编辑" class="headerlink" title="员工列表的编辑"></a>员工列表的编辑</h3><p>修改添加二合一表单</p><p>1）首先修改编辑按钮：</p><pre><code>  &lt;a th:href=&quot;@{/empl/}+${empl.id}&quot; class=&quot;btn btn-sm btn-primary&quot;&gt;编辑&lt;/a&gt;</code></pre><p>2) EmployeeController中：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//去编辑员工的页面</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/empl/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">toEditPage</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Integer id<span class="token punctuation">,</span> Model model<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取员工的信息：</span>        Employee employee <span class="token operator">=</span> employeeDao<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"employee"</span><span class="token punctuation">,</span>employee<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取所有的部门信息：</span>        Collection<span class="token operator">&lt;</span>Department<span class="token operator">></span> departments <span class="token operator">=</span> departmentDao<span class="token punctuation">.</span><span class="token function">getDepartments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"departments"</span><span class="token punctuation">,</span> departments<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//重定向到编辑员工的页面（add页面一样，共用）</span>        <span class="token keyword">return</span> <span class="token string">"empl/employee"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>3) 在employee.html页面中回显员工的信息。</p><pre><code>            &lt;form th:action=&quot;@{/empl}&quot; method=&quot;post&quot;&gt;                &lt;div class=&quot;form‐group&quot;&gt;                    &lt;label&gt;LastName&lt;/label&gt;                    &lt;input type=&quot;text&quot; th:value=&quot;${employee.lastName}&quot; th:name=&quot;lastName&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                     &lt;label&gt;Email&lt;/label&gt;                     &lt;input type=&quot;email&quot; th:value=&quot;${employee.email}&quot; th:name=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot;&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                    &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt;                    &lt;div class=&quot;form‐check form‐check‐inline&quot;&gt;                         &lt;input class=&quot;form‐check‐input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:checked=&quot;${employee.gender}==1&quot;&gt;                         &lt;label class=&quot;form‐check‐label&quot;&gt;男&lt;/label&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form‐check form‐check‐inline&quot;&gt;                         &lt;input class=&quot;form‐check‐input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:checked=&quot;${employee.gender}==0&quot;&gt;                         &lt;label class=&quot;form‐check‐label&quot;&gt;女&lt;/label&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                     &lt;label&gt;department&lt;/label&gt;                     &lt;select class=&quot;form-control&quot; th:name=&quot;department.id&quot;&gt;                    &lt;option th:selected=&quot;${employee.department.id}==${dept.id}&quot; th:value=&quot;${dept.id}&quot; th:text=&quot;${dept.departmentName}&quot; th:each=&quot;dept:${departments}&quot;&gt;1                    &lt;/option&gt;                     &lt;/select&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;div class=&quot;form‐group&quot;&gt;                     &lt;label&gt;Birth&lt;/label&gt;                     &lt;input type=&quot;text&quot; th:value=&quot;${#dates.format(employee.birth, &#39;yyyy-MM-dd HH:mm:ss&#39;)}&quot; th:name=&quot;birth&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt;                &lt;/div&gt;                &lt;br&gt;                &lt;button type=&quot;submit&quot; class=&quot;btn btn-sm btn-primary&quot;&gt;添加&lt;/button&gt;            &lt;/form&gt;</code></pre><p>4) 重启应用，点击编辑<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107193709.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107193721.png"></p><p>回显成功。</p><p>此时，再次点击添加时：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107193842.png"></p><p>控制台：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107193935.png"></p><p>这是因为，我们点击添加的时候，model对象中根本没有employee对象，所以employee.html中的：<br><strong>th:value=”${employee.lastName}”等都会出现空指针异常。</strong></p><p>5）再次修改employee.html页面：添加判断语句</p><p>${employee!=null}?</p><p>例如：</p><pre><code>th:value=&quot;${employee!=null}?${employee.lastName}&quot;</code></pre><p>此时：再次点击员工添加，就不会出现问题了。</p><p>6）button的按钮修改</p><pre><code>  &lt;button type=&quot;submit&quot; th:text=&quot;${employee!=null}?&#39;修改&#39;:&#39;添加&#39;&quot; class=&quot;btn btn-sm btn-primary&quot;&gt;添加&lt;/button&gt;</code></pre><p>7）form表单的method的修改：</p><p>当是添加操作时，就是method=post提交。<br>当是修改操作时，就是method=put提交。</p><p>以前是SpringMVC的时候，想要使用put提交。</p><ol><li>SpringMVC中配置HiddenHttpMethodFilter;</li><li>页面创建一个post表单</li><li>创建一个input项，name=”_method”;值就是我们指定的请求方式</li></ol><p>Springboot已经默认帮我们配置好了HiddenHttpMethodFilter。在WebMvcAutoConfiguration中：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>HiddenHttpMethodFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> OrderedHiddenHttpMethodFilter <span class="token function">hiddenHttpMethodFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OrderedHiddenHttpMethodFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>所以，现在我们只需要添加一个input项，name=”_method”的标签即可：</p><pre><code>      &lt;input type=&quot;hidden&quot; name=&quot;_method&quot;  value=&quot;put&quot; th:if=&quot;${employee!=null}&quot;/&gt;      &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;${employee.id}&quot; th:if=&quot;${employee!=null}&quot;/&gt;</code></pre><p>8) EmployeeController中添加编辑的逻辑：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//修改员工</span>    <span class="token annotation punctuation">@PutMapping</span><span class="token punctuation">(</span><span class="token string">"/empl"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">EditEmployee</span><span class="token punctuation">(</span>Employee employee<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>employee<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//修改员工</span>        employeeDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>employee<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"redirect:/empls"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>9) 随便点击一个员工进行修改：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107195757.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107195859.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107195923.png"></p><p>修改成功！！！</p><h3 id="员工列表的删除"><a href="#员工列表的删除" class="headerlink" title="员工列表的删除"></a>员工列表的删除</h3><p>1）修改删除的按钮以delete的方式提交</p><p>不能简单的将button按钮标签改为a标签，因为a标签默认是get方式提交。</p><p>我们使用js的方式来提交表单：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day05/QQ%E6%88%AA%E5%9B%BE20181107202935.png"></p><p>2）添加js代码：</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>    $<span class="token punctuation">(</span><span class="token string">".deleteBtn"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        var del_url <span class="token operator">=</span> $<span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"del_url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        $<span class="token punctuation">(</span><span class="token string">"#deleteEmpForm"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"action"</span><span class="token punctuation">,</span> del_url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//改变form默认的提交方式</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>3) EmployeeController中：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//删除员工信息</span>    <span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span><span class="token string">"/empl/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">deleteEmlp</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//删除指定员工id的员工</span>        employeeDao<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"redirect:/empls"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>4) 重启应用，试试删除按钮</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_04</title>
      <link href="/2018/11/05/springboot-day-04/"/>
      <url>/2018/11/05/springboot-day-04/</url>
      
        <content type="html"><![CDATA[<p>今天，我们开始Springboot的Web开发</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>使用SpringBoot:</p><p><strong>1）、创建SpringBoot应用，选中我们需要的模块；</strong></p><p><strong>2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来.</strong></p><p><strong>3）、自己编写业务代码；</strong></p><p>想要使用SpringBoot的自动配置的功能，我们必须熟知SpringBoot的自动配置的原理。</p><h4 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h4><p>这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx</p><p>自动配置原理，一般我们需要看：<strong>spring-boot-autoconfigure</strong><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day04/QQ%E6%88%AA%E5%9B%BE20181105134252.png" style="width:50%"></p><p>然后再看我们想要的模块里面的：</p><pre class=" language-java"><code class="language-java">xxxxAutoConfiguration<span class="token operator">:</span> 帮我们给容器中自动配置组件；xxxxProperties<span class="token operator">:</span>        配置类来封装配置文件的内容；</code></pre><p>比如：Web模块，看：DispatchServletAutoConfiguration<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day04/QQ%E6%88%AA%E5%9B%BE20181105134739.png" style="width:50%"></p><h2 id="SpringBoot对静态资源的映射规则"><a href="#SpringBoot对静态资源的映射规则" class="headerlink" title="SpringBoot对静态资源的映射规则"></a>SpringBoot对静态资源的映射规则</h2><p>创建我们的今天的Web项目：（添加Web模块）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day04/QQ%E6%88%AA%E5%9B%BE20181105141110.png"></p><p>在：<strong>spring-boot-autoconfigurejar</strong> 下：</p><p>web下的 <strong>WebMvcAutoConfiguration</strong>：专门为我们配置了默认的Web应用的配置：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day04/QQ%E6%88%AA%E5%9B%BE20181105141946.png"></p><p><strong>设置：静态资源的相关配置的类：</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.resources"</span><span class="token punctuation">,</span> ignoreUnknownFields <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResourceProperties</span> <span class="token keyword">implements</span> <span class="token class-name">ResourceLoaderAware</span><span class="token punctuation">,</span> InitializingBean <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> SERVLET_RESOURCE_LOCATIONS <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"/"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> CLASSPATH_RESOURCE_LOCATIONS <span class="token operator">=</span> <span class="token punctuation">{</span>            <span class="token string">"classpath:/META-INF/resources/"</span><span class="token punctuation">,</span> <span class="token string">"classpath:/resources/"</span><span class="token punctuation">,</span>            <span class="token string">"classpath:/static/"</span><span class="token punctuation">,</span> <span class="token string">"classpath:/public/"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> RESOURCE_LOCATIONS<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        RESOURCE_LOCATIONS <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>CLASSPATH_RESOURCE_LOCATIONS<span class="token punctuation">.</span>length                <span class="token operator">+</span> SERVLET_RESOURCE_LOCATIONS<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>SERVLET_RESOURCE_LOCATIONS<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> RESOURCE_LOCATIONS<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                SERVLET_RESOURCE_LOCATIONS<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>CLASSPATH_RESOURCE_LOCATIONS<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> RESOURCE_LOCATIONS<span class="token punctuation">,</span>                SERVLET_RESOURCE_LOCATIONS<span class="token punctuation">.</span>length<span class="token punctuation">,</span> CLASSPATH_RESOURCE_LOCATIONS<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   ·····  <span class="token comment" spellcheck="true">//可以设置和静态资源有关的参数，缓存时间等</span></code></pre><p><strong>设置静态资源映射的默认方法：</strong></p><pre class=" language-java"><code class="language-java">        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addResourceHandlers</span><span class="token punctuation">(</span>ResourceHandlerRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceProperties<span class="token punctuation">.</span><span class="token function">isAddMappings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Default resource handling disabled"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            Integer cachePeriod <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>resourceProperties<span class="token punctuation">.</span><span class="token function">getCachePeriod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>registry<span class="token punctuation">.</span><span class="token function">hasMappingForPattern</span><span class="token punctuation">(</span><span class="token string">"/webjars/**"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">customizeResourceHandlerRegistration</span><span class="token punctuation">(</span>registry                        <span class="token punctuation">.</span><span class="token function">addResourceHandler</span><span class="token punctuation">(</span><span class="token string">"/webjars/**"</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">addResourceLocations</span><span class="token punctuation">(</span><span class="token string">"classpath:/META-INF/resources/webjars/"</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">setCachePeriod</span><span class="token punctuation">(</span>cachePeriod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            String staticPathPattern <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties<span class="token punctuation">.</span><span class="token function">getStaticPathPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>registry<span class="token punctuation">.</span><span class="token function">hasMappingForPattern</span><span class="token punctuation">(</span>staticPathPattern<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">customizeResourceHandlerRegistration</span><span class="token punctuation">(</span>                        registry<span class="token punctuation">.</span><span class="token function">addResourceHandler</span><span class="token punctuation">(</span>staticPathPattern<span class="token punctuation">)</span>                                <span class="token punctuation">.</span><span class="token function">addResourceLocations</span><span class="token punctuation">(</span>                                        <span class="token keyword">this</span><span class="token punctuation">.</span>resourceProperties<span class="token punctuation">.</span><span class="token function">getStaticLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                <span class="token punctuation">.</span><span class="token function">setCachePeriod</span><span class="token punctuation">(</span>cachePeriod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><h3 id="webjars静态资源映射规则"><a href="#webjars静态资源映射规则" class="headerlink" title="webjars静态资源映射规则"></a>webjars静态资源映射规则</h3><p><code>所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源</code></p><p>webjars：以jar包的方式引入静态资源.</p><p><a href="https://www.webjars.org/" target="_blank" rel="noopener">webjars官网</a></p><p>例子：引入jQuery的静态资源。</p><p>打开webjars官网，找到jQuery的Maven配置信息：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day04/QQ%E6%88%AA%E5%9B%BE20181105143244.png"></p><p>将拷贝的jQuery的Maven配置，导入到我们的项目中。</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.webjars&lt;/groupId&gt;            &lt;artifactId&gt;jquery&lt;/artifactId&gt;            &lt;version&gt;3.3.1-1&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>在我们的依赖jar中，找到jQuery的依赖：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day04/QQ%E6%88%AA%E5%9B%BE20181105143645.png" style="width:50%"></p><p>发现，这个依赖的jar的目录格式，也是 <code>classpath:/META-INF/resources/webjars/</code></p><font color="red">所以：当我们访问/webjars/**的url时，SpringBoot会帮我们在classpath:/META-INF/resources/webjars/选择webjars的静态jar资源。</font><p>启动我们的项目：</p><p>在浏览器中输入：<code>http://localhost:8080/webjars/jquery/3.3.1-1/jquery.js</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day04/QQ%E6%88%AA%E5%9B%BE20181105144226.png"></p><p><strong>webjar的静态资源访问成功！</strong></p><h3 id="静态资源的映射原理"><a href="#静态资源的映射原理" class="headerlink" title="静态资源的映射原理"></a>静态资源的映射原理</h3><p><code>/**  访问当前项目的任何资源，都去（静态资源的文件夹）找映射</code></p><pre class=" language-java"><code class="language-java">String staticPathPattern <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties<span class="token punctuation">.</span><span class="token function">getStaticPathPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>registry<span class="token punctuation">.</span><span class="token function">hasMappingForPattern</span><span class="token punctuation">(</span>staticPathPattern<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">customizeResourceHandlerRegistration</span><span class="token punctuation">(</span>        registry<span class="token punctuation">.</span><span class="token function">addResourceHandler</span><span class="token punctuation">(</span>staticPathPattern<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">addResourceLocations</span><span class="token punctuation">(</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>resourceProperties<span class="token punctuation">.</span><span class="token function">getStaticLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setCachePeriod</span><span class="token punctuation">(</span>cachePeriod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>这里，注册了 <strong>staticPathPattern</strong> 和 <strong>this.resourceProperties.getStaticLocations()</strong> 的静态资源访问。</p><p>点击：staticPathPattern：<code>private String staticPathPattern = &quot;/**&quot;;</code> </p><p>点击：getStaticLocations()：</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">private</span> <span class="token keyword">static</span> final String<span class="token punctuation">[</span><span class="token punctuation">]</span> CLASSPATH_RESOURCE_LOCATIONS <span class="token operator">=</span> <span class="token punctuation">{</span>            <span class="token string">"classpath:/META-INF/resources/"</span><span class="token punctuation">,</span> <span class="token string">"classpath:/resources/"</span><span class="token punctuation">,</span>            <span class="token string">"classpath:/static/"</span><span class="token punctuation">,</span> <span class="token string">"classpath:/public/"</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><font color="red"><strong>总结</strong>：</font><p>对于：/** 的静态资源的访问。</p><p>会到以下的路径寻找静态资源：</p><p><strong>“classpath:/META‐INF/resources/“,</strong></p><p><strong>“classpath:/resources/“,</strong></p><p><strong>“classpath:/static/“,</strong></p><p><strong>“classpath:/public/“</strong></p><p>这里的”classpath”：就相当于我们项目的java、resources目录。</p><p>印证我们的默认的静态资源访问：</p><p>在以上的目录中随意放一张照片：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day04/QQ%E6%88%AA%E5%9B%BE20181105150445.png" style="width:50%"></p><p>三张，不同的照片，但是名字都是123.jpg的照片。</p><p>启动项目，在浏览器中输入：<code>http://localhost:8080/123.jpg</code></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day04/QQ%E6%88%AA%E5%9B%BE20181105150124.png"></p><p>出现的是”META-INF/resources”下的123.jpg照片。 </p><p>删除”META-INF/resources”下的123.jpg照片. 再次访问是”classpath:/resources/“下的123.jpg</p><p>依次类推：再是”classpath:/static/“、”classpath:/public/“。</p><font color="red"><strong>优先级是：从上到下，依次递减</strong></font><hr><h3 id="欢迎页-静态资源文件夹下的所有index-html页面；被”-”映射"><a href="#欢迎页-静态资源文件夹下的所有index-html页面；被”-”映射" class="headerlink" title="欢迎页: 静态资源文件夹下的所有index.html页面；被”/**”映射"></a>欢迎页: 静态资源文件夹下的所有index.html页面；被”/**”映射</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> WelcomePageHandlerMapping <span class="token function">welcomePageHandlerMapping</span><span class="token punctuation">(</span>        ResourceProperties resourceProperties<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WelcomePageHandlerMapping</span><span class="token punctuation">(</span>resourceProperties<span class="token punctuation">.</span><span class="token function">getWelcomePage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties<span class="token punctuation">.</span><span class="token function">getStaticPathPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>getWelcomePage():</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getStaticWelcomePageLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>staticLocations<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String location <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>staticLocations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>location<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                location <span class="token operator">=</span> location <span class="token operator">+</span> <span class="token string">"/"</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> location <span class="token operator">+</span> <span class="token string">"index.html"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>getStaticPathPattern():</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> String staticPathPattern <span class="token operator">=</span> <span class="token string">"/**"</span><span class="token punctuation">;</span></code></pre><p><b>即对:　/**　 的访问。SpringBoot会自动到刚刚我们的提到的静态资源的文件夹下找index.html的页面</b></p><p>localhost:8080/ 找index页面</p><hr><h3 id="所有的-favicon-ico-都是在静态资源文件下找"><a href="#所有的-favicon-ico-都是在静态资源文件下找" class="headerlink" title="所有的 **/favicon.ico 都是在静态资源文件下找"></a>所有的 **/favicon.ico 都是在静态资源文件下找</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> SimpleUrlHandlerMapping <span class="token function">faviconHandlerMapping</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    SimpleUrlHandlerMapping mapping <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleUrlHandlerMapping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mapping<span class="token punctuation">.</span><span class="token function">setOrder</span><span class="token punctuation">(</span>Ordered<span class="token punctuation">.</span>HIGHEST_PRECEDENCE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mapping<span class="token punctuation">.</span><span class="token function">setUrlMap</span><span class="token punctuation">(</span>Collections<span class="token punctuation">.</span><span class="token function">singletonMap</span><span class="token punctuation">(</span><span class="token string">"**/favicon.ico"</span><span class="token punctuation">,</span>            <span class="token function">faviconRequestHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> mapping<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>JSP、Velocity、Freemarker、Thymeleaf<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day04/QQ%E6%88%AA%E5%9B%BE20181105153402.png"></p><p>Springboot默认是不支持jsp模板引擎的，因为SpringBoot是打成jar包，使用嵌入式的Tomcat容器。</p><p>这里，我们使用SpringBoot官方推荐的 <strong>Thymeleaf </strong>模板引擎。语法更简单，功能更强大。</p><h3 id="引入thymeleaf"><a href="#引入thymeleaf" class="headerlink" title="引入thymeleaf"></a>引入thymeleaf</h3><pre><code>  &lt;!-- Springboot默认是：2.1.6 的版本 --&gt;    &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring‐boot‐starter‐thymeleaf&lt;/artifactId&gt;              &lt;/dependency&gt;   &lt;!-- 切换thymeleaf版本 --&gt;  &lt;properties&gt;     &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt;             &lt;!‐‐ 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 ‐‐&gt;                &lt;thymeleaf‐layout‐dialect.version&gt;2.2.2&lt;/thymeleaf‐layout‐dialect.version&gt;          &lt;/properties&gt;</code></pre><p><strong>注意，SpringBoot默认导入的thymeleaf只是2.1.6的版本，如果想切换更高的版本，查看thymeleaf的github中的发行版</strong></p><p><a href="https://github.com/thymeleaf/thymeleaf/releases" target="_blank" rel="noopener">thymeleaf版本</a></p><p><strong>thymeleaf‐layout‐dialect.version：布局的版本，请注意，如果使用thymeleaf3以上的版本，那么布局的版本必须是2.0.0以上</strong>：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day04/QQ%E6%88%AA%E5%9B%BE20181105155420.png"></p><h3 id="Thymeleaf使用"><a href="#Thymeleaf使用" class="headerlink" title="Thymeleaf使用"></a>Thymeleaf使用</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.thymeleaf"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThymeleafProperties</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Charset DEFAULT_ENCODING <span class="token operator">=</span> Charset<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF‐8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> MimeType DEFAULT_CONTENT_TYPE <span class="token operator">=</span> MimeType<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token string">"text/html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String DEFAULT_PREFIX <span class="token operator">=</span> <span class="token string">"classpath:/templates/"</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String DEFAULT_SUFFIX <span class="token operator">=</span> <span class="token string">".html"</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//</span><span class="token punctuation">}</span></code></pre><p>Springboot默认的 themleaf 配置：</p><p>使用UTF-8字码，媒体类型：text/html，模板解析的前缀：classpath:/templates/，模板解析的后缀：.html</p><p>即：只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；</p><p>使用：</p><p>1、导入thymeleaf的名称空间：(在idea中会有相应的提示功能)</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span> xmlns<span class="token operator">:</span>th<span class="token operator">=</span><span class="token string">"http://www.thymeleaf.org"</span><span class="token operator">></span></code></pre><p>2、使用thymeleaf语法</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF‐8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;成功！&lt;/h1&gt;    &lt;!‐‐th:text 将div里面的文本内容设置为 ‐‐&gt;    &lt;div th:text=&quot;${hello}&quot;&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><p><a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html" target="_blank" rel="noopener">thymeleaf参考手册</a></p><p>1）th:text，改变当前元素里面的文本内容。</p><p>th：任意html属性；来替换原生属性的值。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day04/QQ%E6%88%AA%E5%9B%BE20181105163700.png"></p><p>2）表达式</p><p><strong>Simple expressions:（表达式语法）</strong></p><p>Variable Expressions: ${…}：获取变量值；OGNL；</p><p>1）、获取对象的属性、调用方法   </p><p>例如：＄{user.name}</p><p>2）、使用内置的基本对象：</p><p>　　　#ctx : the context object<br>　　　#vars: the context variables.<br>　　　#locale : the context locale.<br>　　　#request : (only in Web Contexts) the HttpServletRequest object.<br>　　　#response : (only in Web Contexts) the HttpServletResponse object.<br>　　　#session : (only in Web Contexts) the HttpSession object.<br>　　　#servletContext : (only in Web Contexts) the ServletContext object.</p><p>例如：${session.foo}</p><p>3）、内置的一些工具对象：</p><pre><code>#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated </code></pre><hr><p><strong>Selection Variable Expressions: *{…}：选择表达式：和 ${} 在功能上是一样；</strong></p><pre><code> 补充：配合 th:object=&quot;${session.user}：     &lt;div th:object=&quot;${session.user}&quot;&gt;    &lt;p&gt;Name: &lt;span th:text=&quot;*{firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;    &lt;p&gt;Surname: &lt;span th:text=&quot;*{lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;    &lt;p&gt;Nationality: &lt;span th:text=&quot;*{nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt;   ---------------------------等价----------------------------------------  &lt;div&gt;    &lt;p&gt;Name: &lt;span th:text=&quot;${session.user.firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;    &lt;p&gt;Surname: &lt;span th:text=&quot;${session.user.lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;    &lt;p&gt;Nationality: &lt;span th:text=&quot;${session.user.nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt;</code></pre><hr><p>其他表达式：</p><pre><code>Message Expressions: #{...}：获取国际化内容Link URL Expressions: @{...}：定义URL；@{/order/process(execId=${execId},execType=&#39;FAST&#39;)} Fragment Expressions: ~{...}：片段引用表达式&lt;div th:insert=&quot;~{commons :: main}&quot;&gt;...&lt;/div&gt;Literals（字面量）      Text literals: &#39;one text&#39; , &#39;Another one!&#39; ,…      Number literals: 0 , 34 , 3.0 , 12.3 ,…      Boolean literals: true , false      Null literal: null      Literal tokens: one , sometext , main ,…Text operations:（文本操作）    String concatenation: +    Literal substitutions: |The name is ${name}|Arithmetic operations:（数学运算）    Binary operators: + , ‐ , * , / , %    Minus sign (unary operator): ‐Boolean operations:（布尔运算）    Binary operators: and , or    Boolean negation (unary operator): ! , notComparisons and equality:（比较运算）    Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )    Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符）    If‐then: (if) ? (then)    If‐then‐else: (if) ? (then) : (else)    Default: (value) ?: (defaultvalue)Special tokens:    No‐Operation: _</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_03</title>
      <link href="/2018/11/04/springboot-day-03/"/>
      <url>/2018/11/04/springboot-day-03/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot的日志框架与配置</p><h1 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h1><p>小张，开发一个大型系统；<br>1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？<br>2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar；<br>3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？<br>4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；<br>5、JDBC—数据库驱动；<br>写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；<br>给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；</p><hr><p><strong>市面上的日志框架</strong></p><p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104094606.png"></p><p>左边选一个门面（抽象层）、右边来选一个实现；</p><p>日志门面： SLF4J；</p><p>日志实现：Logback；</p><p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；</p><p><strong>SpringBoot选用 SLF4j 和 logback.</strong></p><h1 id="SLF4j使用"><a href="#SLF4j使用" class="headerlink" title="SLF4j使用"></a>SLF4j使用</h1><h2 id="如何在系统中使用SLF4j"><a href="#如何在系统中使用SLF4j" class="headerlink" title="如何在系统中使用SLF4j"></a>如何在系统中使用SLF4j</h2><p><a href="https://www.slf4j.org/" target="_blank" rel="noopener">SLF4j参考文档</a></p><p>以后开发的时候，日志记录方法的调用，<strong>不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</strong></p><p>给系统里面导入 <strong>slf4j的jar</strong> 和  <strong>logback的实现jar</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Logger logger <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>HelloWorld<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>图示:<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104095906.png"></p><p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是要用日志实现框架自己本身的配置文件；</strong></p><p>比如使用slf4j 和 logback，就用logback的配置文件，使用slf4j 和 log4j,就使用log4j的配置文件。而不是使用slf4j的配置文件。</p><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>a系统（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p><p>我们自己的a系统想要使用slf4j+logback做日志框架，但是我们的a系统是基于Spring、Hibernate等其他框架的，而这些其他框架底层使用的是其他日志框架，Spring使用的是commons-logging，Hibernate使用的是jboss-logging。</p><p>现在，我们想统一日志记录，即：使别的框架和我一起统一使用slf4j进行输出，能做到吗？</p><p>slf4j官网给出了答案，<a href="https://www.slf4j.org/legacy.html" target="_blank" rel="noopener">参考答案</a></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104101357.png"></p><p><strong>如何让系统中所有的日志都统一到slf4j?</strong></p><font color="red">1、将系统中其他日志框架的日志jar包先排除出去；<br><br>2、用中间包来替换原有的日志框架的jar；<br><br>3、导入slf4j其他的实现。</font><h1 id="SpringBoot日志关系"><a href="#SpringBoot日志关系" class="headerlink" title="SpringBoot日志关系"></a>SpringBoot日志关系</h1><p>创建一个新的Springboot的应用，只需要Web模块即可。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104103732.png"></p><p>现在，我们来查看一下Springboot的依赖关系。</p><p>查看依赖关系</p><p>1）使用idea的自带的maven管理器工具<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104103856.png" style="width:50%"></p><p>这样不够直观。</p><p>2）查看依赖图</p><p>在pom文件中，右键点击Diagrams -&gt; show dependencies<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104104228.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104104542.png"></p><p>首先查看spring‐boot‐starter，因为这是Springboot的应用都必须依赖的jar包。</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre><p>然后发现，在spring‐boot‐starter下，有spring‐boot‐starter‐logging。</p><p>说明SpringBoot使用它来做日志功能</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>再来看spring-boot-starter-logging底层依赖：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104105357.png"></p><p>总结：</p><p>1）、SpringBoot底层也是使用 <strong>slf4j + logback</strong> 的方式进行日志记录</p><p>2）、SpringBoot也把其他的日志都替换成了slf4j；</p><p>3）、中间替换包？</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"rawtypes"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">LogFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J <span class="token operator">=</span><span class="token string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> LogFactory logFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SLF4JLogFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104105601.png" style="width:50%"></p><p>其实这些jar包，本身还是原来的日志框架的jar包，只是在使用的过程中，偷换成了slf4j的日志框架，就和适配器模式很像。</p><p><strong>这些操作，Springboot已经帮我们做好了，我们只需要在引入其他框架的时候，移除掉他们本身的日志框架就行了。</strong></p><p>4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</p><p>　　　我们挑Spring来做一个列子：</p><p>　　　Spring框架用的是commons-logging；</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>                <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring‐core<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>                <span class="token operator">&lt;</span>exclusions<span class="token operator">></span>                     <span class="token operator">&lt;</span>exclusion<span class="token operator">></span>                            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>commons‐logging<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>                                <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>commons‐logging<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>                             <span class="token operator">&lt;</span><span class="token operator">/</span>exclusion<span class="token operator">></span>                    <span class="token operator">&lt;</span><span class="token operator">/</span>exclusions<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre><p>发现，Springboot也帮我们剔除掉了，Springboot真方便！！！</p><font color="red"><strong>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要<br>把这个框架依赖的日志框架排除掉即可；</strong></font><h1 id="日志使用"><a href="#日志使用" class="headerlink" title="日志使用"></a>日志使用</h1><h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><p>直接运行，我们刚刚创建的项目：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104112034.png"></p><p>发现，Springboot已经帮我们创建好了默认的配置。默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。在运行应用程序和其他例子时，你应该已经看到很多INFO级别的日志了。</p><p>从上图可以看到，日志输出内容元素具体如下：</p><ul><li>时间日期：精确到毫秒</li><li>日志级别：ERROR, WARN, INFO, DEBUG or TRACE</li><li>进程ID</li><li>分隔符：－－－ 标识实际日志的开始</li><li>线程名：方括号括起来（可能会截断控制台输出）</li><li>Logger名：通常使用源代码的类名</li><li>日志内容</li></ul><p>使用：</p><p>在测试类中：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringBoot03LoggingApplicationTests</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//日志记录器</span>    Logger logger <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextLoads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//System.out.println();  我们不再使用这种方法来记录了</span>        <span class="token comment" spellcheck="true">//日志的级别，trace &lt; debug &lt; info &lt; warn &lt; error</span>        <span class="token comment" spellcheck="true">//只会打印本级别和比本级别更高的日志</span>        logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"这是trace日志···"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"这是debug日志···"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//Springboot默认的级别是info级别</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"这是info日志···"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"这是warn日志···"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"这error日志···"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行测试方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104113131.png"></p><p>只打印了info级别以及以上的。说明Springboot默认的日志级别是info。</p><p>1) 修改日志的级别。</p><p>在application.properties文件中。</p><pre><code>logging.level.com.liuzhuo=trace</code></pre><p>再次运行测试方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104113410.png"></p><p>格式为：logging.level.* = LEVEL</p><ul><li>logging.level：日志级别控制前缀，*为包名或Logger名</li><li>LEVEL：选项 TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF</li></ul><p>举例：</p><ul><li>logging.level.com.liuzhuo=DEBUG：com.liuzhuo包下所有class以DEBUG级别输出</li><li>logging.level.root=WARN：root日志以WARN级别输出</li></ul><p>2) 日志文件的输出</p><p>默认情况下，Spring Boot将日志输出到控制台，不会写到日志文件。如果要编写除控制台输出之外的日志文件，则需在application.properties中设置logging.file或logging.path属性。</p><ul><li>logging.file，设置文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log</li><li>logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log</li></ul><p>logging.file=xxx.log，会在项目的根目录下生成xxx.log文件<br>logging.file=G:/xxx.log，会在G盘下生xxx.log文件</p><p>logging.path=/aaa/bbb，会在项目的磁盘下，创建aaa/bbb文件夹，然后生成spring.log日志文件，<strong>日志文件的名字都是spring.log</strong></p><font color="red">注：二者不能同时使用，如若同时使用，则只有logging.file生效</font><p><strong>默认情况下，日志文件的大小达到10MB时会切分一次，产生新的日志文件，默认级别为：ERROR、WARN、INFO</strong></p><p>3) 日志输出格式的设置</p><pre><code># 在控制台输出的日志的格式logging.pattern.console=%d{yyyy‐MM‐dd} [%thread] %‐5level %logger{50} ‐ %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d{yyyy‐MM‐dd} === [%thread] === %‐5level === %logger{50} ==== %msg%n</code></pre><pre><code>日志输出格式：%d表示日期时间，        %thread表示线程名，        %‐5level：级别从左显示5个字符宽度        %logger{50} 表示logger名字最长50个字符，否则按照句点分割。         %msg：日志消息，        %n是换行符      ‐‐&gt;%d{yyyy‐MM‐dd HH:mm:ss.SSS} [%thread] %‐5level %logger{50} ‐ %msg%n</code></pre><h2 id="指定配置"><a href="#指定配置" class="headerlink" title="指定配置"></a>指定配置</h2><p>在使用我们自己定义的日志配置文件之前，我们先来看看，为啥我们不用配置日志文件，Springboot中也能使用日志功能？</p><p>1) 打开org.springframework.boot:spring-boot:1.5.17.RELEASE<br>2) 打开org.springframework.boot<br>3) 打开logging、logback、base.xml<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104150319.png" style="width:50%"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104150519.png" style="width:50%"></p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>Base logback configuration provided <span class="token keyword">for</span> compatibility with Spring Boot <span class="token number">1.1</span><span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>included<span class="token operator">></span>    <span class="token operator">&lt;</span>include resource<span class="token operator">=</span><span class="token string">"org/springframework/boot/logging/logback/defaults.xml"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"LOG_FILE"</span> value<span class="token operator">=</span><span class="token string">"${LOG_FILE:-${LOG_PATH:-${LOG_TEMP:-${java.io.tmpdir:-/tmp}}}/spring.log}"</span><span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>include resource<span class="token operator">=</span><span class="token string">"org/springframework/boot/logging/logback/console-appender.xml"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>include resource<span class="token operator">=</span><span class="token string">"org/springframework/boot/logging/logback/file-appender.xml"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>root level<span class="token operator">=</span><span class="token string">"INFO"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>appender<span class="token operator">-</span>ref ref<span class="token operator">=</span><span class="token string">"CONSOLE"</span> <span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span>appender<span class="token operator">-</span>ref ref<span class="token operator">=</span><span class="token string">"FILE"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>root<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>included<span class="token operator">></span></code></pre><p>我们发现，Springboot已经帮我们默认配置好了。</p><p>我们看到root下的 level的等于INFO，所以Springboot默认是info级别。</p><p>再看<code>&lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot; /&gt;</code></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Default logback configuration provided for import, equivalent to the programmaticinitialization performed by Boot--&gt;&lt;included&gt;    &lt;conversionRule conversionWord=&quot;clr&quot; converterClass=&quot;org.springframework.boot.logging.logback.ColorConverter&quot; /&gt;    &lt;conversionRule conversionWord=&quot;wex&quot; converterClass=&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot; /&gt;    &lt;conversionRule conversionWord=&quot;wEx&quot; converterClass=&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot; /&gt;    &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}&quot;/&gt;    &lt;property name=&quot;FILE_LOG_PATTERN&quot; value=&quot;${FILE_LOG_PATTERN:-%d{yyyy-MM-dd HH:mm:ss.SSS} ${LOG_LEVEL_PATTERN:-%5p} ${PID:- } --- [%t] %-40.40logger{39} : %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}&quot;/&gt;    &lt;appender name=&quot;DEBUG_LEVEL_REMAPPER&quot; class=&quot;org.springframework.boot.logging.logback.LevelRemappingAppender&quot;&gt;        &lt;destinationLogger&gt;org.springframework.boot&lt;/destinationLogger&gt;    &lt;/appender&gt;    &lt;logger name=&quot;org.apache.catalina.startup.DigesterFactory&quot; level=&quot;ERROR&quot;/&gt;    &lt;logger name=&quot;org.apache.catalina.util.LifecycleBase&quot; level=&quot;ERROR&quot;/&gt;    &lt;logger name=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; level=&quot;WARN&quot;/&gt;    &lt;logger name=&quot;org.apache.sshd.common.util.SecurityUtils&quot; level=&quot;WARN&quot;/&gt;    &lt;logger name=&quot;org.apache.tomcat.util.net.NioSelectorPool&quot; level=&quot;WARN&quot;/&gt;    &lt;logger name=&quot;org.crsh.plugin&quot; level=&quot;WARN&quot;/&gt;    &lt;logger name=&quot;org.crsh.ssh&quot; level=&quot;WARN&quot;/&gt;    &lt;logger name=&quot;org.eclipse.jetty.util.component.AbstractLifeCycle&quot; level=&quot;ERROR&quot;/&gt;    &lt;logger name=&quot;org.hibernate.validator.internal.util.Version&quot; level=&quot;WARN&quot;/&gt;    &lt;logger name=&quot;org.springframework.boot.actuate.autoconfigure.CrshAutoConfiguration&quot; level=&quot;WARN&quot;/&gt;    &lt;logger name=&quot;org.springframework.boot.actuate.endpoint.jmx&quot; additivity=&quot;false&quot;&gt;        &lt;appender-ref ref=&quot;DEBUG_LEVEL_REMAPPER&quot;/&gt;    &lt;/logger&gt;    &lt;logger name=&quot;org.thymeleaf&quot; additivity=&quot;false&quot;&gt;        &lt;appender-ref ref=&quot;DEBUG_LEVEL_REMAPPER&quot;/&gt;    &lt;/logger&gt;&lt;/included&gt;</code></pre><p>我们能看到</p><pre><code>&lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}&quot;/&gt;</code></pre><p>这里就是配置控制台输出日志格式的配置，我们写在application.propertiese中的logging.pattern.console=xxx.就会覆盖这个配置中的内容，如果不配置的话，就使用默认的配置，就是冒号后面的一串：<code>-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} xxxxx</code></p><hr><p>现在我们已经了解到了Springboot的默认日志文件的配置了。当我们具体使用日志框架时，需要使用哪个配置文件呢？</p><p>打开Spring的官网，<a href="https://docs.spring.io/spring-boot/docs/1.5.17.RELEASE/reference/htmlsingle/#boot-features-logging" target="_blank" rel="noopener">logging参考文献</a></p><p>找到：<strong>26.5 Custom log configuration</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104194411.png"></p><p>从图中，我们可以看出，使用logback日志框架，就使用logback-spring.xml、logback.xml等配置文件。</p><p>其他的日志框架，类似logback。</p><p><strong>给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了。</strong></p><p>现在，我们在类路径下，即resources下，放入一个logback.xml的日志配置文件。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104195557.png"></p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>scan：当此属性设置为<span class="token boolean">true</span>时，配置文件如果发生改变，将会被重新加载，默认值为<span class="token boolean">true</span>。scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为<span class="token boolean">true</span>时，此属性生效。默认的时间间隔为<span class="token number">1</span>分钟。debug：当此属性设置为<span class="token boolean">true</span>时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为<span class="token boolean">false</span>。<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>configuration scan<span class="token operator">=</span><span class="token string">"false"</span> scanPeriod<span class="token operator">=</span><span class="token string">"60 seconds"</span> debug<span class="token operator">=</span><span class="token string">"false"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 定义日志的根目录 <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"LOG_HOME"</span> value<span class="token operator">=</span><span class="token string">"/app/log"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 定义日志文件名称 <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"appName"</span> value<span class="token operator">=</span><span class="token string">"atguigu-springboot"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> ch<span class="token punctuation">.</span>qos<span class="token punctuation">.</span>logback<span class="token punctuation">.</span>core<span class="token punctuation">.</span>ConsoleAppender 表示控制台输出 <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>appender name<span class="token operator">=</span><span class="token string">"stdout"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"ch.qos.logback.core.ConsoleAppender"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>        日志输出格式：            <span class="token operator">%</span>d表示日期时间，            <span class="token operator">%</span>thread表示线程名，            <span class="token operator">%</span><span class="token operator">-</span>5level：级别从左显示<span class="token number">5</span>个字符宽度            <span class="token operator">%</span>logger<span class="token punctuation">{</span><span class="token number">50</span><span class="token punctuation">}</span> 表示logger名字最长<span class="token number">50</span>个字符，否则按照句点分割。             <span class="token operator">%</span>msg：日志消息，            <span class="token operator">%</span>n是换行符        <span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span>layout <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"ch.qos.logback.classic.PatternLayout"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>pattern<span class="token operator">></span><span class="token operator">%</span>d<span class="token punctuation">{</span>yyyy<span class="token operator">-</span>MM<span class="token operator">-</span>dd HH<span class="token operator">:</span>mm<span class="token operator">:</span>ss<span class="token punctuation">.</span>SSS<span class="token punctuation">}</span> <span class="token punctuation">[</span><span class="token operator">%</span>thread<span class="token punctuation">]</span> <span class="token operator">%</span><span class="token operator">-</span>5level <span class="token operator">%</span>logger<span class="token punctuation">{</span><span class="token number">50</span><span class="token punctuation">}</span> <span class="token operator">-</span> <span class="token operator">%</span>msg<span class="token operator">%</span>n<span class="token operator">&lt;</span><span class="token operator">/</span>pattern<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>layout<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>appender<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 <span class="token operator">--</span><span class="token operator">></span>      <span class="token operator">&lt;</span>appender name<span class="token operator">=</span><span class="token string">"appLogAppender"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"ch.qos.logback.core.rolling.RollingFileAppender"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 指定日志文件的名称 <span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span>file<span class="token operator">></span>$<span class="token punctuation">{</span>LOG_HOME<span class="token punctuation">}</span><span class="token operator">/</span>$<span class="token punctuation">{</span>appName<span class="token punctuation">}</span><span class="token punctuation">.</span>log<span class="token operator">&lt;</span><span class="token operator">/</span>file<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>        当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名        TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。        <span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span>rollingPolicy <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>            滚动时产生的文件的存放位置及文件名称 <span class="token operator">%</span>d<span class="token punctuation">{</span>yyyy<span class="token operator">-</span>MM<span class="token operator">-</span>dd<span class="token punctuation">}</span>：按天进行日志滚动             <span class="token operator">%</span>i：当文件大小超过maxFileSize时，按照i进行文件滚动            <span class="token operator">--</span><span class="token operator">></span>            <span class="token operator">&lt;</span>fileNamePattern<span class="token operator">></span>$<span class="token punctuation">{</span>LOG_HOME<span class="token punctuation">}</span><span class="token operator">/</span>$<span class="token punctuation">{</span>appName<span class="token punctuation">}</span><span class="token operator">-</span><span class="token operator">%</span>d<span class="token punctuation">{</span>yyyy<span class="token operator">-</span>MM<span class="token operator">-</span>dd<span class="token punctuation">}</span><span class="token operator">-</span><span class="token operator">%</span>i<span class="token punctuation">.</span>log<span class="token operator">&lt;</span><span class="token operator">/</span>fileNamePattern<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>             可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动，            且maxHistory是<span class="token number">365</span>，则只保存最近<span class="token number">365</span>天的文件，删除之前的旧文件。注意，删除旧文件是，            那些为了归档而创建的目录也会被删除。            <span class="token operator">--</span><span class="token operator">></span>            <span class="token operator">&lt;</span>MaxHistory<span class="token operator">></span><span class="token number">365</span><span class="token operator">&lt;</span><span class="token operator">/</span>MaxHistory<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>             当日志文件超过maxFileSize指定的大小是，根据上面提到的<span class="token operator">%</span>i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy            <span class="token operator">--</span><span class="token operator">></span>            <span class="token operator">&lt;</span>timeBasedFileNamingAndTriggeringPolicy <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span><span class="token operator">></span>                <span class="token operator">&lt;</span>maxFileSize<span class="token operator">></span>100MB<span class="token operator">&lt;</span><span class="token operator">/</span>maxFileSize<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>timeBasedFileNamingAndTriggeringPolicy<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>rollingPolicy<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 日志输出格式： <span class="token operator">--</span><span class="token operator">></span>             <span class="token operator">&lt;</span>layout <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"ch.qos.logback.classic.PatternLayout"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>pattern<span class="token operator">></span><span class="token operator">%</span>d<span class="token punctuation">{</span>yyyy<span class="token operator">-</span>MM<span class="token operator">-</span>dd HH<span class="token operator">:</span>mm<span class="token operator">:</span>ss<span class="token punctuation">.</span>SSS<span class="token punctuation">}</span> <span class="token punctuation">[</span> <span class="token operator">%</span>thread <span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">[</span> <span class="token operator">%</span><span class="token operator">-</span>5level <span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token operator">%</span>logger<span class="token punctuation">{</span><span class="token number">50</span><span class="token punctuation">}</span> <span class="token operator">:</span> <span class="token operator">%</span>line <span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token operator">%</span>msg<span class="token operator">%</span>n<span class="token operator">&lt;</span><span class="token operator">/</span>pattern<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>layout<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>appender<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>         logger主要用于存放日志对象，也可以定义日志类型、级别        name：表示匹配的logger类型前缀，也就是包的前半部分        level：要记录的日志级别，包括 TRACE <span class="token operator">&lt;</span> DEBUG <span class="token operator">&lt;</span> INFO <span class="token operator">&lt;</span> WARN <span class="token operator">&lt;</span> ERROR        additivity：作用在于children<span class="token operator">-</span>logger是否使用 rootLogger配置的appender进行输出，        <span class="token boolean">false</span>：表示只用当前logger的appender<span class="token operator">-</span>ref，<span class="token boolean">true</span>：        表示当前logger的appender<span class="token operator">-</span>ref和rootLogger的appender<span class="token operator">-</span>ref都有效    <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> hibernate logger <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>logger name<span class="token operator">=</span><span class="token string">"com.atguigu"</span> level<span class="token operator">=</span><span class="token string">"debug"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Spring framework logger <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>logger name<span class="token operator">=</span><span class="token string">"org.springframework"</span> level<span class="token operator">=</span><span class="token string">"debug"</span> additivity<span class="token operator">=</span><span class="token string">"false"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>logger<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>     root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应，    要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。     <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>root level<span class="token operator">=</span><span class="token string">"info"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>appender<span class="token operator">-</span>ref ref<span class="token operator">=</span><span class="token string">"stdout"</span> <span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span>appender<span class="token operator">-</span>ref ref<span class="token operator">=</span><span class="token string">"appLogAppender"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>root<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>configuration<span class="token operator">></span> </code></pre><p>现在，我们修改一下日志的输出格式：</p><pre><code> &lt;!-- 日志输出格式： --&gt;     &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;    &lt;pattern&gt;%d{yyyy-MM-dd} -----&gt; [ %thread ] -----&gt; [ %-5level ] [ %logger{50} : %line ] -----&gt; %msg%n&lt;/pattern&gt;&lt;/layout&gt;</code></pre><p><strong>把时间的时分秒去掉，然后把分隔符改为箭头。</strong></p><p>启动Springboot项目：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104200138.png"></p><p>我们的日志配置文件设置成功了。</p><hr><p>我们注意到了，官网上面写了logback.xml和logback-spring.xml两种配置文件的<strong>书写方式。</strong></p><font color="red"><strong>官网推荐我们使用logback-spring.xml命名的配置文件。</strong></font><p>logback.xml: 是直接被日志框架识别，在Spring应用启动之前。不会走Spring的流程。</p><p><strong>logback-spring.xml:</strong> 日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot<br>的高级Profile功能</p><p>可以使用：在哪个环境下生效。</p><pre><code>&lt;springProfile name=&quot;staging&quot;&gt;    &lt;!‐‐ configuration to be enabled when the &quot;staging&quot; profile is active ‐‐&gt;   可以指定某段配置只在某个环境下生效  &lt;/springProfile&gt;</code></pre><p>如：</p><pre><code>&lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;!‐‐        日志输出格式：     %d表示日期时间，                 %thread表示线程名，                 %‐5level：级别从左显示5个字符宽度                 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。                  %msg：日志消息，                 %n是换行符                    ‐‐&gt;        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;            &lt;springProfile name=&quot;dev&quot;&gt;                &lt;pattern&gt;%d{yyyy‐MM‐dd HH:mm:ss.SSS} ‐‐‐‐&gt; [%thread] ‐‐‐&gt; %‐5level %logger{50} ‐ %msg%n&lt;/pattern&gt;            &lt;/springProfile&gt;            &lt;springProfile name=&quot;!dev&quot;&gt;                &lt;pattern&gt;%d{yyyy‐MM‐dd HH:mm:ss.SSS} ==== [%thread] ==== %‐5level %logger{50} ‐ %msg%n&lt;/pattern&gt;            &lt;/springProfile&gt;        &lt;/layout&gt;    &lt;/appender&gt;</code></pre><p>在dev环境下：使用上面的输出格式。</p><p>在非dev环境下：使用下面的输出格式。</p><p>现在运行Springboot项目：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104201524.png"></p><p><strong>发现，日志框架出现错误了。因为我们的日志配置文件的名字还没有改。</strong></p><p>现在修改logback.xml —&gt; logback-spring.xml.</p><p>再次启动Springboot应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104201940.png"></p><p>发现，启动的是非dev环境的日志控制台输出格式。</p><p>我们在配置Springboot为dev环境。</p><p>1）application.properties.</p><p>spring.profiles.active=dev</p><p>2) 配置命令行参数：<br><code>--spring.profiles.active=dev</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104202332.png"></p><p>使用上面两种方法都可以改变Springboot的环境。</p><p>然后启动Springboot应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104202559.png"></p><h1 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="切换日志框架"></a>切换日志框架</h1><h2 id="切换成log4j"><a href="#切换成log4j" class="headerlink" title="切换成log4j"></a>切换成log4j</h2><p>现在，我们使用的是slf4j+logback。但是我们想换成slf4j + log4j怎么办？</p><p><strong>这里，说明一下，就是因为log4j有问题，所以才会推出logback日志框架的，这里只是做个例子演示日志框架的切换，实际情况下，直接使用logback日志框架就行。</strong></p><p>切换日志框架，我们直接参考slf4j的官网的那个图，就行。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104204428.png"></p><p>现在打开我们的依赖图层：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104204742.png"></p><p>去掉图中画红色框框的logback的依赖。</p><p>快速移除依赖：在想要移除的依赖上面，右键Exclude<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104205023.png"></p><p>移除完毕后：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104205144.png" style="width:50%"></p><p>打开pom.xml文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104205307.png"></p><p>现在需要添加log4j的依赖。</p><p>直接在pom.xml文件中添加：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-log412&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104205726.png"></p><p>启动Springboot应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day03/QQ%E6%88%AA%E5%9B%BE20181104205838.png"><br><strong>发出警告，因为在类路径下，没有log4j.properties的配置文件。</strong></p><p>在resources下，添加log4j.properties的配置文件</p><pre><code>### set log levels ###log4j.rootLogger = debug ,  stdout ,  D ,  E### 输出到控制台 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern =  %d{ABSOLUTE} %5p %c{ 1 }:%L - %m%n#### 输出到日志文件 ####log4j.appender.D = org.apache.log4j.DailyRollingFileAppender#log4j.appender.D.File = logs/log.log#log4j.appender.D.Append = true#log4j.appender.D.Threshold = DEBUG ## 输出DEBUG级别以上的日志#log4j.appender.D.layout = org.apache.log4j.PatternLayout#log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n##### 保存异常信息到单独文件 ####log4j.appender.D = org.apache.log4j.DailyRollingFileAppender#log4j.appender.D.File = logs/error.log ## 异常日志文件名#log4j.appender.D.Append = true#log4j.appender.D.Threshold = ERROR ## 只输出ERROR级别以上的日志!!!#log4j.appender.D.layout = org.apache.log4j.PatternLayout#log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n</code></pre><p>再次启动应用，就会打印出日志信息了。</p><hr><h2 id="切换成log4j2"><a href="#切换成log4j2" class="headerlink" title="切换成log4j2"></a>切换成log4j2</h2><p>在官网上面，我们能发现，Springboot默认是加载logback日志框架的，我们也可以直接改成log4j2日志框架。</p><p>在pom.xml文件中：</p><pre class=" language-java"><code class="language-java">    <span class="token operator">&lt;</span>dependency<span class="token operator">></span>       <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>       <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring‐boot‐starter‐web<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>          <span class="token operator">&lt;</span>exclusions<span class="token operator">></span>             <span class="token operator">&lt;</span>exclusion<span class="token operator">></span>                 <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring‐boot‐starter‐logging<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>                 <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>exclusion<span class="token operator">></span>          <span class="token operator">&lt;</span><span class="token operator">/</span>exclusions<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>dependency<span class="token operator">></span>      <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>      <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring‐boot‐starter‐log4j2<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre><p>直接移除spring‐boot‐starter‐logging依赖。然后添加spring‐boot‐starter‐log4j2的依赖。</p><p>然后添加log4j2-spring.xml 或者 log4j2.xml 日志配置文件。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_02</title>
      <link href="/2018/11/03/springboot-day-02/"/>
      <url>/2018/11/03/springboot-day-02/</url>
      
        <content type="html"><![CDATA[<p>Springboot的配置文件</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>SpringBoot使用一个全局的配置文件，配置文件名是<strong>固定的</strong>；</p><ul><li>application.properties</li><li>application.yml</li></ul><p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p><p>xxx.properties文件，我们见的比较多，比较熟悉。</p><p>这里讲解yml文件。</p><p>YAML（YAML Ain’t Markup Language）<br>YAML A Markup Language：是一个标记语言<br>YAML isn’t Markup Language：不是一个标记语言；  </p><p>标记语言：<br>以前的配置文件；大多都使用的是 xxxx.xml文件；<br>YAML：以数据为中心，比json、xml等更适合做配置文件； </p><p>YAML：配置例子  </p><pre><code>server:  port: 8081</code></pre><p>XML：</p><pre><code>&lt;server&gt;   &lt;port&gt;8081&lt;/port&gt;    &lt;/server&gt;</code></pre><hr><p>1）创建新的Springboot项目，添加web模块即可：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103104435.png"></p><p>2）在resources下，创建application.yml文件<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103104633.png"></p><p>3）启动项目<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103104821.png"></p><p>项目的端口号，修改成为8081.</p><h3 id="YAML语法："><a href="#YAML语法：" class="headerlink" title="YAML语法："></a>YAML语法：</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p><code>k:(空格)v</code>：表示一对键值对（<strong>空格必须有</strong>）；</p><p>以<strong>空格的缩进</strong>来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p><p>例子：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103105623.png"></p><p>注意：属性和值也是大小写敏感。</p><h4 id="值的写法"><a href="#值的写法" class="headerlink" title="值的写法"></a>值的写法</h4><h5 id="字面量：普通的值（数字，字符串，布尔）"><a href="#字面量：普通的值（数字，字符串，布尔）" class="headerlink" title="字面量：普通的值（数字，字符串，布尔）"></a>字面量：普通的值（数字，字符串，布尔）</h5><p>k: v：字面量直接来写；</p><p>字符串默认不用加上单引号或者双引号；</p><p>“”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p><p>name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi</p><p>‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p><p>name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi</p><h5 id="对象、Map（属性和值）（键值对）："><a href="#对象、Map（属性和值）（键值对）：" class="headerlink" title="对象、Map（属性和值）（键值对）："></a>对象、Map（属性和值）（键值对）：</h5><p>k: v：在下一行来写对象的属性和值的关系；注意缩进</p><p>对象还是k: v的方式</p><pre><code>friends:    lastName: zhangsan            age: 20 </code></pre><p>行内写法：</p><pre><code>friends: {lastName: zhangsan,age: 18}</code></pre><h5 id="数组（List、Set）："><a href="#数组（List、Set）：" class="headerlink" title="数组（List、Set）："></a>数组（List、Set）：</h5><p>用- 值表示数组中的一个元素</p><pre><code>pets: ‐ cat ‐ dog ‐ pig</code></pre><p>行内写法:</p><pre><code>pets: [cat,dog,pig]</code></pre><h3 id="配置文件值注入"><a href="#配置文件值注入" class="headerlink" title="配置文件值注入"></a>配置文件值注入</h3><h4 id="使用-ConfigurationProperties注解"><a href="#使用-ConfigurationProperties注解" class="headerlink" title="使用@ConfigurationProperties注解"></a>使用@ConfigurationProperties注解</h4><p>1) 在根包下，创建bean包，并创建Person和Dog类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token keyword">private</span> Boolean boss<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birth<span class="token punctuation">;</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> maps<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> lists<span class="token punctuation">;</span>    <span class="token keyword">private</span> Dog dog<span class="token punctuation">;</span>   ····<span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    ····<span class="token punctuation">}</span></code></pre><p>其中省略了，get、set、tostring的方法。</p><p>2）给application.yml文件赋值：</p><pre><code>person:  lastName: zhangSan  age: 18  boss: true  birth: 2018/11/11  maps: {k1: v1,k2: v2}  lists:    - list1    - list2  dog:    name: 小狗    age: 2</code></pre><p>3) 给Person类添加@ConfigurationProperties注解</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 描述: * * @ConfigurationProperties: 配置文件的属性映射 * prefix：前缀。 */</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"person"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span></code></pre><p>4) 测试：<br>在test包下，有一个测试类：<br>SpringBoot02ConfigApplicationTests</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringBoot02ConfigApplicationTests</span></code></pre><p>@RunWith(SpringRunner.class):使用Spring的测试驱动<br>@SpringBootTest：使用Springboot的测试</p><p>不再使用Junit测试，Spring的测试驱动，更加方便，可以使用自动注入什么的。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringBoot02ConfigApplicationTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> Person person<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextLoads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里：<code>private Person person;</code> 会报错，因为我们的Person类没有注入到容器中，所以，我们还需要在Person类上面，加上@Component注解。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"person"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> </code></pre><p>运行测试：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103114614.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103114704.png"></p><p>在控制台，看到到了Person类的属性注入成功了。</p><p><strong>PS：想要在yml文件中书写时，有提示，我们可以加入配置文件处理器依赖：</strong></p><pre class=" language-java"><code class="language-java">        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>配置文件处理器，会给出提示<span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>configuration<span class="token operator">-</span>processor<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>optional<span class="token operator">></span><span class="token boolean">true</span><span class="token operator">&lt;</span><span class="token operator">/</span>optional<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103115009.png"></p><p>在yml配置文件中，person属性下：Alt+/ 会出Person类中还没有配置的属性。</p><p><strong>使用提示出现的属性，比如lastName，会是last-name的样子，都是一样的。-n 就相当于大写的N。</strong></p><hr><p>接下来，使用properties文件配置Person类：</p><p>将yml文件中的Person配置注释掉</p><p>在properties文件中：</p><pre><code>#idea中的properties文件是UTF-8的编码，而我们需要转换成ASCII编码#给person配置属性值person.last-name=张三person.age=20person.boss=falseperson.birth=2018/11/03person.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=dogperson.dog.age=2</code></pre><p>运行测试：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103120508.png"><br>此时出现了中文乱码的现象。</p><p>这是因为idea默认是使用utf-8的编码，不会转义成ascii。</p><p>打开idea的settings：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103120858.png"></p><p>再次运行测试：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103120952.png"></p><hr><h4 id="使用-Value注解"><a href="#使用-Value注解" class="headerlink" title="使用@Value注解"></a>使用@Value注解</h4><p>除了使用@ConfigurationProperties注解来给属性赋值，我们还知道可以使用Spring的@Value注解。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * &lt;bean class="Person">     *      &lt;property name="lastName" value="字面量/${key}从环境变量、配置文件中获取值/#{SpEL}">&lt;/property>     * &lt;bean/>     */</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${person.last‐name}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"#{11*2}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"true"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Boolean boss<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birth<span class="token punctuation">;</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> maps<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> lists<span class="token punctuation">;</span>    <span class="token keyword">private</span> Dog dog<span class="token punctuation">;</span></code></pre><p><strong>@Value获取值 和 @ConfigurationProperties获取值比较</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103122845.png"></p><p>这里的松散绑定的意思是，lastName，last-name,last_name都可以在@ConfigurationProperties中使用，但是在@Value中，必须一模一样，比如：</p><p>在Person类中：<br>@Value(“${person.last-name}”)</p><p>在properties配置文件中，必须是：<br>person.last-name=张三</p><p>JSR303数据校验的意思是：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"person"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Validated</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Email</span>    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span></code></pre><p>在Person类上，添加@Validated注解，开启数据校验的功能，然后在Person的属性上面，添加@Email、等其他注解，就可以提供数据校验的功能。</p><p>复杂类型封装的意思是：<br>比如：<br>使用@ConfigurationProperties(prefix = “person”)后，map类型的数据：<br>在配置文件中：maps: {k1: v1,k2: v2} 或者 person.maps.k1=v1，person.maps.k2=v2</p><p>然后自动就绑定上了，但是使用@Value注解，就不行。</p><p>@Value注入复杂的属性值：</p><p>1）使用util标签</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Properties</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"#{testPro}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Properties pros<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"#{testList}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> myList<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"#{testMap}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> myMap<span class="token punctuation">;</span></code></pre><pre><code>&lt;!-- applicationContext.xml --&gt;    &lt;!-- 扫描测试属性包中的类，要注入属性类需要被Spring管理 --&gt;&lt;context:component-scan base-package=&quot;com.xy.test2&quot; /&gt;&lt;!-- properties --&gt;&lt;util:properties id=&quot;testPro&quot; location=&quot;classpath:info/info2.properties&quot; /&gt;&lt;!-- list --&gt;&lt;util:list id=&quot;testList&quot; list-class=&quot;java.util.ArrayList&quot;&gt;    &lt;value&gt;first&lt;/value&gt;    &lt;value&gt;second&lt;/value&gt;    &lt;value&gt;third&lt;/value&gt;&lt;/util:list&gt;&lt;!-- map --&gt;&lt;util:map id=&quot;testMap&quot; map-class=&quot;java.util.HashMap&quot;&gt;    &lt;entry key=&quot;1&quot; value=&quot;first&quot; /&gt;    &lt;entry key=&quot;2&quot; value=&quot;second&quot; /&gt;    &lt;entry key=&quot;3&quot; value=&quot;third&quot; /&gt;&lt;/util:map&gt;</code></pre><p>2) 直接使用xml的形式来注入复杂的数据类型：</p><p>下边的一个java类包含了所有Map、Set、List、数组、属性集合等这些容器，主要用于演示Spring的注入配置；</p><pre><code>package com.lc.collection;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class Department {    private String name;    private String [] empName;//数组    private List&lt;Employee&gt; empList;//list集合    private Set&lt;Employee&gt; empsets;//set集合    private Map&lt;String,Employee&gt; empMaps;//map集合    private Properties pp;//Properties的使用    public Set&lt;Employee&gt; getEmpsets() {        return empsets;    }    public void setEmpsets(Set&lt;Employee&gt; empsets) {        this.empsets = empsets;    }    public String[] getEmpName() {        return empName;    }    public void setEmpName(String[] empName) {        this.empName = empName;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public List&lt;Employee&gt; getEmpList() {        return empList;    }    public void setEmpList(List&lt;Employee&gt; empList) {        this.empList = empList;    }    public Map&lt;String, Employee&gt; getEmpMaps() {        return empMaps;    }    public void setEmpMaps(Map&lt;String, Employee&gt; empMaps) {        this.empMaps = empMaps;    }    public Properties getPp() {        return pp;    }    public void setPp(Properties pp) {        this.pp = pp;    }}</code></pre><p>Spring配置文件beans.xml文件:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd                http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd                http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;&lt;bean id=&quot;department&quot; class=&quot;com.hsp.collection.Department&quot;&gt;&lt;property name=&quot;name&quot; value=&quot;财务部&quot;/&gt;&lt;!-- 给数组注入值 --&gt;&lt;property name=&quot;empName&quot;&gt;    &lt;list&gt;        &lt;value&gt;小明&lt;/value&gt;        &lt;value&gt;小明小明&lt;/value&gt;        &lt;value&gt;小明小明小明小明&lt;/value&gt;    &lt;/list&gt;&lt;/property&gt;&lt;!-- 给list注入值 ，list中可以有相同的对象 --&gt;&lt;property name=&quot;empList&quot;&gt;    &lt;list&gt;        &lt;ref bean=&quot;emp2&quot; /&gt;        &lt;ref bean=&quot;emp1&quot;/&gt;        &lt;ref bean=&quot;emp1&quot;/&gt;        &lt;ref bean=&quot;emp1&quot;/&gt;        &lt;ref bean=&quot;emp1&quot;/&gt;        &lt;ref bean=&quot;emp1&quot;/&gt;        &lt;ref bean=&quot;emp1&quot;/&gt;    &lt;/list&gt;&lt;/property&gt;&lt;!-- 给set注入值， set不能有相同的对象 --&gt;&lt;property name=&quot;empsets&quot;&gt;    &lt;set&gt;        &lt;ref bean=&quot;emp1&quot; /&gt;        &lt;ref bean=&quot;emp2&quot;/&gt;        &lt;ref bean=&quot;emp2&quot;/&gt;        &lt;ref bean=&quot;emp2&quot;/&gt;        &lt;ref bean=&quot;emp2&quot;/&gt;    &lt;/set&gt;&lt;/property&gt;&lt;!-- 给map注入值 ，map只有key不一样，就可以装配value --&gt;&lt;property name=&quot;empMaps&quot;&gt;    &lt;map&gt;        &lt;entry key=&quot;11&quot; value-ref=&quot;emp1&quot; /&gt;         &lt;entry key=&quot;22&quot; value-ref=&quot;emp2&quot;/&gt;        &lt;entry key=&quot;22&quot; value-ref=&quot;emp1&quot;/&gt;    &lt;/map&gt;&lt;/property&gt;&lt;!-- 给属性集合配置 --&gt;&lt;property name=&quot;pp&quot;&gt;    &lt;props&gt;        &lt;prop key=&quot;pp1&quot;&gt;abcd&lt;/prop&gt;        &lt;prop key=&quot;pp2&quot;&gt;hello&lt;/prop&gt;    &lt;/props&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;emp1&quot; class=&quot;com.hsp.collection.Employee&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;北京&quot;/&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;emp2&quot; class=&quot;com.hsp.collection.Employee&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;天津&quot;/&gt;    &lt;property name=&quot;id&quot; value=&quot;2&quot;/&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><hr><p>配置文件yml还是properties他们都能获取到值；</p><p>总结：</p><p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；<br>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p><h4 id="PropertySource-amp-ImportResource-amp-Bean"><a href="#PropertySource-amp-ImportResource-amp-Bean" class="headerlink" title="@PropertySource &amp; @ImportResource &amp; @Bean"></a>@PropertySource &amp; @ImportResource &amp; @Bean</h4><p>@ConfigurationProperties默认加载默认的全局配置中的内容。</p><p>但是，我们并不想将所有的配置内容都放在全局的配置文件中，则使用@PropertySource注解。</p><p>@PropertySource：加载指定的配置文件。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能； *  @ConfigurationProperties(prefix = "person")默认从全局配置文件中获取值； * */</span><span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"classpath:person.properties"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"person"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>   ···｝</code></pre><p>@PropertySource(value = {“classpath:person.properties”})：这里指定了在类路径下的person.properties文件中内容映射到本类的属性中。</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103141521.png"></p><p><strong>注意：</strong><br>再将默认的全局配置文件中的person属性注释掉，因为全局的配置文件的优先级高于自定义的配置文件的优先级。</p><p>运行测试类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103141730.png"></p><p>此时，我们加载的就是自定义person.properties文件中的内容了。</p><p>@<strong>ImportResource</strong>：导入Spring的xml配置文件，让配置文件里面的内容生效；</p><p>Spring Boot里面没有Spring的xml配置文件，我们自己编写的配置文件，也不能自动识别；<br>想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上。</p><p>在resources下，创建beans.xml文件。<br>在service下，创建HellService类</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103142248.png"></p><p>修改测试类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103142451.png"></p><p>运行测试方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103142633.png"></p><p>在Springboot启动类上，加上@ImportResource注解：</p><p>因为@SpringBootApplication注解本身也是一个配置类<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103142813.png"></p><p>再次运行测试方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103142947.png"></p><p><strong>@Bean</strong></p><p>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p><p>不来编写Spring的xml配置文件。</p><p>1）配置类@Configuration——&gt;Spring配置文件</p><p>2）使用@Bean给容器中添加组件</p><p>在config下，创建一个配置类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103143527.png"></p><p>去掉SpringBootApplication启动类上的@ImportResource注解；</p><p>运行测试方法：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103142947.png"></p><hr><h4 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h4><p>1）随机数</p><pre><code>${random.value}、${random.int}、${random.long}${random.int(10)}、${random.int[1024,65536]}</code></pre><p>比如：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103144510.png"></p><p>2）占位符获取之前配置的值，如果没有可以是用:指定默认值</p><pre><code>person.last‐name=张三${random.uuid}person.age=${random.int}person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=${person.hello:hello}_dogperson.dog.age=15</code></pre><p>这里的person.dog.name使用了${person.hello:hello}_dog，如果${person.hello:hello}之前没有配置，就会使用冒号后面的默认值hello。如果没有写冒号后面的值，即：person.dog.name=${person.hello}_dog。则原样输出。（没有配置${person.hello}的话）。</p><h4 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h4><h5 id="多Profile文件"><a href="#多Profile文件" class="headerlink" title="多Profile文件"></a>多Profile文件</h5><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml</p><p><strong>默认使用application.properties的配置。</strong></p><p>默认的配置文件application.properties：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103150324.png"></p><p>创建dev配置文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103150535.png"></p><p>创建prod配置文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103150641.png"></p><p>启动SpringBoot应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103150737.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103150805.png"></p><p>可以看出，默认启动，application.properties的配置。端口号：8081</p><h5 id="激活指定profile"><a href="#激活指定profile" class="headerlink" title="激活指定profile"></a>激活指定profile</h5><p>1）在默认配置文件中指定 spring.profiles.active=dev<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103151018.png"></p><p>启动SpringBoot应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103151137.png"></p><p>端口号：8082.</p><p>2）命令行：</p><p>java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar  <code>--spring.profiles.active=dev</code></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103151355.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103151622.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103151704.png"></p><p>端口号是：8083</p><p><strong>激活的是prod，说明命令行参数的优先级 高于 配置文件的激活的优先级。</strong></p><p>3) 虚拟机参数；</p><p><code>-Dspring.profiles.active=dev</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103152038.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103152205.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103152225.png"></p><p>端口号：8082</p><p><strong>激活的是dev。说明虚拟机参数的优先级 高于 配置文件的优先级</strong></p><hr><p><strong>当命令行参数与虚拟机参数同时存在时，以命令行参数为准。</strong></p><p>即：命令行的优先级最高。</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103152736.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103152756.png"></p><p>端口号是：8083</p><p>激活的是prod。</p><h5 id="yml支持多文档块方式"><a href="#yml支持多文档块方式" class="headerlink" title="yml支持多文档块方式"></a>yml支持多文档块方式</h5><p>在yml文件中，支持多文档块方式，即在一个yml文件中，书写多个文件配置。</p><p>使用<code>---</code>隔开。</p><p>首先，注释掉所有的properties文件和启动的命令行与虚拟机参数。</p><p>修改yml文件：</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103153342.png"></p><p>启动SpringBoot应用：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103153506.png"></p><p>端口号：8084</p><p>激活的是dev文件。</p><h4 id="配置文件加载位置"><a href="#配置文件加载位置" class="headerlink" title="配置文件加载位置"></a>配置文件加载位置</h4><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件。</p><p><code>–file:./config/</code><br><code>–file:./</code><br><code>–classpath:/config/</code><br><code>–classpath:/</code></p><p><strong>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</strong></p><p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置。</strong></p><p><strong>file：代表的是项目的根路径下。</strong></p><p><strong>classpath：代表的是resources下。</strong></p><p>1）application.properties中：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103155025.png"><br>端口号：8081</p><p>启动项目：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103155147.png"><br>端口号启动的也是8081.</p><p>2）在resources下创建config包，并创建application.properties文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103155312.png"><br>端口号是：8082</p><p>启动项目：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103155414.png"><br>启动的端口号：8082</p><p>3）在项目的根路径下创建application.properties文件：</p><p>即：在spring-boot-02-config右键创建文件。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103155603.png"><br>端口号：8083</p><p>启动项目：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103155649.png"><br>启动的端口号：8083</p><p>4）在项目的根路径下创建config文件夹，并application.properties文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103155800.png"><br>端口号：8084</p><p>启动项目：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103155859.png"><br>启动的端口号：8084</p><p>印证了SpringBoot加载配置文件的优先级。</p><p>当四个位置都有配置文件时，是<strong>互补配置的</strong>。</p><p>即当高优先级的配置文件中存在低优先级的配置文件中的内容时会覆盖低优先级中的内容，但是当高优先级的配置文件中，没有低优先级文件中的内容时，会直接加载低优先级文件中的内容。</p><p><strong>注意：我们还可以通过spring.config.location来改变默认的配置文件位置</strong></p><p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默<br>认加载的这些配置文件共同起作用形成互补配置；</p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar  –spring.config.location=G:/application.properties</p><p>此时：G:/application.properties文件的优先级最高，然后互补配置。</p><h4 id="外部配置加载顺序"><a href="#外部配置加载顺序" class="headerlink" title="外部配置加载顺序"></a>外部配置加载顺序</h4><p><strong>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</strong></p><font color="red">1.命令行参数</font><br>所有的配置都可以在命令行上进行指定<br>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar  <code>--server.port=8087  --server.context-path=/abc</code><br><br>多个配置用空格分开； <code>--配置项 = 值</code><br><br>2.来自java:comp/env的JNDI属性<br><br>3.Java系统属性（System.getProperties()）<br><br>4.操作系统环境变量<br><br>5.RandomValuePropertySource配置的random.*属性值<br><br><strong>由jar包外向jar包内进行寻找；</strong><br><br><strong>优先加载带profile</strong><br><br><font color="red">6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</font><br><font color="red">7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</font><p><strong>再来加载不带profile</strong></p><font color="red">8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</font><br><font color="red">9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</font><p>10.@Configuration注解类上的@PropertySource<br>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><p>所有支持的配置加载来源；</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">参考官方文档</a></p><h4 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h4><p>配置文件到底能写什么？怎么写？自动配置原理；</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><h5 id="自动配置原理："><a href="#自动配置原理：" class="headerlink" title="自动配置原理："></a>自动配置原理：</h5><p>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 <strong>@EnableAutoConfiguration</strong></p><p>2）、@EnableAutoConfiguration 作用：</p><ul><li>利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</li><li>可以查看selectImports()方法的内容；</li><li>List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置<pre class=" language-java"><code class="language-java">SpringFactoriesLoader<span class="token punctuation">.</span><span class="token function">loadFactoryNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span>扫描所有jar包类路径下  META‐INF<span class="token operator">/</span>spring<span class="token punctuation">.</span>factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span>类（类名）对应的值，然后把他们添加在容器中</code></pre></li></ul><p><strong>将类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；</strong></p><pre><code># Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</code></pre><p>每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p><p>3）、每一个自动配置类进行自动配置功能；</p><p>4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；</p><pre><code>@Configuration   //表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class)  //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class)  //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing =true)  //判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration {   //他已经和SpringBoot的配置文件映射了     private final HttpEncodingProperties properties;   //只有一个有参构造器的情况下，参数的值就会从容器中拿   public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) {        this.properties = properties;           }    @Bean   //给容器中添加一个组件，这个组件的某些值需要从properties中获取@ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？    public CharacterEncodingFilter characterEncodingFilter() {        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();            filter.setEncoding(this.properties.getCharset().name());            filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));            filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));            return filter;        } </code></pre><p>根据当前不同的条件判断，决定这个配置类是否生效？</p><p>一旦这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p><p>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者；配置文件能配置什么就可以参照某个功能对应的这个属性类</p><pre><code>@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;)  //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties {   public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF‐8&quot;);</code></pre><p><strong>精髓：<br>1）、SpringBoot启动会加载大量的自动配置类<br>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；<br>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）<br>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这<br>些属性的值.</strong></p><p>xxxxAutoConfigurartion：自动配置类；给容器中添加组件</p><p>xxxxProperties:封装配置文件中相关属性；</p><h5 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h5><p>1、@Conditional派生注解（Spring注解版原生的@Conditional作用）</p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置里面的所有内容才生效；</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day02/QQ%E6%88%AA%E5%9B%BE20181103170857.png"></p><p><strong>自动配置类必须在一定的条件下才能生效；</strong></p><p>我们怎么知道哪些自动配置类生效；</p><font color="#EE2C2C">我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</font><pre class=" language-java"><code class="language-java"><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>AUTO‐CONFIGURATION REPORT<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>Positive matches<span class="token operator">:</span>（自动配置类启用的）‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐   DispatcherServletAutoConfiguration matched<span class="token operator">:</span> ‐ <span class="token annotation punctuation">@ConditionalOnClass</span> found required <span class="token keyword">class</span><span class="token string">'org.springframework.web.servlet.DispatcherServlet'</span><span class="token punctuation">;</span> <span class="token annotation punctuation">@ConditionalOnMissingClass</span> did not findunwanted <span class="token keyword">class</span> <span class="token punctuation">(</span>OnClassCondition<span class="token punctuation">)</span>      ‐ <span class="token annotation punctuation">@ConditionalOnWebApplication</span> <span class="token punctuation">(</span>required<span class="token punctuation">)</span> found <span class="token function">StandardServletEnvironment</span><span class="token punctuation">(</span>OnWebApplicationCondition<span class="token punctuation">)</span>Negative matches<span class="token operator">:</span>（没有启动，没有匹配成功的自动配置类）‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐   ActiveMQAutoConfiguration<span class="token operator">:</span>      Did not match<span class="token operator">:</span>         ‐ <span class="token annotation punctuation">@ConditionalOnClass</span> did not find required classes <span class="token string">'javax.jms.ConnectionFactory'</span><span class="token punctuation">,</span><span class="token string">'org.apache.activemq.ActiveMQConnectionFactory'</span> <span class="token punctuation">(</span>OnClassCondition<span class="token punctuation">)</span>   AopAutoConfiguration<span class="token operator">:</span>      Did not match<span class="token operator">:</span>         ‐ <span class="token annotation punctuation">@ConditionalOnClass</span> did not find required classes<span class="token string">'org.aspectj.lang.annotation.Aspect'</span><span class="token punctuation">,</span> <span class="token string">'org.aspectj.lang.reflect.Advice'</span> <span class="token punctuation">(</span>OnClassCondition<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot_day_01</title>
      <link href="/2018/11/02/springboot-day-01/"/>
      <url>/2018/11/02/springboot-day-01/</url>
      
        <content type="html"><![CDATA[<p>Spring boot 来简化Spring应用开发，约定大于配置，去繁从简，just run就能创建一个独立的，产品级别的应用。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>J2EE笨重的开发、繁多的配置、低下的开发效率、复杂的部署流程、第三方技术集成难度大。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>“Spring全家桶”时代.</p><p>SpringBoot -&gt; J2EE一站式解决方案</p><p>SpingCloud -&gt; 分布式整体解决方案</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>快速创建独立运行的Spring项目以及与主流框架集成  </li><li>使用嵌入式的Servlet容器，应用无需打成WAR包  </li><li>starters自动依赖与版本控制  </li><li>大量的自动配置，简化开发，也可修改默认值  </li><li>无需配置XML，无代码生成，开箱即用  </li><li>准生产环境的运行时应用监控  </li><li>与云计算的天然集成  </li></ul><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>2014，martin fowler</p><p>微服务：架构风格（服务微化）</p><p>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p><p>单体应用：ALL IN ONE</p><p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p><p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa" title="微服务参考" target="_blank" rel="noopener">微服务参考</a></p><h3 id="环境约束："><a href="#环境约束：" class="headerlink" title="环境约束："></a>环境约束：</h3><ul><li>jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112”  </li><li>maven3.x：maven 3.3以上版本；Apache Maven 3.3.9  </li><li>IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64 、STS  </li><li>SpringBoot 1.5.9.RELEASE：1.5.9；  </li></ul><p><a href="https://pan.baidu.com/s/1ay5tPJkNJeptSkFgjiL_Zw" target="_blank" rel="noopener">环境软件下载</a></p><p>密码：jpro</p><p>统一环境；</p><p><strong>1.Maven设置</strong></p><p>给maven 的 settings.xml配置文件的profiles标签添加</p><pre><code>&lt;profile&gt;  &lt;id&gt;jdk‐1.8&lt;/id&gt;  &lt;activation&gt;    &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;    &lt;jdk&gt;1.8&lt;/jdk&gt;  &lt;/activation&gt;  &lt;properties&gt;    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;    &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;  &lt;/properties&gt;&lt;/profile&gt;</code></pre><p><strong>2.IDEA设置</strong></p><p>整合maven进来</p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102151849.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102152017.png"></p><p>将maven配置成我们的maven，不使用idea自带的maven。</p><p>Maven home directory： maven的安装路径</p><p>User setting file：maven的setting配置文件的路径</p><p>Local repository：maven的本地仓库的路径。</p><h3 id="Spring-Boot-HelloWorld"><a href="#Spring-Boot-HelloWorld" class="headerlink" title="Spring Boot HelloWorld"></a>Spring Boot HelloWorld</h3><p>一个功能：</p><p>浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；</p><h4 id="创建一个maven项目-jar"><a href="#创建一个maven项目-jar" class="headerlink" title="创建一个maven项目(jar)"></a>创建一个maven项目(jar)</h4><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102154909.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102155112.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102155230.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102155348.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102155708.png"></p><h4 id="导入spring-boot相关的依赖"><a href="#导入spring-boot相关的依赖" class="headerlink" title="导入spring boot相关的依赖"></a>导入spring boot相关的依赖</h4><pre><code>   &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring‐boot‐starter‐parent&lt;/artifactId&gt;        &lt;version&gt;1.5.17.RELEASE&lt;/version&gt;   &lt;/parent&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p><strong>现在的spring boot的1.x的版本没有1.5.9，所以我们使用1.5.17.RELEASE。</strong></p><p>我们可以参考Spring的官网的文档。<a href="https://spring.io/" target="_blank" rel="noopener">Spring官网</a><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102160852.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102161036.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102161400.png"></p><p>添加依赖后，idea就会帮我们开始下载依赖，如果没有自动下载，可以点击idea的右边的Maven Projects，然后点击上面的循环标志。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102162613.png" style="width:50%"></p><p>依赖下载完毕后，可以看到我们的依赖文件：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102162819.png"></p><h4 id="编写一个主程序"><a href="#编写一个主程序" class="headerlink" title="编写一个主程序"></a>编写一个主程序</h4><p>在src/main/java下创建com.liuzhuo的包，并创建HelloWorldApplication类：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102163202.png"></p><p>添加@SpringBootApplication注解，并编写一个主函数。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span>  <span class="token comment" spellcheck="true">//表明这是一个Springboot的启动类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorldApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//启动Springboot应用。</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>HelloWorldApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="编写相关的Controller"><a href="#编写相关的Controller" class="headerlink" title="编写相关的Controller"></a>编写相关的Controller</h4><p>在com.liuzhuo.controller下，创建HelloController</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="运行主程序测试"><a href="#运行主程序测试" class="headerlink" title="运行主程序测试"></a>运行主程序测试</h4><p>回到Springboot的启动类中，直接运行main函数：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102163832.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102163913.png"><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102163946.png"></p><p>出现上图所示的效果就说明Springboot应用启动成功。</p><p>在浏览器中输入：<code>http://localhost:8080/hello</code></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102164146.png"></p><h4 id="简化部署"><a href="#简化部署" class="headerlink" title="简化部署"></a>简化部署</h4><p>以前，部署Web应用，需要将我们的Web项目生成War，然后在服务器中安装服务器，比如Tomcat等，然后将War放在Tomcat容器中，启动Tomcat容器。</p><p>现在，我们不需要这么麻烦了，我们直接生成jar就行。生成jar之前，我们需要在pom文件中添加Springboot的构建插件。</p><pre><code>    &lt;!-- 这个插件，可以将应用打包成一个可执行的jar包--&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><p>然后生成jar包：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102164849.png" style="width:50%"></p><p>双击：package。</p><p>控制台输出：BUILD SUCCESS<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102165053.png"></p><p>我们，可以在target包下，看到我们生成的可运行的jar。<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102165310.png"></p><p>拷贝这个jar到我们的桌面上面：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102165410.png"></p><p>打开命令行界面：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102165718.png"></p><p>我们的Springboot应用就启动了，这样是不是很简单，都不需要打成war包和安装Tomcat。</p><p>在浏览器中输入：<code>http://localhost:8080/hello</code></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102164146.png"></p><h3 id="Hello-World-的探究"><a href="#Hello-World-的探究" class="headerlink" title="Hello World 的探究"></a>Hello World 的探究</h3><h4 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h4><p>1）父项目</p><pre><code>&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring‐boot‐starter‐parent&lt;/artifactId&gt;    &lt;version&gt;1.5.17.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring‐boot‐dependencies&lt;/artifactId&gt;  &lt;version&gt;1.5.17.RELEASE&lt;/version&gt;  &lt;relativePath&gt;../../spring‐boot‐dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本；</code></pre><p>Spring Boot的版本仲裁中心；</p><p>以后我们导入依赖,默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）</p><p>2) 启动器</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>spring-boot-starter-web：</p><p>spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；</p><p>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter.<br>相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器.</p><h4 id="主程序类，主入口类"><a href="#主程序类，主入口类" class="headerlink" title="主程序类，主入口类"></a>主程序类，主入口类</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 描述: * * @author liuzhuo * @create 2018-11-02 16:31 */</span><span class="token annotation punctuation">@SpringBootApplication</span>  <span class="token comment" spellcheck="true">//表明这是一个Springboot的启动类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorldApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//启动Springboot应用。</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>HelloWorldApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>@SpringBootApplication:</strong> Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot<br>就应该运行这个类的main方法来启动SpringBoot应用；</p><p>点击@SpringBootApplication注解：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> TypeExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> AutoConfigurationExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SpringBootApplication</span></code></pre><p>发现@SpringBootApplication注解是一个组合注解，下面我们一一来看。</p><p><strong>@SpringBootConfiguration:</strong> Spring Boot的配置类；</p><p>标注在某个类上，表示这是一个Spring Boot的配置类；</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SpringBootConfiguration</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>其实就是一个@Configuration注解，只是@Configuration注解，我们是在Spring中使用，@SpringBootConfiguration是在Springboot中使用，本质都一个配置类。</p><p>配置类 —– 配置文件；配置类也是容器中的一个组件；@Component</p><p><strong>@EnableAutoConfiguration</strong>：开启自动配置功能；</p><p>以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自<br>动配置功能；这样自动配置才能生效；</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"deprecation"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@AutoConfigurationPackage</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>EnableAutoConfigurationImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableAutoConfiguration</span></code></pre><p><strong>@AutoConfigurationPackage</strong>：自动配置包</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>AutoConfigurationPackages<span class="token punctuation">.</span>Registrar<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">AutoConfigurationPackage</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>@Import(AutoConfigurationPackages.Registrar.class)：<br>Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class注入；</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Order</span><span class="token punctuation">(</span>Ordered<span class="token punctuation">.</span>HIGHEST_PRECEDENCE<span class="token punctuation">)</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Registrar</span> <span class="token keyword">implements</span> <span class="token class-name">ImportBeanDefinitionRegistrar</span><span class="token punctuation">,</span> DeterminableImports <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span>AnnotationMetadata metadata<span class="token punctuation">,</span>                BeanDefinitionRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">register</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">PackageImport</span><span class="token punctuation">(</span>metadata<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPackageName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> Set<span class="token operator">&lt;</span>Object<span class="token operator">></span> <span class="token function">determineImports</span><span class="token punctuation">(</span>AnnotationMetadata metadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Collections<span class="token punctuation">.</span>&lt;Object<span class="token operator">></span><span class="token function">singleton</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PackageImport</span><span class="token punctuation">(</span>metadata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>给这个方法打上断点。debug下</p><p><strong>会发现，Spring会把将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；</strong></p><p>@<strong>Import(EnableAutoConfigurationImportSelector.class)；</strong></p><p>给容器中导入组件？</p><p>EnableAutoConfigurationImportSelector：导入哪些组件的选择器；</p><p>将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p><p>会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102192759.png"></p><p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；<br>SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；</p><p>Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将<br>这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东<br>西，自动配置类都帮我们；<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102193127.png"></p><p>J2EE的整体整合解决方案和自动配置都在:<code>spring-boot-autoconfigure-X.X.X.RELEASE.jar</code>；</p><p>所以，@EnableAutoConfiguration自动配置的魔法骑士就变成了：</p><p><strong>从classpath中搜寻所有的 META-INF/spring.factories 配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项</strong>  </p><p><strong>通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。</strong></p><h3 id="深入探索SpringApplication执行流程"><a href="#深入探索SpringApplication执行流程" class="headerlink" title="深入探索SpringApplication执行流程"></a>深入探索SpringApplication执行流程</h3><p>SpringApplication的run方法的实现是我们本次旅程的主要线路，该方法的主要流程大体可以归纳如下：</p><p>1） 如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：</p><ul><li>根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。</li><li>推断并设置main方法的定义类。</li></ul><p>2）SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行开始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。</p><p>3） 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</p><p>4） 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。</p><p>5） 如果SpringApplication的showBanner属性被设置为true，则打印banner。</p><p>6） 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。</p><p>7） ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</p><p>8） 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</p><p>9） 最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。</p><p>10） 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</p><p>11） 调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</p><p>12） 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</p><p>13） 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）</p><p><strong>总结</strong></p><p>到此，SpringBoot的核心组件完成了基本的解析，综合来看，大部分都是Spring框架背后的一些概念和实践方式，SpringBoot只是在这些概念和实践上对特定的场景事先进行了固化和升华，而也恰恰是这些固化让我们开发基于Sping框架的应用更加方便高效。</p><h3 id="使用Spring-Initializer快速创建Spring-Boot项目"><a href="#使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="使用Spring Initializer快速创建Spring Boot项目"></a>使用Spring Initializer快速创建Spring Boot项目</h3><p>IDE都支持使用<strong>Spring的项目创建向导</strong>快速创建一个Spring Boot项目；<br>选择我们需要的模块；向导会联网创建Spring Boot项目；<br>默认生成的Spring Boot项目；<br>主程序已经生成好了，我们只需要我们自己的逻辑</p><p>resources文件夹中目录结构：</p><ul><li>static：保存所有的静态资源； js css images；</li><li>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的- - Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</li><li>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</li></ul><p>1）打开idea，创建一个工程Project<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102201430.png"></p><p>2）选择Spring Initializr<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102201714.png"></p><p>3) 填写Group和Artifact<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102202215.png"></p><p>4）选择Spring boot的版本 和 我们需要的模块（Web）<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102202456.png"></p><p>5）填写项目名和项目的路径<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102202648.png"></p><p>6）删除不需要的文件<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102202925.png"></p><p>7）编写逻辑控制层<br>在com.liuzhuo.springboot的包下，创建controller包，并创建HelloController：<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102205841.png"></p><p>8）启动Springboot应用<br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102210019.png"></p><p>9）在浏览器中输入：<code>http://localhost:8080/hello</code><br><img src="https://gakkil.gitee.io/gakkil-image/SpringBoot/day01/QQ%E6%88%AA%E5%9B%BE20181102210130.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决idea控制台输出乱码问题</title>
      <link href="/2018/10/29/jie-jue-idea-kong-zhi-tai-shu-chu-luan-ma-wen-ti/"/>
      <url>/2018/10/29/jie-jue-idea-kong-zhi-tai-shu-chu-luan-ma-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>解决IntelliJ IDEA 控制台输出乱码问题</p><h3 id="找到安装Intellij-idea目录bin下面的idea-exe-vmoptions和idea64-exe-vmoptions文件，我的安装目录是D-IntelliJ-IDEA-IntelliJ-IDEA-15-0-2-bin"><a href="#找到安装Intellij-idea目录bin下面的idea-exe-vmoptions和idea64-exe-vmoptions文件，我的安装目录是D-IntelliJ-IDEA-IntelliJ-IDEA-15-0-2-bin" class="headerlink" title="找到安装Intellij idea目录bin下面的idea.exe.vmoptions和idea64.exe.vmoptions文件，我的安装目录是D:\IntelliJ IDEA\IntelliJ IDEA 15.0.2\bin"></a>找到安装Intellij idea目录bin下面的idea.exe.vmoptions和idea64.exe.vmoptions文件，我的安装目录是D:\IntelliJ IDEA\IntelliJ IDEA 15.0.2\bin</h3><p><img src="https://gakkil.gitee.io/gakkil-image/idea/luanma/QQ%E6%88%AA%E5%9B%BE20181029164601.png"></p><h3 id="修改idea-exe-vmoptions和idea64-exe-vmoptions文件，在末尾添加-Dfile-encoding-UTF-8"><a href="#修改idea-exe-vmoptions和idea64-exe-vmoptions文件，在末尾添加-Dfile-encoding-UTF-8" class="headerlink" title="修改idea.exe.vmoptions和idea64.exe.vmoptions文件，在末尾添加                -Dfile.encoding=UTF-8"></a>修改idea.exe.vmoptions和idea64.exe.vmoptions文件，在末尾添加                -Dfile.encoding=UTF-8</h3><p><img src="https://gakkil.gitee.io/gakkil-image/idea/luanma/QQ%E6%88%AA%E5%9B%BE20181029164704.png"></p><h3 id="设置idea-file编码。在菜单栏找到”File-gt-settings-gt-搜索File-Encodeing”-设置utf-8。如图所示"><a href="#设置idea-file编码。在菜单栏找到”File-gt-settings-gt-搜索File-Encodeing”-设置utf-8。如图所示" class="headerlink" title="设置idea file编码。在菜单栏找到”File-&gt;settings-&gt;搜索File Encodeing” 设置utf-8。如图所示"></a>设置idea file编码。在菜单栏找到”File-&gt;settings-&gt;搜索File Encodeing” 设置utf-8。如图所示</h3><p><img src="https://gakkil.gitee.io/gakkil-image/idea/luanma/QQ%E6%88%AA%E5%9B%BE20181029164741.png"></p><h3 id="设置idea-server编码。在菜单栏找到”run-gt-editconfigration”-找到”server”选项卡-设置-vm-option为-Dfile-encoding-utf-8，如图所示"><a href="#设置idea-server编码。在菜单栏找到”run-gt-editconfigration”-找到”server”选项卡-设置-vm-option为-Dfile-encoding-utf-8，如图所示" class="headerlink" title="设置idea server编码。在菜单栏找到”run-&gt;editconfigration” 找到”server”选项卡 设置 vm option为 -Dfile.encoding=utf-8，如图所示"></a>设置idea server编码。在菜单栏找到”run-&gt;editconfigration” 找到”server”选项卡 设置 vm option为 -Dfile.encoding=utf-8，如图所示</h3><p><img src="https://gakkil.gitee.io/gakkil-image/idea/luanma/QQ%E6%88%AA%E5%9B%BE20181029164814.png"></p><h3 id="重启Intellij-IDEA"><a href="#重启Intellij-IDEA" class="headerlink" title="重启Intellij IDEA"></a>重启Intellij IDEA</h3>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
          <category> 乱码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
            <tag> 乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet3.0与SpringMVC整合</title>
      <link href="/2018/10/29/servlet3-0-yu-springmvc-zheng-he/"/>
      <url>/2018/10/29/servlet3-0-yu-springmvc-zheng-he/</url>
      
        <content type="html"><![CDATA[<p>Servlet3.0与SpringMVC的整合，永久告别web.xml的配置文件啦~~</p><h3 id="创建maven-web工程"><a href="#创建maven-web工程" class="headerlink" title="创建maven-web工程"></a>创建maven-web工程</h3><p>如果大家对idea创建maven-web工程不熟悉的话，去看我的另一篇博客<a href="/2018/10/29/idea-chuang-jian-maven-web-gong-cheng/">idea创建maven-web工程</a></p><p><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0_SpringMVC/QQ%E6%88%AA%E5%9B%BE20181029201934.png" style="width:50%"></p><h3 id="打开pom-xml文件"><a href="#打开pom-xml文件" class="headerlink" title="打开pom.xml文件"></a>打开pom.xml文件</h3><p>添加两个依赖，SpringMVC和Servlet的依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;4.1.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;  &lt;!-- 3.0以上的版本都可以--&gt;    &lt;scope&gt;provided&lt;/scope&gt;   &lt;!-- 因为Tomcat容器中有servlet的jar，所以打成war包的时候，不需要这个--&gt;&lt;/dependency&gt;</code></pre><h3 id="现在开始整合SpringMVC开发。打开Spring的官网。"><a href="#现在开始整合SpringMVC开发。打开Spring的官网。" class="headerlink" title="现在开始整合SpringMVC开发。打开Spring的官网。"></a>现在开始整合SpringMVC开发。打开Spring的官网。</h3><p>找到相关的文档处<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#spring-web" target="_blank" rel="noopener">Spring-web</a></p><p>我们能发现在servlet3.0以后，SpringMVC的官网推不再使用web.xml开发，直接使用java的配置类来替代web.xml文件。</p><p>我们只需要编写一个类实现<strong>WebApplicationInitializer</strong>接口，就相当于web.xml文件了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyWebApplicationInitializer</span> <span class="token keyword">implements</span> <span class="token class-name">WebApplicationInitializer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStartup</span><span class="token punctuation">(</span>ServletContext servletCxt<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Load Spring web application configuration</span>        AnnotationConfigWebApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigWebApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ac<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>AppConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ac<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Create and register the DispatcherServlet</span>        DispatcherServlet servlet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DispatcherServlet</span><span class="token punctuation">(</span>ac<span class="token punctuation">)</span><span class="token punctuation">;</span>        ServletRegistration<span class="token punctuation">.</span>Dynamic registration <span class="token operator">=</span> servletCxt<span class="token punctuation">.</span><span class="token function">addServlet</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">,</span> servlet<span class="token punctuation">)</span><span class="token punctuation">;</span>        registration<span class="token punctuation">.</span><span class="token function">setLoadOnStartup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registration<span class="token punctuation">.</span><span class="token function">addMapping</span><span class="token punctuation">(</span><span class="token string">"/app/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>容器启动后，会执行这个实现WebApplicationInitializer接口的实现类。然后执行onStartup()方法。</p><p>在该方法中，创建了注解式配置应用上下文，传入spring的配置文件。然后向该容器中注入DispatcherServlet，来完成SpringMVC的前端控制器。</p><p><font color="red"><strong>重点</strong></font>:</p><p>那为啥实现了WebApplicationInitializer接口的实现类，在容器启动时调用呢？</p><p>首先打开这个接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">WebApplicationInitializer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Configure the given {@link ServletContext} with any servlets, filters, listeners     * context-params and attributes necessary for initializing this web application. See     * examples {@linkplain WebApplicationInitializer above}.     * @param servletContext the {@code ServletContext} to initialize     * @throws ServletException if any call against the given {@code ServletContext}     * throws a {@code ServletException}     */</span>    <span class="token keyword">void</span> <span class="token function">onStartup</span><span class="token punctuation">(</span>ServletContext servletContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>只有一个方法，看不出什么头绪。但是，在这个包下有另外一个类，SpringServletContainerInitializer。它的实现如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@HandlesTypes</span><span class="token punctuation">(</span>WebApplicationInitializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringServletContainerInitializer</span> <span class="token keyword">implements</span> <span class="token class-name">ServletContainerInitializer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStartup</span><span class="token punctuation">(</span>Set<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> webAppInitializerClasses<span class="token punctuation">,</span> ServletContext servletContext<span class="token punctuation">)</span>            <span class="token keyword">throws</span> ServletException <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>WebApplicationInitializer<span class="token operator">></span> initializers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>WebApplicationInitializer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>webAppInitializerClasses <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> waiClass <span class="token operator">:</span> webAppInitializerClasses<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Be defensive: Some servlet containers provide us with invalid classes,</span>                <span class="token comment" spellcheck="true">// no matter what @HandlesTypes says...</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>waiClass<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Modifier<span class="token punctuation">.</span><span class="token function">isAbstract</span><span class="token punctuation">(</span>waiClass<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                        WebApplicationInitializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>waiClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        initializers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">(</span>WebApplicationInitializer<span class="token punctuation">)</span> waiClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServletException</span><span class="token punctuation">(</span><span class="token string">"Failed to instantiate WebApplicationInitializer class"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initializers<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            servletContext<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"No Spring WebApplicationInitializer types detected on classpath"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        AnnotationAwareOrderComparator<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>initializers<span class="token punctuation">)</span><span class="token punctuation">;</span>        servletContext<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Spring WebApplicationInitializers detected on classpath: "</span> <span class="token operator">+</span> initializers<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>WebApplicationInitializer initializer <span class="token operator">:</span> initializers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            initializer<span class="token punctuation">.</span><span class="token function">onStartup</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个类就比较有意思了，先不管其他的，读一下这段代码，可以得到这样的意思。</p><p>先判断webAppInitializerClasses这个Set是否为空。如果不为空的话，找到这个set中不是接口，不是抽象类，并且是WebApplicationInitializer接口实现类的类，将它们保存到list中。当这个list为空的时候，直接return。不为空的话就按照一定的顺序排序，并将它们按照一定的顺序实例化。调用<strong>其onStartup方法执行</strong>。到这里，就可以解释WebApplicationInitializer实现类的工作过程了。</p><p><strong>但是，在web项目运行的时候，SpringServletContainerInitializer这个类又是怎样被调用的呢？</strong></p><p>再看被它实现的ServletContainerInitializer这个接口<br>它只有一个接口方法onStartup()，通过它就可以解释SpringServletContainerInitializer是如何被调用的。它的内容如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ServletContainerInitializer</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">onStartup</span><span class="token punctuation">(</span>Set<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> var1<span class="token punctuation">,</span> ServletContext var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>首先，这个接口是javax.servlet下的，官方的解释是这样的：</p><p>为了支持可以不使用web.xml。提供了ServletContainerInitializer，它可以通过SPI机制。</p><p>当启动web容器的时候，会自动到项目中添加的jar包下找到META-INF/services/javax.servlet.ServletContainerInitializer文件。</p><p>它的内容为ServletContainerInitializer实现类的全路径，将它们实例化。</p><p>既然这样的话，那么SpringServletContainerInitializer作为ServletContainerInitializer的实现类，它的jar包下也应该有相应的文件。<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0_SpringMVC/QQ%E6%88%AA%E5%9B%BE20181029211845.png"></p><p>哈，现在就可以解释清楚了。首先，SpringServletContainerInitializer作为ServletContainerInitializer的实现类，通过<strong>SPI机制</strong>，在web容器加载的时候会自动的被调用。（这个类上还有一个注解@HandlesTypes，它的作用是将感兴趣的一些类注入到ServletContainerInitializer）， 而这个类的方法又会扫描找到WebApplicationInitializer的实现类，调用它的onStartup方法，从而起到启动web.xml相同的作用。</p><hr><p>等价于web.xml文件：</p><pre><code>&lt;web-app&gt;    &lt;!-- 注册这个监听器来注入Spring的父容器--&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;!-- 注册这个Servlet来注入SpringMVC的子容器--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;app&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;app&lt;/servlet-name&gt;        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>总结：</p><p>1）servlet3.0以后的Web容器在启动的时候，会扫描每个jar包下的META-INF/services/javax.servlet.ServletContainerInitializer文件</p><p>2）加载这个文件指定的类(实现了ServletContainerInitializer接口类)，并调用这个接口的onStartup()方法。<br>void onStartup(Set&lt;Class&lt;?&gt;&gt; var1, ServletContext var2) throws ServletException;</p><p>3）现在，我们在pom.xml文件中加入了spring-mvc的依赖，其中有一个jar：<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0_SpringMVC/QQ%E6%88%AA%E5%9B%BE20181029214152.png" style="width:50%"></p><p>在该META-INF/services/javax.servlet.ServletContainerInitializer文件下，有一个：org.springframework.web.SpringServletContainerInitializer的全路径。</p><p>打开SpringServletContainerInitializer类。</p><pre><code>@HandlesTypes(WebApplicationInitializer.class)public class SpringServletContainerInitializer implements ServletContainerInitializer {  ···}</code></pre><p>该类上面有一个@HandlesTypes注解，该注解会在web容器启动的时候，传入我们感兴趣的类型，这里会传入WebApplicationInitializer的类型。</p><p>然后在该类的onStartup()方法中：</p><pre><code>        if (webAppInitializerClasses != null) {            for (Class&lt;?&gt; waiClass : webAppInitializerClasses) {                // Be defensive: Some servlet containers provide us with invalid classes,                // no matter what @HandlesTypes says...                if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;                        WebApplicationInitializer.class.isAssignableFrom(waiClass)) {                    try {                        initializers.add((WebApplicationInitializer) waiClass.newInstance());                    }                    catch (Throwable ex) {                        throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);                    }                }            }        }</code></pre><p>这里的webAppInitializerClasses就是传入的我们感兴趣的类型，判断该传入的类型，在不是接口，不是抽象类，而且是WebApplicationInitializer类型的时候，实例化该传入的类型。</p><pre><code>for (WebApplicationInitializer initializer : initializers) {    initializer.onStartup(servletContext);}</code></pre><p>最后调用WebApplicationInitializer的<br>onStartup(ServletContext servletContext) throws ServletException;</p><hr><p>我们可以直接实现WebApplicationInitializer接口，像Spring官网一样整合SpringMVC。</p><p>但是，这里，我们来看看<strong>WebApplicationInitializer的继承体系</strong>：<br>会发现有三个抽象类：<br><code>AbstractContextLoaderInitializer</code><br><code>AbstractDispatcherServletInitializer</code><br><code>AbstractAnnotationConfigDispatcherServletInitializer</code></p><hr><p>AbstractContextLoaderInitializer：</p><pre><code>public abstract class AbstractContextLoaderInitializer implements WebApplicationInitializer {    /** Logger available to subclasses */    protected final Log logger = LogFactory.getLog(getClass());    @Override    public void onStartup(ServletContext servletContext) throws ServletException {        registerContextLoaderListener(servletContext);    }    protected void registerContextLoaderListener(ServletContext servletContext) {        WebApplicationContext rootAppContext = createRootApplicationContext();        if (rootAppContext != null) {            servletContext.addListener(new ContextLoaderListener(rootAppContext));        }        else {            logger.debug(&quot;No ContextLoaderListener registered, as &quot; +                    &quot;createRootApplicationContext() did not return an application context&quot;);        }    }    protected abstract WebApplicationContext createRootApplicationContext();}</code></pre><p>这里，我们可以看到：首先执行onStartup(),然后执行registerContextLoaderListener().</p><p>在然后执行registerContextLoaderListener中，调用createRootApplicationContext()方法来获取Spring的根容器。该方法需要我们来实现。</p><p>然后将我们创建的根容器注入到ServletContext中。</p><hr><p>AbstractDispatcherServletInitializer：</p><pre><code>public abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer {    public static final String DEFAULT_SERVLET_NAME = &quot;dispatcher&quot;;    public AbstractDispatcherServletInitializer() {    }    public void onStartup(ServletContext servletContext) throws ServletException {        super.onStartup(servletContext);        this.registerDispatcherServlet(servletContext);    }    protected void registerDispatcherServlet(ServletContext servletContext) {        String servletName = this.getServletName();        Assert.hasLength(servletName, &quot;getServletName() must not return empty or null&quot;);        WebApplicationContext servletAppContext = this.createServletApplicationContext();        Assert.notNull(servletAppContext, &quot;createServletApplicationContext() did not return an application context for servlet [&quot; + servletName + &quot;]&quot;);        DispatcherServlet dispatcherServlet = new DispatcherServlet(servletAppContext);        Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet);        Assert.notNull(registration, &quot;Failed to register servlet with name &#39;&quot; + servletName + &quot;&#39;.&quot; + &quot;Check if there is another servlet registered under the same name.&quot;);        registration.setLoadOnStartup(1);        registration.addMapping(this.getServletMappings());        registration.setAsyncSupported(this.isAsyncSupported());        Filter[] filters = this.getServletFilters();        if (!ObjectUtils.isEmpty(filters)) {            Filter[] var7 = filters;            int var8 = filters.length;            for(int var9 = 0; var9 &lt; var8; ++var9) {                Filter filter = var7[var9];                this.registerServletFilter(servletContext, filter);            }        }        this.customizeRegistration(registration);    }</code></pre><p>第一，创建Spring的WebApplicationContext容器。</p><p><code>protected abstract WebApplicationContext createServletApplicationContext();</code></p><p>需要我们自己实现，这个方法，返回一个WebApplicationContext容器。</p><p>第二，帮我们创建了一个dispatcherServlet，然后注入到ServletContext中。</p><p>第三，registration.addMapping(this.getServletMappings());添加映射，Filter[] filters = this.getServletFilters();注入过滤器等。</p><p><code>protected abstract String[] getServletMappings();</code></p><p>映射器也需要我们重写。</p><hr><p>AbstractAnnotationConfigDispatcherServletInitializer:</p><p>注解版注册DispatcherServlet的版本</p><pre><code>public abstract class AbstractAnnotationConfigDispatcherServletInitializer extends AbstractDispatcherServletInitializer {    public AbstractAnnotationConfigDispatcherServletInitializer() {    }    protected WebApplicationContext createRootApplicationContext() {        Class&lt;?&gt;[] configClasses = this.getRootConfigClasses();        if (!ObjectUtils.isEmpty(configClasses)) {            AnnotationConfigWebApplicationContext rootAppContext = new AnnotationConfigWebApplicationContext();            rootAppContext.register(configClasses);            return rootAppContext;        } else {            return null;        }    }    protected WebApplicationContext createServletApplicationContext() {        AnnotationConfigWebApplicationContext servletAppContext = new AnnotationConfigWebApplicationContext();        Class&lt;?&gt;[] configClasses = this.getServletConfigClasses();        if (!ObjectUtils.isEmpty(configClasses)) {            servletAppContext.register(configClasses);        }        return servletAppContext;    }    protected abstract Class&lt;?&gt;[] getRootConfigClasses();    protected abstract Class&lt;?&gt;[] getServletConfigClasses();}</code></pre><p>里面就重写了两个方法：</p><p>createRootApplicationContext():创建配置类的根容器<br>重写getRootConfigClasses():传入一个配置类。</p><p>createServletApplicationContext():创建Web的ioc容器<br>重写getServletConfigClasses():获取Web版的配置类。</p><hr><p>总结：</p><p>以注解方法来启动SpringMVC的话：继承AbstractAnnotationConfigDispatcherServletInitializer；</p><p>实现抽象方法指定DispatcherServlet的配置信息。</p><h3 id="Servlet3-0与SpringMVC的整合"><a href="#Servlet3-0与SpringMVC的整合" class="headerlink" title="Servlet3.0与SpringMVC的整合"></a>Servlet3.0与SpringMVC的整合</h3><p>1) 在src下的main下面的java里面写我们的源代码：</p><p>如果还不知道怎么配置，看我的<strong>idea创建maven-web</strong>的博客，最后有说明。</p><p>创建com.liuzhuo包，并在该包下面，创建MyWebAppInitializer类，继承AbstractAnnotationConfigDispatcherServletInitializer：</p><pre><code>//Web容器启动的时候创建对象；调用方法来初始化容器以前的前端控制器public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {    //获取根容器的配置类；（Spring的配置文件）父容器。    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() {        return new Class[]{RootConfig.class};    }    //获取Web容器的配置类（SpringMVC配置文件）子容器    @Override    protected Class&lt;?&gt;[] getServletConfigClasses() {        return new Class[]{AppConfig.class};    }    //获取DispatchServlet的映射信息    // /:拦截所有请求（包括静态资源（XX.js,XX.png））,但是不包括*.jsp    // /*:拦截所有请求；连*.jsp页面都拦截；jsp页面需要Tomcat的jsp引擎解析的。    @Override    protected String[] getServletMappings() {        return new String[]{&quot;/&quot;};    }}</code></pre><p>2) 在com.liuzhuo.config包下，创建RootConfig、AppConfig类：</p><pre><code>@ComponentScan(value = &quot;com.liuzhuo&quot;, excludeFilters = {        @ComponentScan.Filter(type = FilterType.ANNOTATION, value = {Controller.class})})//Spring的根容器（父容器）,扫描排除含有Controller注解的bean对象public class RootConfig {}</code></pre><pre><code>@ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = {        @ComponentScan.Filter(type = FilterType.ANNOTATION, value = {Controller.class})}, useDefaultFilters = false)//SpringMVC的子容器，只扫描含有Controller注解的Bean对象//禁用默认的规则(扫描所有)：useDefaultFilters = falsepublic class AppConfig {}</code></pre><p>这样配置，是根据Spring的官方给的建议：<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0_SpringMVC/QQ%E6%88%AA%E5%9B%BE20181030134334.png" style="width:50%"></p><p>父容器:   配置@service、@repository，数据连接池，事务管理等。<br>子容器：配置@Controller层，视图解析器，映射配置。</p><p>3）在com.liuzhuo.service包下，创建HelloService：</p><pre><code>@Servicepublic class HelloService {    public String sayHello(String name) {        return &quot;Hello:&quot; + name;    }}</code></pre><p>4) 在com.liuzhuo.controller包下，创建HelloController：</p><pre><code>@Controllerpublic class HelloController {    @Autowired    private HelloService helloService;    @ResponseBody    @RequestMapping(&quot;/hello&quot;)    public String hello() {        String hello = helloService.sayHello(&quot;tomcat·····&quot;);        return hello;    }}</code></pre><p>整体的项目结构：<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0_SpringMVC/QQ%E6%88%AA%E5%9B%BE20181030134808.png" style="width:50%"></p><p>5) 启动项目，运行</p><p>浏览器输入：<br><code>http://localhost:8080/hello</code><br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0_SpringMVC/QQ%E6%88%AA%E5%9B%BE20181030134940.png"></p><p>到现在为止，Servlet3.0与SpringMVC整合完成。</p><h3 id="定性配置SpringMVC"><a href="#定性配置SpringMVC" class="headerlink" title="定性配置SpringMVC"></a>定性配置SpringMVC</h3><p>打开官网，查看 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config" target="_blank" rel="noopener">MVC Config</a>章节。</p><p>开启MVC的高级功能，需要@EnableWebMvc注解。</p><p>比如：</p><pre><code>@Configuration@EnableWebMvcpublic class WebConfig {}</code></pre><p>相等于xml文件：<code>&lt;mvc:annotation-driven/&gt;</code></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;mvc:annotation-driven/&gt;&lt;/beans&gt;</code></pre><p>只有开启了@EnableWebMvc或者<code>&lt;mvc:annotation-driven/&gt;</code>才能定制SpringMVC的其他信息。</p><p>在官网中，我们使用配置实现 WebMvcConfigurer 接口，然后实现其中的所有方法来定制其他组件(视图解析器、拦截器、过滤器等)。</p><pre><code>@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer {    // Implement configuration methods...}</code></pre><p>但是，这样，我们就必须实现其中的所有方法了，为了方便，我们可以继承：WebMvcConfigurerAdapter 适配器，其中所有的方法帮我们实现了，只是返回空方法。然后我们通过重写自己想要定制的方法来完成自身的需求。</p><h4 id="定制视图解析器"><a href="#定制视图解析器" class="headerlink" title="定制视图解析器"></a>定制视图解析器</h4><p>1）改写我们的AppConfig配置类：</p><p>添加@EnableWebMvc、并且继承WebMvcConfigurerAdapter抽象类</p><pre><code>@ComponentScan(value = &quot;com.liuzhuo&quot;, includeFilters = {        @ComponentScan.Filter(type = FilterType.ANNOTATION, value = {Controller.class})}, useDefaultFilters = false)//SpringMVC的子容器，只扫描含有Controller注解的Bean对象//禁用默认的规则(扫描所有)：useDefaultFilters = false@EnableWebMvcpublic class AppConfig extends WebMvcConfigurerAdapter {}</code></pre><p>2）添加自定义的视图解析器</p><p>都是在AppConfig类中，直接重写方法</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//配置视图解析器</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configureViewResolvers</span><span class="token punctuation">(</span>ViewResolverRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//定制jsp的视图解析器</span>        <span class="token comment" spellcheck="true">//参数一：视图的前缀路径</span>        <span class="token comment" spellcheck="true">//参数二：视图的后缀名</span>        registry<span class="token punctuation">.</span><span class="token function">jsp</span><span class="token punctuation">(</span><span class="token string">"WEB-INF/views/"</span><span class="token punctuation">,</span> <span class="token string">".jsp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>3）在HelloController中</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/suc"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">sucess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"sucess"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>4) 在WEB-INF/views下，添加一个sucess.jsp的文件</p><pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;sucess!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>5) 运行项目</p><p>在浏览器中输入：<code>http://localhost:8080/suc</code><br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0_SpringMVC/QQ%E6%88%AA%E5%9B%BE20181030150751.png"></p><p>成功定制了jsp的视图解析器了。</p><hr><h4 id="定制静态资源"><a href="#定制静态资源" class="headerlink" title="定制静态资源"></a>定制静态资源</h4><p>没有配置之前：</p><p>1）在webapp根目录下：</p><p>放入一张图片，随便一张就行。<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0_SpringMVC/QQ%E6%88%AA%E5%9B%BE20181030151708.png" style="width:50%"></p><p>2）在index.jsp中，添加img标签<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0_SpringMVC/QQ%E6%88%AA%E5%9B%BE20181030151855.png" style="width:50%"></p><p>3) 启动项目</p><p>浏览器中输入：<code>http://localhost:8080</code><br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0_SpringMVC/QQ%E6%88%AA%E5%9B%BE20181030152023.png" style="width:50%"></p><p>发现，我们的照片出不来，这是为啥呢？这是因为，我们的静态资源也会被DispatchServlet拦截。</p><p>在控制台中能发现：</p><pre><code>30-Oct-2018 15:20:00.904 警告 [http-nio-8080-exec-4] org.springframework.web.servlet.PageNotFound.noHandlerFound No mapping found for HTTP request with URI [/gakki.jpg] in DispatcherServlet with name &#39;dispatcher&#39;</code></pre><p><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0_SpringMVC/QQ%E6%88%AA%E5%9B%BE20181030152314.png"></p><p>发现 /gakki.jpg 也被DispatchServlet拦截了。</p><p>现在，我们需要不让DispatchServlet拦截我们的静态资源，使用Tomcat容器来加载静态资源。</p><p>4）在AppConfig下：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//静态资源访问</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configureDefaultServletHandling</span><span class="token punctuation">(</span>DefaultServletHandlerConfigurer configurer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//默认是匹配路径：/**</span>        configurer<span class="token punctuation">.</span><span class="token function">enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>相等于xml中的：<code>&lt;mvc:default-servlet-handler/&gt;</code></p><p>5) 启动项目<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0_SpringMVC/QQ%E6%88%AA%E5%9B%BE20181030153052.png"></p><hr><h4 id="定制拦截器"><a href="#定制拦截器" class="headerlink" title="定制拦截器"></a>定制拦截器</h4><p>1）在com.liuzhuo.interceptors在，创建MyInterceptor，实现HandlerInterceptor接口</p><pre><code>//自定义的拦截器public class MyInterceptor implements HandlerInterceptor {    //拦截之前调用    @Override    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {        //放行        System.out.println(&quot;preHandle·······&quot;);        return true;    }    //处理之后调用    @Override    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {        System.out.println(&quot;postHandle·······&quot;);    }    //成功处理后调用    @Override    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {        System.out.println(&quot;afterCompletion·······&quot;);    }}</code></pre><p>2）在AppConfig类下：</p><pre><code>    //添加拦截器    @Override    public void addInterceptors(InterceptorRegistry registry) {        registry.addInterceptor(new MyInterceptor()).addPathPatterns(&quot;/**&quot;);    }</code></pre><p>3) 启动项目</p><p>在浏览器中输入：<code>http://localhost:8080/suc</code><br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0_SpringMVC/QQ%E6%88%AA%E5%9B%BE20181030155103.png"></p><p>拦截成功。</p><p>如果还想定制其他功能，请查看<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config" target="_blank" rel="noopener">Spring的官方文档</a>。<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0_SpringMVC/QQ%E6%88%AA%E5%9B%BE20181030155351.png"></p>]]></content>
      
      
      <categories>
          
          <category> servlet3.0 </category>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet3.0 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea创建maven-web工程</title>
      <link href="/2018/10/29/idea-chuang-jian-maven-web-gong-cheng/"/>
      <url>/2018/10/29/idea-chuang-jian-maven-web-gong-cheng/</url>
      
        <content type="html"><![CDATA[<p>前不久有学弟问我使用maven来创建web项目，不要创建原始的Dynamic Web项目了，那好吧，我们今天就来使用idea来创建maven的web项目吧。</p><h3 id="首先先创建一个project-一个project就是一个工作空间-，在这里就是创建一个maven的工作空间"><a href="#首先先创建一个project-一个project就是一个工作空间-，在这里就是创建一个maven的工作空间" class="headerlink" title="首先先创建一个project(一个project就是一个工作空间)，在这里就是创建一个maven的工作空间"></a>首先先创建一个project(一个project就是一个工作空间)，在这里就是创建一个maven的工作空间</h3><p><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029170715.png" style="width:50%"></p><h3 id="你要选择maven然后按照下面图片-的指示操作就可以了—-gt-最后点击next按钮"><a href="#你要选择maven然后按照下面图片-的指示操作就可以了—-gt-最后点击next按钮" class="headerlink" title="你要选择maven然后按照下面图片 的指示操作就可以了—&gt;最后点击next按钮"></a>你要选择maven然后按照下面图片 的指示操作就可以了—&gt;最后点击next按钮</h3><p><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029171222.png"></p><h3 id="填写，groupID、ArtifactID"><a href="#填写，groupID、ArtifactID" class="headerlink" title="填写，groupID、ArtifactID"></a>填写，groupID、ArtifactID</h3><p><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029171531.png"></p><h3 id="配置maven的本地仓库的位置"><a href="#配置maven的本地仓库的位置" class="headerlink" title="配置maven的本地仓库的位置"></a>配置maven的本地仓库的位置</h3><p>是通过修改本机中的maven中的settings.xml配置文件来实现的，需要你加上阿里巴巴的仓库，这样你的下载速度就会加快，如果你不采用阿里巴巴的仓库，你在下载你需要的jar包的时，是通过FQ去下载，你的速度就会变慢，尤其是某些包！！！！<br><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029172013.png"></p><h3 id="填写项目名"><a href="#填写项目名" class="headerlink" title="填写项目名"></a>填写项目名</h3><p>一般不用改了，直接finish<br><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029172634.png"></p><h3 id="喝杯咖啡，泡杯茶稍安勿躁，等一等。maven正在下载架构"><a href="#喝杯咖啡，泡杯茶稍安勿躁，等一等。maven正在下载架构" class="headerlink" title="喝杯咖啡，泡杯茶稍安勿躁，等一等。maven正在下载架构"></a>喝杯咖啡，泡杯茶稍安勿躁，等一等。maven正在下载架构</h3><p><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029172839.png"></p><h3 id="等出结果，如果目录结构还不出来直接按图操作一波"><a href="#等出结果，如果目录结构还不出来直接按图操作一波" class="headerlink" title="等出结果，如果目录结构还不出来直接按图操作一波"></a>等出结果，如果目录结构还不出来直接按图操作一波</h3><p><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029172941.png"></p><h3 id="项目的基本目录结构出来后我们最后还需要为项目配置下编译路径。"><a href="#项目的基本目录结构出来后我们最后还需要为项目配置下编译路径。" class="headerlink" title="项目的基本目录结构出来后我们最后还需要为项目配置下编译路径。"></a>项目的基本目录结构出来后我们最后还需要为项目配置下编译路径。</h3><p><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029173041.png" style="width:50%"></p><p>点击Modules，如果你的是空的的话，就需要配置了，如果存在就不需要配置了，<strong>idea201703版本后</strong>，会自动帮我们配置的。<br><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029173524.png" style="width:50%"><br><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029173829.png"></p><p>如果你的idea的自动帮你配置了，你只需要检查那两个路径对不对即可，一般都是对的。</p><h3 id="为项目配置下Artifacts"><a href="#为项目配置下Artifacts" class="headerlink" title="为项目配置下Artifacts"></a>为项目配置下Artifacts</h3><p>和Modules一样，如果已经存在了，就不要配置了。如果没有的话<br><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029174352.png" style="width:50%"></p><p>选择我们的项目<br><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029174451.png"></p><h3 id="配置Tomcat容器"><a href="#配置Tomcat容器" class="headerlink" title="配置Tomcat容器"></a>配置Tomcat容器</h3><p><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029174611.png"></p><p>出现这个画面，然后按图再操作一波<br><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029174659.png" style="width:50%"></p><p>接着出现这个画面，继续看图操作<br><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029175057.png"></p><p>然后你选择右边第二个选项，Deployment，还是看图操作。。。<br><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029175151.png"><br><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029175319.png"></p><p>最后点击ok完成Tomcat配置，现在就可以启动tomcat跑跑我们的helloWorld了！</p><h3 id="启动tomcat，看效果"><a href="#启动tomcat，看效果" class="headerlink" title="启动tomcat，看效果"></a>启动tomcat，看效果</h3><p><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029175623.png"><br><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181029175655.png"></p><h3 id="配置src-main-java"><a href="#配置src-main-java" class="headerlink" title="配置src/main/java"></a>配置src/main/java</h3><p>如上图，src/main目录下缺少java目录，我们可以右键创建目录java，然后在modules中配置为Sources目录</p><p><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181030112516.png"></p><p>这样src/main/java图标就变成了蓝色，作为java源代码区了。</p><h3 id="配置src-main-resources"><a href="#配置src-main-resources" class="headerlink" title="配置src/main/resources"></a>配置src/main/resources</h3><p>如上图，src/main目录下缺少resources目录，我们可以右键创建目录resources，然后再modules中配置为Resources目录<br><img src="https://gakkil.gitee.io/gakkil-image/idea/maven/QQ%E6%88%AA%E5%9B%BE20181030112807.png"></p><p>这样src/main/resources图标就变成了右下角有黄标了，作为resources资源区了。</p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
          <category> maven </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> idea </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet3.0</title>
      <link href="/2018/10/28/servlet3-0/"/>
      <url>/2018/10/28/servlet3-0/</url>
      
        <content type="html"><![CDATA[<p>以前，不管是编写servlet、filter 和 Listener等等，还是编写SpringMVC的前端控制器，都是在web.xml中编写的。Servlet3.0版本之后，只需要使用<strong>注解</strong>就可以完成组件的注入，<font color="red">还有运行时的组件式插拔开发。</font></p><p><strong>注意：</strong> servlet3.0的容器Tomcat 必须是<strong>7.0.x以上版本</strong>才能使用servlet3.0。</p><h3 id="创建dynamic-Web项目"><a href="#创建dynamic-Web项目" class="headerlink" title="创建dynamic Web项目"></a>创建dynamic Web项目</h3><p>我这里使用的是idea，大家也可以使用eclipse开发。大家估计都对eclipse开发熟悉，如果对idea创建动态web项目不熟悉的话，可以看我另一篇博客<a href="/2018/10/28/idea-chuang-jian-dong-tai-web-xiang-mu/">idea 创建动态Web项目</a>。</p><p>创建好工程后如下：<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0/QQ%E6%88%AA%E5%9B%BE20181029114758.png" style="width:50%"></p><h4 id="使用web-xml的方式"><a href="#使用web-xml的方式" class="headerlink" title="使用web.xml的方式"></a>使用web.xml的方式</h4><p>1）在src下创建com.liuzhuo.servlet包，并创建 HelloServlet（继承 HttpServlet）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">doPost</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"hello world servlet3.0 ~~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2) 在WBE-INF下的index.jsp中：</p><p>添加：<code>&lt;a href=&quot;hello&quot;&gt;hello&lt;/a&gt;</code></p><pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;servlet3.0&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;hello&quot;&gt;hello&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>3) 在web.xml中配置servlet的映射关系</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;         version=&quot;3.1&quot;&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;        &lt;servlet-class&gt;com.liuzhuo.servlet.HelloServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>4) 运行web应用<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0/QQ%E6%88%AA%E5%9B%BE20181029124916.png"></p><p>点击hello的超链接<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0/QQ%E6%88%AA%E5%9B%BE20181029124951.png"></p><p>以上就是servlet3.0之前的版本开发web工程的演示。</p><hr><h4 id="不使用web-xml-servlet3-0"><a href="#不使用web-xml-servlet3-0" class="headerlink" title="不使用web.xml(servlet3.0)"></a>不使用web.xml(servlet3.0)</h4><p>1) 去掉web.xml中的servlet的配置：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;         version=&quot;3.1&quot;&gt;&lt;/web-app&gt;</code></pre><p>2) 此时再运行web项目，点击hello超链接<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0/QQ%E6%88%AA%E5%9B%BE20181029125311.png"></p><p>3）使用@WebServlet注解</p><p>在HelloServlet类上面写上@WebServlet注解<br>name : 就是servlet的名字<br>value：就是映射的路径</p><p>@WebServlet上的name  &lt;==&gt; <code>&lt;servlet-name&gt;hello&lt;/servlet-name&gt;</code><br>@WebServlet上的value &lt;==&gt; <code>&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token string">"/hello"</span> <span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">doPost</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"hello world servlet3.0 ~~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>4) 重新启动web项目</p><p>会发现，项目启动正常了。</p><p><strong>ps：在idea中，有一个web的窗口，在编辑器的左下角，点开，会看见当前web项目的映射信息，很方便排错。</strong><br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0/QQ%E6%88%AA%E5%9B%BE20181029130641.png" style="width:50%"></p><p>其他注解：</p><p>@WebFilter   ：注解过滤器<br>@WebListener ：注解监听器<br>@WebInitParam：注解初始化的参数</p><p>具体的使用情况：看官方文档即可。</p><hr><h3 id="servlet3-0的共享库和运行时插件"><a href="#servlet3-0的共享库和运行时插件" class="headerlink" title="servlet3.0的共享库和运行时插件"></a>servlet3.0的共享库和运行时插件</h3><p>Shared libraries / runtimes pluggability</p><p>1）在Servlet容器启动的时候，会扫描当前应用里面的每一个jar包的<code>ServletContainerInitializer</code>的实现类</p><p>2）提供ServletContainerInitializer的实现类</p><p>必须绑定在：<code>META-INF/services/javax.servlet.ServletContainerInitializer</code>文件中。<br><strong>文件名就是 javax.servlet.ServletContainerInitializer 没有后缀。</strong></p><p>文件中的内容就是：ServletContainerInitializer实现类的<strong>全类名</strong>。</p><p>总结：容器在启动的时候，会扫描当前应用中每一个jar包里面的：META-INF/services/javax.servlet.ServletContainerInitializer文件中ServletContainerInitializer实现类，启动并运行这个实现类中的方法和传入感兴趣的类型。</p><p>3）测试</p><p>3.1) 这里就不创建jar包了，直接在src下创建META-INF/services目录，然后在该目录下，创建javax.servlet.ServletContainerInitializer文件。<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0/QQ%E6%88%AA%E5%9B%BE20181029135845.png" style="width:50%"></p><p><strong>注意：目录和文件名称不要打错！！！</strong></p><p>3.2）在src下的com.liuzhuo.servlet下创建MyServletContainerInitializer，并实现ServletContainerInitializer接口。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@HandlesTypes</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span>HelloService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyServletContainerInitializer</span> <span class="token keyword">implements</span> <span class="token class-name">ServletContainerInitializer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * @param set：感兴趣的类型的所有子类型.@HandlesTypes注解中的value即为感兴趣的类型。     * @param servletContext :代表当前Web应用的ServletContext,一个Web应用一个上下文     * @throws ServletException     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStartup</span><span class="token punctuation">(</span>Set<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> set<span class="token punctuation">,</span> ServletContext servletContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"感兴趣的类型："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> aClass <span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3.3) 在src下的com.liuzhuo.service下创建<br>HelloService：接口<br>HelloServiceExt：实现了HelloService的子接口<br>AbstractHelloService：实现了HelloService的抽象类<br>HelloServiceImpl：HelloService的实现类<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0/QQ%E6%88%AA%E5%9B%BE20181029140510.png" style="width:50%"></p><p>3.4）将MyServletContainerInitializer的全类名添加到：javax.servlet.ServletContainerInitializer文件中<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0/QQ%E6%88%AA%E5%9B%BE20181029140722.png"></p><p>3.5）运行web项目<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0/QQ%E6%88%AA%E5%9B%BE20181029140828.png"></p><p>能看到，输出感兴趣的类型：</p><pre><code>class com.liuzhuo.service.HelloServiceImplinterface com.liuzhuo.service.HelloServiceExtclass com.liuzhuo.service.AbstractHelloService</code></pre><p><strong>注意感兴趣的类型：不包括本身（HelloService接口）！！！</strong></p><hr><h3 id="使用ServletContainerInitializer给容器添加组件"><a href="#使用ServletContainerInitializer给容器添加组件" class="headerlink" title="使用ServletContainerInitializer给容器添加组件"></a>使用ServletContainerInitializer给容器添加组件</h3><p>根据上文，我们已经了解到了，我们使用@WebServlet注解，给容器添加我们自己写的Servlet类，但是无法添加第三方的组件。只能使用Web.xml文件来添加。</p><p>现在，我们了解了Servlet3.0的共享库和运行时机制，可以使用ServletContainerInitializer的机制来注册Web组件(Servlet、Filter、Listener)，不必使用Web.xml配置文件。</p><p>接着现有的项目继续开发。</p><p>1）在com.liuzhuo.servlet下创建UserServlet、UserFilter、UserListener三大组件<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0/QQ%E6%88%AA%E5%9B%BE20181029143900.png" style="width:50%"></p><p>UserServlet:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"UserServlet ·····"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>UserFilter:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span>ServletRequest req<span class="token punctuation">,</span> ServletResponse resp<span class="token punctuation">,</span> FilterChain chain<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//执行过滤的方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"UserFilter ~~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//放行</span>        chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> resp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>FilterConfig config<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>UserListener:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserListener</span> <span class="token keyword">implements</span> <span class="token class-name">ServletContextListener</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//容器初始化的时候</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextInitialized</span><span class="token punctuation">(</span>ServletContextEvent servletContextEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取ServletContext容器的上下文，这里也可以注册Servlet、Fliter、Listener组件</span>        ServletContext servletContext <span class="token operator">=</span> servletContextEvent<span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"UserListener监听ServletContextListener的初始化"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//容器销毁的时候</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextDestroyed</span><span class="token punctuation">(</span>ServletContextEvent servletContextEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"UserListener监听ServletContextListener的销毁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2) 在MyServletContainerInitializer中的onStartup方法中使用ServletContext注册三大组件：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@HandlesTypes</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span>HelloService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyServletContainerInitializer</span> <span class="token keyword">implements</span> <span class="token class-name">ServletContainerInitializer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * @param set：感兴趣的类型的所有子类型.@HandlesTypes注解中的value即为感兴趣的类型。     * @param servletContext :代表当前Web应用的ServletContext：一个Web应用一个上下文     * @throws ServletException     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStartup</span><span class="token punctuation">(</span>Set<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> set<span class="token punctuation">,</span> ServletContext servletContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"感兴趣的类型："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> aClass <span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//添加userServelt组件。</span>        ServletRegistration<span class="token punctuation">.</span>Dynamic userServelt <span class="token operator">=</span> servletContext<span class="token punctuation">.</span><span class="token function">addServlet</span><span class="token punctuation">(</span><span class="token string">"userServelt"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">UserServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//添加Servlet的映射路径</span>        userServelt<span class="token punctuation">.</span><span class="token function">addMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//添加监听器</span>        servletContext<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span>UserListener<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//添加过滤器</span>        FilterRegistration<span class="token punctuation">.</span>Dynamic userFilter <span class="token operator">=</span> servletContext<span class="token punctuation">.</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token string">"userFilter"</span><span class="token punctuation">,</span> UserFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//添加拦截规则</span>        <span class="token comment" spellcheck="true">//EnumSet&lt;DispatcherType> var1 :拦截的请求类型</span>        <span class="token comment" spellcheck="true">// boolean var2                ：true</span>        <span class="token comment" spellcheck="true">// String... var3              ：拦截的路径</span>        userFilter<span class="token punctuation">.</span><span class="token function">addMappingForUrlPatterns</span><span class="token punctuation">(</span>EnumSet<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>DispatcherType<span class="token punctuation">.</span>REQUEST<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">"/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3) 运行Web项目<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0/QQ%E6%88%AA%E5%9B%BE20181029150012.png"></p><p>说明userListener监听器注册成功。</p><p>在浏览器中输入：<code>http://localhost:8080/user</code><br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0/QQ%E6%88%AA%E5%9B%BE20181029150247.png"><br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0/QQ%E6%88%AA%E5%9B%BE20181029150400.png"></p><p>说明UserServlet和userFliter注册也成功了。</p><p>停止Web项目：<br><img src="https://gakkil.gitee.io/gakkil-image/servlet3.0/QQ%E6%88%AA%E5%9B%BE20181029150554.png"></p><p>以上，就是不使用Web.xml的注册Servlet、Filter、Listener三大组件的过程，使用硬编码的形式。</p><p><strong>注意：servlet3.0动态注册，只能在webapp启动时进行注册,可能是为了安全考虑吧.不能在运行时完成对servlet的注册和销毁</strong></p><p>在初始化情况下的注册Servlet组件有除了上面的方式，还有另外一种方式：<br>就是在实现<code>ServletContextListener接口</code> , 在<code>contextInitialized</code>方法中完成注册.</p><p>就是在上述UserListener中contextInitialized方法中获取：<br> ServletContext servletContext = servletContextEvent.getServletContext();<br>然后进行三大组件的注册。</p>]]></content>
      
      
      <categories>
          
          <category> servlet3.0 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet3.0 </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea 创建动态Web项目</title>
      <link href="/2018/10/28/idea-chuang-jian-dong-tai-web-xiang-mu/"/>
      <url>/2018/10/28/idea-chuang-jian-dong-tai-web-xiang-mu/</url>
      
        <content type="html"><![CDATA[<p>intellij idea这个开发工具功能强大，但是大部分人都习惯eclipse 开发，所以对这个工具还不是太了解。今天就使用idea来创建动态web项目。</p><h3 id="idea-创建动态Web项目"><a href="#idea-创建动态Web项目" class="headerlink" title="idea 创建动态Web项目"></a>idea 创建动态Web项目</h3><p>打开idea</p><p>我使用的是2017版本的。</p><p>(1)点击左上角的File–&gt; new –&gt; Project<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028182054.png"></p><p>(2)之后会弹出一个选择框，选择Java Enterprise ，网上有的会说选择第一个java 当然也是可行的 ，两者之间有一点点细微的差别啦，当然别忘记<strong>勾选Web Application</strong>,点击Next。<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028191302.png"></p><p>(3)填好项目名称，和项目路径，Finish。<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028191740.png"></p><p>(4)完成后，需要添加web.xml文件。在<strong>idea201703版本之前</strong>。在第二步的选择Web Application时，可以选择版本号，并创建web.xml文件。但是之后的版本没有。我们可以手工创建，但是麻烦，教大家另外的创建方法。</p><p>打开 Project Structure（Ctrl+Alt+Shift+S），在 facets 里<strong>选中次级的 web 或者 在Modules 中选中web</strong>，在deployment Descriptors面板里，点击 +号选择web.xml以及版本号。然后在弹出的对话框中修改xml默认的目录，加上web就可以了。<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028194446.png" style="width:50%"><br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028194836.png"><br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028195525.png" style="width:50%"></p><p>这样就把 WEB-INF web.xml 添加上了 。<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028195719.png" style="width:50%"></p><p>.idea文件夹和webapp.iml是IDEA自动创建的，包含了工程和模块的配置数据<br>src文件夹是源码目录<br>web文件夹相当于eclipse创建的web工程WebContent文件夹，包含了WEB-INF/web.xml及index.jsp<br>External Libraries包含了JDK及Tomcat带的jsp-api、servlet-api jar文件</p><p>(4)完善工程目录，点击WEF-INF  ,右键，NEW–&gt;Directory  创建两个文件夹，<code>classes</code> 和 <code>lib</code>  <strong>这两个名字不要改哦！</strong></p><p>4.1 创建classes文件夹<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028200211.png"><br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028200344.png" style="width:50%"></p><p>4.2 同理，创建lib文件夹<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028200618.png" style="width:50%"></p><p>(5) 完成后再点击File , 选择Project Structure  </p><p>点击Modules , 选择Paths , 选中 Use module compile output path , 将Outputpath 和 Test output path 都设置为刚刚创建的classes文件夹。<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028201015.png"></p><p><strong>点击apply就行，接着第六步。</strong></p><p>(6) 点击path旁边的<code>Dependencies</code>, 点击”+”号，选择: 1 JARs or directories<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028201526.png"></p><p>选择刚刚创建的lib。<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028201634.png"></p><p>选择第三个，jar Directory。一路ok到底！<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028201803.png" style="width:50%"></p><p>(7) 配置servlet容器：Tomcat<br>点击右上角的tomcat的向下的小三角，然后点击Edit Configurations<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028202512.png" style="width:30%"></p><p>看tomcat已经有啦，这是java Enterprise的好处啦，点击Deployment。<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028203004.png"><br>1，设置On frame deactivation : Update classes and resources<br>2，设置自己的jre位置路径。（jdk对应的jre）</p><p>Application context可以填也可以不填，配置后，访问网站就必须加上这个路径了。<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028203156.png"><br>点击ok。</p><p>(8) 点击index.jsp，随便写一段话，比如helloworld。<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028203422.png"></p><p>(9) 运行程序，就点击右上角的绿色图标<br><img src="https://gakkil.gitee.io/gakkil-image/idea/web/QQ%E6%88%AA%E5%9B%BE20181028203713.png"></p><h3 id="WEB-INF目录与META-INF目录的作用"><a href="#WEB-INF目录与META-INF目录的作用" class="headerlink" title="WEB-INF目录与META-INF目录的作用"></a>WEB-INF目录与META-INF目录的作用</h3><p>1) /WEB-INF/web.xml</p><p>Web应用程序配置文件，描述了 servlet 和 其他的应用组件配置及命名规则。</p><p>2) /WEB-INF/classes/</p><p>包含了站点所有的 class 文件，包括 servlet.class 和 非servlet.class，他们不能包含在 .jar文件中。</p><p>3) /WEB-INF/lib/</p><p>存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件。</p><p>4) /WEB-INF/src/</p><p>源码目录，按照包名结构放置各个Java文件。</p><p>5) /WEB-INF/database.properties</p><p>数据库配置文件</p><p>6) /WEB-INF/tags/</p><p>存放了自定义标签文件，该目录并不一定为 tags，可以根据自己的喜好和习惯为自己的标签文件库命名，当使用自定义的标签文件库名称时，在使用标签文件时就必须声明正确的标签文件库路径。例如：当自定义标签文件库名称为 simpleTags 时，在使用 simpleTags 目录下的标签文件时，就必须在 jsp 文件头声明为：&lt;%@ taglibprefix=”tags” tagdir=”/WEB-INF/simpleTags” % &gt;。</p><p>7) /WEB-INF/jsp/</p><p>jsp 1.2 以下版本的文件存放位置。改目录没有特定的声明，同样，可以根据自己的喜好与习惯来命名。此目录主要存放的是 jsp 1.2 以下版本的文件，为区分 jsp 2.0 文件，通常使用 jsp 命名，当然你也可以命名为 jspOldEdition 。</p><p>8) /WEB-INF/jsp2/</p><p>与 jsp 文件目录相比，该目录下主要存放 Jsp 2.0 以下版本的文件，当然，它也是可以任意命名的，同样为区别 Jsp 1.2以下版本的文件目录，通常才命名为 jsp2。</p><p>9) META-INF</p><p>相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务manifest.mf文件，在用jar打包时自动生成。</p><h3 id="META-INF有什么用？它跟WEB-INF有什么区别？"><a href="#META-INF有什么用？它跟WEB-INF有什么区别？" class="headerlink" title="META-INF有什么用？它跟WEB-INF有什么区别？"></a>META-INF有什么用？它跟WEB-INF有什么区别？</h3><p>WEB-INF是在使用web 项目才会有这个文件夹,普通的j2se项目是没有这个文件夹的。</p><p>META-INF 存放程序入口相关信息, 每个jar 都会有这个文件夹,里面的 MANIFEST文件 记录下面这些信息。我们把MANIFEST中的配置信息进行分类，可以归纳出下面几个大类：</p><pre><code>一. 一般属性　　1. Manifest-Version　　用来定义manifest文件的版本，例如：Manifest-Version: 1.0　　2. Created-By　　    声明该文件的生成者，一般该属性是由jar命令行工具生成的，例如：Created-By: Apache Ant 1.5.1　　3. Signature-Version　　定义jar文件的签名版本　　4. Class-Path　　应用程序或者类装载器使用该值来构建内部的类搜索路径　　二. 应用程序相关属性　　1. Main-Class　　定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件。　　三. 小程序(Applet)相关属性　　1. Extendsion-List　　该属性指定了小程序需要的扩展信息列表，列表中的每个名字对应以下的属性　　2. &lt;extension&gt;-Extension-Name　　3. &lt;extension&gt;-Specification-Version　　4. &lt;extension&gt;-Implementation-Version　　5. &lt;extension&gt;-Implementation-Vendor-Id　　6. &lt;extension&gt;-Implementation-URL　　四. 扩展标识属性　　1. Extension-Name　　该属性定义了jar文件的标识，例如Extension-Name: Struts Framework　　五. 包扩展属性　　1. Implementation-Title 定义了扩展实现的标题　　2. Implementation-Version 定义扩展实现的版本　　3. Implementation-Vendor 定义扩展实现的组织 　　4. Implementation-Vendor-Id 定义扩展实现的组织的标识　　5. Implementation-URL : 定义该扩展包的下载地址(URL)　　6. Specification-Title 定义扩展规范的标题　　7. Specification-Version 定义扩展规范的版本　　8. Specification-Vendor 声明了维护该规范的组织　　9. Sealed 定义jar文件是否封存，值可以是true或者false (这点我还不是很理解)　　六. 签名相关属性　　签名方面的属性我们可以来参照JavaMail所提供的mail.jar中的一段　　Name: javax/mail/Address.class　　Digest-Algorithms: SHA MD5 　　SHA-Digest: AjR7RqnN//cdYGouxbd06mSVfI4=　　MD5-Digest: ZnTIQ2aQAtSNIOWXI1pQpw==　　这段内容定义类签名的类名、计算摘要的算法名以及对应的摘要内容(使用BASE64方法进行编码)</code></pre><h3 id="为什么需要把页面放在WEB-INF文件夹下面？"><a href="#为什么需要把页面放在WEB-INF文件夹下面？" class="headerlink" title="为什么需要把页面放在WEB-INF文件夹下面？"></a>为什么需要把页面放在WEB-INF文件夹下面？</h3><ol><li>基于不同的功能 JSP 被放置在不同的目录下</li></ol><p>这种方法的问题是这些页面文件容易被偷看到源代码，或被直接调用。某些场合下这可能不是个大问题，可是在特定情形中却可能构成安全隐患。用户可以绕过Struts的controller直接调用JSP同样也是个问题。</p><p>为了减少风险，可以把这些页面文件移到WEB-INF 目录下。基于Servlet的声明，WEB-INF不作为Web应用的公共文档树的一部分。因此，WEB-INF 目录下的资源不是为客户直接服务的。我们仍然可以使用WEB-INF目录下的JSP页面来提供视图给客户，客户却不能直接请求访问JSP。</p><ol start="2"><li>JSP存放在 WEB-INF 目录下更为安全</li></ol><p>如果把这些JSP页面文件移到WEB-INF 目录下，在调用页面的时候就必须把”WEB-INF”添加到URL中。</p><p>我们知道，实现页面的跳转有两种方式，一种是通过redirect的方式，一种是通过forward的方式。redirect方式的跳转，系统会在一个新的页面打开要跳转的网页；而forward方式跳转，系统会在原来的页面上打开一个要跳转的网页。所以放到WEB-INF目录下的文件是不允许采用redirect方式的跳转来访问的.</p><p>WEB-INF文件夹是受保护的文件夹，外部无法访问这个文件夹内的文件，只有服务器内部才能访问。</p><p>重要的服务器初始化核心文件web.xml就这在个文件夹内。</p><p>为了达到服务器端访问的目的，我们可以使用action进行转向，我们先去请求一个action，然后由这个action转发到WEB-INF下的页面，这样客户端就可以访问了。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git初级入门</title>
      <link href="/2018/10/25/git-chu-ji-ru-men/"/>
      <url>/2018/10/25/git-chu-ji-ru-men/</url>
      
        <content type="html"><![CDATA[<h3 id="Git的下载"><a href="#Git的下载" class="headerlink" title="Git的下载"></a>Git的下载</h3><p>git的官网：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p>点击右下角的：Downloade xxxx for Windows</p><p>由于是国外的网站，下载速度或许会很慢，请耐心等待~~</p><p>下载完后，直接安装就行。</p><p>安装完成，在桌面会创建Git Bash快捷方式。</p><p><strong>在任意目录下右击鼠标：会看到Git GUI Here 和 Git Bash Here 两个命令</strong></p><h3 id="Git的初步设置"><a href="#Git的初步设置" class="headerlink" title="Git的初步设置"></a>Git的初步设置</h3><ol><li>首先复制git的安装路径，追加到高级环境变量的PATH之后。确定保存退出。</li><li>打开cmd命令窗口（可用win+r,输入cmd确定即可）, 输入<code>git --version</code>命令（version前是两杠),显示版本号：</li></ol><pre><code>C:\Users\liuzhuo&gt;git --versiongit version 2.15.0.windows.1C:\Users\liuzhuo&gt;</code></pre><ol start="3"><li><p>进入Git界面，就是在任意目录下，右键，点击Git Bash Here<br><img src="https://gakkil.gitee.io/gakkil-image/git/20181025091705.png"></p></li><li><p>配置全局的用户名和密码：</p></li></ol><p><code>git config --global user.name</code> 你的用户名 #用户名<br><code>git config --global user.email</code> 你的邮箱 #邮箱 </p><p>这里加了 <code>--global</code>的选项，说明是全局配置，意思是在当前windows下，使用的git都是在这个用户下，也可以给一个项目配置单独的用户名和邮箱。</p><ol start="5"><li>查看配置信息</li></ol><p>使用 <code>git config --list</code></p><pre><code>liuzhuo@Gakki MINGW64 ~/Desktop$ git config --listcore.symlinks=falsecore.autocrlf=truecore.fscache=truecolor.diff=autocolor.status=autocolor.branch=autocolor.interactive=truehelp.format=htmlrebase.autosquash=truehttp.sslcainfo=D:/Git/mingw64/ssl/certs/ca-bundle.crthttp.sslbackend=openssldiff.astextplain.textconv=astextplainfilter.lfs.clean=git-lfs clean -- %ffilter.lfs.smudge=git-lfs smudge -- %ffilter.lfs.process=git-lfs filter-processfilter.lfs.required=truecredential.helper=manageruser.name=liuzhuouser.email=575920824@qq.com</code></pre><p>使用<code>git config --global --list</code>:查看全局配置信息</p><pre><code>liuzhuo@Gakki MINGW64 ~/Desktop$ git config --global --listuser.name=liuzhuouser.email=575920824@qq.com</code></pre><ol start="6"><li>常用的配置命令</li></ol><pre><code>//查git config --global --listgit config --global user.name//增git config  --global --add user.name jianan//删git config  --global --unset user.name//改git config --global user.name zhangsan</code></pre><ol start="7"><li>全局配置文件的地方</li></ol><p><code>~/.gitconfig</code></p><p>例如Windows下，则是</p><p><code>C:\Users\用户名\.gitconfig</code></p><ol start="8"><li>各个仓库的配置</li></ol><p><code>.git/config</code></p><p>例如orange仓库目录下</p><p><code>/home/lanyang/orange/.git/config</code></p><h3 id="Git的GUI界面"><a href="#Git的GUI界面" class="headerlink" title="Git的GUI界面"></a>Git的GUI界面</h3><p>这里，我使用SourceTree</p><p>官网：<a href="https://www.sourcetreeapp.com" target="_blank" rel="noopener">https://www.sourcetreeapp.com</a></p><p>点击：Downloade for Windows</p><h3 id="Git-仓库"><a href="#Git-仓库" class="headerlink" title="Git 仓库"></a>Git 仓库</h3><p>1) 初始化版本库</p><p>git init</p><p>2) 添加文件到版本库</p><p>git add</p><p>git commit</p><p>3) 查看仓库状态</p><p>git status</p><hr><h4 id="使用SourceTree来操作"><a href="#使用SourceTree来操作" class="headerlink" title="使用SourceTree来操作"></a>使用SourceTree来操作</h4><p>首先，使用SourceTree来创建本地仓库：</p><p>1）打开SourceTree<br><img src="https://gakkil.gitee.io/gakkil-image/git/20181025103910.png"></p><p>左上角：</p><p>Local： 代表本地仓库</p><p>Remote：代表远程仓库</p><p>右边：</p><p>Clone：代表克隆其他人的仓库</p><p>Add： 在原有仓库的基础上添加新的仓库</p><p>Create：创建新的仓库</p><p>2）点击Local和Create来创建本地仓库<br><img src="https://gakkil.gitee.io/gakkil-image/git/20181025104307.png"></p><p>第一行：仓库的路径</p><p>第二行：仓库的名字<br><img src="https://gakkil.gitee.io/gakkil-image/git/20181025104441.png"></p><p>这里：选择了E盘下的gitdemo\demo1目录。</p><p>点击创建</p><p>3）在demo1目录下，创建一个新的文件(.txt)，并随便写入几句话。</p><p>demo test······</p><p>4）观察SourceTree界面：<br><img src="https://gakkil.gitee.io/gakkil-image/git/20181025104851.png"></p><p>此时，在未暂存区域出现了我们刚刚创建的文件。</p><p>说明，刚刚创建的文件现在只是在我们的工作目录下，还没有提交到本地仓库中。</p><p><strong>ps：此时，有三个区域，第一个是我们的工作目录，第二个是暂存区域，第三个是本地仓库区域</strong></p><p>我们一般在自己的工作目录下，编写自己的代码，然后提加到暂存区域，最后没有问题后，再提交到本地仓库保存起来。</p><p>5）点击text.txt，然后点击暂存所选<br><img src="https://gakkil.gitee.io/gakkil-image/git/20181025105356.png"></p><p>此时，我们的文件就保存到暂存区域了。</p><p>6）提交到本地仓库中</p><p>在最下面，填写我们的提交信息，然后点击提交。<br><img src="https://gakkil.gitee.io/gakkil-image/git/20181025105612.png"></p><p>7) 提交成功后，查看仓库的状态</p><p>第一次添加都是在主分支下面的，即master分支。</p><p>点击master分支<br><img src="https://gakkil.gitee.io/gakkil-image/git/20181025105822.png"></p><p>我们，就看到了，自己刚刚提交到本地仓库中的记录了。</p><hr><h4 id="使用命令行来操作"><a href="#使用命令行来操作" class="headerlink" title="使用命令行来操作"></a>使用命令行来操作</h4><p>现在，使用命令行界面来操作：</p><p>在一个目录下，右键，点击Git Bush：</p><p>我选择的是：E:\gitdemo<br><img src="https://gakkil.gitee.io/gakkil-image/git/20181025110804.png"></p><p>1) git init demo2</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo$ git init demo2Initialized empty Git repository in E:/gitdemo/demo2/.git/</code></pre><p>2) 进入仓库的目录</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo$ cd demo2liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$</code></pre><p><strong>ps:上面的右边的括号(master)，代表现在是主分支。</strong></p><p>3) 创建新的文件</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ echo &quot;demo2 text~~~~&quot; &gt;&gt; text2.txtliuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$</code></pre><p>此时，在demo2工作目录下，就会出现一个新的文件，text2.txt文件。</p><p>4）查看状态</p><p>git status</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git statusOn branch masterNo commits yetUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        text2.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre><p>说明，当前是在主分支下，新建的text2.txt文件还没有提交。</p><p>5）先添加到暂存区</p><p>git add text2.txt</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git add text2.txtwarning: LF will be replaced by CRLF in text2.txt.The file will have its original line endings in your working directory.liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git statusOn branch masterNo commits yetChanges to be committed:  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)        new file:   text2.txt</code></pre><p>此时，文件已经加入到暂存区域了，最后，需要提交到本地仓库中</p><p>6）提交到本地仓库</p><p>git commit -m “repo2 first commit”</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git commit -m &quot;repo2 first commit&quot;[master (root-commit) 8f22147] repo2 first commit 1 file changed, 1 insertion(+) create mode 100644 text2.txt</code></pre><p>7) 查看本地仓库的状态</p><p>git status</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git statusOn branch masternothing to commit, working tree clean</code></pre><hr><h3 id="Git-工作流"><a href="#Git-工作流" class="headerlink" title="Git 工作流"></a>Git 工作流</h3><p>现在，模拟一下，你上班的情况。第一天上班，创建自己的本地仓库，提交自己的完成的代码需求。</p><h4 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h4><p>1）新建一个本地仓库</p><p>这里，我选择的是 E:\gitdemo\demo3，大家可以根据自己的喜好自由创建。<br><img src="https://gakkil.gitee.io/gakkil-image/git/20181025113245.png"></p><p>2) 添加新的文件</p><p>点击中间的：在文件管理器中打开</p><p>然后，创建demo3.txt文件，并输入：第一天的需要，已经完成</p><p>再回到SourceTree中：</p><p><img src="https://gakkil.gitee.io/gakkil-image/git/20181025113527.png"></p><p>3）add + commit<br><img src="https://gakkil.gitee.io/gakkil-image/git/20181025114112.png"></p><p>4) 提交成功<br><img src="https://gakkil.gitee.io/gakkil-image/git/20181025114212.png"></p><hr><p>现在，快到下班了，产品经理提了一个临时的需求，所以，我们快马加鞭的写完，但是还没有自测，就只将先写的代码，保存到暂存区域中，不提交到本地仓库中。</p><p>1）打开，demo3.txt 文件，先加入一句话：临时需求已做完！<br><img src="https://gakkil.gitee.io/gakkil-image/git/20181025114518.png"></p><p>2) 在SourceTree中，将先修改的demo3文件，保存到暂存区域中：</p><p><img src="https://gakkil.gitee.io/gakkil-image/git/20181025114641.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/git/20181025114717.png"></p><p>此时，拿起我们的背包，下班回家。</p><p>第二天，上班，那个该死的产品经理，说昨天的临时需求不要了，内心一万个曹尼玛~~~</p><p>所以，我们需要将暂存区域的代码和工作区域的代码，回滚到上一个阶段。</p><p>3）点击demo3.text，右键：丢弃<br><img src="https://gakkil.gitee.io/gakkil-image/git/20181025115021.png"></p><p>4) 点击确定丢弃<br><img src="https://gakkil.gitee.io/gakkil-image/git/20181025115425.png"></p><p>5) 点击demo3.txt文件<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025115532.png"></p><p><strong>发现，demo3.txt文件中，回滚到了上一次提交的状态。</strong></p><p><strong>删除了：临时需求已做完</strong></p><hr><p>第二天，继续codeing，编写产品经理提出的新需求。</p><p>1）打开demo3.txt文件</p><p>添加：第二天的需要已经完成！<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025115902.png"></p><p>2) add + commit<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025120045.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025120147.png"></p><p>能看到，有两次的提交记录。</p><p>3）突然，产品经理说，这个需要不要了。内心无话可说</p><p>所以，我们需要回滚到上一次提交的状态。</p><p>点击 first commit ，<strong>右键：重置当前分支到此次提交</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025124253.png"></p><p>要回到哪个状态，就点击哪个状态，然后右键重置当前分支到此次提交：</p><p><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025124921.png"></p><p>点击确定。</p><p>4）现在在工作区域下，能看到，上次修改后的没有提交的代码。<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025125125.png"></p><p>5) 丢弃修改的demo3.txt<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025125317.png"></p><p>6）打开demo3.txt文件：<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025125416.png"></p><p>回滚到第一次提交成功的状态了。</p><hr><p>现在，产品经理，说第一次提交的需求，也不需要了，需要删除这个文件。</p><p>1）直接在工作目录下，直接删除demo3.txt文件<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025125817.png"></p><p>2）add + commit<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025125922.png"></p><p><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025125959.png"></p><p>3) 此时，工作目录，暂存区域，本地仓库都删除了demo3.txt文件了。</p><hr><h4 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h4><p>现在使用命令行来操作：</p><p>1）打开命令行<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025130301.png"></p><p>2）在demo2下，创建bash_demo.txt文件</p><p>在文件中，输入：bash_demo 第一次提交成功.<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025130624.png"></p><p>3) 在命令行查看状态</p><p> git status</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git statusOn branch masterUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        bash_demo.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>4) 报存到暂存区：</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git add bash_demo.txtliuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        new file:   bash_demo.txt</code></pre><p>5) 提交到本地仓库中：</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git commit -m &quot;bash_demo first commit&quot;[master 136ecd0] bash_demo first commit 1 file changed, 1 insertion(+) create mode 100644 bash_demo.txtliuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git statusOn branch masternothing to commit, working tree clean</code></pre><hr><p>6) 产品经理提出了临时的需要</p><p>打开bash_demo.txt文件，添加：产品经理临时变更需要。<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025131337.png"></p><p>7) 查看 + add到暂存区域中：</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   bash_demo.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git add bash_demo.txt</code></pre><p>下班走人。</p><p>8）产品经理说，临时需要不要了</p><p>使用 <code>git reset head xxx.txt</code> （重置）</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git reset head bash_demo.txtUnstaged changes after reset:M       bash_demo.txtliuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   bash_demo.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>此时，只是将本地仓库的文件替换了暂存区域中的bash_demo文件。我们工作区域的文件还没有替换。</p><p>需要使用：<code>git checkout -- bash_demo.txt</code></p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git checkout -- bash_demo.txtliuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git statusOn branch master</code></pre><p>打开bash_demo.txt文件。发现：产品经理临时变更需要。删除了</p><p>9）第二天继续开发</p><p>修改bash_demo.txt 文件。</p><p>添加：第二天的需要已经完成<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025132555.png"></p><p>10) 将修改后的文件，add + commit</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git add bash_demo.txtliuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        modified:   bash_demo.txtliuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git commit -m &quot;second commit&quot;[master b8412ec] second commit 1 file changed, 3 insertions(+), 1 deletion(-)liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git statusOn branch masternothing to commit, working tree clean</code></pre><p>不幸的是，产品经理说，第二天的需要不需要了。</p><p>11）查看提交日志</p><p><code>git log</code></p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git logcommit b8412ec81784d6be4a5097fca881a811fe1b1a58 (HEAD -&gt; master)Author: liuzhuo &lt;575920824@qq.com&gt;Date:   Thu Oct 25 13:27:36 2018 +0800    second commitcommit 136ecd07ab2b0742dff45dcdcfbde1d51da2df42Author: liuzhuo &lt;575920824@qq.com&gt;Date:   Thu Oct 25 13:10:32 2018 +0800    bash_demo first commit</code></pre><p>找到：bash_demo第一次提交的序列号：</p><p>commit 136ecd07ab2b0742dff45dcdcfbde1d51da2df42<br>Author: liuzhuo <a href="mailto:&#53;&#55;&#x35;&#x39;&#50;&#48;&#x38;&#50;&#52;&#x40;&#113;&#x71;&#46;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#53;&#55;&#x35;&#x39;&#50;&#48;&#x38;&#50;&#52;&#x40;&#113;&#x71;&#46;&#99;&#111;&#x6d;</a><br>Date:   Thu Oct 25 13:10:32 2018 +0800</p><p>bash_demo first commit</p><p>这里，就是：<code>136ecd07ab2b0742dff45dcdcfbde1d51da2df42</code></p><p>12）回滚</p><p><code>git reset --hard 136ecd07ab2b0742dff45dcdcfbde1d51da2df42</code></p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git reset --hard 136ecd07ab2b0742dff45dcdcfbde1d51da2df42HEAD is now at 136ecd0 bash_demo first commitliuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git statusOn branch masternothing to commit, working tree clean</code></pre><p>查看，bash_demo.txt文件：<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025133411.png"></p><p>bash_demo文件就回滚到第一次提交的状态了。</p><p>13）现在产品经理说，所做的工作都不需要了。</p><p>删除bash_demo文件</p><p>git rm bash_demo</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git rm bash_demo.txtrm &#39;bash_demo.txt&#39;</code></pre><p>git commit -m “delete bash demo”</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git commit -m &quot;delete bash demo&quot;[master 6d7eacc] delete bash demo 1 file changed, 1 deletion(-) delete mode 100644 bash_demo.txtliuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ git statusOn branch masternothing to commit, working tree clean</code></pre><p>这样工作目录和本地仓库都删除了bash_demo文件了。</p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025134253.png"></p><p>1) 在工作区，先创建的文件，使用add，添加到暂存区，然后commit提交到本地仓库中。</p><p>2）reset head命令：head是指向本地仓库的指针。<br><code>reset head file</code> 就是重置本地仓库中版本文件到暂存区中。<br>然后使用<code>checkout -- file</code> 命令，将暂存区中的版本文件，重写到工作区中。</p><p>3）<code>rm -- file</code>: 直接删除暂存区中的文件。然后commit提交，就更新到本地仓库中了。</p><p>4）<code>checkout head file</code>: 一般不用，比较危险，因为使用这个命令，会把本地仓库中的版本文件，直接覆写到暂存区和工作区中。</p><hr><p>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。</p><p>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个“指针”。所以，图示的命令中出现 HEAD 的地方可以用 master 来替换。</p><p>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下。</p><p>当对工作区新增或修改的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区新增或修改的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。（如上图）</p><p>当执行提交操作 “git commit” 时，暂存区的目录树写到版本库的对象库（objects）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。（如上图）</p><p>当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 <code>git rm --cached &lt;file&gt;</code> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</p><p>当执行 “git checkout “ 或者 <code>git checkout -- &lt;file&gt;</code> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</p><p>当执行 “git checkout HEAD .” 或者  <code>git checkout HEAD &lt;file&gt;</code>  命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p><hr><h3 id="创建ssh-key"><a href="#创建ssh-key" class="headerlink" title="创建ssh key"></a>创建ssh key</h3><p>1）我们如果需要使用ssh来连接远程仓库的话，这里使用github当做远程仓库。</p><p>首先，生成我们的ssh的公钥：<br>ssh -keygen -t rsa -C “<a href="mailto:youremail@exmple.com" target="_blank" rel="noopener">youremail@exmple.com</a>“</p><p>在github上面，创建我们的账号。在setting里面，找到 SSH and GPG keys<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025144339.png"></p><p>点击右上角的：New SSH key<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025144438.png"></p><p>填写title，自己定义。key，需要使用命令来生成。</p><p>在Git bash界面下，输入生成ssh的命令：</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ ssh-keygen -t rsa -C &quot;575920824@qq.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/liuzhuo/.ssh/id_rsa):</code></pre><p>直接回车，覆盖以前的就好了。</p><p>这样就会在c盘的用户目录生成一个.ssh文件夹</p><p>C:\Users\liuzhuo.ssh</p><p>打开<strong>id_rsa.pub</strong>文件，将里面的key复制到github的ssh中key中：<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025145015.png"></p><p>2) 测试是否连接github成功：</p><p>使用命令：ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo2 (master)$ ssh -T git@github.comHi liuzhuo19940206! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><p>连接成功！！</p><hr><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><h4 id="使用命令行的方式"><a href="#使用命令行的方式" class="headerlink" title="使用命令行的方式"></a>使用命令行的方式</h4><p>在自己的github上面的，添加新的远程仓库<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025145915.png" style="width:50%"></p><p>点击 New repository<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025150029.png"></p><p>填写  </p><p>Repository name:仓库的名字</p><p>Description：仓库的描述信息</p><p>public：公共的仓库</p><p>private：私有的仓库<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025150238.png"></p><p>点击：Create repository<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025150341.png"></p><p>上面的两块部分，描述了，将本地仓库和这个远程仓库连接起来的方法！</p><p>第一种：</p><pre><code>…or create a new repository on the command lineecho &quot;# gitDemo&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/liuzhuo19940206/gitDemo.gitgit push -u origin master</code></pre><p>按照上面的步骤来，就行了。</p><p>在E:\gitdemo\demo4目录下，启动git的命令行界面</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4$ echo &quot;# gitDemo&quot; &gt;&gt; README.md      //创建一个文件liuzhuo@Gakki MINGW64 /e/gitdemo/demo4$ git init                          //创建一个本地仓库Initialized empty Git repository in E:/gitdemo/demo4/.git/liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)$ git add README.md                 //添加文件到暂存区warning: LF will be replaced by CRLF in README.md.The file will have its original line endings in your working directory.liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)$ git commit -m &quot;first commit&quot;      //提交信息到本地仓库[master (root-commit) e1e56e5] first commit 1 file changed, 1 insertion(+) create mode 100644 README.md</code></pre><p>接下来，连接本地仓库和远程仓库：</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)$ git remote add origin https://github.com/liuzhuo19940206/gitDemo.git</code></pre><p>最后，将本地仓库的提交到远程仓库中：</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)$ git push -u origin master</code></pre><p>第一次提交会出现验证信息的弹窗：<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025151356.png" style="width:50%"></p><p>输入用户名和密码即可。</p><p>出现了 fatal: HttpRequestException encountered.</p><p>解决：Github 禁用了TLS v1.0 and v1.1，必须更新Windows的git凭证管理器 </p><p>通过此网址 <a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/" target="_blank" rel="noopener">https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/</a><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025152916.png"></p><p>点击GCMW-1.14.0.exe，下载并安装。</p><p>重启git窗口：</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)$ git push -u origin masterCounting objects: 3, done.Writing objects: 100% (3/3), 217 bytes | 217.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)remote:remote: Create a pull request for &#39;master&#39; on GitHub by visiting:remote:      https://github.com/liuzhuo19940206/gitDemo/pull/new/masterremote:To https://github.com/liuzhuo19940206/gitDemo.git * [new branch]      master -&gt; masterBranch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;origin&#39;.</code></pre><p>就可以了，说明你的git和github已经可以同步了</p><p>在github上面，刷新你刚刚创建的项目：<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025154108.png"></p><hr><p>现在，修改README.md文件<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025154259.png"></p><p>然后  </p><p>git add README.md</p><p>git commit -m “second commit”</p><p>最后</p><p>将本地仓库同步到远程仓库</p><p>git push</p><p>这里不用指明远程仓库的名字，因为第一次同步后，就不需要了。</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo4 (master)$ git pushCounting objects: 3, done.Writing objects: 100% (3/3), 277 bytes | 277.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To https://github.com/liuzhuo19940206/gitDemo.git   e1e56e5..39e3593  master -&gt; master</code></pre><p>刷新远程仓库：<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025154719.png"></p><p>说明，本地仓库和远程仓库同步成功!!!!</p><hr><h4 id="使用SourceTree"><a href="#使用SourceTree" class="headerlink" title="使用SourceTree"></a>使用SourceTree</h4><p>1）创建新的远程仓库<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025155615.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025155703.png"></p><p>2) 打开SourceTree创建本地仓库<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025155817.png"></p><p>在本地仓库中，新建文件sourcetree.txt文件<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025160003.png"></p><p>3）使用SourceTree添加到本地仓库中<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025160104.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025160120.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025160210.png"></p><p>4）将本地仓库和远程仓库连接起来</p><p>点击master，然后点击右上角的设置<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025160348.png"></p><p>点击添加远程仓库：<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025160430.png"></p><p>填写信息：</p><p>远程仓库名称：origin（自定义）</p><p>URL：在github中远程仓库复制。<br>这里是：<a href="https://github.com/liuzhuo19940206/gitDemo_SourceTree.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/gitDemo_SourceTree.git</a></p><p>用户名：提交的用户名<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025160716.png"></p><p>点击确认。</p><p>在SourceTree中的左边的<strong>远程中</strong>：出现origin。<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025160844.png"></p><p>到此，我们就将远程仓库和本地仓库连接起来了。还没有同步！</p><p>5) 将本地仓库和远程仓库同步</p><p>点击菜单栏的推送<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025161056.png"></p><p>选好推送的远程仓库，添上加号，点击推送！</p><p>6）刷新远程仓库<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025161257.png"></p><p>发现，同步成功，点击sourcetree.txt文件<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025161359.png"></p><p>7）修改本地仓库中的sourcetree.txt文件<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025161447.png"></p><p>8）使用SourceTree提交<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025161550.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025174045.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025174124.png"></p><p>9）推送到远程仓库</p><p>此时，会发现推送上面会出现一个 1<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025174248.png"></p><p>点击推送<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025174319.png"></p><p>10）刷新远程仓库<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025174433.png"></p><p>这里出现了乱码，不影响我们的操作。</p><hr><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><p>克隆仓库：将远程的仓库克隆到本地当中。</p><p>使用的命令是：<br>git clone htt或ssh地址<br>git clone <a href="https://github.com/liuzhuo19940206/clone_repo_demo.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/clone_repo_demo.git</a></p><p>1）在github上创建一个新的仓库<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025175600.png"></p><p>2) 直接在github上面创建一个README.md文件<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025175832.png"></p><p>上面两个步骤，就是假设刚刚创建的项目是别人的远程仓库，我们需要克隆别人的远程仓库，来进行多人开发。</p><h4 id="使用命令行来克隆"><a href="#使用命令行来克隆" class="headerlink" title="使用命令行来克隆"></a>使用命令行来克隆</h4><p>1）在E:\gitdemo\demo6下，启动git窗口<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025180055.png"></p><p>使用 ls -a</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo6$ ls -a./  ../</code></pre><p>如果没有出现.git文件，说明此目录才能克隆仓库。不能在已经是本地仓库下的情况下克隆远程仓库</p><p>2）执行克隆命令</p><p>git clone <a href="https://github.com/liuzhuo19940206/clone_repo_demo.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/clone_repo_demo.git</a></p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo6$ git clone https://github.com/liuzhuo19940206/clone_repo_demo.gitCloning into &#39;clone_repo_demo&#39;...remote: Enumerating objects: 3, done.remote: Counting objects: 100% (3/3), done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.</code></pre><p>此时，打开demo6目录：在该目录下面会出远程仓库的名称和README.md文件<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025183824.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025183908.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025183938.png"></p><p>到此，克隆成功。</p><hr><h4 id="使用SourceTree来克隆"><a href="#使用SourceTree来克隆" class="headerlink" title="使用SourceTree来克隆"></a>使用SourceTree来克隆</h4><p>1）打开SourceTree，新建窗口<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025184546.png"></p><p>2）点击Clone按钮<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025184631.png"></p><p>第一行：远程仓库的地址<br><a href="https://github.com/liuzhuo19940206/clone_repo_demo.git" target="_blank" rel="noopener">https://github.com/liuzhuo19940206/clone_repo_demo.git</a></p><p>第二行：本地仓库的地址<br>E:\gitdemo\demo7</p><p><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025184839.png"></p><p>点击克隆<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025184925.png"></p><p>3）打开E:\gitdemo\demo7目录<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025185035.png"></p><hr><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>标签的作用是，给某个时刻的版本加上一个标签，然后，可以回滚到指定的标签。</p><p>标签的命令：</p><p>1) 查看所有标签 　　　　 git tag</p><p>2) 创建标签 　　　　　　 git tag name</p><p>3) 指定提交信息 　　　　 git tag -a name -m “comment”</p><p>4) 删除标签 　　　　　　 git tag -d name</p><p>5) 标签发布 　　　　　 　git push origin name</p><p><strong>ps:markdown中使用空格</strong></p><p><strong>1) 手动输入空格 （&amp;nbsp；）。注意！此时的分号为英文分号，但是不推荐使用此方法，太麻烦！</strong></p><p><strong>2) 使用全角空格。即：在全角输入状态下直接使用空格键就ok了</strong></p><h4 id="使用命令行创建标签"><a href="#使用命令行创建标签" class="headerlink" title="使用命令行创建标签"></a>使用命令行创建标签</h4><p>现在是在E:\gitdemo\demo7目录下。<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025192253.png"></p><p>1）git tag 查看标签</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)$ git tagliuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)$</code></pre><p>发现，没有标签</p><p>2）创建标签</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)$ git tag v1.0.1liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)$ git tagv1.0.1</code></pre><p>3) push标签</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/demo7 (master)$ git push origin v1.0.1Total 0 (delta 0), reused 0 (delta 0)To https://github.com/liuzhuo19940206/clone_repo_demo.git * [new tag]         v1.0.1 -&gt; v1.0.1</code></pre><p>4) 在远程仓库中验证标签是否推送成功<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025192912.png"></p><hr><h4 id="使用SourceTree创建标签"><a href="#使用SourceTree创建标签" class="headerlink" title="使用SourceTree创建标签"></a>使用SourceTree创建标签</h4><p>1) 现在修改一下E:\gitdemo\demo7下的README.md文件，为了和命令行创建的标签形成对比.<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025193635.png"></p><p>使用SourceTree，add + commit + push<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025193833.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025193850.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025193916.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025194050.png"></p><p>2) 在SourceTree下创建新的标签</p><p>在SourceTree的菜单栏上面有一个标签的按钮，点击<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025194223.png"></p><p>第一行：标签的名称</p><p>提交：点击指定的提交<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025194327.png"></p><p>此时，可以选择在哪个提交的版本上面，创建新的标签，因为first commit上面有一个v1.0.1的标签了，为了区别，现在选择second commit的提交。点击确认</p><p>点击推送标签前面的方格，会将本地的标签推送到远程仓库上面。<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025194613.png"></p><p>3）点击添加标签<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025194731.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025194804.png"></p><p>4）在远程仓库上面验证<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025194853.png"></p><p>5）切换标签</p><p>点击v1.0.1标签：<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025195005.png"><br><strong>下面的README.md文件中，没有second commit。</strong></p><p>点击v2.0.1标签：<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025195110.png"><br><strong>下面的README.md文件中，有second commit。</strong></p><font color="red"><strong>以后，就可以切换标签，来回滚到自己想要的版本。</strong></font><hr><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025200337.png"></p><p>一般是，在我们开发的过程中，在主分支master上面写。但是，每个人都有自己的任务，这个任务，不能短时间内完成，不能只完成一部分就提交到master主分支上面，这样会使的其他人无法使用master主分支了。我们也不能等到我们开发完后，一次性提交代码到master主分支上面。因为我们想记录我们的每一个开发流程。</p><p>所以，需要创建子分支来记录我们的开发流程。最后与主分支合并。</p><h4 id="使用命令行的方式-1"><a href="#使用命令行的方式-1" class="headerlink" title="使用命令行的方式"></a>使用命令行的方式</h4><p>1）新建一个目录：E:\gitdemo\branch_demo</p><p>2）在该目录下，打开git窗口<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025201915.png"></p><p>3) 添加一个新的文件，模拟开发流程。</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo$ echo &quot;branch first&quot; &gt;&gt; branch_demo.txt            //创建新的文件liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo $ git init                                         //创建本地仓库Initialized empty Git repository in E:/gitdemo/branch_demo/.git/liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)$ git statusOn branch masterNo commits yetUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        branch_demo.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track)liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)$ git add branch_demo.txt                         //添加到暂存区warning: LF will be replaced by CRLF in branch_demo.txt.The file will have its original line endings in your working directory.liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)$ git statusOn branch masterNo commits yetChanges to be committed:  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)        new file:   branch_demo.txtliuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)$ git commit -m &quot;branch first commit&quot;           //提交到本地仓库中[master (root-commit) ac97673] branch first commit 1 file changed, 1 insertion(+) create mode 100644 branch_demo.txtliuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)$ git statusOn branch masternothing to commit, working tree clean</code></pre><p>4）开启新的分支<br>git brach  : 查看所有分支<br>git brach 分支名称 ：创建新的分支</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)$ git branch* masterliuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)$ git branch new_branchliuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)$ git branch* master  new_branch</code></pre><p>5）切换分支<br>git checkout 分支名称</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)$ git checkout new_branchSwitched to branch &#39;new_branch&#39;liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)</code></pre><p>切换成功后，右边的括号内就是分支的名称。</p><p>6）在新分支继续开发</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)$ echo &quot; new_branch&quot; &gt;&gt; branch_demo.txtliuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)$ git statusOn branch new_branchChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   branch_demo.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)$ git add branch_demo.txtwarning: LF will be replaced by CRLF in branch_demo.txt.The file will have its original line endings in your working directory.liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)$ git statusOn branch new_branchChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        modified:   branch_demo.txtliuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)$ git commit -m &quot;new_branch commit&quot;[new_branch 25fe8ff] new_branch commit 1 file changed, 2 insertions(+), 1 deletion(-)liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)$ git statusOn branch new_branchnothing to commit, working tree clean</code></pre><p>7) 分别在每个分支查看branch_demo.txt文件</p><p>在新的分支下查看：<br>cat branch_demo.txt</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)$ git branch  master* new_branchliuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)$ cat branch_demo.txtbranch firstnew_branch</code></pre><p>切换到主分支查看：</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (new_branch)$ git checkout masterSwitched to branch &#39;master&#39;liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)$ cat branch_demo.txtbranch first</code></pre><p>8) 合并分支</p><p>git merge 子分支的名字</p><font color="red">在主分支(master)下，执行该命令</font><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)$ git merge new_branchUpdating ac97673..25fe8ffFast-forward branch_demo.txt | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-)</code></pre><p>9）查看主分支中的文件</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)$ cat branch_demo.txtbranch firstnew_branch</code></pre><p><strong>现在，主分支与子分支合并成功，文件中出现了new_branch的信息。</strong></p><p>10）删除分支</p><p>当我们的项目接着开发，之前的new_brach分子不需要，浪费空间，所有需要删除。</p><p>git branch -d 分支的名称</p><pre><code>liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)$ git branch -d new_branchDeleted branch new_branch (was 25fe8ff).liuzhuo@Gakki MINGW64 /e/gitdemo/branch_demo (master)$ git branch* master</code></pre><p>此时，new_branch分支删除成功。</p><h4 id="使用SourceTree的方式"><a href="#使用SourceTree的方式" class="headerlink" title="使用SourceTree的方式"></a>使用SourceTree的方式</h4><p>1）打开SourceTree</p><p>在E:\gitdemo\branch_sourcetree_demo下创建本地仓库<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025205416.png"></p><p>2）在E:\gitdemo\branch_sourcetree_demo下创建branch_demo.txt文件：<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025205522.png"></p><p>3）add + commit<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025205642.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025205658.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025205724.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025205758.png"></p><p>4) 创建新的分支</p><p>在SourceTree的菜单栏上面有一个分支的按钮<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025205849.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025205950.png"></p><p>创建分支成功后，在SourceTree左边，会出现新的分支<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025210021.png"></p><p><strong>选中的分支前面会有一个圆圈</strong></p><p>5）在新的分支下，修改branch_demo.txt文件<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025210235.png"></p><p>6) 在新的分支下，add + commit<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025210332.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025210426.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025210509.png"></p><p>7）切换到master分支下</p><p>双击master主分支，就切换成功了。<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025210659.png"></p><p>8）打开E:\gitdemo\branch_sourcetree_demo下的branch_demo.txt文件<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025210750.png"></p><p>发现文件里面，没有new_branch second信息。</p><p>9）将子分支合并到主分支中</p><p>在主分支的情况下，点击菜单栏下的合并按钮<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025211021.png"></p><p>点击我们要合并的分支。然后点击确定。<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025211223.png"></p><p>现在，再打开E:\gitdemo\branch_sourcetree_demo下的branch_demo.txt文件。<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025211400.png"></p><p>现在，合并成功了。</p><p>10）删除分支</p><p>直接在要删除的分支上面右键<br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025211604.png"><br><img src="https://gakkil.gitee.io/gakkil-image/git/QQ%E6%88%AA%E5%9B%BE20181025211636.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC注解</title>
      <link href="/2018/10/24/springmvc-zhu-jie/"/>
      <url>/2018/10/24/springmvc-zhu-jie/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC注解</strong></p><p>SpringMVC注解的详细解答</p><h3 id="注解概观"><a href="#注解概观" class="headerlink" title="注解概观"></a>注解概观</h3><p><strong>Spring2.5 引入注解式处理器</strong></p><p>@Controller：用于标识是处理器类；</p><p>@RequestMapping：请求到处理器功能方法的映射规则；</p><p>@RequestParam：请求参数到处理器功能处理方法的方法参数上的绑定；</p><p>@ModelAttribute：请求参数到命令对象的绑定；</p><p>@SessionAttributes：用于声明session级别存储的属性，放置在处理器类上，通常列出模型属性（如@ModelAttribute）对应的名称，则这些属性会透明的保存到session中；</p><p>@InitBinder：自定义数据绑定注册支持，用于将请求参数转换到命令对象属性的对应类型；</p><hr><p><strong>Spring3.0 引入RESTful架构风格支持(通过@PathVariable注解和一些其他特性支持),且又引入了更多的注解支持</strong></p><p>@CookieValue：cookie数据到处理器功能处理方法的方法参数上的绑定；</p><p>@RequestHeader：请求头（header）数据到处理器功能处理方法的方法参数上的绑定；</p><p>@RequestBody：请求的body体的绑定（通过HttpMessageConverter进行类型转换）；</p><p>@ResponseBody：处理器功能处理方法的返回值作为响应体（通过HttpMessageConverter进行类型转换）；</p><p>@ResponseStatus：定义处理器功能处理方法/异常处理器返回的状态码和原因；</p><p>@ExceptionHandler：注解式声明异常处理器；</p><p>@PathVariable：请求URI中的模板变量部分到处理器功能处理方法的方法参数上的绑定</p><h3 id="类与方法注解"><a href="#类与方法注解" class="headerlink" title="类与方法注解"></a>类与方法注解</h3><p>@Controller @RestController</p><p>@RestContrller注解相当于@ResponseBody和@Controller的结合 :</p><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><p>通过HttpMessageConverter接口转换为指定格式的数据</p><h4 id="InitBinder-局部转换器"><a href="#InitBinder-局部转换器" class="headerlink" title="@InitBinder-局部转换器"></a>@InitBinder-局部转换器</h4><p>如果希望某个属性编辑器仅作用于特定的 Controller ，</p><p>可以在 Controller 中定义一个标注 @InitBinder 注解的方法，</p><p>可以在该方法中向 Controller 了注册若干个属性编辑器</p><p>例如:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@InitBinder</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initBinder</span><span class="token punctuation">(</span>WebDataBinder binder<span class="token punctuation">)</span> <span class="token punctuation">{</span>    SimpleDateFormat dateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dateFormat<span class="token punctuation">.</span><span class="token function">setLenient</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    binder<span class="token punctuation">.</span><span class="token function">registerCustomEditor</span><span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CustomDateEditor</span><span class="token punctuation">(</span>dateFormat<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="RequestMapping-请求路径映射"><a href="#RequestMapping-请求路径映射" class="headerlink" title="@RequestMapping-请求路径映射"></a>@RequestMapping-请求路径映射</h4><p>RequestMapping是一个用来处理请求地址映射的注解（将请求映射到对应的控制器方法中），可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>RequestMapping请求路径映射，如果标注在某个controller的类级别上，则表明访问此类路径下的方法都要加上其配置的路径；最常用是标注在方法上，表明哪个具体的方法来接受处理某次请求。</p><p>属性:</p><pre class=" language-java"><code class="language-java">RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。<span class="token number">1</span>、 value， method；value：   指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；method：  指定请求的method类型， GET、POST、PUT、DELETE等；<span class="token number">2</span>、consumes，producesconsumes： 指定处理请求的提交内容类型（Content<span class="token operator">-</span>Type），例如application<span class="token operator">/</span>json<span class="token punctuation">,</span> text<span class="token operator">/</span>html<span class="token punctuation">;</span>produces<span class="token operator">:</span>  指定返回的内容类型，仅当request请求头中的<span class="token punctuation">(</span>Accept<span class="token punctuation">)</span>类型中包含该指定类型才返回；<span class="token number">3</span>、params，headersparams：  指定request中必须包含某些参数值是，才让该方法处理。headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</code></pre><p>派生的子类：</p><pre><code>Ø  @GetMappingØ  @PostMappingØ  @PutMappingØ  @DeleteMappingØ  @PatchMapping</code></pre><p>属性详解：</p><h5 id="value的用法"><a href="#value的用法" class="headerlink" title="value的用法"></a><font size="4">value</font>的用法</h5><p>(1)普通的具体值。如前面的 value=”/book”。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/get/{bookId}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">getBookById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> String bookId<span class="token punctuation">,</span>Model model<span class="token punctuation">)</span><span class="token punctuation">{</span>  model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"bookId"</span><span class="token punctuation">,</span> bookId<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token string">"book"</span><span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><p>(2)含某变量的一类值。</p><p>(3)ant风格</p><pre class=" language-java"><code class="language-java">  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/get/id?"</span><span class="token punctuation">)</span>：可匹配“<span class="token operator">/</span>get<span class="token operator">/</span>id1”或“<span class="token operator">/</span>get<span class="token operator">/</span>ida”，但不匹配“<span class="token operator">/</span>get<span class="token operator">/</span>id”或“<span class="token operator">/</span>get<span class="token operator">/</span>idaa”<span class="token punctuation">;</span>  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/get/id*"</span><span class="token punctuation">)</span>：可匹配“<span class="token operator">/</span>get<span class="token operator">/</span>idabc”或“<span class="token operator">/</span>get<span class="token operator">/</span>id”，但不匹配“<span class="token operator">/</span>get<span class="token operator">/</span>idabc<span class="token operator">/</span>abc”<span class="token punctuation">;</span>  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/get/id/*"</span><span class="token punctuation">)</span>：可匹配“<span class="token operator">/</span>get<span class="token operator">/</span>id<span class="token operator">/</span>abc”，但不匹配“<span class="token operator">/</span>get<span class="token operator">/</span>idabc”<span class="token punctuation">;</span>  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/get/id/**/{id}"</span><span class="token punctuation">)</span>：可匹配“<span class="token operator">/</span>get<span class="token operator">/</span>id<span class="token operator">/</span>abc<span class="token operator">/</span>abc<span class="token operator">/</span><span class="token number">123</span>”或“<span class="token operator">/</span>get<span class="token operator">/</span>id<span class="token operator">/</span><span class="token number">123</span>”，也就是Ant风格和URI模板变量风格可混用。</code></pre><p>(4)含正则表达式的一类值</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/get/{idPre:\d+}-{idNum:\d+}"</span><span class="token punctuation">)</span>：可以匹配“<span class="token operator">/</span>get<span class="token operator">/</span><span class="token number">123</span><span class="token operator">-</span><span class="token number">1</span>”，但不能匹配“<span class="token operator">/</span>get<span class="token operator">/</span>abc<span class="token operator">-</span><span class="token number">1</span>”，这样可以设计更加严格的规则。可以通过<span class="token annotation punctuation">@PathVariable</span> 注解提取路径中的变量<span class="token punctuation">(</span>idPre<span class="token punctuation">,</span>idNum<span class="token punctuation">)</span></code></pre><p>(5)或关系</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"/get"</span><span class="token punctuation">,</span><span class="token string">"/fetch"</span><span class="token punctuation">}</span> <span class="token punctuation">)</span> 即 <span class="token operator">/</span>get或<span class="token operator">/</span>fetch都会映射到该方法上。</code></pre><h5 id="method"><a href="#method" class="headerlink" title="method"></a><font size="4">method</font></h5><p>指定请求的method类型， GET、POST、PUT、DELETE等；</p><p>用法:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/get/{bookid}"</span><span class="token punctuation">,</span>method<span class="token operator">=</span><span class="token punctuation">{</span>RequestMethod<span class="token punctuation">.</span>GET<span class="token punctuation">,</span>RequestMethod<span class="token punctuation">.</span>POST<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h5 id="params："><a href="#params：" class="headerlink" title="params："></a><font size="4">params：</font></h5><p><strong>指定request中必须包含某些参数值是，才让该方法处理。</strong></p><p>@RequestMapping(params=”action=del”)，请求参数包含”action=del”,如：</p><p><code>http://localhost:8080/book?action=del</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/owners/{ownerId}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RelativePathUriTemplateController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/pets/{petId}"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>GET<span class="token punctuation">,</span> params<span class="token operator">=</span><span class="token string">"myParam=myValue"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">findPet</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> String ownerId<span class="token punctuation">,</span> <span class="token annotation punctuation">@PathVariable</span> String petId<span class="token punctuation">,</span> Model model<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// implementation omitted</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>仅处理请求中包含了名为“myParam”，值为“myValue”的请求</code></pre><h5 id="headers："><a href="#headers：" class="headerlink" title="headers："></a><font size="4">headers：</font></h5><p>指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><p>@RequestMapping(value=”/header/id”, headers = “Accept=application/json”)：</p><p>表示请求的URL必须为“/header/id 且请求头中必须有“Accept =application/json”参数即可匹配。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/owners/{ownerId}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RelativePathUriTemplateController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/pets"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>GET<span class="token punctuation">,</span> headers<span class="token operator">=</span><span class="token string">"Referer=http://www.ifeng.com/"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">findPet</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> String ownerId<span class="token punctuation">,</span> <span class="token annotation punctuation">@PathVariable</span> String petId<span class="token punctuation">,</span> Model model<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// implementation omitted</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    仅处理request的header中包含了指定“Refer”请求头和对应值为“http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>ifeng<span class="token punctuation">.</span>com<span class="token operator">/</span>”的请求。</code></pre><h5 id="consumes："><a href="#consumes：" class="headerlink" title="consumes："></a><font size="4">consumes：</font></h5><p>指定处理请求的提交内容类型（Content-Type），例如application/json, text/html。</p><p>用法:</p><p>@RequestMapping(value = “/pets”, method = RequestMethod.POST, consumes=”application/json”)</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/pets"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>POST<span class="token punctuation">,</span> consumes<span class="token operator">=</span><span class="token string">"application/json"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addPet</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> Pet pet<span class="token punctuation">,</span> Model model<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// implementation omitted</span><span class="token punctuation">}</span>  该方法仅处理request Content<span class="token operator">-</span>Type为“application<span class="token operator">/</span>json”类型的请求。</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC-参数绑定</title>
      <link href="/2018/10/24/springmvc-can-shu-bang-ding/"/>
      <url>/2018/10/24/springmvc-can-shu-bang-ding/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC-参数绑定</strong></p><p>探究SpringMVC中控制层的方法中的参数绑定</p><h4 id="Model-ModelMap-ModelAndView"><a href="#Model-ModelMap-ModelAndView" class="headerlink" title="Model/ModelMap/ModelAndView"></a>Model/ModelMap/ModelAndView</h4><p>ModelMap是Model接口的实现类，通过Model或ModelMap向页面传递数据，如下</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/itemEdit"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">itemEdit</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">,</span> Model model<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Items items <span class="token operator">=</span> itemService<span class="token punctuation">.</span><span class="token function">getItemById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向jsp传递数据</span>        model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">,</span> items<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置跳转的jsp页面</span>        <span class="token keyword">return</span> <span class="token string">"editItem"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*@RequestMapping("/itemEdit")    public String editItem(HttpServletRequest request,             HttpServletResponse response, HttpSession session, Model model) {        //从request中取参数        String strId = request.getParameter("id");        int id = new Integer(strId);        //调用服务        Items items = itemService.getItemById(id);        //把结果传递给页面        //ModelAndView modelAndView = new ModelAndView();        //modelAndView.addObject("item", items);        //设置逻辑视图        //modelAndView.setViewName("editItem");        //return modelAndView;        //设置返回结果        model.addAttribute("item", items);        //返回逻辑视图        return "editItem";    }    */</span></code></pre><h4 id="Any-other-argument原始参数"><a href="#Any-other-argument原始参数" class="headerlink" title="Any other argument原始参数"></a>Any other argument原始参数</h4><p>当请求的参数名称和处理器形参<strong>名称一致时</strong>会将请求参数与形参进行绑定。从Request取参数的方法可以进一步简化。</p><pre class=" language-java"><code class="language-java">      <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/itemEdit"</span><span class="token punctuation">)</span>      <span class="token keyword">public</span> String <span class="token function">itemEdit</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">,</span> Model model<span class="token punctuation">)</span> <span class="token punctuation">{</span>          Items items <span class="token operator">=</span> itemService<span class="token punctuation">.</span><span class="token function">getItemById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//向jsp传递数据</span>          model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">,</span> items<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//设置跳转的jsp页面</span>          <span class="token keyword">return</span> <span class="token string">"editItem"</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  参数类型推荐使用包装数据类型，因为基础数据类型不可以为null  整形：  Integer、<span class="token keyword">int</span>  字符串：String  单精度：Float、<span class="token keyword">float</span>  双精度：Double、<span class="token keyword">double</span>  布尔型：Boolean、<span class="token keyword">boolean</span>  说明：对于布尔类型的参数，请求的参数值为<span class="token boolean">true</span>或<span class="token boolean">false</span>。  处理方法：  <span class="token keyword">public</span> String <span class="token function">editItem</span><span class="token punctuation">(</span>Model model<span class="token punctuation">,</span>Integer id<span class="token punctuation">,</span>Boolean status<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception  请求url：  http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">:</span><span class="token number">8080</span><span class="token operator">/</span>xxx<span class="token punctuation">.</span>action<span class="token operator">?</span>id<span class="token operator">=</span><span class="token number">2</span><span class="token operator">&amp;</span>status<span class="token operator">=</span><span class="token boolean">false</span>  处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。 </code></pre><h3 id="注解形式："><a href="#注解形式：" class="headerlink" title="注解形式："></a>注解形式：</h3><p>下面是具体使用说明，几乎都是下面这种格式：Public String (@RequestParam int id){..}</p><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h4><p>@RequestParam用来接收路径后面的参数<br><code>http:www.lifeibai.com?petId = 1.</code><br> 一般用来处理接收的参数和形参的参数不一致的情况</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">,</span>defaultValue <span class="token operator">=</span> <span class="token string">"10"</span><span class="token punctuation">,</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>defaultValue 表示设置默认值，required     通过<span class="token keyword">boolean</span>设置是否是必须要传入的参数，value        值表示接受的传入的参数名称使用<span class="token annotation punctuation">@RequestParam</span>常用于处理简单类型的绑定。</code></pre><p>例子：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/pets"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EditPetForm</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  <span class="token annotation punctuation">@GetMapping</span>  <span class="token keyword">public</span> String <span class="token function">setupForm</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"petId"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> Id<span class="token punctuation">,</span> Model model<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Pet pet <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>clinic<span class="token punctuation">.</span><span class="token function">loadPet</span><span class="token punctuation">(</span>petId<span class="token punctuation">)</span><span class="token punctuation">;</span>      model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"pet"</span><span class="token punctuation">,</span> pet<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token string">"petForm"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre><h4 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h4><p>@RequestHeader用来接收指定参数的请求头信息</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/demo"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>      <span class="token annotation punctuation">@RequestHeader</span><span class="token punctuation">(</span><span class="token string">"Accept-Encoding"</span><span class="token punctuation">)</span> String encoding<span class="token punctuation">,</span>      <span class="token annotation punctuation">@RequestHeader</span><span class="token punctuation">(</span><span class="token string">"Keep-Alive"</span><span class="token punctuation">)</span> <span class="token keyword">long</span> keepAlive<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre><h4 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h4><p>用来接收指定名称的cookie的值</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token annotation punctuation">@CookieValue</span><span class="token punctuation">(</span><span class="token string">"JSESSIONID"</span><span class="token punctuation">)</span> String cookie<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre><h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a><font color="red">@ModelAttribute</font></h4><p>ModelAttribute可以应用在<strong>方法参数上</strong>或<strong>方法上</strong>，他的作用主要是当注解在方法参数上时会将注解的参数对象添加到Model中；</p><p>当注解在请求处理方法Action上时会将该方法变成一个非请求处理的方法，但其它Action被调用时会<strong>首先</strong>调用该方法。</p><p><font color="#FF3E96">被@ModelAttribute注释的方法会在此controller每个方法执行前被执行，下面访问 http:localhost:8080/test_project/test.action</font></p><pre class=" language-java"><code class="language-java">  <span class="token annotation punctuation">@RestController</span>  <span class="token annotation punctuation">@SessionAttributes</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>      <span class="token annotation punctuation">@ModelAttribute</span><span class="token punctuation">(</span><span class="token string">"age2"</span><span class="token punctuation">)</span>      <span class="token keyword">public</span> String <span class="token function">mdoeltest1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"This is ModelAttribute1 !"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token string">"33"</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token annotation punctuation">@ModelAttribute</span><span class="token punctuation">(</span><span class="token string">"age1"</span><span class="token punctuation">)</span>      <span class="token keyword">public</span> String <span class="token function">mdoeltestrrr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"This is ModelAttributee1 !"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token string">"22"</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/test.action"</span><span class="token punctuation">)</span>      <span class="token keyword">public</span> String <span class="token function">test</span><span class="token punctuation">(</span>User user <span class="token punctuation">,</span>                          <span class="token annotation punctuation">@ModelAttribute</span><span class="token punctuation">(</span><span class="token string">"age1"</span><span class="token punctuation">)</span> String age1 <span class="token punctuation">,</span>                         <span class="token annotation punctuation">@ModelAttribute</span><span class="token punctuation">(</span><span class="token string">"age2"</span><span class="token punctuation">)</span> String age2 <span class="token punctuation">,</span>                         HttpSession session<span class="token punctuation">)</span><span class="token punctuation">{</span>          Object user2 <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"age1:"</span><span class="token operator">+</span>age1<span class="token punctuation">)</span><span class="token punctuation">;</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"age2:"</span><span class="token operator">+</span>age2<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token string">"test"</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  结果：  This is ModelAttributee1 <span class="token operator">!</span>  This is ModelAttribute1 <span class="token operator">!</span>  User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'李四'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">22</span><span class="token punctuation">}</span>  User<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'李四'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">22</span><span class="token punctuation">}</span>  age1<span class="token operator">:</span><span class="token number">22</span>  age2<span class="token operator">:</span><span class="token number">33</span></code></pre><h4 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h4><p>Value={“name”,“age”} 取出name或者value、或者把model中的name，age扔到session中<br>Type=User.Class   将一个实体类扔到session中<br>这个玩意加在 类上面，然后所有的方法的参数都可以在sesssion中找，找到了就赋值。<br>@SessionAttributes需要清除时，使用SessionStatus.setComplete();来清除。</p><p>1、  将model中的值，扔到session中</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@SessionAttributes</span><span class="token punctuation">(</span>types <span class="token operator">=</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginController</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/login"</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> String <span class="token function">login</span><span class="token punctuation">(</span>HttpServletRequest req<span class="token punctuation">,</span>Model model<span class="token punctuation">,</span>SessionStatus status<span class="token punctuation">)</span><span class="token punctuation">{</span>      User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"user"</span> <span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token string">"forward:test.action"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2、  从session取出来</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@SessionAttributes</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/test.action"</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> String  <span class="token function">test</span><span class="token punctuation">(</span>User user<span class="token punctuation">,</span> HttpSession session<span class="token punctuation">)</span><span class="token punctuation">{</span>      Object user2 <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token string">"test"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a>@SessionAttribute</h4><p>这玩意是加在方法上的参数的，将session中的数据赋值给参数 。但是4.3以后的版本才支持</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">handle</span><span class="token punctuation">(</span><span class="token annotation punctuation">@SessionAttribute</span> User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><p>@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为json、xml等格式的数据并绑定到controller方法的参数上</p><pre class=" language-java"><code class="language-java">List<span class="token punctuation">.</span>action<span class="token operator">?</span>id<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>name<span class="token operator">=</span>zhangsan<span class="token operator">&amp;</span>age<span class="token operator">=</span><span class="token number">12</span>本例子应用：<span class="token annotation punctuation">@RequestBody</span>注解实现接收http请求的json数据，将json数据转换为java对象<span class="token comment" spellcheck="true">// 商品修改提交json信息，响应json信息</span>  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/editItemSubmit_RequestJson"</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token annotation punctuation">@ResponseBody</span> Items <span class="token function">editItemSubmit_RequestJson</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> Items items<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//itemService.saveItem(items);</span>      <span class="token keyword">return</span> items<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><p>该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端</p><p>@ResponseBody注解实现将controller方法返回对象转换为json响应给客户端</p><p><strong><font color="red">使用这个注解 ，sessionAttributes注解将会失效</font></strong></p><h4 id="PathVariable（RESTful）"><a href="#PathVariable（RESTful）" class="headerlink" title="@PathVariable（RESTful）"></a>@PathVariable（RESTful）</h4><pre class=" language-java"><code class="language-java">用法<span class="token operator">:</span>     <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/users/{userId}/topics/{topicId}"</span><span class="token punctuation">)</span>     <span class="token keyword">public</span> String <span class="token function">test</span><span class="token punctuation">(</span>     <span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"userId"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> userId<span class="token punctuation">,</span>      <span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"topicId"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> topicId<span class="token punctuation">)</span>      如请求的URL为“控制器URL<span class="token operator">/</span>users<span class="token operator">/</span><span class="token number">123</span><span class="token operator">/</span>topics<span class="token operator">/</span><span class="token number">456</span>”，     则自动将URL中模板变量<span class="token punctuation">{</span>userId<span class="token punctuation">}</span>和<span class="token punctuation">{</span>topicId<span class="token punctuation">}</span>绑定到     通过<span class="token annotation punctuation">@PathVariable</span>注解的同名参数上，即入参后userId<span class="token operator">=</span><span class="token number">123</span>、topicId<span class="token operator">=</span><span class="token number">456</span>。</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC-Return Values返回值</title>
      <link href="/2018/10/24/values-fan-hui-zhi/"/>
      <url>/2018/10/24/values-fan-hui-zhi/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC-Return Values返回值</strong></p><p>本篇文章，主要讲解SpringMVC的返回值的使用。</p><hr><h3 id="Handler-Return-Values返回值"><a href="#Handler-Return-Values返回值" class="headerlink" title="Handler-Return Values返回值"></a>Handler-Return Values返回值</h3><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><p> 返回值通过HttpMessageConverters转换并写入响应。   请参阅@ResponseBody。<br> 处理器功能处理方法的返回值作为响应体（通过HttpMessageConverter进行类型转换）；<br> 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。<br> 使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p><h4 id="HttpEntity-ResponseEntity"><a href="#HttpEntity-ResponseEntity" class="headerlink" title="HttpEntity,ResponseEntity"></a>HttpEntity,ResponseEntity</h4><p>返回值:指定完整响应，包括HTTP标头和正文通过HttpMessageConverters转换并写入响应。 请参阅ResponseEntity。</p><h4 id="HttpHeaders"><a href="#HttpHeaders" class="headerlink" title="HttpHeaders"></a>HttpHeaders</h4><p>为了返回一个响应头和没有正文。</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>一个视图名称，用ViewResolver解决，并与隐式模型一起使用 - 通过命令对象和@ModelAttribute方法确定。 处理程序方法也可以通过声明一个Model参数来以编程方式丰富模型。</p><h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><p>用于与隐式模型一起渲染的View实例 - 通过命令对象和@ModelAttribute方法确定。 处理程序方法也可以通过声明一个Model参数来以编程方式丰富模型。</p><h4 id="java-util-Map-org-springframework-ui-Model"><a href="#java-util-Map-org-springframework-ui-Model" class="headerlink" title="java.util.Map,org.springframework.ui.Model"></a>java.util.Map,org.springframework.ui.Model</h4><p>要通过RequestToViewNameTranslator隐式确定的视图名称添加到隐式模型的属性。</p><h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h4><p>要通过RequestToViewNameTranslator隐式确定的视图名称添加到模型的属性。   请注意@ModelAttribute是可选的。</p><h4 id="ModelAndView-，object"><a href="#ModelAndView-，object" class="headerlink" title="ModelAndView ，object"></a>ModelAndView ，object</h4><p>要使用的视图和模型属性，以及可选的响应状态。</p><h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><p>具有void返回类型（或返回值为null）的方法如果还有ServletResponse，OutputStream参数或@ResponseStatus注释，则认为它已完全处理响应。<br>如果控制器进行了积极的ETag或lastModified时间戳检查（请参阅@Controller缓存了解详细信息），情况也是如此。<br>如果以上都不是这样，那么void返回类型也可能指示REST控制器的“无响应主体”，或HTML控制器的默认视图名称选择。</p><h4 id="DeferredResult"><a href="#DeferredResult" class="headerlink" title="DeferredResult"></a><font color="red">DeferredResult</font></h4><p>从任何线程异步生成任何上述返回值 - 例如 可能是由于某些事件或回调。</p><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a><font color="red">Callable</font></h4><p>Produce any of the above return values asynchronously in a Spring MVC managed thread. See Async Requests and Callable.使用异步线程来执行请求，然后返回给handler。</p><h4 id="ListenableFuture-java-util-concurrent-CompletionStage-java-util-concurrent-CompletableFuture"><a href="#ListenableFuture-java-util-concurrent-CompletionStage-java-util-concurrent-CompletableFuture" class="headerlink" title="ListenableFuture, java.util.concurrent.CompletionStage,   java.util.concurrent.CompletableFuture"></a>ListenableFuture, java.util.concurrent.CompletionStage,   java.util.concurrent.CompletableFuture</h4><p>在Spring MVC托管线程中异步生成上述任何返回值。</p><h4 id="ResponseBodyEmitter-SseEmitter"><a href="#ResponseBodyEmitter-SseEmitter" class="headerlink" title="ResponseBodyEmitter,   SseEmitter"></a>ResponseBodyEmitter,   SseEmitter</h4><p>用HttpMessageConverter’s异步发出一个对象流写入响应; 也支持作为ResponseEntity的主体。</p><h4 id="StreamingResponseBody"><a href="#StreamingResponseBody" class="headerlink" title="StreamingResponseBody"></a>StreamingResponseBody</h4><p>异步写入响应的OutputStream; 也支持作为ResponseEntity的主体。</p><h4 id="Reactive-types-—-Reactor-RxJava-or-others-via-ReactiveAdapterRegistry"><a href="#Reactive-types-—-Reactor-RxJava-or-others-via-ReactiveAdapterRegistry" class="headerlink" title="Reactive   types — Reactor, RxJava, or others via ReactiveAdapterRegistry"></a>Reactive   types — Reactor, RxJava, or others via ReactiveAdapterRegistry</h4><p>具有多值流的DeferredResult（例如Flux，Observable）的替代方法被收集到列表中。<br>对于流式场景 - 例如 text / event-stream，application / json +   stream - 使用SseEmitter和ResponseBodyEmitter，而在Spring MVC托管线程上执行ServletOutputStream阻塞I / O，并在每次写入完成时施加背压。</p><h4 id="Any-other-return-value"><a href="#Any-other-return-value" class="headerlink" title="Any other return  value"></a>Any other return  value</h4><p> 如果返回值与以上任何一个不匹配，默认情况下它被视为视图名称，如果它是String或void（通过RequestToViewNameTranslator应用的默认视图名称选择）; 或者作为要添加到模型的模型属性，除非它是一个简单的类型，由BeanUtils＃isSimpleProperty确定，在这种情况下，它仍然未解决。</p><hr><h3 id="返回ModelAndView-Model"><a href="#返回ModelAndView-Model" class="headerlink" title="返回ModelAndView/Model"></a>返回ModelAndView/Model</h3><p>controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。</p><p>Model与ModelAndView的传递效果是一样的，且传递是数据不能是引用类型。<br>重定向时，会把数据拼接到Url后面</p><p>@返回void </p><p>啥也不做 - -</p><hr><p>返回字符串</p><p>这玩意需要用到@ResponseBody注解</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/test.action"</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> String  <span class="token function">test</span><span class="token punctuation">(</span> <span class="token keyword">int</span> ids<span class="token punctuation">)</span><span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"id:"</span><span class="token operator">+</span>ids<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token string">"this is test"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>逻辑视图名</p><p>这玩意需要你配置视图解析器</p><pre class=" language-java"><code class="language-java">INF<span class="token operator">/</span>jsp<span class="token operator">/</span>item<span class="token operator">/</span>editItem<span class="token punctuation">.</span>jsp<span class="token keyword">return</span> <span class="token string">"item/editItem"</span><span class="token punctuation">;</span></code></pre><p>Redirect重定向</p><p>Contrller方法返回结果重定向到一个url地址，如下商品修改提交后重定向到商品查询方法，参数无法带到商品查询方法中.</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//重定向到queryItem.action地址,request无法带过去</span><span class="token keyword">return</span> <span class="token string">"redirect:queryItem.action"</span><span class="token punctuation">;</span></code></pre><p>redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response。</p><p>由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/item/queryItem.action后边加参数，如下：</p><p>/item/queryItem?…&amp;…..</p><p>对于model设置的值，重定向会拼接到？key=value…. 版本4.3以后好像改了，记不太清了，你们可以自己去玩一下</p><hr><p>forward转发</p><p>跟Redirect一样的用法，不同的是 转发可以传递参数</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//结果转发到editItem.action，request可以带过去</span><span class="token keyword">return</span> <span class="token string">"forward:editItem.action"</span><span class="token punctuation">;</span>forward方式相当于“request<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span>response<span class="token punctuation">)</span>”，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到。带域的返回</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC架构与流程</title>
      <link href="/2018/10/24/springmvc-jia-gou-yu-liu-cheng/"/>
      <url>/2018/10/24/springmvc-jia-gou-yu-liu-cheng/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC的架构与流程</strong></p><p>探究MVC在SpringMVC中的关系。<br><strong>前言：</strong></p><p>顾名思义SpringMVC是一个基于MVC设计思想的框架。</p><p>什么是mvc？MVC是模型(model)－视图(view)－控制器(controller)的缩写 ，是一种软件设计思想，主要的作用就是解决应用开发的耦合性，将应用的输入、控制、输出进行强制解耦。</p><p>mvc中的模型、视图、控制器分别担负着不同的角色：</p><p>模型：页面的数据和业务的处理。我们平常用的service和dao层就属于这一层面</p><p>视图：只用于用户的显示，不进行任何的业务处理。主要用来获取和显示数据</p><p>控制器：控制视图层与用户的交互，将对应的操作调用对应的模型。简单的说，就是管理交互的</p><p>理解了mvc，我们就来说一说mvc的执行过程：用户通过view层向服务器发出请求，controller接收请求后，调用对应的model后获取数据，控制器在将数据返回给view。</p><p><strong>好了，我们可以进入正题了，既然SpringMVC是基于MVC的软件设计思想的框架，我们就先看一下SpringMVC的M、V、C分别是什么</strong></p><p><img src="https://gakkil.gitee.io/gakkil-image/SpringMVC/20181024152707.png"></p><p>上图里的东西我们不用细看，只需要大概晓得对应的mvc是啥的就行</p><p>M:这里的模型指定是具体执行的Handler(Controller)。</p><p>V:就是试图View</p><p>C:指的的前端控制器</p><p><strong>了解的springMVC的架构思想（mvc），我就开始继续深入的学习springmvc的执行流程吧。</strong></p><p>下面的顺序并不代表图中的顺序：</p><p>用户将请求发送给前端控制器（DispatcherServlet）也就是SpringMVC的控制器</p><p>然后 前端控制器 请求调用HandlerMapper（处理器映射器）</p><p>处理器映射器 根据请求的url返回 Handler和处理器拦截器（如果有）给前端控制器（DispatcherServlet）</p><p>前端控制器（DispatcherServlet）找到合适的 处理器适配器(HanderAdatper)，由处理器适配器调用Handler</p><p>Handler（以后统称为Controller）执行操作，Handler通常就是我们定义的controller(这里的controller是springmvc的model层),执行完后返回ModelAndView</p><p>处理器映射器(HanderAdatper)将ModelAndView返回给 前端控制器</p><p>然后 前端控制器将ModelAndView 传递给 视图解析器（ViewReslover )</p><p>视图解析器解析（ViewReslover )后 返回具体view，给前端控制器（DispatcherServlet）</p><p>前端控制器（DispatcherServlet）对视图进行渲染（将数据填充到视图中）</p><p>前端控制器（DispatcherServlet）将视图返回给用户。</p><hr><p>了解了流程，我们在详细了解一下里面讲到的部件：</p><p>前端控制器（DispatcherServlet）：这玩意是 SpringMVC的入口（实际上呢就是一个Servlet对象），所有的请求都要通过它，因为是个Servlet所以不可避免的你要在web.xml进行配置(Servlet3.0以后，可以不使用web.xml配置文件了)。</p><p>处理器映射器(HandlerMapper)，这个玩意就是根据不同的方式找到处理器（Handler），它支持的有配置文件形式，接口形式，注解形式等等</p><p>处理器适配器（HandlAdapter ）这玩意就是 分析处理器是哪种方式的处理器（配置文件，接口、注解等形式）然后执行Handler</p><p>ModelAndView 封装了数据和视图信息，如果想进行页面的数据交互，可以选择这玩意进行传输，数据的存放位置，默认的是Request域</p><p>视图解析器（ViewResolver ），负责将处理结果生成View视图。</p><p>视图（View ） SpringMVC提供了很多视图，比如jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp</p><hr><p><strong>在spring-mvc.xml文件中配置：</strong></p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 配置处理器映射器 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>bean <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 配置处理器适配器 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>bean <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span><span class="token operator">/</span><span class="token operator">></span> 为什么这么配置spring就能用呢？因为spring对bean的加载有一个顺序，同名称的spring只会认第一次加载的bean，也就是配置文件最先配置的bean</code></pre><p><strong>当然了还有更简洁的配置，添加这个配置即可 mvc:annotation-driven</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.lifeibai&quot;/&gt;    &lt;mvc:annotation-driven/&gt;&lt;/beans&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_16</title>
      <link href="/2018/10/23/spring-annotation-day-16/"/>
      <url>/2018/10/23/spring-annotation-day-16/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring容器的创建过程</strong></p><p>今天，我们来统一学习一下，Spring容器的整个创建过程。</p><hr><p><strong>Spring容器的refresh()[创建刷新]</strong></p><h3 id="prepareRefresh-【刷新前的预处理】"><a href="#prepareRefresh-【刷新前的预处理】" class="headerlink" title="prepareRefresh();【刷新前的预处理】"></a>prepareRefresh();【刷新前的预处理】</h3><p>1）initPropertySources();初始化一些属性设置；子类自定义个性化的属性设置方法；</p><pre class=" language-java"><code class="language-java">   <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initPropertySources</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// For subclasses: do nothing by default.</span>     <span class="token punctuation">}</span></code></pre><p>2)  getEnvironment().validateRequiredProperties();检验属性的合法性等</p><p>3）earlyApplicationEvents = new LinkedHashSet<applicationevent>();保存容器的一些早期的事件；</applicationevent></p><h3 id="obtainFreshBeanFactory；【获取BeanFactory】"><a href="#obtainFreshBeanFactory；【获取BeanFactory】" class="headerlink" title="obtainFreshBeanFactory；【获取BeanFactory】"></a>obtainFreshBeanFactory；【获取BeanFactory】</h3><p>1）refreshBeanFactory();刷新BeanFactory<br>创建 this.beanFactory = new DefaultListableBeanFactory();<br>设置id。</p><p>2）getBeanFactory();<br>返回GenericApplicationContext创建的beanFactory对象;return this.beanFactory;</p><p>3)将创建好的BeanFactory【GenericApplicationContext】对象返回；</p><h3 id="prepareBeanFactory-beanFactory"><a href="#prepareBeanFactory-beanFactory" class="headerlink" title="prepareBeanFactory(beanFactory);"></a>prepareBeanFactory(beanFactory);</h3><p>BeanFactory的预准备工作（BeanFactory进行一些设置）</p><p>1）设置BeanFactory的类加载、支持表达式解析器····</p><p>2）添加部分BeanPostProcessor【ApplicationContextAwareProcessor】</p><p>3）设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware等</p><p>4）注册可以解析的自动装配：我们能直接在任何组件中自动注入：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext。</p><p>5）添加BeanPostProcessor【ApplicationListenerDetector】</p><p>6）添加编译时Aspectj</p><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">containsBean</span><span class="token punctuation">(</span>LOAD_TIME_WEAVER_BEAN_NAME<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            beanFactory<span class="token punctuation">.</span><span class="token function">addBeanPostProcessor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoadTimeWeaverAwareProcessor</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Set a temporary ClassLoader for type matching.</span>            beanFactory<span class="token punctuation">.</span><span class="token function">setTempClassLoader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ContextTypeMatchClassLoader</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>7) 给BeanFactory中注册一些能用的组件</p><p>environment【ConfigurableEnvironment】</p><p>systemProperties【Map&lt;String, Object&gt;】</p><p>systemEnvironment【Map&lt;String, Object&gt;】</p><h3 id="postProcessBeanFactory-beanFactory"><a href="#postProcessBeanFactory-beanFactory" class="headerlink" title="postProcessBeanFactory(beanFactory);"></a>postProcessBeanFactory(beanFactory);</h3><p>BeanFactory准备工作完成后进行的后置处理工作</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>ConfigurableListableBeanFactory beanFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>子类通过覆写这个方法来在BeanFactory创建并准备完成以后做进一步的设置。</p><div style="text-align: center;"><font color="#00ffff" size="4">以上是BeanFactory的创建以及准备工作</font></div><hr><h3 id="invokeBeanFactoryPostProcessors-beanFactory"><a href="#invokeBeanFactoryPostProcessors-beanFactory" class="headerlink" title="invokeBeanFactoryPostProcessors(beanFactory);"></a>invokeBeanFactoryPostProcessors(beanFactory);</h3><p>执行BeanFactoryPostProcessor</p><p>BeanFactoryPostProcessor：BeanFactory的后置处理器。在BeanFactory标准化初始化之后执行。</p><p>两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor。</p><p>一、执行BeanFactoryPostProcessor的方法：</p><p><strong>先执行BeanDefinitionRegistryPostProcessor</strong></p><p>1）获取所有的BeanDefinitionRegistryPostProcessor  </p><p>2）先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor<br>postProcessor.postProcessBeanDefinitionRegistry(registry);</p><p>3）再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor<br>postProcessor.postProcessBeanDefinitionRegistry(registry);</p><p>4）最后执行没有实现任何优先级或者顺序接口的BeanDefinitionRegistryPostProcessor<br>postProcessor.postProcessBeanDefinitionRegistry(registry);</p><p><strong>后执行BeanFactoryPostProcessor的方法</strong></p><p>1）获取所有的BeanFactoryPostProcessor</p><p>2）先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor<br>postProcessor.postProcessBeanFactory();</p><p>3）再执行实现了Ordered顺序接口的BeanFactoryPostProcessor<br>postProcessor.postProcessBeanFactory();</p><p>4）最后执行没有实现任何优先级或者顺序接口的BeanFactoryPostProcessor<br>postProcessor.postProcessBeanFactory();</p><h3 id="registerBeanPostProcessors（BeanFactory）"><a href="#registerBeanPostProcessors（BeanFactory）" class="headerlink" title="registerBeanPostProcessors（BeanFactory）"></a>registerBeanPostProcessors（BeanFactory）</h3><p>注册BeanPostProcessor（Bean的后置处理器）【Intercept bean creation.】</p><p>不同类型的BeanPostProcessor：在Bean的创建前后的执行顺序是不同的</p><p>DestructionAwareBeanPostProcessor</p><p>InstantiationAwareBeanPostProcessor</p><p>MergedBeanDefinitionPostProcessor【internalPostProcessor】</p><p>SmartInstantiationAwareBeanPostProcessor</p><p>1）获取所有的BeanPostProcessor；后置处理器默认都可以通过PriorityOrdered、Ordered接口来执行优先级</p><p>2）先注册PriorityOrdered优先级接口的BeanPostProcessor；把每一个BeanPostProcessor添加到BeanFactory中</p><p>3）再注册Ordered</p><p>4）注册其他的没有实现任何接口的BeanPostProcessor</p><p>5）最终注册MergedBeanDefinitionPostProcessor</p><p>6）注册一个ApplicationListenerDetector；来在Bean创建后检查是否是ApplicationListener，如果是，就添加到容器中：applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</p><h3 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource();"></a>initMessageSource();</h3><p>初始化MessageSource组件，做国家化功能；消息绑定；消息解析。</p><p>1）获取BeanFactory</p><p>2）看容器中是否有id=messageSource，类型是MessageSource的组件。如果有就赋值给messageSource，如果没有就自己创建一个DelegatingMessageSource组件。</p><p>MessageSource：取出国际化配置文件中的某个key的值；能按照区域信息获取。</p><p>3）把创建好的messageSource注册到容器中，以后获取国际化配置文件时，可以自动注入MessageSource</p><h3 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster();"></a>initApplicationEventMulticaster();</h3><p>初始化事件派发器</p><p>1）获取BeanFactory</p><p>2）从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster</p><p>3）如果上一步没有配置，就创建一个SimpleApplicationEventMulticaster</p><p>4）将创建好的ApplicationEventMulticaster添加到容器中，以后其他组件直接自动注入</p><h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh();"></a>onRefresh();</h3><p>留给子类，重写onRefresh()方法.在容器刷新的时候自定义逻辑。</p><h3 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners();"></a>registerListeners();</h3><p>给容器中将所有项目里面的ApplicationListener注册进来</p><p>1）从容器中拿到所有的ApplicationListener组件</p><p>2）将每个监听器添加到事件派发器中：getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</p><p>3）派发之前步骤中产生的事件：</p><pre class=" language-java"><code class="language-java">  Set<span class="token operator">&lt;</span>ApplicationEvent<span class="token operator">></span> earlyEventsToProcess <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>earlyApplicationEvents<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>earlyApplicationEvents <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>earlyEventsToProcess <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>ApplicationEvent earlyEvent <span class="token operator">:</span> earlyEventsToProcess<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">getApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">multicastEvent</span><span class="token punctuation">(</span>earlyEvent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><h3 id="finishBeanFactoryInitialization-beanFactory"><a href="#finishBeanFactoryInitialization-beanFactory" class="headerlink" title="finishBeanFactoryInitialization(beanFactory);"></a>finishBeanFactoryInitialization(beanFactory);</h3><p>初始化所有的剩下的单实例Bean对象</p><p>1）beanFactory.preInstantiateSingletons();初始化剩下的单实例Bean</p><p>1.1 获取容器中的所有Bean，依次初始化和创建对象</p><p>1.2 获取Bean的定义信息：RootBeanDefinition</p><p>1.3 Bean不是抽象的、是单实例、是懒加载  </p><p>　　1.3.1 判断是不是FactoryBean；是否是实现FactoryBean接口的Bean  </p><p>　　1.3.2 不是工厂Bean，就利用getBean()获取Bean对象。 </p><hr><p>　　　　1.3.2.1）getBean(beanName);ioc.getBean();</p><p>　　　　1.3.2.2) doGetBean(name,null,null,false);</p><p>　　　　1.3.2.3) 先获取缓存中保存的单实例bean。如果能获取说明这个Bean之前创建过（所有创建过的单实例Bean都会被保存起来）</p><p>　　　　1.3.2.4）缓存中获取不到，开始Bean的创建对象流程</p><p>　　　　1.3.2.5）标记当前Bean已经被创建，防止多线程下创建多个单实例Bean</p><p>　　　　1.3.2.6）获取Bean的定义信息</p><p>　　　　1.3.2.7）获取当前Bean依赖的其他Bean；如果有按照getBean()把依赖的Bean先创建出来；</p><p>　　　　1.3.2.8）启动单实例Bean的创建过程：</p><hr><p>　　　　　　1.3.2.8.1) createBean(beanName,mbd,args)</p><p>　　　　　　1.3.2.8.2) resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor在Bean的创建之前执行，是InstantiationAwareBeanPostProcessor类型的后置处理器。看是否是需要创建代理对象。</p><p>先触发applyBeanPostProcessorsBeforeInstantiation：postProcessBeforeInstantiation()</p><p>如果有返回值：applyBeanPostProcessorsAfterInitialization：postProcessAfterInitialization()</p><p>　　　　　　1.3.2.8.3)如果前面InstantiationAwareBeanPostProcessor没有返回值，说明不需要创建代理对象。</p><p>　　　　　　1.3.2.8.4)Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean</p><hr><p>　　　　　　　　1.3.2.8.4.1) instanceWrapper = createBeanInstance(beanName, mbd, args);创建Bean对象；利用工厂方法或者构造器创建出Bean对象</p><p>　　　　　　　　1.3.2.8.4.2) applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);</p><p>　　　　　　　　1.3.2.8.4.3) 【属性赋值】populateBean(beanName, mbd, instanceWrapper);</p><hr><p>赋值之前：<br>　　　　　　　　　　1.3.2.8.4.3.1) InstantiationAwareBeanPostProcessor后置处理器；<br>postProcessAfterInstrantiation();</p><p>　　　　　　　　　　1.3.2.8.4.3.2) InstantiationAwareBeanPostProcessor后置处理器；<br>postProcessPropertyValues();</p><p>赋值之后：<br>　　　　　　　　　　1.3.2.8.4.3.3) 应用Bean属性的值：为属性利用setter方法等进行赋值<br>applyPropertyValues(beanName, mbd, bw, pvs);</p><p>　　　　　　　　　　1.3.2.8.4.4) 【Bean初始化】initializeBean(beanName, exposedObject, mbd)；</p><hr><p>1.3.2.8.4.4.1) 【执行Aware接口方法】invokeAwareMethods(beanName, bean);</p><pre class=" language-java"><code class="language-java">     <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">Aware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">BeanNameAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>BeanNameAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setBeanName</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">BeanClassLoaderAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>BeanClassLoaderAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setBeanClassLoader</span><span class="token punctuation">(</span><span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">BeanFactoryAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>BeanFactoryAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setBeanFactory</span><span class="token punctuation">(</span>AbstractAutowireCapableBeanFactory<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><p>1.3.2.8.4.4.2) 【执行后置处理器初始化之前】 </p><p>applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>beanProcessor.postProcessBeforeInitialization(result, beanName);</p><p>1.3.2.8.4.4.3)【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);</p><hr><p>1.3.2.8.4.4.3.1) 是否是InitializingBean接口的实现；执行接口规定的初始化</p><p>1.3.2.8.4.4.3.2) 是否自定义初始化方法：invokeCustomInitMethod(beanName, bean, mbd);</p><hr><p>1.3.2.8.4.4.4)【执行后置处理器初始化之后】  </p><p>applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>beanProcessor.postProcessAfterInitialization(result, beanName);</p><p>1.3.2.8.4.5)【注册Bean的销毁方法】：DisposableBeanAdapter</p><p>1.3.2.8.5）将创建的Bean添加到缓存中singletonObjects；<br>ioc容器就是这些Map：很多的Map里面保存了单实例Bean，环境信息····</p><p>所有的Bean都利用getBean()创建完后：<br> 检查所有的Bean是否是SmartInitializingSingleton接口类型；如果是，就执行afterSingletonsInstantion()方法</p><h3 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh();"></a>finishRefresh();</h3><p>完成BeanFactory的初始化创建工作；IoC容器就创建完了。</p><p>1）initLifecycleProcessor();初始化和生命周期有关的后置处理器：LifecycleProcessor</p><p>默认从容器中找是否是lifecycleProcessor的组件；如果没有，创建一个默认的 new DefaultLifecycleProcessor()；并加入到容器中。</p><p>2）getLifecycleProcessor().onRefresh();</p><p>拿到前面定义的生命周期处理器，并回调onRefresh()方法。</p><p>3）publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件。</p><p>4）LiveBeansView.registerApplicationContext(this);</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1）<strong>Spring容器在启动的时候，先会保存所有注册进来的Bean定义信息。</strong></p><p>1.1 xml注册的bean；<bean></bean></p><p>1.2 注解注册Bean:@Bean、@Service、@Component、XXX</p><p>2）<strong>Spring容器会在合适的时候创建这些Bean</strong></p><p>2.1 用到这个bean的时候，利用getBean创建bean；创建好以后保存在容器中；</p><p>2.2 统一创建剩下的所有单实例bean；finishBeanFactoryInitialization(beanFactory);</p><p>3）<strong>后置处理器</strong></p><p>每个bean创建完后，都会使用各种后置处理器进行处理；来增强bean的功能；  </p><p>AutowiredAnnotationBeanPostProcessor：处理自动注入</p><p>AnnotationAwareAspectJAutoProxyCreator：来做AOP功能</p><p>XXX····</p><p>增强的功能注解：</p><p>AsyncAnnotationBeanPostProcessor</p><p>4）<strong>事件驱动模型：</strong></p><p>ApplicationListener：事件监听器</p><p>ApplicationEventMulticaster：事件派发</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_15</title>
      <link href="/2018/10/22/spring-annotation-day-15/"/>
      <url>/2018/10/22/spring-annotation-day-15/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong> </p><p>今天，来讲解其他的扩展原理，帮助大家学习其他的小知识点</p><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>BeanPostProcessor：bean的后置处理器，bean创建对象初始化前后进行拦截工作的。  </p><p>BeanFactoryPostProcessor：BeanFactory的后置处理器，在BeanFactory标准初始化之后调用，来定制和修改BeanFactory的内容，所有的Bean的定义已经保存加载到BeanFactory，<strong>但是bean的实例还没有创建</strong>。</p><h4 id="创建ExConfig配置类："><a href="#创建ExConfig配置类：" class="headerlink" title="创建ExConfig配置类："></a>创建ExConfig配置类：</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.liuzhuo.ext"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExtConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Blue <span class="token function">blue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Blue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="创建自定义的BeanFactoryPostProcessor："><a href="#创建自定义的BeanFactoryPostProcessor：" class="headerlink" title="创建自定义的BeanFactoryPostProcessor："></a>创建自定义的BeanFactoryPostProcessor：</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanFactoryPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanFactoryPostProcessor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * @param beanFactory     * @throws BeansException     * 在BeanFactory标准初始化之后调用，来定制和修改BeanFactory的内容，     * 此时，所有的bean的定义信息已经保存到BeanFactory，但是Bean还没有创建     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>ConfigurableListableBeanFactory beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"postProcessBeanFactory·······"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBeanDefinitionCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String name <span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="创建新的测试类："><a href="#创建新的测试类：" class="headerlink" title="创建新的测试类："></a>创建新的测试类：</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IoCTest_EXT</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span>             <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>ExtConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h4><pre><code>postProcessBeanFactory·······org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactoryextConfigmyBeanFactoryPostProcessorblue</code></pre><p><strong>能看到，我们获取了所有的BeanFactory中定义的bean了，但是还没有创建bean的实例对象</strong>。</p><h4 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h4><p>给MyBeanFactoryPostProcessor中的postProcessBeanFactory方法加上断点，并运行。</p><p>过程：<br>1）加载容器。<br>2）refresh();刷新容器<br>3）invokeBeanFactoryPostProcessors(beanFactory);</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">,</span> IllegalStateException <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Allows post-processing of the bean factory in context subclasses.</span>        <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Invoke factory processors registered as beans in the context.</span>        <span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Register bean processors that intercept bean creation.</span>        <span class="token function">registerBeanPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Initialize message source for this context.</span>        <span class="token function">initMessageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Initialize event multicaster for this context.</span>        <span class="token function">initApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Initialize other special beans in specific context subclasses.</span>        <span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Check for listener beans and register them.</span>        <span class="token function">registerListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Instantiate all remaining (non-lazy-init) singletons.</span>        <span class="token function">finishBeanFactoryInitialization</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Last step: publish corresponding event.</span>        <span class="token function">finishRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>能发现，invokeBeanFactoryPostProcessors(beanFactory);是在finishBeanFactoryInitialization(beanFactory);方法之前的，就说明了BeanFactoryPostProcessor是在bean的实例化之前的，是在BeanFactory实例化之后的。</p><hr><h3 id="BeanDefinitionRegisterPostProcessor"><a href="#BeanDefinitionRegisterPostProcessor" class="headerlink" title="BeanDefinitionRegisterPostProcessor"></a>BeanDefinitionRegisterPostProcessor</h3><p>BeanDefinitionRegisterPostProcessor extends BeanFactoryPostProcessor</p><p>在所有bean定义信息将要被加载，bean实例还未创建。</p><p>优先于BeanFactoryPostProcessor执行<br>利用BeanDefinitionRegisterPostProcessor给容器中再额外添加一些组件。</p><p>原理：<br>1）ioc创建对象<br>2）refresh() -&gt; invokeBeanFactoryPostProcessors(beanFactory);<br>3) 从容器中获取所有的BeanDefinitionRegisterPostProcessor组件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)依次触发所有的postProcessorBeanDefinitionRegistry()方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)再次触发postProcessorBeanFactory()方法的BeanFactoryPostProcessor；<br>4）再来从容器中找到BeanFactoryPostProcessor组件；然后依次触发postProcessorBeanFactory()方法</p><h4 id="创建MyBeanDefinitionRegisterPostProcessor类："><a href="#创建MyBeanDefinitionRegisterPostProcessor类：" class="headerlink" title="创建MyBeanDefinitionRegisterPostProcessor类："></a>创建MyBeanDefinitionRegisterPostProcessor类：</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanDefinitionRegisterPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//先执行</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanDefinitionRegistry</span><span class="token punctuation">(</span>BeanDefinitionRegistry registry<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"postProcessBeanDefinitionRegistry······"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> registry<span class="token punctuation">.</span><span class="token function">getBeanDefinitionCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"容器中注册的bean的个数(1)："</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//还能注册新的bean组件</span>        RootBeanDefinition beanDefinition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span>Blue<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//后执行</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>ConfigurableListableBeanFactory beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"postProcessBeanFactory··········"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBeanDefinitionCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"容器中注册的bean的个数(2)："</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="运行测试类"><a href="#运行测试类" class="headerlink" title="运行测试类:"></a>运行测试类:</h4><pre><code>十月 22, 2018 11:32:15 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 11:32:15 CST 2018]; root of context hierarchypostProcessBeanDefinitionRegistry······容器中注册的bean的个数(1)：10postProcessBeanFactory··········容器中注册的bean的个数(2)：11十月 22, 2018 11:32:15 上午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;信息: JSR-330 &#39;javax.inject.Inject&#39; annotation found and supported for autowiringpostProcessBeanFactory·······org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactoryextConfigmyBeanDefinitionRegisterPostProcessormyBeanFactoryPostProcessorbluehello十月 22, 2018 11:32:15 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 11:32:15 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>能发现<br>1）首先执行BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法<br>2）再执行BeanDefinitionRegistryPostProcessor的postProcessBeanFactory()方法<br>3）最后执行BeanFactoryPostProcessor的postProcessBeanFactory()方法</p><h4 id="调试-原理"><a href="#调试-原理" class="headerlink" title="调试(原理)"></a>调试(原理)</h4><p>给MyBeanDefinitionRegisterPostProcessor的postProcessBeanDefinitionRegistry()方法打上断点，并debug。</p><p>1）加载容器<br>2）refresh();刷新容器<br>3）invokeBeanFactoryPostProcessors(beanFactory);和BeanFactoryPostProcessor的流程一样<br>4）invokeBeanFactoryPostProcessors()</p><p>在invokeBeanFactoryPostProcessors()方法中，可以看到<br>1）首先获取所有的BeanDefinitionRegistryPostProcessor的定义信息</p><pre class=" language-java"><code class="language-java">String<span class="token punctuation">[</span><span class="token punctuation">]</span> postProcessorNames <span class="token operator">=</span>    beanFactory<span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span>BeanDefinitionRegistryPostProcessor<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String ppName <span class="token operator">:</span> postProcessorNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">isTypeMatch</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> PriorityOrdered<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        currentRegistryProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> BeanDefinitionRegistryPostProcessor<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        processedBeans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>2）然后调用invokeBeanDefinitionRegistryPostProcessors()方法：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">invokeBeanDefinitionRegistryPostProcessors</span><span class="token punctuation">(</span>            Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token operator">></span> postProcessors<span class="token punctuation">,</span> BeanDefinitionRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>BeanDefinitionRegistryPostProcessor postProcessor <span class="token operator">:</span> postProcessors<span class="token punctuation">)</span> <span class="token punctuation">{</span>            postProcessor<span class="token punctuation">.</span><span class="token function">postProcessBeanDefinitionRegistry</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>3) 再调用invokeBeanFactoryPostProcessors：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>            Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">BeanFactoryPostProcessor</span><span class="token operator">></span> postProcessors<span class="token punctuation">,</span> ConfigurableListableBeanFactory beanFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>BeanFactoryPostProcessor postProcessor <span class="token operator">:</span> postProcessors<span class="token punctuation">)</span> <span class="token punctuation">{</span>            postProcessor<span class="token punctuation">.</span><span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>4) 获取所有的BeanFactoryPostProcessor的定义信息</p><pre class=" language-java"><code class="language-java">String<span class="token punctuation">[</span><span class="token punctuation">]</span> postProcessorNames <span class="token operator">=</span>        beanFactory<span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span>BeanFactoryPostProcessor<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>5）调用invokeBeanFactoryPostProcessors：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>            Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">BeanFactoryPostProcessor</span><span class="token operator">></span> postProcessors<span class="token punctuation">,</span> ConfigurableListableBeanFactory beanFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>BeanFactoryPostProcessor postProcessor <span class="token operator">:</span> postProcessors<span class="token punctuation">)</span> <span class="token punctuation">{</span>            postProcessor<span class="token punctuation">.</span><span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><hr><h3 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener:"></a>ApplicationListener:</h3><p>监听容器中发布的事件。事件驱动模型开发。</p><p>步骤：</p><p>1）写一个监听器(ApplicationListener实现类)来监听某个事件(ApplicationEvent及其子类)</p><p>2) 把监听器加入到容器中</p><p>3）只要容器中有相关事件的发布，我们就能监听到这个事件</p><p>4）发布一个事件: applicationContext.publishEvent();</p><h4 id="编写一个MyApplicationListener"><a href="#编写一个MyApplicationListener" class="headerlink" title="编写一个MyApplicationListener"></a>编写一个MyApplicationListener</h4><pre class=" language-javascript"><code class="language-javascript">@Component<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyApplicationListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token operator">&lt;</span>ApplicationEvent<span class="token operator">></span> <span class="token punctuation">{</span>    @Override    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span>ApplicationEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"监听:"</span> <span class="token operator">+</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="运行测试类："><a href="#运行测试类：" class="headerlink" title="运行测试类："></a>运行测试类：</h4><pre><code>十月 22, 2018 8:42:11 下午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;信息: JSR-330 &#39;javax.inject.Inject&#39; annotation found and supported for autowiring监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:42:11 CST 2018]; root of context hierarchy]十月 22, 2018 8:42:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:42:11 CST 2018]; root of context hierarchy监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:42:11 CST 2018]; root of context hierarchy]</code></pre><p>说明容器，为我们发布了两个事件：ContextRefreshedEvent 和 ContextClosedEvent</p><h4 id="发布自己的事件"><a href="#发布自己的事件" class="headerlink" title="发布自己的事件"></a>发布自己的事件</h4><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span>             <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>ExtConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        applicationContext<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"自定义事件"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行：</p><pre><code>监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:47:38 CST 2018]; root of context hierarchy]监听:com.liuzhuo.test.IoCTest_EXT$1[source=自定义事件]监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Mon Oct 22 20:47:38 CST 2018]; root of context hierarchy]</code></pre><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>1）初始化容器；refresh();</p><p>2）finishRefresh();  // Last step: publish corresponding event.</p><p>3）publishEvent(new ContextRefreshedEvent(this));发布事件</p><p>4）getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);获取派发器</p><p>5）获取所有的ApplicationListener：for (final ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type))</p><p>6）如果有Executor，可以支持使用Executor进行异步派发，否则，使用同步方式直接执行invokeListener(listener, event);</p><p>7）doInvokeListener(listener, event);回调listener.onApplicationEvent(event);</p><p>我们这里的三个事件：  </p><p>1）finishRefresh();容器刷新完成后，执行ContextRefreshedEvent事件。</p><p>2）自己发布的事件</p><p>3）容器关闭会发布ContextClosedEvent事件</p><hr><p>事件派发器(EventMulticaster)：</p><p>1）容器创建对象；refresh();</p><p>2）initApplicationEventMulticaster();初始化事件派发器</p><p>3）先去查看容器中是否有id=“applicationEventMulticaster”组件，如果有直接使用，没有的话，new SimpleApplicationEventMulticaster()组件。并且加入到容器中。我们就可以在其他组件要派发事件时，自动注入这个applicationEventMulticaster组件。</p><hr><p>容器中有哪些监听器：</p><p>1）容器创建对象；refresh();</p><p>2）registerListeners(); //注册监听器<br>从容器中拿到所有的监听器，把它们注册到applicationEventMulticaster中。<br>String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);<br>getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</p><h3 id="EventListener"><a href="#EventListener" class="headerlink" title="@EventListener"></a>@EventListener</h3><p>@EventListener注解，可以使普通类的普通方法来监听事件，不用去实现ApplicationEvent接口。</p><p>1）在com.liuzhuo.ext包下，创建UserService类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@EventListener</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span>ApplicationEvent<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span>ApplicationEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"UserService监听:"</span> <span class="token operator">+</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2) 运行IoCTest_EXT测试类：</p><pre><code>UserService监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]监听:org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]UserService监听:com.liuzhuo.test.IoCTest_EXT$1[source=自定义事件]监听:com.liuzhuo.test.IoCTest_EXT$1[source=自定义事件]UserService监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]监听:org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Tue Oct 23 09:52:08 CST 2018]; root of context hierarchy]</code></pre><p>3) 原理：</p><p>@EventListener使用EventListenerMethodProcessor处理器来完成的</p><pre class=" language-java"><code class="language-java"><span class="token operator">*</span> <span class="token annotation punctuation">@author</span> Stephane Nicoll <span class="token operator">*</span> <span class="token annotation punctuation">@since</span> <span class="token number">4.2</span> <span class="token operator">*</span> <span class="token annotation punctuation">@see</span> EventListenerMethodProcessor <span class="token operator">*</span><span class="token operator">/</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>ANNOTATION_TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EventListener</span></code></pre><p>点击EventListenerMethodProcessor处理器：</p><pre><code>public class EventListenerMethodProcessor implements SmartInitializingSingleton, ApplicationContextAware</code></pre><p>实现了SmartInitializingSingleton接口，所有重点是SmartInitializingSingleton接口。</p><p>点击SmartInitializingSingleton接口：</p><pre><code>public interface SmartInitializingSingleton {    /**     * Invoked right at the end of the singleton pre-instantiation phase,     * with a guarantee that all regular singleton beans have been created     * already. {@link ListableBeanFactory#getBeansOfType} calls within     * this method won&#39;t trigger accidental side effects during bootstrap.     * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This callback won&#39;t be triggered for singleton beans     * lazily initialized on demand after {@link BeanFactory} bootstrap,     * and not for any other bean scope either. Carefully use it for beans     * with the intended bootstrap semantics only.     */    void afterSingletonsInstantiated();}</code></pre><p>其中有一个方法：afterSingletonsInstantiated(); 该方法是在所有的单实例初始化完成后才调用的。</p><p>调试：<br>给UserService类打上断点，并debug。</p><p>1）ioc容器创建对象；refresh();刷新容器</p><p>2）finishBeanFactoryInitialization(beanFactory)；初始化剩下的单实例bean</p><p>3）先创建所有的单实例bean；getBean();</p><p>4) 获取所有创建好的单实例bean，判断是否是SmartInitializingSingleton类型的，如果是就调用afterSingletonsInstantiated()方法</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_14</title>
      <link href="/2018/10/20/spring-annotation-day-14/"/>
      <url>/2018/10/20/spring-annotation-day-14/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong> </p><p>今天来学习Spring的声明式事务。</p><h4 id="不使用事务"><a href="#不使用事务" class="headerlink" title="不使用事务"></a>不使用事务</h4><p>环境搭建</p><p>1）导入相关依赖</p><p>数据源、数据驱动、Spring-jdbc模块.<br>数据源、数据驱动之前已经导入过，现在只需要Spring-jdbc模块.</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;5.1.1.RELEASE&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>2）创建com.liuzhuo.tx包，并创建TxConfig类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.liuzhuo.tx"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TxConfig</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//c3p0的数据源</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> DataSource <span class="token function">dataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ComboPooledDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setJdbcUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setDriverClass</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dataSource<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//注入jdbcTemplate模板</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> JdbcTemplate <span class="token function">jdbcTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        JdbcTemplate jdbcTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JdbcTemplate</span><span class="token punctuation">(</span><span class="token function">dataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> jdbcTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>注意，这里的数据链接url，必须加上?serverTimezone=GMT%2B8，这是在使用MySQL 8.0以上版本时候必须加上的，否则会出现时区问题！！！！</strong></p><p>3）在com.liuzhuo.tx包下，创建UserService和UserDao类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserDao userDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        userDao<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"插入成功!!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Repository</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDao</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> JdbcTemplate jdbcTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String sql <span class="token operator">=</span> <span class="token string">"insert into tbl_user(username,age) VALUES(?,?);"</span><span class="token punctuation">;</span>        String username <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>        jdbcTemplate<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>sql<span class="token punctuation">,</span> username<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>4) 创建新的测试类IoCTest_TX：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IoCTest_TX</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span>             <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>TxConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        UserService userService <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>UserService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userService<span class="token punctuation">.</span><span class="token function">insertUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>5) 运行测试方法：</p><pre><code>十月 20, 2018 10:42:43 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Sat Oct 20 10:42:43 CST 2018]; root of context hierarchy十月 20, 2018 10:42:43 上午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;信息: JSR-330 &#39;javax.inject.Inject&#39; annotation found and supported for autowiring十月 20, 2018 10:42:43 上午 com.mchange.v2.log.MLog 信息: MLog clients using java 1.4+ standard logging.十月 20, 2018 10:42:44 上午 com.mchange.v2.c3p0.C3P0Registry 信息: Initializing c3p0-0.9.5.2 [built 08-December-2015 22:06:04 -0800; debug? true; trace: 10]十月 20, 2018 10:42:44 上午 com.mchange.v2.c3p0.impl.AbstractPoolBackedDataSource 信息: Initializing c3p0 pool... com.mchange.v2.c3p0.ComboPooledDataSource [ acquireIncrement -&gt; 3, acquireRetryAttempts -&gt; 30, acquireRetryDelay -&gt; 1000, autoCommitOnClose -&gt; false, automaticTestTable -&gt; null, breakAfterAcquireFailure -&gt; false, checkoutTimeout -&gt; 0, connectionCustomizerClassName -&gt; null, connectionTesterClassName -&gt; com.mchange.v2.c3p0.impl.DefaultConnectionTester, contextClassLoaderSource -&gt; caller, dataSourceName -&gt; 2s4fkk9y13rx1eqqia0s|69b2283a, debugUnreturnedConnectionStackTraces -&gt; false, description -&gt; null, driverClass -&gt; com.mysql.jdbc.Driver, extensions -&gt; {}, factoryClassLocation -&gt; null, forceIgnoreUnresolvedTransactions -&gt; false, forceSynchronousCheckins -&gt; false, forceUseNamedDriverClass -&gt; false, identityToken -&gt; 2s4fkk9y13rx1eqqia0s|69b2283a, idleConnectionTestPeriod -&gt; 0, initialPoolSize -&gt; 3, jdbcUrl -&gt; jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8, maxAdministrativeTaskTime -&gt; 0, maxConnectionAge -&gt; 0, maxIdleTime -&gt; 0, maxIdleTimeExcessConnections -&gt; 0, maxPoolSize -&gt; 15, maxStatements -&gt; 0, maxStatementsPerConnection -&gt; 0, minPoolSize -&gt; 3, numHelperThreads -&gt; 3, preferredTestQuery -&gt; null, privilegeSpawnedThreads -&gt; false, properties -&gt; {user=******, password=******}, propertyCycle -&gt; 0, statementCacheNumDeferredCloseThreads -&gt; 0, testConnectionOnCheckin -&gt; false, testConnectionOnCheckout -&gt; false, unreturnedConnectionTimeout -&gt; 0, userOverrides -&gt; {}, usesTraditionalReflectiveProxies -&gt; false ]Loading class `com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&#39;. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.Sat Oct 20 10:42:45 CST 2018 WARN: Establishing SSL connection without server&#39;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&#39;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &#39;false&#39;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.Sat Oct 20 10:42:45 CST 2018 WARN: Establishing SSL connection without server&#39;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&#39;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &#39;false&#39;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.Sat Oct 20 10:42:45 CST 2018 WARN: Establishing SSL connection without server&#39;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&#39;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &#39;false&#39;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.插入成功!!!!十月 20, 2018 10:42:45 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@6d1e7682: startup date [Sat Oct 20 10:42:43 CST 2018]; root of context hierarchy</code></pre><p>看到插入成功，打开数据库也能发现数据库中多了一条新的记录。</p><p>ps：以上操作是建立在本地存在数据库test，和一个表，表的字段有: id自增，username用户名，age用户的年龄，这里就不详细描述数据库的创建过程了。</p><hr><p>6）修改UserService类：<br>添加 int res = 1 / 0;</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserDao userDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        userDao<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"插入成功!!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>7）再次运行测试方法：</p><pre><code>插入成功!!!!java.lang.ArithmeticException: / by zero    at com.liuzhuo.tx.UserService.insertUser(UserService.java:21)    at com.liuzhuo.test.IoCTest_TX.test01(IoCTest_TX.java:23)</code></pre><p><strong>会出现异常。打开数据库，发现还是会添加一条新的记录，这是因为没有添加事务的原因。</strong></p><h3 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h3><p>1）修改UserService类：<br>添加@Transactional注解</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserDao userDao<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Transactional</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        userDao<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"插入成功!!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2) 运行测试方法：</p><pre><code>插入成功!!!!java.lang.ArithmeticException: / by zero</code></pre><p>出现ArithmeticException异常，打开数据库，发现还是会添加一条数据，说明事务还没有添加上去，<strong>因为没有开启注解时事务</strong>。</p><p>3）修改配置类<br>添加@EnableTransactionManagement注解</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.liuzhuo.tx"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableTransactionManagement</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TxConfig</span> </code></pre><p>4) 运行测试方法：</p><pre><code>No qualifying bean of type &#39;org.springframework.transaction.PlatformTransactionManager&#39; available</code></pre><p>发现出现没有PlatformTransactionManager这个组件的异常，此时虽然数据库没有添加一条数据，但是是出现了其他异常，而不是出现ArithmeticException异常。</p><p>出现没有PlatformTransactionManager这个组件异常，说明我们还需要配置事务管理器。</p><p>5) 添加事务管理器</p><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">//添加事务管理器</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> PlatformTransactionManager <span class="token function">transactionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DataSourceTransactionManager</span><span class="token punctuation">(</span><span class="token function">dataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>6) 运行测试方法：</p><pre><code>插入成功!!!!java.lang.ArithmeticException: / by zero</code></pre><p>出现了ArithmeticException异常，打开数据库，发现也没有添加新的一条记录，说明事务起作用了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用事务的步骤：</p><ol><li>添加相关的依赖(Spring-jdbc)</li><li>配置数据源、事务管理器(PlatformTransactionManager)</li><li>开始注解式事务(@EnableTransactionManagement)</li><li>给相关的方法添加@Transactional注解</li></ol><hr><h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><p>点击@EnableTransactionManagement注解：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span>TransactionManagementConfigurationSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableTransactionManagement</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> <span class="token function">proxyTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    AdviceMode <span class="token function">mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> AdviceMode<span class="token punctuation">.</span>PROXY<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">order</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">2147483647</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>@Import({TransactionManagementConfigurationSelector.class})</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span>AdviceMode adviceMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>adviceMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> PROXY<span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>AutoProxyRegistrar<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        ProxyTransactionManagementConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> ASPECTJ<span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token function">determineTransactionAspectClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>会导入AutoProxyRegistrar和ProxyTransactionManagementConfiguration两个组件。</p><p>1）AutoProxyRegistrar会给容器注入InfrastructureAdvisorAutoProxyCreator组件（也是一个后置处理器）。</p><p>InfrastructureAdvisorAutoProxyCreator组件利用后置处理器机制在对象创建时，包装对象，返回一个代理对象（增强器），代理对象执行方法利用拦截器链执行。</p><p>2）ProxyTransactionManagementConfiguration</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给容器注入事务增强器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务增强器要用事务注解的信息<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务拦截器：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TransactionInterceptor：保存了事务属性信息，事务管理器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是一个MethodInterceptor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在目标方法执行的时候：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行拦截器链：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务拦截器：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先获取事务相关的属性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再获取事务管理器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行目标方法：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果异常，获取事务管理器，回滚<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果正常，利用事务管理器，提交事务</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring4配置文件详解</title>
      <link href="/2018/10/19/spring4-pei-zhi-wen-jian-xiang-jie/"/>
      <url>/2018/10/19/spring4-pei-zhi-wen-jian-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>总结Spring4中的各种配置文件的信息。</p><p>欢迎大家补充，完善各种配置信息。</p><p>好的习惯，将会伴随你的一生。</p><p>开始今天的主题！！！</p><h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><hr><p>基本的加载properties配置文件</p><pre><code>&lt;context:property-placeholder location=&quot;classpath*:/appConfig.properties&quot; /&gt;</code></pre><h4 id="JNDI方式"><a href="#JNDI方式" class="headerlink" title="JNDI方式"></a>JNDI方式</h4><pre><code>&lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;/jdbc/mysqlDS&quot; resource-ref=&quot;true&quot;/&gt;</code></pre><p>jndi-name：指定JNDI中资源名称</p><p>resource-ref：如果应用程序运行在java应用程序服务器中，值设为true，这样jndi-name会自动加上java:comp/env/前缀</p><h4 id="数据连接池方式"><a href="#数据连接池方式" class="headerlink" title="数据连接池方式"></a>数据连接池方式</h4><h5 id="DBCP连接池："><a href="#DBCP连接池：" class="headerlink" title="DBCP连接池："></a>DBCP连接池：</h5><p>使用：org.apache.commons.dbcp.BasicDataSource进行配置</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;  &lt;!-- 【必须】  数据库驱动--&gt;  &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;  &lt;!-- 【必须】 数据库连接地址 --&gt;  &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;  &lt;!-- 【必须】 数据库用户名 --&gt;  &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;  &lt;!-- 【必须】 数据库密码 --&gt;  &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;  &lt;!-- 可选 启动时创建的连接数 --&gt;  &lt;property name=&quot;initialSize&quot; value=&quot;5&quot;/&gt;  &lt;!-- 可选 同时可从池中分配的最多连接数，0无限制 --&gt;  &lt;property name=&quot;maxActive&quot; value=&quot;10&quot;/&gt;  &lt;!-- 可选 池中不会被释放的最多空闲连接数 0无限制 --&gt;  &lt;property name=&quot;maxIdle&quot; value=&quot;&quot;/&gt;  &lt;!-- 可选 同时能从语句池中分配的预处理语句最大值，0无限制 --&gt;  &lt;property name=&quot;maxOpenPreparedStatement&quot; value=&quot;100&quot;/&gt;  &lt;!-- 可选 抛异常前池等待连接回收最大时间（当无可用连接），-1无限等待 --&gt;  &lt;property name=&quot;maxWait&quot; value=&quot;1000&quot;/&gt;  &lt;!-- 可选 连接在池中保持空闲而不被回收的最大时间 --&gt;  &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;2000&quot;/&gt;  &lt;!-- 可选 不创建新连接情况下池中保持空闲的最小连接数 --&gt;  &lt;property name=&quot;minIdle&quot; value=&quot;2&quot;/&gt;  &lt;!-- 可选 布尔值，是否对预处理语句进行池管理 --&gt;  &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt;&lt;/bean&gt;</code></pre><h5 id="C3P0连接池："><a href="#C3P0连接池：" class="headerlink" title="C3P0连接池："></a>C3P0连接池：</h5><p>使用：com.mchange.v2.c3p0.ComboPooledDataSource进行配置</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; destroy-method=&quot;close&quot;&gt;  &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot; /&gt;  &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot; /&gt;  &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot; /&gt;  &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;&lt;/bean&gt;</code></pre><h5 id="alibaba-DRUID连接池："><a href="#alibaba-DRUID连接池：" class="headerlink" title="alibaba DRUID连接池："></a>alibaba DRUID连接池：</h5><p>使用：com.alibaba.druid.pool.DruidDataSource进行配置</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;     &lt;!-- 基本属性 url、user、password --&gt;    &lt;property name=&quot;url&quot; value=&quot;${jdbc_url}&quot; /&gt;    &lt;property name=&quot;username&quot; value=&quot;${jdbc_user}&quot; /&gt;    &lt;property name=&quot;password&quot; value=&quot;${jdbc_password}&quot; /&gt;    &lt;!-- 配置初始化大小、最小、最大 --&gt;    &lt;property name=&quot;initialSize&quot; value=&quot;1&quot; /&gt;    &lt;property name=&quot;minIdle&quot; value=&quot;1&quot; /&gt;     &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt;    &lt;!-- 配置获取连接等待超时的时间 --&gt;    &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt;    &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;    &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt;    &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;    &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot; /&gt;    &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT &#39;x&#39;&quot; /&gt;    &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt;    &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt;    &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt;    &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt;    &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot; /&gt;    &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;20&quot; /&gt;    &lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt;    &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt;  &lt;/bean&gt;</code></pre><h4 id="JDBC驱动的数据源"><a href="#JDBC驱动的数据源" class="headerlink" title="JDBC驱动的数据源"></a>JDBC驱动的数据源</h4><p>使用：</p><p>org.springframework.jdbc.datasource.SingleConnectionDataSource【每个链接请求会返回同一个连接，不推荐】</p><p>org.springframework.jdbc.datasource.DriverManagerDataSource进行配置</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;  &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;  &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;  &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;  &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;&lt;/bean&gt;</code></pre><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><hr><h4 id="spring-JDBC模板"><a href="#spring-JDBC模板" class="headerlink" title="spring JDBC模板"></a>spring JDBC模板</h4><p>模板类选择：</p><p>JdbcTemplate：提供最简单的数据访问等功能。</p><p>NamedParameterJdbcTemplate：通过该模板，可以把参数作为查询的条件传入方法中。</p><p>SimpleJdbcTemplate（推荐）：结合了一些自动装箱等功能，2.5以后，整合了NamedParameterJdbcTemplate。</p><p>配置方式：</p><pre><code>&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.simple.SimpleJdbcTemplate&quot;&gt;  &lt;constructor-arg ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;</code></pre><h4 id="与ORM框架集成"><a href="#与ORM框架集成" class="headerlink" title="与ORM框架集成"></a>与ORM框架集成</h4><p>主要是配置spring的Session工厂（sessionFactory），可以使用到诸如延迟加载、预先抓取、级联复杂特性。</p><p>spring对ORM框架的支持提供提供了一些附加服务：</p><p>spring声明式事务集成支持</p><p>透明的异常处理</p><p>线程安全、轻量级的模板类</p><p>DAO支持</p><p>资源管理</p><h5 id="集成Hibernate方式：-hibernate4为例"><a href="#集成Hibernate方式：-hibernate4为例" class="headerlink" title="集成Hibernate方式：[hibernate4为例]"></a>集成Hibernate方式：[hibernate4为例]</h5><p>hibernate的HBM文件配置方式（Xxx.hbm.xml)：</p><pre><code>&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt;  &lt;!-- 数据源 --&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  &lt;!-- 映射文件形式--&gt;  &lt;property name=&quot;mappingResources&quot;&gt;     &lt;list&gt;        &lt;value&gt;User.hbm.xml&lt;/value&gt;     &lt;/list&gt;  &lt;/property&gt;  &lt;!-- Hibernate属性配置 --&gt;  &lt;property name=&quot;hibernateProperties&quot;&gt;     &lt;props&gt;         &lt;prop key=&quot;dialect&quot;&gt;            org.hibernate.dialect.MySQLDialect &lt;!-- 数据库方言 --&gt;         &lt;/prop&gt;        &lt;!-- ……其他 --&gt;     &lt;/props&gt;  &lt;/property&gt;&lt;/bean&gt;</code></pre><p>代码中使用注解的方式：</p><pre><code>&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt;  &lt;!-- 数据源 --&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;!-- 自动扫描实体对象 tdxy.bean的包结构中存放实体类  --&gt;  &lt;property name=&quot;packagesToScan&quot; value=&quot;com.test.entity&quot;/&gt;  &lt;!-- hibernate的相关属性配置 --&gt;  &lt;property name=&quot;hibernateProperties&quot;&gt;     &lt;value&gt;        &lt;!-- 设置数据库方言 --&gt;        hibernate.dialect=org.hibernate.dialect.MySQLDialect        &lt;!-- 设置自动创建|更新|验证数据库表结构 --&gt;        hibernate.hbm2ddl.auto=update                         &lt;!-- 是否在控制台显示sql --&gt;        hibernate.show_sql=true                         &lt;!-- 是否格式化sql，优化显示 --&gt;        hibernate.format_sql=true                        &lt;!-- 是否开启二级缓存 --&gt;        hibernate.cache.use_second_level_cache=false                        &lt;!-- 是否开启查询缓存 --&gt;        hibernate.cache.use_query_cache=false                        &lt;!-- 数据库批量查询最大数 --&gt;        hibernate.jdbc.fetch_size=50        &lt;!-- 数据库批量更新、添加、删除操作最大数  --&gt;        hibernate.jdbc.batch_size=50                        &lt;!-- 是否自动提交事务  --&gt;        hibernate.connection.autocommit=true        &lt;!-- 指定hibernate在何时释放JDBC连接  --&gt;        hibernate.connection.release_mode=auto        &lt;!-- 创建session方式 hibernate4.x 的方式  --&gt;        hibernate.current_session_context_class=org.springframework.orm.hibernate4.SpringSessionContext        &lt;!-- javax.persistence.validation.mode默认情况下是auto的，就是说如果不设置的话它是会自动去你的classpath下面找一个bean-validation**包，所以把它设置为none即可  --&gt;        javax.persistence.validation.mode=none                 &lt;/value&gt;  &lt;/property&gt;&lt;/bean&gt;</code></pre><p>针对少量实体类，还可以通过annotatedClasses属性来将应用程序中所有的持久化类以全局定名的方式明确列出：</p><pre><code>&lt;property name=&quot;annotatedClasses&quot;&gt;  &lt;list&gt;     &lt;value&gt;com.demo.entity.User&lt;/value&gt;     &lt;value&gt;com.demo.entity.Blog&lt;/value&gt;  &lt;/list&gt;&lt;/property&gt;</code></pre><p><strong>推荐使用packagesToScan属性扫描包方式。</strong></p><p>【构建不依赖于spring的Hibernate代码】</p><pre><code>package com.demo.dao;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import com.demo.entity.User;@Repositorypublic class UserDaoImpl implements IUserDao  {  private SessionFactory sessionFactory;  // 构造注入  @Autowired  public UserDaoImpl(SessionFactory sessionFactory) {     this.sessionFactory = sessionFactory;  }  private Session currentSession(){     return sessionFactory.getCurrentSession();  }  @Override  public void addUser(User param) {     Session session = currentSession();     session.save(param);     System.out.println(&quot;Add User&quot;);  }  @Override  public User get(Integer id) {     return (User) currentSession().get(User.class, id);  }  @Override  public void save(User user) {     currentSession().update(user);  }}</code></pre><p>还需配置：</p><pre><code>&lt;context:component-scan base-package=&quot;com.demo.dao&quot;/&gt;</code></pre><p>就会像扫描其他注解一样扫描带@Repository注解的类到容器中。</p><h5 id="集成MyBatis方式"><a href="#集成MyBatis方式" class="headerlink" title="集成MyBatis方式"></a>集成MyBatis方式</h5><pre><code>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;  p:dataSource-ref=&quot;dataSource&quot; p:configLocation=&quot;classpath:mybatis-config.xml&quot;  p:mapperLocations=&quot;classpath:com/demo/dao/*.xml&quot; /&gt;&lt;!-- spring与mybatis整合配置，扫描所有dao --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;  p:basePackage=&quot;com.demo.dao&quot; p:sqlSessionFactoryBeanName=&quot;sqlSessionFactory&quot; /&gt;</code></pre><h4 id="与其他JPA集成方式"><a href="#与其他JPA集成方式" class="headerlink" title="与其他JPA集成方式"></a>与其他JPA集成方式</h4><p>配置实体管理工厂</p><p>应用程序管理类型的JPA（LocalEntityManagerFactoryBean）：它的EntityManager是由EntityManagerFactory创建的；</p><p>容器管理类型的JPA（LocalContainerEntityManagerFactoryBean）：通过PersistenceProvider的createEntityManagerFactory()方法得到，即它的EntityManagerFactory是通过PersistenceProvider的createContainerEntityManagerFactory()方法得到。</p><p>使用应用程序管理类型的JPA</p><p>绝大部分配置文件来源于名为persistence.xml的配置文件，这个文件位置必须位于类路径下的WETA-INF目录下</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;persistence version=&quot;2.0&quot;     xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot;     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd&quot;&gt;  &lt;persistence-unit name=&quot;persistenceUnit&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;     &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;     &lt;properties&gt;        &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQL5Dialect&quot; /&gt;        &lt;property name=&quot;hibernate.max_fetch_depth&quot; value=&quot;3&quot;/&gt;        &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt;        &lt;property name=&quot;hibernate.jdbc.fetch_size&quot; value=&quot;18&quot;/&gt;        &lt;property name=&quot;hibernate.jdbc.batch_size&quot; value=&quot;10&quot;/&gt;        &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;false&quot;/&gt;        &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;false&quot;/&gt;     &lt;/properties&gt;     &lt;class&gt;com.demo.entity.User&lt;/class&gt;     &lt;class&gt;com.demo.entity.Blog&lt;/class&gt;     &lt;!-- …… ……--&gt;   &lt;/persistence-unit&gt;&lt;/persistence&gt;</code></pre><p>这样在spring的配置文件中配置的信息就很少了：</p><pre><code>&lt;bean id=&quot;demo&quot; class=&quot;org.springframework.orm.jpa.LocalEntityManagerFactoryBean&quot;&gt;  &lt;property name=&quot;persistenceUnit&quot; &gt;&lt;/bean&gt;</code></pre><p>【TIPS】上面persistence.xml文件中的配置会出现问题：</p><p>如果每次请求EntityManagerFactory时都要定义持久化单元，代码回迅速膨胀</p><p>借助spring对JPA的支持，不再需要直接处理PersistenceProvider了，就是下面的容器管理的JPA！</p><p>使用容器管理类型的JPA</p><p>将数据源信息配置在spring的应用上下文中，而不是在persistence.xml文件中。</p><pre><code>&lt;bean id=&quot;emf&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;   &lt;!-- 指定使用的是哪一个厂商的JPA实现 如Hibernate --&gt;  &lt;property name=&quot;jpaVendorAdapter&quot; ref=&quot;hibernateJpaVendorAdapter&quot;/&gt;&lt;/bean&gt;</code></pre><p>配置JPA实现：</p><p>可选的有：EclipseLinkJpaVendorAdapter、HibernateJpaVendorAdapter、OpenJpaVendorAdapter、TopLinkJpaVendorAdapter</p><pre><code>&lt;bean id=&quot;hibernateJpaVendorAdapter&quot; class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt;  &lt;property name=&quot;database&quot; value=&quot;MYSQL&quot;/&gt;  &lt;property name=&quot;showSql&quot; value=&quot;true&quot;/&gt;  &lt;property name=&quot;generateDdl&quot; value=&quot;true&quot;/&gt;  &lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQL5Dialect&quot;/&gt;&lt;/bean&gt;</code></pre><p>【TIPS】database属性：属性值表示支持哪种数据库，下面Hibernate的JPA是一些支持的数据库：<br><img src="http://pp66ww0jt.bkt.clouddn.com/20181019214107.png"></p><p><strong>【注】JNDI获取实体管理工厂：</strong></p><p>如果spring应用部署在应用服务器中，Spring可能已经创建好EntityManagerFactory并将其置于JNDI中等饭查询使用，这种情况可使用JNDI来获取对EntityManagerFactory的引用：</p><pre><code>&lt;jee:jndi-lookup id=&quot;emf&quot; jndi-name=&quot;persistence/testDS&quot;/&gt;</code></pre><p>编写基于JPA的DAO</p><pre><code>package com.demo.dao;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;import org.springframework.stereotype.Repository;import org.springframework.transaction.annotation.Transactional;import com.demo.entity.User;@Repository@Transactionalpublic class JpaDao implements IUserDao {  // 注入EntityManager  @PersistenceContext  private EntityManager em;  // 使用EntityManager  @Override  public void addUser(User param) {     em.persist(param);  }  @Override  public User get(Integer id) {     return em.find(User.class, id);  }  @Override  public void save(User user) {     em.merge(user);  }}</code></pre><p>上面使用到了@PersistenceContext注解将EntityManager注入。</p><p>这样用需要在spring的上下文配置文件中配置一个PersistenceAnnotationBeanPostProcessor：</p><pre><code>&lt;!-- 使用EntityManager --&gt;&lt;bean class=&quot;org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor&quot;/&gt;</code></pre><p>以上，是如何使用JDBC、Hibernate或JPA为spring应用程序构建持久层，至于选择哪种方案完全取决于偏好.</p><h3 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h3><p>通过毁掉机制将实际事务实现从事务性代码中抽象出来。</p><h4 id="选择事务管理器"><a href="#选择事务管理器" class="headerlink" title="选择事务管理器"></a>选择事务管理器</h4><p>事务管理器结构</p><p>事务处理流程：</p><p>开始事务-&gt;绑定资源-&gt;使用资源-&gt;完成事务-&gt;释放资源</p><h5 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h5><pre><code>&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;     &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;</code></pre><p>DataSourceTransactionManager通过调用java.sql.Connection来管理事务，由java.sql.Connection对象来提交、回滚事务。</p><h5 id="Hibernate事务"><a href="#Hibernate事务" class="headerlink" title="Hibernate事务"></a>Hibernate事务</h5><pre><code>&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;&gt;  &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;&lt;/bean&gt;</code></pre><p>HibernateTransactionManager通过将事务管理的职责委托给org.hibernate.Transaction对象，org.hibernate.Transaction对象从Hibernate Session中获取，然后由Transaction对象来提交、回滚事务。</p><h5 id="JPA事务"><a href="#JPA事务" class="headerlink" title="JPA事务"></a>JPA事务</h5><pre><code>&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;  &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt;&lt;/bean&gt;</code></pre><p>JpaTransactionManager只需要装配一个JPA实体管理工厂（EntityManagerFactory的任意实现），然后与由工厂产生的JPA EntityManager合作构建事务。</p><p>如果你还希望将事务应用于简单JDBC操作（JDBC操作使用的datasource和EntityManagerFactory使用的dataSource必须相同），那么JpaTransactionManager必须装配一个JpaDialect的实现：</p><pre><code>&lt;bean id=&quot;jpaDialect&quot; class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;/&gt;&lt;!--然后将jpaDialect装配到transactionManager中 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;  &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt;  &lt;property name=&quot;jpaDialect&quot; ref=&quot;jpaDialect&quot;/&gt;&lt;/bean&gt;</code></pre><h5 id="JTA事务"><a href="#JTA事务" class="headerlink" title="JTA事务"></a>JTA事务</h5><p>如果前面的事务管理器不能满足需求或事物需要跨多个事务资源（两个及以上数据库），需要使用JtaTrasactionManager了：</p><pre><code>&lt;bean id=&quot;transactionManager&quot;  class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;&gt;  &lt;property name=&quot;transactionManagerName&quot; value=&quot;java:/TrasactionManager&quot;/&gt;&lt;/bean&gt;</code></pre><p>JtaTransactionManager将事务委托给一个JTA的实现（java.transaction.UserTransaction和javax.transaction.TransactionManager），通过UserTransaction来操作事务。JTA规定了应用程序晕一个或多个数据源之间协调事务的标准API，transactionManagerName属性指定了要在JNDI上查找JTA事务管理器。</p><h4 id="Spring事务实现方式"><a href="#Spring事务实现方式" class="headerlink" title="Spring事务实现方式"></a>Spring事务实现方式</h4><p>1）编码事务</p><p>通过TransactionTemplate的回调机制，例如：（UserSeriveImpl.java）</p><pre><code>public void addUser(final User u) {  TransactionTemplate temp = new TransactionTemplate();  temp.execute(new TransactionCallback&lt;Void&gt;() {     @Override     public Void doInTransaction(TransactionStatus txtStatus) {          // 要执行的事务代码        try {           userDao.save(u);        } catch (RuntimeException e) {           e.printStackTrace();           txtStatus.setRollbackOnly();        }        return null;     }  });}</code></pre><p>此时UserService需要如下装配：</p><pre><code>&lt;bean id=&quot;userSerive&quot; class=&quot;com.demo.service.UserServiceImpl&quot;&gt;  &lt;property name=&quot;transactionTemplate&quot;&gt;     &lt;bean class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;     &lt;/bean&gt;  &lt;/property&gt;&lt;/bean&gt;</code></pre><p>优点：可以完全控制事务边界，精确控制事务。</p><p>缺点：侵入性的，事务控制在代码中实现，耦合度高</p><p>2）声明式事务</p><p>传播行为</p><p>传播行为回答了新的事务是该被启动还是被挂起，或者方法是否要在事务环境中运行。</p><p>事务的传播行为都在org.springframework.transaction.TransactionDefinition接口中以常量的方式定义出来。</p><p>隔离级别</p><p>隔离级别定义了一个事务可能受其他并发事务影响的程度。</p><p>隔离级别都在org.springframework.transaction.TransactionDefinition接口中以常量的方式定义出来。</p><p>只读</p><p>事务启动的时候由数据库实施的，只有针对具备启动一个新事务传播行为（PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW和PROPAGATION_NESTED）的方法来说才有意义。【tips】如果使用Hibernate，将事务声明为只读会导致flush模式被设置为FLUSH_NEVER，这会告诉hibernate避免和数据库进行不必要的对象同步，并将所有的更新延迟到事务结束。</p><p>事务超时</p><p>长时间事务会导致一些不必要的数据库资源占用。</p><p>超时时钟会在事务开始时启动，只有针对具备启动一个新事务传播行为（PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW和PROPAGATION_NESTED）的方法来说才有意义。</p><p>回滚规则</p><p>这些规则定义了哪些异常会导致事务回滚哪些不会，默认情况下，运行时异常会回滚，检查异常不回滚，但是可以声明事务遇到检查异常回滚，运行时异常不回滚。</p><p>3）Spring在XML中定义事务</p><p>需要包括beans、aop、tx命名空间。</p><pre><code>&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;  &lt;tx:attributes&gt;     &lt;!-- 事务执行方式 REQUIRED：指定当前方法必需在事务环境中运行，     如果当前有事务环境就加入当前正在执行的事务环境，     如果当前没有事务，就新建一个事务。 这是默认值。 --&gt;     &lt;tx:method name=&quot;create*&quot; propagation=&quot;REQUIRED&quot; /&gt;     &lt;tx:method name=&quot;save*&quot;   propagation=&quot;REQUIRED&quot; /&gt;     &lt;tx:method name=&quot;add*&quot;    propagation=&quot;REQUIRED&quot; /&gt;     &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt;     &lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot; /&gt;     &lt;tx:method name=&quot;del*&quot;    propagation=&quot;REQUIRED&quot; /&gt;     &lt;tx:method name=&quot;import*&quot; propagation=&quot;REQUIRED&quot; /&gt;     &lt;!-- 指定当前方法以非事务方式执行操作，如果当前存在事务，就把当前事务挂起，等我以非事务的状态运行完，再继续原来的事务。 查询定义即可        read-only=&quot;true&quot; 表示只读 --&gt;     &lt;tx:method name=&quot;*&quot;       propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot; /&gt;  &lt;/tx:attributes&gt;&lt;/tx:advice&gt;</code></pre><p>其中&lt;tx:method /&gt;有很多属性用来帮助定义方法的事务策略：<br><img src="http://pp66ww0jt.bkt.clouddn.com/20181019215056.png"></p><p>4）定义注解驱动的事务</p><p>在XML配置文件中添加：</p><pre><code>&lt;tx:annotation-driven/&gt;</code></pre><p>可通过transaction-manager属性（默认值”transactionManager”）来指定事务管理器，如：</p><pre><code>&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;</code></pre><p><code>&lt;tx:annotation-driven/&gt;</code>告诉Spring检查上下文中所有bean并检查使用到@Transactional注解的bean。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中无处不在的Properties</title>
      <link href="/2018/10/19/spring-zhong-wu-chu-bu-zai-de-properties/"/>
      <url>/2018/10/19/spring-zhong-wu-chu-bu-zai-de-properties/</url>
      
        <content type="html"><![CDATA[<p>对 Spring 里面的 Properties 不理解的开发者可能会觉得有点乱，主要是因为配置方式很多种，使用方式也很多种。</p><p>本文不是原理分析、源码分析文章，只是希望可以帮助读者更好地理解和使用 Spring Properties。</p><h3 id="Properties-的使用"><a href="#Properties-的使用" class="headerlink" title="Properties 的使用"></a>Properties 的使用</h3><p>先来看看 Properties 是怎么使用的，Spring 中常用的有以下几种使用方式：</p><h4 id="在-xml-配置文件中使用"><a href="#在-xml-配置文件中使用" class="headerlink" title="在 xml 配置文件中使用"></a>在 xml 配置文件中使用</h4><p>即自动替换 ${} 里面的值。</p><pre><code>&lt;bean id=&quot;xxx&quot; class=&quot;com.javadoop.Xxx&quot;&gt;     &lt;property name=&quot;url&quot; value=&quot;${javadoop.jdbc.url}&quot; /&gt;&lt;/bean&gt;</code></pre><h4 id="通过-Value-注入使用"><a href="#通过-Value-注入使用" class="headerlink" title="通过 @Value 注入使用"></a>通过 @Value 注入使用</h4><pre><code>@Value(&quot;${javadoop.jdbc.url}&quot;)private String url;</code></pre><h4 id="通过-Environment-获取"><a href="#通过-Environment-获取" class="headerlink" title="通过 Environment 获取"></a>通过 Environment 获取</h4><p>此法有需要注意的地方。并不是所有的配置方式都支持通过 Environment 接口来获取属性值，亲测只有使用注解 @PropertySource 的时候可以用，否则会得到 null，至于怎么配置，下面马上就会说。</p><pre><code>@Autowiredprivate Environment env;public String getUrl() {   return env.getProperty(&quot;javadoop.jdbc.url&quot;);}</code></pre><p><strong>注：如果是 Spring Boot 的 application.properties 注册的，那也是可以的。</strong></p><hr><h3 id="Properties-配置"><a href="#Properties-配置" class="headerlink" title="Properties 配置"></a>Properties 配置</h3><p>前面我们说了怎么使用我们配置的 Properties，那么该怎么配置呢？Spring 提供了很多种配置方式。</p><h4 id="通过-xml-配置"><a href="#通过-xml-配置" class="headerlink" title="通过 xml 配置"></a>通过 xml 配置</h4><p>下面这个是最常用的配置方式了，很多项目都是这么写的：</p><pre><code>&lt;context:property-placeholder location=&quot;classpath:sys.properties&quot; /&gt;</code></pre><h4 id="通过-PropertySource-配置"><a href="#通过-PropertySource-配置" class="headerlink" title="通过 @PropertySource 配置"></a>通过 @PropertySource 配置</h4><p>前面的通过 xml 配置非常常用，但是如果你也有一种要消灭所有 xml 配置文件的冲动的话，你应该使用以下方式：</p><pre><code>@PropertySource(&quot;classpath:sys.properties&quot;)@Configurationpublic class JavaDoopConfig {}</code></pre><p><strong>注：@PropertySource 在这里必须搭配 @Configuration 来使用，具体不展开说了。</strong></p><h4 id="PropertyPlaceholderConfigurer"><a href="#PropertyPlaceholderConfigurer" class="headerlink" title="PropertyPlaceholderConfigurer"></a>PropertyPlaceholderConfigurer</h4><p>如果读者见过这个，也不必觉得奇怪，在 Spring 3.1 之前，经常就是这么使用的：</p><pre><code>&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;   &lt;property name=&quot;locations&quot;&gt;       &lt;list&gt;           &lt;value&gt;classpath:sys.properties&lt;/value&gt;       &lt;/list&gt;   &lt;/property&gt;   &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot;/&gt;     &lt;!-- 这里可以配置一些属性 --&gt;&lt;/bean&gt;</code></pre><p>当然，我们也可以用相应的 java configuration 的版本：</p><pre><code>@Beanpublic PropertyPlaceholderConfigurer propertiess() {   PropertyPlaceholderConfigurer ppc = new PropertyPlaceholderConfigurer();   Resource[] resources = new ClassPathResource[]{new ClassPathResource(&quot;sys.properties&quot;)};   ppc.setLocations(resources);   ppc.setIgnoreUnresolvablePlaceholders(true);   return ppc;}</code></pre><h4 id="PropertySourcesPlaceholderConfigurer"><a href="#PropertySourcesPlaceholderConfigurer" class="headerlink" title="PropertySourcesPlaceholderConfigurer"></a>PropertySourcesPlaceholderConfigurer</h4><p>到了 Spring 3.1 的时候，引入了 PropertySourcesPlaceholderConfigurer，这是一个新的类，注意看和之前的 PropertyPlaceholderConfigurer 在名字上多了一个 Sources，所属的包也不一样，它在 Spring-Context 包中。</p><p>在配置上倒是没有什么区别：</p><pre><code>&lt;bean class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt;   &lt;property name=&quot;locations&quot;&gt;       &lt;list&gt;           &lt;value&gt;classpath:sys.properties&lt;/value&gt;       &lt;/list&gt;   &lt;/property&gt;   &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot;/&gt;   &lt;!-- 这里可以配置一些属性 --&gt;&lt;/bean&gt;</code></pre><p>也来一个 java configuration 版本吧：</p><pre><code>@Beanpublic PropertySourcesPlaceholderConfigurer properties() {   PropertySourcesPlaceholderConfigurer pspc = new PropertySourcesPlaceholderConfigurer();   Resource[] resources = new ClassPathResource[]{new ClassPathResource(&quot;sys.properties&quot;)};   pspc.setLocations(resources);   pspc.setIgnoreUnresolvablePlaceholders(true);   return pspc;}</code></pre><h3 id="Spring-Boot-相关"><a href="#Spring-Boot-相关" class="headerlink" title="Spring Boot 相关"></a>Spring Boot 相关</h3><p>Spring Boot 真的是好东西，开箱即用的感觉实在是太好了。这里简单介绍下相关的内容。</p><p>快速生成一个 Spring Boot 项目：</p><p><a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a></p><p><strong>application.properties</strong></p><p>我们每个项目都默认有一个 application.properties 文件，这个配置文件不需要像前面说的那样进行注册，Spring Boot 会帮我们自动注册。</p><p>当然，也许你想换个名字也是可以的，在启动的时候指定你的文件名字就可以了：</p><pre><code>java -Dspring.config.location=classpath:sys.properties -jar app.jar</code></pre><p><strong>application-{env}.properties</strong></p><p>为了给不同的环境指定不同的配置，我们会用到这个。比如测试环境和生产环境的数据库连接信息就不一样。</p><p>所以，在 application.properties 的基础上，我们还需要新建 application-dev.properties 和 application-prd.properties，用于配置环境相关的信息，然后启动的时候指定环境。</p><pre><code>java -Dspring.profiles.active=prd -jar app.jar</code></pre><p>结果就是，application.properties 和 application-prd.properties 两个文件中的配置都会注册进去，如果有重复的 key，application-prd.properties 文件中的优先级较高。</p><p><strong>@ConfigurationProperties</strong></p><p>这个注解是 Spring Boot 中才有的。即使大家不使用这个注解，大家也可能会在开源项目中看到这个，这里简单介绍下。</p><p>来一个例子直观一些。按照之前说的，在配置文件中填入下面的信息，你可以选择写入 application.properties 也可以用第一节介绍的方法。</p><pre><code>javadoop.database.url=jdbc:mysql:javadoop.database.username=adminjavadoop.database.password=admin123456</code></pre><p>java 文件：</p><pre><code>@Configuration@ConfigurationProperties(prefix = &quot;javadoop.database&quot;)public class DataBase {   String url;   String username;   String password;   // getters and setters}</code></pre><p>这样，就在 Spring 的容器中就自动注册了一个类型为 DataBase 的 bean 了，而且属性都已经 set 好了。</p><p><strong>在启动过程中动态修改属性值</strong></p><p>这个我觉得都不需要太多介绍，用 Spring Boot 的应该基本上都知道。</p><p>属性配置有个覆盖顺序，也就是当出现相同的 key 的时候，以哪里的值为准。</p><p>启动参数 &gt; application-{env}.properties &gt; application.properties</p><p>启动参数动态设置属性：</p><pre><code>java -Djavadoop.database.password=admin4321 -jar app.jar</code></pre><p>另外，还可以利用系统环境变量设置属性，还可以指定随机数等等，确实很灵活，不过没什么用，就不介绍了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>读者如果想要更加深入地了解 Spring 的 Properties，需要去理解 Spring 的 Environment 接口相关的源码。建议感兴趣的读者去翻翻源代码看看</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_13</title>
      <link href="/2018/10/19/spring-annotation-day-13/"/>
      <url>/2018/10/19/spring-annotation-day-13/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong> </p><p>今天来学习AOP原理。</p><p>我们上篇文章已经描述了AOP的使用情况，现在来研究一下AOP的原理。首先从@EnableAspectJAutoProxy注解开始。</p><hr><h3 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h3><p>1）点击@EnableAspectJAutoProxy注解：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>AspectJAutoProxyRegistrar<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableAspectJAutoProxy</span> </code></pre><p>发现，使用了@Import注解来注入组件。组件是AspectJAutoProxyRegistrar类。</p><p>2）点击AspectJAutoProxyRegistrar类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AspectJAutoProxyRegistrar</span> <span class="token keyword">implements</span> <span class="token class-name">ImportBeanDefinitionRegistrar</span><span class="token punctuation">{</span>  ···<span class="token punctuation">}</span></code></pre><p>该类，实现了ImportBeanDefinitionRegistrar接口，说明是用来自定义注入组件的。其中有一个registerBeanDefinitions（）方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span>AnnotationMetadata importingClassMetadata<span class="token punctuation">,</span> BeanDefinitionRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AopConfigUtils<span class="token punctuation">.</span><span class="token function">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>        AnnotationAttributes enableAspectJAutoProxy <span class="token operator">=</span>                AnnotationConfigUtils<span class="token punctuation">.</span><span class="token function">attributesFor</span><span class="token punctuation">(</span>importingClassMetadata<span class="token punctuation">,</span> EnableAspectJAutoProxy<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>enableAspectJAutoProxy<span class="token punctuation">.</span><span class="token function">getBoolean</span><span class="token punctuation">(</span><span class="token string">"proxyTargetClass"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            AopConfigUtils<span class="token punctuation">.</span><span class="token function">forceAutoProxyCreatorToUseClassProxying</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>enableAspectJAutoProxy<span class="token punctuation">.</span><span class="token function">getBoolean</span><span class="token punctuation">(</span><span class="token string">"exposeProxy"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            AopConfigUtils<span class="token punctuation">.</span><span class="token function">forceAutoProxyCreatorToExposeProxy</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>查看其中的AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</p><p>最终会调用registerOrEscalateApcAsRequired方法：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> BeanDefinition <span class="token function">registerOrEscalateApcAsRequired</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cls<span class="token punctuation">,</span> BeanDefinitionRegistry registry<span class="token punctuation">,</span> Object source<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> <span class="token string">"BeanDefinitionRegistry must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>registry<span class="token punctuation">.</span><span class="token function">containsBeanDefinition</span><span class="token punctuation">(</span>AUTO_PROXY_CREATOR_BEAN_NAME<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            BeanDefinition apcDefinition <span class="token operator">=</span> registry<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span>AUTO_PROXY_CREATOR_BEAN_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cls<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>apcDefinition<span class="token punctuation">.</span><span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> currentPriority <span class="token operator">=</span> <span class="token function">findPriorityForClass</span><span class="token punctuation">(</span>apcDefinition<span class="token punctuation">.</span><span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> requiredPriority <span class="token operator">=</span> <span class="token function">findPriorityForClass</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>currentPriority <span class="token operator">&lt;</span> requiredPriority<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    apcDefinition<span class="token punctuation">.</span><span class="token function">setBeanClassName</span><span class="token punctuation">(</span>cls<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        RootBeanDefinition beanDefinition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>        beanDefinition<span class="token punctuation">.</span><span class="token function">setSource</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>        beanDefinition<span class="token punctuation">.</span><span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"order"</span><span class="token punctuation">,</span> Ordered<span class="token punctuation">.</span>HIGHEST_PRECEDENCE<span class="token punctuation">)</span><span class="token punctuation">;</span>        beanDefinition<span class="token punctuation">.</span><span class="token function">setRole</span><span class="token punctuation">(</span>BeanDefinition<span class="token punctuation">.</span>ROLE_INFRASTRUCTURE<span class="token punctuation">)</span><span class="token punctuation">;</span>        registry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>AUTO_PROXY_CREATOR_BEAN_NAME<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> beanDefinition<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>最后是给容器注入了一个Bean：<br>id：internalAutoProxyCreator ==》 Class：AnnotationAwareAspectJAutoProxyCreator</p><hr><h3 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h3><p>@EnableAspectJAutoProxy注解帮我们注入了AnnotationAwareAspectJAutoProxyCreator组件，这个组件有什么作用呢？</p><p>我们观察一下AnnotationAwareAspectJAutoProxyCreator的继承关系：</p><p>AnnotationAwareAspectJAutoProxyCreator</p><p>&nbsp;&nbsp;&nbsp;AspectJAwareAdvisorAutoProxyCreator  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractAdvisorAutoProxyCreator  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractAutoProxyCreator</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware</strong></p><p><strong>关键:实现了两个接口，一个后置处理器(在Bean初始化完成前后做事情)、一个自动装配BeanFactory</strong></p><hr><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>打上断点：(与后置处理器，自动装配有关的)</p><p>1）AbstractAutoProxyCreator.setBeanFactory<br>2）AbstractAutoProxyCreator.postProcessBeforeInstantiation<br>3) AbstractAutoProxyCreator.postProcessAfterInitialization</p><p>4) AbstractAdvisorAutoProxyCreator.setBeanFactory(父类重写的方法也打上断点)<br>5）AbstractAdvisorAutoProxyCreator.initBeanFactory</p><p>6) AspectJAwareAdvisorAutoProxyCreator类没有相关的就不打上断点</p><p>7）AnnotationAwareAspectJAutoProxyCreator.initBeanFactory(父类重写的方法也打上断点)</p><p>8) MainConfigOfAOP配置类的中的两个Bean对象打上断点：<br>&nbsp;&nbsp;&nbsp;mathCalculator和logAspects</p><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>流程：<br>1）传入配置类，创建IoC容器</p><pre class=" language-java"><code class="language-java">AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfigOfAOP<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>2) 注册配置类，调用refresh（）, 刷新容器</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> annotatedClasses<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">register</span><span class="token punctuation">(</span>annotatedClasses<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//注入配置类</span>        <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//刷新容器</span>    <span class="token punctuation">}</span></code></pre><p>3）registerBeanPostProcessors(beanFactory);注册bean的后置处理器，来拦截bean的初始化操作。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;1.先获取IoC容器已经定义了的需要创建对象的所有BeanPostProcessor  </p><pre class=" language-java"><code class="language-java">String<span class="token punctuation">[</span><span class="token punctuation">]</span> postProcessorNames <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span>BeanPostProcessor<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;2.给容器中加别的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;3.优先注册实现了PriorityOrdered接口的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;4.再注册实现了Ordered接口的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;5.注册没有实现优先级接口的BeanPostProcessor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;6.注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存到容器中</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 创建    internalAutoProxyCreator的BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.创建Bean对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.populateBean：给bean的属性赋值</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.initializeBean：初始化bean</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.invokeAwareMethods：处理Aware接口的回调：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeAwareMethods</span><span class="token punctuation">(</span><span class="token keyword">final</span> String beanName<span class="token punctuation">,</span> <span class="token keyword">final</span> Object bean<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">Aware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">BeanNameAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>BeanNameAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setBeanName</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">BeanClassLoaderAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>BeanClassLoaderAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setBeanClassLoader</span><span class="token punctuation">(</span><span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">BeanFactoryAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>BeanFactoryAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setBeanFactory</span><span class="token punctuation">(</span>AbstractAutowireCapableBeanFactory<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.applyBeanPostProcessorsBeforeInitialization:执行后置处理器的postProcessor：postProcessBeforeInitialization方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.invokeInitMethods：自定义的初始化方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.applyBeanPostProcessorsAfterInitialization：执行postProcessor：postProcessAfterInitialization方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;7.把BeanPostProcessor注册到BeanFactory中：beanFactory.addBeanPostProcessor（）</p><hr><p>以上是创建AnnotationAwareAspectJAutoProxyCreator的过程。</p><p>AnnotationAwareAspectJAutoProxyCreator =》InstantiationAwareBeanPostProcessor，而不是 BeanPostProcessor 后置处理器</p><p>InstantiationAwareBeanPostProcessor是 postProcessBeforeInstantiation（实例化）</p><p>BeanPostProcessor是postProcessBeforeInitialization（初始化）</p><p><strong>说明InstantiationAwareBeanPostProcessor后置处理器是 在Bean实例化前后执行</strong></p><p><strong>BeanPostProcessor后置处理器是 在Bean对象初始化前后执行</strong></p><p>4）finishBeanFactoryInitialization(beanFactory);完成BeanFactory初始化工作，创建剩下的没有创建的Bean组件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;1.遍历获取容器中所有的Bean，依次创建对象；getBean(beanName)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getBean()-&gt;doGetBean()-&gt;getSingleton()-&gt;createBean()</p><p>&nbsp;&nbsp;&nbsp;&nbsp;2.创建Bean：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.先从缓存中获取当前的Bean，如果能获取到，说明bean是之前被创建过，直接使用，否则再创建.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要创建了bean就会被缓存起来。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.createBean():创建Bean</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.resolveBeforeInstantiation():解析BeanPostProcessors<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>想让后置处理器在次能返回一个代理对象</strong>，如果能返回代理对象就使用，如果不能就继续。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.后置处理器先尝试返回代理对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bean=applyBeanPostProcessorsBeforeInstantiation();拿到所有的后置处理器，如果是 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InstantiationAwareBeanPostProcessor；就执行postProcessBeforeInstantiation方法</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      bean <span class="token operator">=</span> <span class="token function">applyBeanPostProcessorsAfterInitialization</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.doCreateBean()：真正去创建一个bean实例；和3.6流程一样</p><hr><p>AnnotationAwareAspectJAutoProxyCreator[InstantiationAwareBeanPostProcessor]</p><p>1) 每一个bean创建之前，调用postProcessBeforeInstantiation()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关心<strong>mathCalculator</strong>和<strong>logAspects</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）判断当前bean是否是在advicedBean中（保存了所有需要增强bean）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）判断当前bean是否是基础类型的Advice、PointCut、Advisor、AopInfrastructureBean或者是否是切面(@Aspect)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）是否需要跳过</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）获取候选的增强器(切面里面的通知方法)【List<advisor> candidateAdvisors】<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个封装的通知方法的增强器是InstantiationModelAwarePointcutAdvisor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判断每一个增强器是否是AspectJPointcutAdvisor类型的；返回true</advisor></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）永远返回false</p><p>2）创建对象<br>postProcessAfterInitialization：<br>return wrapIfNecessary(bean, beanName, cacheKey);//需要包装的情况下  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）获取当前bean的所有增强器(通知方法) Object[] specificInterceptors</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）找到候选的所有增强器(找哪些通知方法是需要切入当前bean方法的)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）获取到能在bean使用的增强器</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）给增强器排序</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）保存当前bean在advisedBeans中；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）如果当前bean需要增强，创建当前bean的代理对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）获取所有的增强器(通知方法)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）保存到proxyFactory</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）创建代理对象：Spring自动决定<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdk代理<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cglib代理</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）给容器中返回当前组件使用cglib代理的对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5）以后容器中获取的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程</p><p>3）目标方法的执行流程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容器中保存了组件的代理对象(cglib增强后的对象)，这个对象里面保存了详细信息(比如增强器、目标对象，xxx)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）CglibAopProxy.intercept();拦截目标方法的执行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）根据ProxyFactory对象获取将要执行的目标方法拦截器</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List<object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</object></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）List<object> interceptorList保存所有拦截器：5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个默认的ExposeInvocationInterceptor和4个增强器</object></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）遍历所有的增强器，将其转为Interceptor</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）将增强器转为List<methodinterceptor>,如果是MethodInterceptor，直接加入集合中，如果不是，使用AdvisorAdapter将增强器转为   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MethodInterceptor，转换完后返回MethodInterceptor数组</methodinterceptor></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）如果没有拦截器链，直接执行目标方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）如果有拦截器链，把需要执行的目标对象，目标方法，拦截器链等信息传入，创建一个CglibMethodInvocation对象，并调用<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object retVal = mi.proceed();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5) 拦截器链的触发过程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）如果没有拦截器执行，就直接执行目标方法，或者拦截器的索引和拦截器数组的个数-1一样大，执行目标方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拦截器链的机制，保证通知方法与目标方法的执行顺序.<br><img src="https://gakkil.gitee.io/gakkil-image/spring_annotation/day13/20181019201432.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1）@EnableAspectJAutoProxy注解 开启AOP功能</p><p>2）@EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator</p><p>3）AnnotationAwareAspectJAutoProxyCreator是一个后置处理器</p><p>4）容器的创建流程：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）registerBeanPostProcessors()注册后置处理器，创建AnnotationAwareAspectJAutoProxyCreator对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）finishBeanFactoryInitialization()：初始化剩下的单实例bean<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）创建业务逻辑组件和切面组件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）组件创建完之后，判断组件是否需要增强。是：切面的通知方法，包装成增强器(Advisor);给业务逻辑组件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4)  创建一个代理对象 </p><p>5）执行目标方法：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）代理对象执行目标方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）CglibAopProxy.Intercept:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）得到目标方法的拦截器链(增强器包装成拦截器MethodIntercept)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）利用拦截器的链式机制，依次进入每一个拦截器进行执行；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）效果：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 正常执行：前置通知 -》目标方法 -》后置通知 -》返回通知<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 出现异常：前置通知 -》目标方法 -》后置通知 -》异常通知  </p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring和SpringMVC父子容器关系初窥</title>
      <link href="/2018/10/19/spring-he-springmvc-fu-zi-rong-qi-guan-xi-chu-kui/"/>
      <url>/2018/10/19/spring-he-springmvc-fu-zi-rong-qi-guan-xi-chu-kui/</url>
      
        <content type="html"><![CDATA[<p>Spring和SpringMVC父子容器关系初窥，探究父容器与子容器之间的关系</p><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>最近由于项目的包扫描出现了问题，在解决问题的过程中，偶然发现了Spring和SpringMVC是有父子容器关系的，而且正是因为这个才往往会出现包扫描的问题，我们在此来分析和理解Spring和SpringMVC的父子容器关系并且给出Spring和SpringMVC配置文件中包扫描的官方推荐方式。</p><h3 id="二、概念理解和知识铺垫"><a href="#二、概念理解和知识铺垫" class="headerlink" title="二、概念理解和知识铺垫"></a>二、概念理解和知识铺垫</h3><p>在Spring整体框架的核心概念中，容器是核心思想，就是用来管理Bean的整个生命周期的，而在一个项目中，容器不一定只有一个，Spring中可以包括多个容器，而且容器有上下层关系</p><p>目前最常见的一种场景就是在一个项目中引入Spring和SpringMVC这两个框架，那么它其实就是两个容器，Spring是父容器，SpringMVC是其子容器</p><p>并且在Spring父容器中注册的Bean对于SpringMVC容器中是可见的，而在SpringMVC容器中注册的Bean对于Spring父容器中是不可见的，也就是子容器可以看见父容器中的注册的Bean，反之就不行。</p><p>我们可以使用统一的如下注解配置来对Bean进行批量注册，而不需要再给每个Bean单独使用xml的方式进行配置。</p><p><code>&lt;context:component-scan base-package=&quot;com.liuzhuo.www&quot; /&gt;</code></p><p>从Spring提供的参考手册中我们得知该配置的功能是扫描配置的base-package包下的所有使用了@Component注解的类，并且将它们自动注册到容器中，同时也扫描@Controller，@Service，@Respository这三个注解，因为他们是继承自@Component</p><hr><p>在项目中我们经常见到还有如下这个配置，其实有了上面的配置，这个是可以省略掉的，因为上面的配置会默认打开以下配置。</p><p>以下配置会默认声明了@Required、@Autowired、 @PostConstruct、@PersistenceContext、@Resource、@PreDestroy等注解</p><p><code>&lt;context:annotation-config/&gt;</code></p><p><strong>另外，还有一个和SpringMVC相关如下配置，经过验证，这个是SpringMVC必须要配置的，因为它声明了@RequestMapping、@RequestBody、@ResponseBody等。并且，该配置默认加载很多的参数绑定方法，比如json转换解析器等。</strong></p><p><code>&lt;mvc:annotation-driven /&gt;</code></p><p>而上面这句,配置Spring3.1之前的版本和以下配置方式等价</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>配置注解控制器映射器<span class="token punctuation">,</span>它是SpringMVC中用来将Request请求URL到映射到具体Controller<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>bean <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>配置注解控制器适配器<span class="token punctuation">,</span>它是SpringMVC中用来将具体请求映射到具体方法<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>bean <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"</span><span class="token operator">/</span><span class="token operator">></span></code></pre><p>Spring3.1之后的版本和以下配置方式等价：</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>配置注解控制器映射器<span class="token punctuation">,</span>它是SpringMVC中用来将Request请求URL到映射到具体Controller<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>bean <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>配置注解控制器适配器<span class="token punctuation">,</span>它是SpringMVC中用来将具体请求映射到具体方法<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>bean <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span><span class="token operator">/</span><span class="token operator">></span></code></pre><h3 id="三、具体场景分析"><a href="#三、具体场景分析" class="headerlink" title="三、具体场景分析"></a>三、具体场景分析</h3><p>下面让我们来详细扒一扒Spring与SpringMVC的容器冲突的原因到底在那里？</p><p>我们共有Spring和SpringMVC两个容器，它们的配置文件分别为applicationContext.xml和applicationContext-MVC.xml</p><p>1、在applicationContext.xml中配置了&lt;context:component-scan base-package=“com.hafiz.www” /&gt;，负责所有需要注册的Bean的扫描和注册工作</p><p>2、在applicationContext-MVC.xml中配置&lt;mvc:annotation-driven /&gt;，负责SpringMVC相关注解的使用</p><p>3、启动项目我们发现SpringMVC无法进行跳转，将log的日志打印级别设置为DEBUG进行调试，发现SpringMVC容器中的请求好像没有映射到具体controller中</p><p>4、在applicationContext-MVC.xml中配置&lt;context:component-scan base-package=“com.hafiz.www” /&gt;，重启后，验证成功，springMVC跳转有效</p><p>下面我们来查看具体原因，翻看源码，从SpringMVC的DispatcherServlet开始往下找，我们发现SpringMVC初始化时，会寻找SpringMVC容器中的所有使用了@Controller注解的Bean，来确定其是否是一个handler</p><p>1、2两步的配置使得当前SpringMVC容器中并没有注册带有@Controller注解的Bean，而是把所有带有@Controller注解的Bean都注册在Spring这个父容器中了，所以SpringMVC找不到处理器，不能进行跳转。核心源码如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initHandlerMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　<span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Looking for request mappings in application context: "</span> <span class="token operator">+</span> <span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token punctuation">}</span>　　String<span class="token punctuation">[</span><span class="token punctuation">]</span> beanNames <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>detectHandlerMethodsInAncestorContexts <span class="token operator">?</span>　　　　　　  BeanFactoryUtils<span class="token punctuation">.</span><span class="token function">beanNamesForTypeIncludingAncestors</span><span class="token punctuation">(</span><span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">:</span>　　　　　　　<span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token keyword">for</span> <span class="token punctuation">(</span>String beanName <span class="token operator">:</span> beanNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isHandler</span><span class="token punctuation">(</span><span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>　　　　　　<span class="token function">detectHandlerMethods</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>　　　　<span class="token punctuation">}</span>　　<span class="token punctuation">}</span>　　<span class="token function">handlerMethodsInitialized</span><span class="token punctuation">(</span><span class="token function">getHandlerMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在方法isHandler中会判断当前bean的注解是否是controller，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHandler</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> beanType<span class="token punctuation">)</span> <span class="token punctuation">{</span>　　<span class="token keyword">return</span> AnnotationUtils<span class="token punctuation">.</span><span class="token function">findAnnotation</span><span class="token punctuation">(</span>beanType<span class="token punctuation">,</span> Controller<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>而在第4步配置中，SpringMVC容器中也注册了所有带有@Controller注解的Bean，故SpringMVC能找到处理器进行处理，从而正常跳转。</p><p>我们找到了出现不能正确跳转的原因，那么它的解决办法是什么呢？</p><p>我们注意到在initHandlerMethods()方法中，detectHandlerMethodsInAncestorContexts这个Switch，它主要控制获取哪些容器中的bean以及是否包括父容器，默认是不包括的。</p><p>所以解决办法就是在SpringMVC的配置文件中配置HandlerMapping的detectHandlerMethodsInAncestorContexts属性为true即可（这里需要根据具体项目看使用的是哪种HandlerMapping），让它检测父容器的bean。如下：</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>bean <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"detectHandlerMethodsInAncestorContexts"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>value<span class="token operator">></span><span class="token boolean">true</span><span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span></code></pre><p>但在实际工程中会包括很多配置，我们按照官方推荐根据不同的业务模块来划分不同容器中注册不同类型的Bean：</p><p>Spring父容器负责所有其他非@Controller注解的Bean的注册，而SpringMVC只负责@Controller注解的Bean的注册，使得他们各负其责、明确边界。配置方式如下</p><p>1、在applicationContext.xml中配置:</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Spring容器中注册非<span class="token annotation punctuation">@controller</span>注解的Bean <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>context<span class="token operator">:</span>component<span class="token operator">-</span>scan base<span class="token operator">-</span><span class="token keyword">package</span><span class="token operator">=</span><span class="token string">"com.hafiz.www"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>context<span class="token operator">:</span>exclude<span class="token operator">-</span>filter type<span class="token operator">=</span><span class="token string">"annotation"</span> expression<span class="token operator">=</span><span class="token string">"org.springframework.stereotype.Controller"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>context<span class="token operator">:</span>component<span class="token operator">-</span>scan<span class="token operator">></span></code></pre><p>2、applicationContext-MVC.xml中配置</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> SpringMVC容器中只注册带有<span class="token annotation punctuation">@controller</span>注解的Bean <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>context<span class="token operator">:</span>component<span class="token operator">-</span>scan base<span class="token operator">-</span><span class="token keyword">package</span><span class="token operator">=</span><span class="token string">"com.hafiz.www"</span> use<span class="token operator">-</span><span class="token keyword">default</span><span class="token operator">-</span>filters<span class="token operator">=</span><span class="token string">"false"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>context<span class="token operator">:</span>include<span class="token operator">-</span>filter type<span class="token operator">=</span><span class="token string">"annotation"</span> expression<span class="token operator">=</span><span class="token string">"org.springframework.stereotype.Controller"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>context<span class="token operator">:</span>component<span class="token operator">-</span>scan<span class="token operator">></span></code></pre><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>这样我们在清楚了Spring和SpringMVC的父子容器关系、以及扫描注册的原理以后，根据官方建议我们就可以很好把不同类型的Bean分配到不同的容器中进行管理。再出现Bean找不到或者SpringMVC不能跳转以及事务的配置失效的问题，我们就可以很快的定位以及解决问题了。很开心，有木有~</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_12</title>
      <link href="/2018/10/18/spring-annotation-day-12/"/>
      <url>/2018/10/18/spring-annotation-day-12/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天学习AOP的开发与使用</p><h3 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h3><p>AOP是Spring 框架的一个关键组件，全称为Aspect-Oriented-Programming（面向切面编程），目前已是一种比较成熟的编程方式。</p><p>AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在编译或运行的时候，再将这些代码应用到需要执行的地方。</p><p><strong>注：提取出来的代码应用到需要执行的地方，并不会把源代码加到需要的地方执行，即源代码文件不会更改，但是它会影响最终的机器编译代码</strong></p><p>意思就是，有一些通用功能的代码可以提取出来，然后在使用的时候应用进去就可以了，比如表单验证和日志记录等等。</p><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><p>Aspect（切面）</p><p>通常指封装起来用于插入到指定位置实现某项功能的类</p><p>Join point（连接点）</p><p>在SpringAOP中，连接点指方法的调用</p><p>Pointcut（切入点）</p><p>切面与程序流程的交叉点，即那些需要处理的连接点，通常在程序中，切入点指的是类或者方法名</p><p>Advice（通知/增强处理）</p><p>就是程序实际运行之前或之后执行的方法，也就是AOP加入的代码</p><p>Target Object（目标对象）</p><p>即需要加入AOP代码的对象</p><p>Proxy（代理）</p><p>AOP框架动态生成的一个对象，该对象可以作为目标对象使用</p><p>Weaving（织入）</p><p>把切面连接到其它的应用程序类型或者对象上，并创建一个需要Advice对象的过程</p><h3 id="AOP的例子（JDK代理）"><a href="#AOP的例子（JDK代理）" class="headerlink" title="AOP的例子（JDK代理）"></a>AOP的例子（JDK代理）</h3><p>1）首先建立一个java工程</p><p><img src="https://gakkil.gitee.io/gakkil-image/spring_annotation/day12/20181018211302.png" style="width:50%"></p><p>UserDao接口:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>aop<span class="token punctuation">.</span>jdk<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserDao</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>UserDaoImpl:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>aop<span class="token punctuation">.</span>jdk<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserDao</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"新增用户"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>JdkProxy:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>aop<span class="token punctuation">.</span>jdk<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationHandler<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Proxy<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>aop<span class="token punctuation">.</span>aspect<span class="token punctuation">.</span>MyAspect<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*** JDK代理类*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JdkProxy</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 声明目标类接口</span> <span class="token keyword">private</span> UserDao userDao<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建代理方法</span> <span class="token keyword">public</span>  Object <span class="token function">createProxy</span><span class="token punctuation">(</span>UserDao userDao<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>userDao <span class="token operator">=</span> userDao<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 1.类加载器</span>   ClassLoader classLoader <span class="token operator">=</span> JdkProxy<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 2.被代理对象实现的所有接口</span>   <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"rawtypes"</span><span class="token punctuation">)</span>   Class<span class="token punctuation">[</span><span class="token punctuation">]</span> clazz <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 3.使用代理类，进行增强，返回的是代理后的对象</span>   <span class="token keyword">return</span>  Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">,</span>clazz<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/*  * 所有动态代理类的方法调用，都会交由invoke()方法去处理  * proxy 被代理后的对象   * method 将要执行的方法  * args 执行方法时需要的参数  */</span> <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>      <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 声明切面</span>   MyAspect myAspect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyAspect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 指定位置程序执行前执行这个方法</span>   myAspect<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 在目标类上调用方法</span>   Object obj <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>userDao<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 指定位置程序执行结束后执行</span>   myAspect<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> obj<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>MyAspect:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>aop<span class="token punctuation">.</span>aspect<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/***  切面*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAspect</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"模拟事务处理功能 ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序结束后执行此处 ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>JdkTest:</p><p>测试结果项目编写完之后运行该类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>aop<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>aop<span class="token punctuation">.</span>jdk<span class="token punctuation">.</span>JdkProxy<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>aop<span class="token punctuation">.</span>jdk<span class="token punctuation">.</span>UserDao<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>aop<span class="token punctuation">.</span>jdk<span class="token punctuation">.</span>UserDaoImpl<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JdkTest</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 创建代理对象</span>   JdkProxy jdkProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JdkProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建目标对象</span>   UserDao userDao<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 从代理对象中获取增强后的目标对象</span>   UserDao userDao1 <span class="token operator">=</span> <span class="token punctuation">(</span>UserDao<span class="token punctuation">)</span> jdkProxy<span class="token punctuation">.</span><span class="token function">createProxy</span><span class="token punctuation">(</span>userDao<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 执行方法</span>   userDao1<span class="token punctuation">.</span><span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行之后，我们可以看到以下结果：<br><img src="https://gakkil.gitee.io/gakkil-image/spring_annotation/day12/20181018211845.png" style="width:50%"></p><hr><p>我们可以看到，在我们执行新增用户的方法时，依据我们AOP编程，系统自动执行了start方法和end方法</p><p>在实际运用中，我们可以把一些通用的方法放到start和end的位置，在需要的方法处加入切面即可</p><p>此外，建议大家再了解下AspectJ</p><p>AspectJ实现AOP有两种方式：一种是基于XML的声明式，另一种是基于注解的声明式</p><p>基于XML的声明式AspectJ要便捷一些，但是存在配置信息多的缺点</p><p>基于注解的声明式AspectJ则通过注解的方式减少了很多配置信息</p><h3 id="Spring中的AOP使用"><a href="#Spring中的AOP使用" class="headerlink" title="Spring中的AOP使用"></a>Spring中的AOP使用</h3><p>1）创建新的配置类MainConfigOfAOP</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigOfAOP</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>2) 在com.liuzhuo.aop包下，创建MathCalculator类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MathCalculator</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2) 在com.liuzhuo.aop包下，创建切面类MathCalculator</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LogAspects</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法调用之前------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法调用之后-------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logReturn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法成功返回之后------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logThrowing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法出现异常之后------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logRound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//环绕方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"环绕：方法调用之前----"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"环绕：方法调用之后----"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3) 添加AOP的依赖，在pom文件中：</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>mvnrepository<span class="token punctuation">.</span>com<span class="token operator">/</span>artifact<span class="token operator">/</span>org<span class="token punctuation">.</span>springframework<span class="token operator">/</span>spring<span class="token operator">-</span>aspects <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>aspects<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">5.1</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">.</span>RELEASE<span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre><p>4) 将切面与目标方法进行连接：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Aspect</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LogAspects</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(public int com.liuzhuo.aop.MathCalculator.div(int,int))"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pointCut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//调用本类的切点</span>    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pointCut()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法调用之前------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//调用外面类的切点</span>    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"com.liuzhuo.aop.LogAspects.pointCut()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法调用之后-------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"pointCut()"</span><span class="token punctuation">,</span> returning <span class="token operator">=</span> <span class="token string">"returns"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logReturn</span><span class="token punctuation">(</span>Object returns<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法成功返回之后------:"</span> <span class="token operator">+</span> returns<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@AfterThrowing</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"pointCut()"</span><span class="token punctuation">,</span> throwing <span class="token operator">=</span> <span class="token string">"e"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logThrowing</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法出现异常之后------:"</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"pointCut()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">logRound</span><span class="token punctuation">(</span>ProceedingJoinPoint proceedingJoinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//环绕方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"环绕：方法调用之前----"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object proceed <span class="token operator">=</span> proceedingJoinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"环绕：方法调用之后----"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> proceed<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>5) 将切面和目标类注入到容器中：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigOfAOP</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> MathCalculator <span class="token function">mathCalculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MathCalculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> LogAspects <span class="token function">logAspects</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LogAspects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>6) <strong>开启Aspect的注解驱动</strong>：@EnableAspectJAutoProxy </p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableAspectJAutoProxy</span> <span class="token comment" spellcheck="true">//开启AOP注解驱动</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigOfAOP</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> MathCalculator <span class="token function">mathCalculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MathCalculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> LogAspects <span class="token function">logAspects</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LogAspects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>7) 创建新的测试类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IoCTest_AOP</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span>             <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfigOfAOP<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//不要自己创建MathCalculator类</span>        <span class="token comment" spellcheck="true">//MathCalculator mathCalculator = new MathCalculator();</span>        <span class="token comment" spellcheck="true">//mathCalculator.div(1, 1);</span>        MathCalculator mathCalculator <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>MathCalculator<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mathCalculator<span class="token punctuation">.</span><span class="token function">div</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>8) 运行结果：</p><pre><code>环绕：方法调用之前----方法调用之前------div:正在执行-----环绕：方法调用之后----方法调用之后-------方法成功返回之后------:1十月 18, 2018 10:03:03 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@3a4afd8d: startup date [Thu Oct 18 22:03:02 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>将业务逻辑组件和切面类都加入到容器中，告诉Spring哪个是切面类(Aspect)  </li><li>在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式）</li><li>开启基于注解的AOP模式：@EnableAspectJAutoProxy</li></ol>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean的生命周期</title>
      <link href="/2018/10/18/bean-de-sheng-ming-zhou-qi/"/>
      <url>/2018/10/18/bean-de-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<p>Spring作为当前Java最流行、最强大的轻量级框架，受到了程序员的热烈欢迎。准确的了解Spring Bean的生命周期是非常必要的。<br><a id="more"></a></p><p>我们通常使用ApplicationContext作为Spring容器。这里，我们讲的也是 ApplicationContext中Bean的生命周期。而实际上BeanFactory也是差不多的，只不过处理器需要手动注册。</p><h3 id="一、生命周期流程图："><a href="#一、生命周期流程图：" class="headerlink" title="一、生命周期流程图："></a>一、生命周期流程图：</h3><p>Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点。<br><img src="https://gakkil.gitee.io/gakkil-image/spring_bean_life/20181018162309.png"><br><img src="https://gakkil.gitee.io/gakkil-image/spring_bean_life/20181018162419.png"></p><p>若容器注册了以上各种接口，程序那么将会按照以上的流程进行。下面将仔细讲解各接口作用。</p><h3 id="二、各种接口方法分类"><a href="#二、各种接口方法分类" class="headerlink" title="二、各种接口方法分类"></a>二、各种接口方法分类</h3><p>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p><p>1、Bean自身的方法:这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</bean></p><p>2、Bean级生命周期接口方法:这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</p><p>3、容器级生命周期接口方法:这个包括了<code>InstantiationAwareBeanPostProcessor</code> 和 <code>BeanPostProcessor</code> 这两个接口实现，一般称它们的实现类为“后处理器”。</p><p>4、工厂后处理器接口方法:这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</p><h3 id="三、演示"><a href="#三、演示" class="headerlink" title="三、演示"></a>三、演示</h3><p>我们用一个简单的Spring Bean来演示一下Spring Bean的生命周期。</p><p>1、首先是一个简单的Spring Bean，调用Bean自身的方法和Bean级生命周期接口方法，为了方便演示，它实现了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这4个接口，同时有2个方法，对应配置文件中<bean>的init-method和destroy-method。如下：</bean></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> springBeanTest<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>BeansException<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>BeanFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>BeanFactoryAware<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>BeanNameAware<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>DisposableBean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>InitializingBean<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*** @author lz*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">BeanFactoryAware</span><span class="token punctuation">,</span> BeanNameAware<span class="token punctuation">,</span>       InitializingBean<span class="token punctuation">,</span> DisposableBean <span class="token punctuation">{</span>   <span class="token keyword">private</span> String name<span class="token punctuation">;</span>   <span class="token keyword">private</span> String address<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> phone<span class="token punctuation">;</span>   <span class="token keyword">private</span> BeanFactory beanFactory<span class="token punctuation">;</span>   <span class="token keyword">private</span> String beanName<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"【构造器】调用Person的构造器实例化"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> name<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"【注入属性】注入属性name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> String <span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> address<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAddress</span><span class="token punctuation">(</span>String address<span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"【注入属性】注入属性address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> phone<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPhone</span><span class="token punctuation">(</span><span class="token keyword">int</span> phone<span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"【注入属性】注入属性phone"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>phone <span class="token operator">=</span> phone<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token string">"Person [address="</span> <span class="token operator">+</span> address <span class="token operator">+</span> <span class="token string">", name="</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">", phone="</span>               <span class="token operator">+</span> phone <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 这是BeanFactoryAware接口方法</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanFactory</span><span class="token punctuation">(</span>BeanFactory arg0<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out               <span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory <span class="token operator">=</span> arg0<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 这是BeanNameAware接口方法</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanName</span><span class="token punctuation">(</span>String arg0<span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"【BeanNameAware接口】调用BeanNameAware.setBeanName()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>beanName <span class="token operator">=</span> arg0<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 这是InitializingBean接口方法</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>"【InitializingBean接口】调用                          InitializingBean<span class="token punctuation">.</span><span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 这是DiposibleBean接口方法</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"【DiposibleBean接口】调用DiposibleBean.destory()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 通过&lt;bean>的init-method属性指定的初始化方法</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"【init-method】调用&lt;bean>的init-method属性指定的初始化方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 通过&lt;bean>的destroy-method属性指定的初始化方法</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myDestory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"【destroy-method】调用&lt;bean>的destroy-method属性指定的初始化方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2、接下来是演示BeanPostProcessor接口的方法，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> springBeanTest<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>BeansException<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>config<span class="token punctuation">.</span>BeanPostProcessor<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token function">MyBeanPostProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是BeanPostProcessor实现类构造器！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// TODO Auto-generated constructor stub</span>   <span class="token punctuation">}</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> Object <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span>Object arg0<span class="token punctuation">,</span> String arg1<span class="token punctuation">)</span>           <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out       <span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> arg0<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> Object <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span>Object arg0<span class="token punctuation">,</span> String arg1<span class="token punctuation">)</span>           <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out       <span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> arg0<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>如上，BeanPostProcessor接口包括2个方法: postProcessAfterInitialization和postProcessBeforeInitialization，这两个方法的第一个参数都是要处理的Bean对象，第二个参数都是Bean的name。返回值也都是要处理的Bean对象。这里要注意。</strong></p><p>3、InstantiationAwareBeanPostProcessor 接口本质是BeanPostProcessor的子接口，一般我们继承Spring为其提供的适配器类<code>InstantiationAwareBeanPostProcessorAdapter</code>来使用它，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> springBeanTest<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>PropertyDescriptor<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>BeansException<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>PropertyValues<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>config<span class="token punctuation">.</span>InstantiationAwareBeanPostProcessorAdapter<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInstantiationAwareBeanPostProcessor</span> <span class="token keyword">extends</span>       <span class="token class-name">InstantiationAwareBeanPostProcessorAdapter</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token function">MyInstantiationAwareBeanPostProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out               <span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 接口方法、实例化Bean之前调用</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> Object <span class="token function">postProcessBeforeInstantiation</span><span class="token punctuation">(</span>Class <span class="token class-name">beanClass</span><span class="token punctuation">,</span>           String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>"InstantiationAwareBeanPostProcessor调用                          postProcessBeforeInstantiation方法"<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> null<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 接口方法、实例化Bean之后调用</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> Object <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span>           <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out               <span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> bean<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 接口方法、设置某个属性时调用</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> PropertyValues <span class="token function">postProcessPropertyValues</span><span class="token punctuation">(</span>PropertyValues pvs<span class="token punctuation">,</span>           PropertyDescriptor<span class="token punctuation">[</span><span class="token punctuation">]</span> pds<span class="token punctuation">,</span> Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span>           <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out               <span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> pvs<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>这个有3个方法，其中第二个方法postProcessAfterInitialization就是重写了BeanPostProcessor的方法。第三个方法postProcessPropertyValues用来操作属性，返回值也应该是PropertyValues对象。</strong></p><p>4、演示工厂后处理器接口方法，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> springBeanTest<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>BeansException<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>config<span class="token punctuation">.</span>BeanDefinition<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>config<span class="token punctuation">.</span>BeanFactoryPostProcessor<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>config<span class="token punctuation">.</span>ConfigurableListableBeanFactory<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanFactoryPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanFactoryPostProcessor</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token function">MyBeanFactoryPostProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是BeanFactoryPostProcessor实现类构造器！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>ConfigurableListableBeanFactory arg0<span class="token punctuation">)</span>           <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"BeanFactoryPostProcessor调用postProcessBeanFactory方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       BeanDefinition bd <span class="token operator">=</span> arg0<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       bd<span class="token punctuation">.</span><span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPropertyValue</span><span class="token punctuation">(</span><span class="token string">"phone"</span><span class="token punctuation">,</span> <span class="token string">"110"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>5、配置文件如下beans.xml，很简单，使用ApplicationContext处理器不用手动注册：</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span>beans xmlns<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/beans"</span>   xmlns<span class="token operator">:</span>xsi<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/XMLSchema-instance"</span> xmlns<span class="token operator">:</span>p<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/p"</span>   xmlns<span class="token operator">:</span>aop<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/aop"</span> xmlns<span class="token operator">:</span>tx<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/tx"</span>   xsi<span class="token operator">:</span>schemaLocation<span class="token operator">=</span>"           http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>beans            http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>beans<span class="token operator">/</span>spring<span class="token operator">-</span>beans<span class="token operator">-</span><span class="token number">3.2</span><span class="token punctuation">.</span>xsd"<span class="token operator">></span>   <span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"beanPostProcessor"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"springBeanTest.MyBeanPostProcessor"</span><span class="token operator">></span>   <span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span>   <span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"instantiationAwareBeanPostProcessor"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"springBeanTest.MyInstantiationAwareBeanPostProcessor"</span><span class="token operator">></span>   <span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span>   <span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"beanFactoryPostProcessor"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"springBeanTest.MyBeanFactoryPostProcessor"</span><span class="token operator">></span>   <span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span>   <span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"person"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"springBeanTest.Person"</span> init<span class="token operator">-</span>method<span class="token operator">=</span><span class="token string">"myInit"</span>       destroy<span class="token operator">-</span>method<span class="token operator">=</span><span class="token string">"myDestory"</span> scope<span class="token operator">=</span><span class="token string">"singleton"</span> p<span class="token operator">:</span>name<span class="token operator">=</span><span class="token string">"张三"</span> p<span class="token operator">:</span>address<span class="token operator">=</span><span class="token string">"广州"</span>       p<span class="token operator">:</span>phone<span class="token operator">=</span><span class="token string">"15900000000"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>beans<span class="token operator">></span></code></pre><p>6、下面测试一下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> springBeanTest<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationContext<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>support<span class="token punctuation">.</span>ClassPathXmlApplicationContext<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanLifeCycle</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"现在开始初始化容器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       ApplicationContext factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"springBeanTest/beans.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"容器初始化成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//得到Preson，并使用</span>       Person person <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">,</span>Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"现在开始关闭容器！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span>ClassPathXmlApplicationContext<span class="token punctuation">)</span>factory<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerShutdownHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>关闭容器使用的是实际是AbstractApplicationContext的钩子方法。</p><p>我们来看一下结果：</p><pre><code>现在开始初始化容器2014-5-18 15:46:20 org.springframework.context.support.AbstractApplicationContext prepareRefresh信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@19a0c7c: startup date [Sun May 18 15:46:20 CST 2014]; root of context hierarchy2014-5-18 15:46:20 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions信息: Loading XML bean definitions from class path resource [springBeanTest/beans.xml]这是BeanFactoryPostProcessor实现类构造器！！BeanFactoryPostProcessor调用postProcessBeanFactory方法这是BeanPostProcessor实现类构造器！！这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！2014-5-18 15:46:20 org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons信息: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@9934d4: defining beans [beanPostProcessor,instantiationAwareBeanPostProcessor,beanFactoryPostProcessor,person]; root of factory hierarchyInstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法【构造器】调用Person的构造器实例化InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法【注入属性】注入属性address【注入属性】注入属性name【注入属性】注入属性phone【BeanNameAware接口】调用BeanNameAware.setBeanName()【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！【InitializingBean接口】调用InitializingBean.afterPropertiesSet()【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法容器初始化成功Person [address=广州, name=张三, phone=110]现在开始关闭容器！【DiposibleBean接口】调用DiposibleBean.destory()【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ Idea 常用快捷键 列表(实战终极总结！！！)</title>
      <link href="/2018/10/18/idea/"/>
      <url>/2018/10/18/idea/</url>
      
        <content type="html"><![CDATA[<p>IntelliJ Idea 常用快捷键 列表 总结</p><h3 id="自动代码"><a href="#自动代码" class="headerlink" title="自动代码"></a>自动代码</h3><p>常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 。</p><p>例如要输入for(User user : users) 只需输入user.for+Tab ;</p><p><strong>再比如，要输入Date birthday = user.getBirthday() 只需输入user.getBirthday().var+Tab即可。<br>代码标签输入完成后，按Tab，生成代码。</strong></p><p>Ctrl+Alt+O 优化导入的类和包 </p><p>Alt+Insert 生成代码(如get,set方法,构造函数等)   或者右键（Generate） </p><p>fori/sout/psvm + Tab  </p><p>Ctrl+Alt+T  生成try catch  或者 Alt+enter </p><p>CTRL+ALT+T  把选中的代码放在 TRY{} IF{} ELSE{} 里 </p><p>Ctrl + O 重写方法  </p><p>Ctrl + I 实现方法 </p><p>Ctrl+shift+U 大小写转化  </p><p>ALT+回车    导入包,自动修正  </p><p>ALT+/       代码提示 </p><p>CTRL+J      自动代码  </p><p>Ctrl+Shift+J，整合两行为一行 </p><p>CTRL+空格   代码提示  </p><p>CTRL+SHIFT+SPACE 自动补全代码  </p><p>CTRL+ALT+L  格式化代码  </p><p>CTRL+ALT+I  自动缩进  </p><p>CTRL+ALT+O  优化导入的类和包  </p><p>ALT+INSERT  生成代码(如GET,SET方法,构造函数等)  </p><p>CTRL+E      最近更改的代码  </p><p>CTRL+ALT+SPACE  类名或接口名提示  </p><p>CTRL+P   方法参数提示  </p><p>CTRL+Q，可以看到当前方法的声明 </p><p>Shift+F6  重构-重命名 (包、类、方法、变量、甚至注释等) </p><p>Ctrl+Alt+V 提取变量 </p><h3 id="查询快捷键"><a href="#查询快捷键" class="headerlink" title="查询快捷键"></a>查询快捷键</h3><p>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 </p><p>CTRL+ALT+ left/right 前后导航编辑过的地方 </p><p>ALT+7  靠左窗口显示当前文件的结构 </p><p>Ctrl+F12 浮动显示当前文件的结构 </p><p>ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 </p><p>CTRL+ALT+F7  找到你的函数或者变量或者类的所有引用到的地方 </p><p>Ctrl+Shift+Alt+N 查找类中的方法或变量 </p><p>双击SHIFT 在项目的所有目录查找文件 </p><p>Ctrl+N   查找类 </p><p>Ctrl+Shift+N 查找文件 </p><p>CTRL+G   定位行  </p><p>CTRL+F   在当前窗口查找文本  </p><p>CTRL+SHIFT+F  在指定窗口查找文本  </p><p>CTRL+R   在 当前窗口替换文本  </p><p>CTRL+SHIFT+R  在指定窗口替换文本  </p><p>ALT+SHIFT+C  查找修改的文件  </p><p>CTRL+E   最近打开的文件  </p><p>F3   向下查找关键字出现位置  </p><p>SHIFT+F3  向上一个关键字出现位置  </p><p>选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本 </p><p>F4   查找变量来源  </p><p>CTRL+SHIFT+O  弹出显示查找内容 </p><p>Ctrl+W 选中代码，连续按会有其他效果 </p><p>F2 或Shift+F2 高亮错误或警告快速定位 </p><p>Ctrl+Up/Down 光标跳转到第一行或最后一行下 </p><p>Ctrl+B 快速打开光标处的类或方法  </p><p>CTRL+ALT+B  找所有的子类  </p><p>CTRL+SHIFT+B  找变量的类  </p><p>Ctrl+Shift+上下键  上下移动代码 </p><p>Ctrl+Alt+ left/right 返回至上次浏览的位置 </p><p>Ctrl+X 删除行 </p><p>Ctrl+D 复制行 </p><p>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ） </p><p>Ctrl+H 显示类结构图 </p><p>Ctrl+Q 显示注释文档 </p><p>Alt+F1 查找代码所在位置 </p><p>Alt+1 快速打开或隐藏工程面板 </p><p>Alt+ left/right 切换代码视图 </p><p>ALT+ ↑/↓  在方法间快速移动定位  </p><p>CTRL+ALT+ left/right 前后导航编辑过的地方 </p><p>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 </p><p>Alt+6    查找TODO </p><h3 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h3><p>SHIFT+ENTER 另起一行 </p><p>CTRL+Z   倒退(撤销) </p><p>CTRL+SHIFT+Z  向前(取消撤销) </p><p>CTRL+ALT+F12  资源管理器打开文件夹  </p><p>ALT+F1   查找文件所在目录位置  </p><p>SHIFT+ALT+INSERT 竖编辑模式  </p><p>CTRL+F4  关闭当前窗口 </p><p>Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 </p><p>Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） </p><h3 id="svn快捷键"><a href="#svn快捷键" class="headerlink" title="svn快捷键"></a>svn快捷键</h3><p>ctrl+k 提交代码到SVN </p><p>ctrl+t 更新代码 </p><h3 id="调试快捷键"><a href="#调试快捷键" class="headerlink" title="调试快捷键"></a>调试快捷键</h3><p>其实常用的 就是F8 F7 F9 最值得一提的就是Drop Frame 可以让运行过的代码从头再来。</p><p>alt+F8    debug时选中查看值 </p><p>Alt+Shift+F9，选择 Debug </p><p>Alt+Shift+F10，选择 Run </p><p>Ctrl+Shift+F9，编译 </p><p>Ctrl+Shift+F8，查看断点 </p><p>F7，步入 </p><p>Shift+F7，智能步入 </p><p>Alt+Shift+F7，强制步入 </p><p>F8，步过 </p><p>Shift+F8，步出 </p><p>Alt+Shift+F8，强制步过 </p><p>Alt+F9，运行至光标处 </p><p>Ctrl+Alt+F9，强制运行至光标处 </p><p>F9，恢复程序 </p><p>Alt+F10，定位到断点 </p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>Ctrl+Alt+Shift+T，弹出重构菜单 </p><p>Shift+F6，重命名 </p><p>F6，移动 </p><p>F5，复制 </p><p>Alt+Delete，安全删除 </p><p>Ctrl+Alt+N，内联 </p><h3 id="十大Intellij-IDEA快捷键"><a href="#十大Intellij-IDEA快捷键" class="headerlink" title="十大Intellij IDEA快捷键"></a>十大Intellij IDEA快捷键</h3><p>Intellij IDEA中有很多快捷键让人爱不释手，stackoverflow上也有一些有趣的讨论。每个人都有自己的最爱，想排出个理想的榜单还真是困难。 </p><p>以前也整理过Intellij的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的十大快捷-神-键吧。 </p><p>1 <strong>智能提示:</strong><br>Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。</p><p>用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。 </p><p>最后要说一点，Intellij能够智能感知Spring、Hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。 </p><p>2 <strong>重构:</strong><br>Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。 </p><p>切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。 </p><p>3 <strong>代码生成：</strong><br>这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。 </p><p>另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。 </p><p>4 <strong>编辑：</strong><br>编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+折叠代码就不多说了。 </p><p>关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。</p><p>5 <strong>查找打开：</strong><br>类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。 </p><p>类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。 </p><p>要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。 </p><p>Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。 </p><p>6 <strong>其他辅助：</strong><br>以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有：</p><p>Ø  命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 </p><p>Ø  新建：Alt+Insert可以新建类、方法等任何东西。 </p><p>Ø  格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。 </p><p>Ø  切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。 </p><p>Ø  单元测试：Ctrl+Alt+T创建单元测试用例。 </p><p>Ø  运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。 </p><p>Ø  调试：F7/F8/F9分别对应Step into，Step over，Continue。<br><i><strong>此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。</strong> </i></p><p>Ø  Top #10切来切去：Ctrl+Tab </p><p>Ø  Top #9选你所想：Ctrl+W </p><p>Ø  Top #8代码生成：Template/Postfix +Tab </p><p>Ø  Top #7发号施令：Ctrl+Shift+A </p><p>Ø  Top #6无处藏身：Shift+Shift </p><p>Ø  Top #5自动完成：Ctrl+Shift+Enter </p><p>Ø  Top #4创造万物：Alt+Insert </p><p><strong>太难割舍，前三名并列吧！</strong></p><p>Ø  Top #1智能补全：Ctrl+Shift+Space </p><p>Ø  Top #1自我修复：Alt+Enter </p><p>Ø  Top #1重构一切：Ctrl+Shift+Alt+T </p><p>CTRL+ALT+ left/right 前后导航编辑过的地方<br>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方</p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring_Ioc</title>
      <link href="/2018/10/18/spring-ioc/"/>
      <url>/2018/10/18/spring-ioc/</url>
      
        <content type="html"><![CDATA[<p>面试被问烂的 Spring IOC(求求你别再问了) </p><h3 id="广义的Ioc"><a href="#广义的Ioc" class="headerlink" title="广义的Ioc"></a>广义的Ioc</h3><p>1）IoC(Inversion of Control) 控制反转，即“不用打电话过来，我们会打给你”。</p><p>两种实现： 依赖查找（DL）和 依赖注入（DI）。</p><p>IoC 和 DI 、DL 的关系（这个 DL，Avalon 和 EJB 就是使用的这种方式实现的 IoC）：</p><p><img src="https://gakkil.gitee.io/gakkil-image/Spring_ioc/20181018125125.png"></p><p>2) DL 已经被抛弃，因为他需要用户自己去是使用 API 进行查找资源和组装对象。即有侵入性。  </p><p>3) DI 是 Spring 使用的方式，容器负责组件的装配。</p><p><strong>注意：</strong><br>Java 使用 DI 方式实现 IoC 的不止 Spring，包括 Google 的 Guice，还有一个冷门的 PicoContainer（极度轻量，但只提供 IoC）。</p><h3 id="Spring的IoC"><a href="#Spring的IoC" class="headerlink" title="Spring的IoC"></a>Spring的IoC</h3><ol><li>依赖注入</li><li>依赖检查</li><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调某些方法(但是需要实现Spring接口，略有侵入)</li></ol><p>其中，最重要的就是依赖注入，从 XML 的配置上说， 即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p><p><strong>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</strong>  </p><p>那么， Spring 如何设计容器的呢？  </p><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。  </p><ol><li>BeanFactory</li><li>ApplicationContext</li></ol><p>BeanFactory 粗暴简单，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p><p>ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。</p><p>例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。  </p><p>该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p><p>当然，除了这两个大接口，还有其他的辅助接口，但我今天不会花太多篇幅介绍他们。</p><p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，我这里通过常用的 ClassPathXmlApplicationContext 类，来展示整个容器的层级 UML 关系。</p><p><img src="https://gakkil.gitee.io/gakkil-image/Spring_ioc/20181018130402.png"></p><p>有点复杂？ 先不要慌，我来解释一下。</p><p>最上面的 BeanFactory 知道吧？我就不讲了。</p><p>下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p><p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p><p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置。生命周期事件回调等。</p><font color="#00ffff" size="4">好，解释了低级容器和高级容器，我们可以看看一个 IoC 启动过程是什么样子的。说白了，就是 ClassPathXmlApplicationContext 这个类，在启动时，都做了啥。</font><p>下图是 ClassPathXmlApplicationContext 的构造过程，实际就是 Spring IoC 的初始化过程。<br><img src="https://gakkil.gitee.io/gakkil-image/Spring_ioc/20181018131026.png"></p><p>注意，这里为了理解方便，有所简化。</p><p>这里再用文字来描述这个过程：</p><ol><li>用户构造 ClassPathXmlApplicationContext（简称 CPAC）</li><li>CPAC 首先访问了 “抽象高级容器” 的 final 的 refresh 方法，这个方法是模板方法。所以要回调子类（低级容器）的 refreshBeanFactory 方法，这个方法的作用是使用低级容器加载所有 BeanDefinition 和 Properties 到容器中。</li><li>低级容器加载成功后，高级容器开始处理一些回调，例如 Bean 后置处理器。回调 setBeanFactory 方法。或者注册监听器等，发布事件，实例化单例 Bean 等等功能，这些功能，随着 Spring 的不断升级，功能越来越多，很多人在这里迷失了方向）。</li></ol><p>简单说就是：</p><ol><li>低级容器 加载配置文件（从 XML，数据库，Applet），并解析成 BeanDefinition 到低级容器中。</li><li>加载成功后，高级容器启动高级功能，例如接口回调，监听器，自动实例化单例，发布事件等等功能。</li></ol><p><strong>所以，一定要把 “低级容器” 和“高级容器” 的区别弄清楚。不能一叶障目不见泰山。</strong></p><p>好，当我们创建好容器，就会使用 getBean 方法，获取 Bean，而 getBean 的流程如下：<br><img src="https://gakkil.gitee.io/gakkil-image/Spring_ioc/20181018131432.png" heigth="50%"></p><p>从图可以看出，getBean 的操作都是在低级容器里操作的。其中有个递归操作，这个是什么意思呢？</p><font color="#00ffff" size="4"><br>假设：当 Bean_A 依赖着 Bean_B，而这个 Bean_A 在加载的时候，其配置的 ref = “Bean_B” 在解析的时候只是一个占位符，被放入了 Bean_A 的属性集合中，当调用 getBean 时，需要真正 Bean_B 注入到 Bean_A 内部时，就需要从容器中获取这个 Bean_B，因此产生了递归。<br></font><p>为什么不是在加载的时候，就直接注入呢？因为加载的顺序不同，很可能 Bean_A 依赖的 Bean_B 还没有加载好，也就无法从容器中获取，你不能要求用户把 Bean 的加载顺序排列好，这是不人道的。</p><p>所以，Spring 将其分为了 2 个步骤：</p><ol><li><p>加载所有的 Bean 配置成 BeanDefinition 到容器中，如果 Bean 有依赖关系，则使用占位符暂时代替。</p></li><li><p>然后，在调用 getBean 的时候，进行真正的依赖注入，即如果碰到了属性是 ref 的（占位符），那么就从容器里获取这个 Bean，然后注入到实例中 —— 称之为依赖注入。<br>可以看到，依赖注入实际上，只需要 “低级容器” 就可以实现。  </p></li></ol><p>这就是 IoC。</p><p>所以 ApplicationContext 的 refresh 方法里面的操作不只是 IoC，是高级容器的所有功能（包括 IoC），IoC 的功能在低级容器里就可以实现。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p><ol><li><p>加载配置文件，解析成 BeanDefinition 放在 Map 里。</p></li><li><p>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p></li></ol><p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p><p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p><p>可以预见，随着 Spring 的不断发展，高级容器的功能会越来越多。</p><font color="#00ffff" size="4"><br>诚然，了解 IoC 的过程，实际上为了了解 Spring 初始化时，各个接口的回调时机。例如 InitializingBean，BeanFactoryAware，ApplicationListener 等等接口。 </font><p>但是请注意，实现 Spring 接口代表着你这个应用就绑定死 Spring 了！代表 Spring 具有侵入性！要知道，Spring 发布时，无侵入性就是他最大的宣传点之一 —— 即 IoC 容器可以随便更换，代码无需变动。而现如今，Spring 已然成为 J2EE 社区准官方解决方案，也没有了所谓的侵入性这个说法。因为他就是标准，和 Servlet 一样，你能不实现 Servlet 的接口吗？</p><p>好了，下次如果再有面试官问 Spring IoC 初始化过程，就再也不会含糊其词、支支吾吾了！！！</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_11</title>
      <link href="/2018/10/17/spring-annotation-day-11/"/>
      <url>/2018/10/17/spring-annotation-day-11/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天学习，@Profile注解的使用。</p><h3 id="Profile注解"><a href="#Profile注解" class="headerlink" title="@Profile注解"></a>@Profile注解</h3><p>Profile：Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能。</p><p>比如：开发环境、测试环境、生产环境；</p><p>根据不同是环境，我们自动切换我们的数据源。</p><p>1）添加c3p0的数据源和mysql的驱动依赖：</p><pre class=" language-java"><code class="language-java">       <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>mvnrepository<span class="token punctuation">.</span>com<span class="token operator">/</span>artifact<span class="token operator">/</span>com<span class="token punctuation">.</span>mchange<span class="token operator">/</span>c3p0 <span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>com<span class="token punctuation">.</span>mchange<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>c3p0<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">0.9</span><span class="token punctuation">.</span><span class="token number">5.2</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>mvnrepository<span class="token punctuation">.</span>com<span class="token operator">/</span>artifact<span class="token operator">/</span>mysql<span class="token operator">/</span>mysql<span class="token operator">-</span>connector<span class="token operator">-</span>java <span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>mysql<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>mysql<span class="token operator">-</span>connector<span class="token operator">-</span>java<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">8.0</span><span class="token punctuation">.</span><span class="token number">12</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre><p>2) 创建数据源的配置dbconfig.properties：</p><pre><code>db.user=rootdb.password=123456db.driverClass=com.mysql.jdbc.Driver </code></pre><p>3) 创建新的配置类MainConfigOfProfile：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"classpath:/dbconfig.properties"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigOfProfile</span> <span class="token keyword">implements</span> <span class="token class-name">EmbeddedValueResolverAware</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${db.user}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String user<span class="token punctuation">;</span>    <span class="token keyword">private</span> StringValueResolver valueResolver<span class="token punctuation">;</span>    <span class="token keyword">private</span> String driverClass<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setEmbeddedValueResolver</span><span class="token punctuation">(</span>StringValueResolver resolver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>valueResolver <span class="token operator">=</span> resolver<span class="token punctuation">;</span>        String driverClass <span class="token operator">=</span> valueResolver<span class="token punctuation">.</span><span class="token function">resolveStringValue</span><span class="token punctuation">(</span><span class="token string">"${db.driverClass}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>driverClass <span class="token operator">=</span> driverClass<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"testDataSource"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> DataSource <span class="token function">dataSourceTest</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${db.password}"</span><span class="token punctuation">)</span> String pwd<span class="token punctuation">)</span> <span class="token keyword">throws</span> PropertyVetoException <span class="token punctuation">{</span>        ComboPooledDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>pwd<span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setJdbcUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setDriverClass</span><span class="token punctuation">(</span>driverClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dataSource<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"devDataSource"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> DataSource <span class="token function">dataSourceDev</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> PropertyVetoException <span class="token punctuation">{</span>        ComboPooledDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setJdbcUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/school"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setDriverClass</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dataSource<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"proDataSource"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> DataSource <span class="token function">dataSourcePro</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> PropertyVetoException <span class="token punctuation">{</span>        ComboPooledDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setJdbcUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/sell"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setDriverClass</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dataSource<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述，有三个不同环境的数据源，test，dev，pro数据源，使用了不同的方式来给数据源进行赋值。</p><p>4）创建新的测试类IoCTest_Profile:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IoCTest_Profile</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>         <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfigOfProfile<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> beanDefinitionNames <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String name <span class="token operator">:</span> beanDefinitionNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>5) 运行：</p><pre><code>mainConfigOfProfiletestDataSourcedevDataSourceproDataSource</code></pre><p>说明数据源都已经注入到容器中了。</p><hr><p>现在我们需要根据不同的环境，来指定加载需要的配置。</p><p>1)使用@Profile注解，是给属性、类加上一个标记的，标记这个属性或者类是属于这个环境的，只有激活了这个环境，才能被注册到容器中，默认激活default的环境，即@Profile(“default”）.</p><p>2)写在配置类上的@Profile，只能在该环境激活的情况下，整个配置类才能起作用，不管配置类里面的Bean是否是符合当前环境。</p><p>3）没有标记环境的bean，在任何环境下都是加载的</p><p><strong>验证：</strong></p><p>1) 在配置类MainConfigOfProfile中，给三个数据源加上标记：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"classpath:/dbconfig.properties"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigOfProfile</span> <span class="token keyword">implements</span> <span class="token class-name">EmbeddedValueResolverAware</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${db.user}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String user<span class="token punctuation">;</span>    <span class="token keyword">private</span> StringValueResolver valueResolver<span class="token punctuation">;</span>    <span class="token keyword">private</span> String driverClass<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setEmbeddedValueResolver</span><span class="token punctuation">(</span>StringValueResolver resolver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>valueResolver <span class="token operator">=</span> resolver<span class="token punctuation">;</span>        String driverClass <span class="token operator">=</span> valueResolver<span class="token punctuation">.</span><span class="token function">resolveStringValue</span><span class="token punctuation">(</span><span class="token string">"${db.driverClass}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>driverClass <span class="token operator">=</span> driverClass<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Profile</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"testDataSource"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> DataSource <span class="token function">dataSourceTest</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${db.password}"</span><span class="token punctuation">)</span> String pwd<span class="token punctuation">)</span> <span class="token keyword">throws</span> PropertyVetoException <span class="token punctuation">{</span>        ComboPooledDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>pwd<span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setJdbcUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setDriverClass</span><span class="token punctuation">(</span>driverClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dataSource<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Profile</span><span class="token punctuation">(</span><span class="token string">"dev"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"devDataSource"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> DataSource <span class="token function">dataSourceDev</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> PropertyVetoException <span class="token punctuation">{</span>        ComboPooledDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setJdbcUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/school"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setDriverClass</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dataSource<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Profile</span><span class="token punctuation">(</span><span class="token string">"pro"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"proDataSource"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> DataSource <span class="token function">dataSourcePro</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> PropertyVetoException <span class="token punctuation">{</span>        ComboPooledDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setJdbcUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/sell"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dataSource<span class="token punctuation">.</span><span class="token function">setDriverClass</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dataSource<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2) 设置当前的环境：</p><p><strong>方法一：</strong>  </p><p> 配置虚拟机的运行参数。</p><p>-Dspring.profiles.active=test</p><p>运行：</p><pre><code>mainConfigOfProfiletestDataSource</code></pre><p>此时，容器中只有testDataSource数据源了。</p><hr><p>-Dspring.profiles.active=dev</p><p>运行：</p><pre><code>mainConfigOfProfiledevDataSource</code></pre><p>此时，容器中只有devDataSource数据源了。</p><p><strong>方法二：</strong>  </p><p>使用无参数的AnnotationConfigApplicationContext容器。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IoCTest_Profile</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1.无参数</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>         <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2.设置环境,这里激活了test和dev</span>        applicationContext<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setActiveProfiles</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span><span class="token string">"dev"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//3.设置配置类</span>        applicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>MainConfigOfProfile<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//4.刷新容器</span>        applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> beanDefinitionNames <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String name <span class="token operator">:</span> beanDefinitionNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><pre><code>mainConfigOfProfiletestDataSourcedevDataSource</code></pre><p>这里，test和dev数据源被激活了。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_10</title>
      <link href="/2018/10/17/spring-annotation-day-10/"/>
      <url>/2018/10/17/spring-annotation-day-10/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天来学习，自定义组件想要使用Spring容器底层的一些组件来开发(ApplicationContext,BeanFactory,xxx)  </p><p>自定义组件实现xxxAware，在创建对象的时候，会调用接口规定的方法注入相关组件，Aware会把Spring底层的一些组件注入到自定义的Bean中。</p><p>xxxAware:功能使用xxxAwareProcessor现实的，比如：ApplicationContextAware是用ApplicationContextAwareProcessor注入的。</p><h3 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h3><p>1）在com.liuzhuo.bean包，随便找个Bean来实验：</p><p>这里使用Red类来实验：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Red</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ApplicationContext applicationContext<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span>ApplicationContext applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext <span class="token operator">=</span> applicationContext<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"容器:"</span> <span class="token operator">+</span> applicationContext<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2）将Red类注入到容器中，使用包扫描，修改MainConfigOfAutowired配置类：<br><strong>加入了com.liuzhuo.bean包的扫描</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"com.liuzhuo.controller"</span><span class="token punctuation">,</span> <span class="token string">"com.liuzhuo.service"</span><span class="token punctuation">,</span> <span class="token string">"com.liuzhuo.dao"</span><span class="token punctuation">,</span><span class="token string">"com.liuzhuo.bean"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigOfAutowired</span></code></pre><p>3) 运行测试类IocTest_Autowired：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IocTest_Autowired</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfigOfAutowired<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>4) 运行结果：</p><pre><code>org.springframework.context.event.internalEventListenerProcessor------postProcessBeforeInitializationorg.springframework.context.event.internalEventListenerProcessor------postProcessAfterInitializationorg.springframework.context.event.internalEventListenerFactory------postProcessBeforeInitializationorg.springframework.context.event.internalEventListenerFactory------postProcessAfterInitializationmainConfigOfAutowired------postProcessBeforeInitializationmainConfigOfAutowired------postProcessAfterInitializationbookController------postProcessBeforeInitializationbookController------postProcessAfterInitializationbookDao2------postProcessBeforeInitializationbookDao2------postProcessAfterInitializationbookService------postProcessBeforeInitializationbookService------postProcessAfterInitializationbookDao------postProcessBeforeInitializationbookDao------postProcessAfterInitializationCat constructer ···cat------postProcessBeforeInitializationCat afterPropertiesSet ····cat------postProcessAfterInitializationDog construct ····dog------postProcessBeforeInitializationDog @PostConstruct ····dog------postProcessAfterInitialization容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:08:27 CST 2018]; root of context hierarchyred------postProcessBeforeInitializationred------postProcessAfterInitializationDog @PreDestroy ····Cat destroy ····十月 17, 2018 2:08:28 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:08:27 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>能观察到：</p><p><code>容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:08:27 CST 2018]; root of context hierarchy</code></p><p>说明在Red类中，注入了容器类。</p><p>5）验证是否是同一个容器，修改测试方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IocTest_Autowired</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfigOfAutowired<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>        applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>6) 运行测试方法：</p><pre><code>org.springframework.context.event.internalEventListenerProcessor------postProcessBeforeInitializationorg.springframework.context.event.internalEventListenerProcessor------postProcessAfterInitializationorg.springframework.context.event.internalEventListenerFactory------postProcessBeforeInitializationorg.springframework.context.event.internalEventListenerFactory------postProcessAfterInitializationmainConfigOfAutowired------postProcessBeforeInitializationmainConfigOfAutowired------postProcessAfterInitializationbookController------postProcessBeforeInitializationbookController------postProcessAfterInitializationbookDao2------postProcessBeforeInitializationbookDao2------postProcessAfterInitializationbookService------postProcessBeforeInitializationbookService------postProcessAfterInitializationbookDao------postProcessBeforeInitializationbookDao------postProcessAfterInitializationCat constructer ···cat------postProcessBeforeInitializationCat afterPropertiesSet ····cat------postProcessAfterInitializationDog construct ····dog------postProcessBeforeInitializationDog @PostConstruct ····dog------postProcessAfterInitialization容器:org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:14:10 CST 2018]; root of context hierarchyred------postProcessBeforeInitializationred------postProcessAfterInitialization十月 17, 2018 2:14:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:14:10 CST 2018]; root of context hierarchyorg.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Wed Oct 17 14:14:10 CST 2018]; root of context hierarchyDog @PreDestroy ····Cat destroy ····Process finished with exit code 0</code></pre><p>观察到：<br>容器:</p><p><code>org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf:</code></p><p><code>org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf:</code></p><p>一样，都是@2f410acf，说明是一个容器。</p><hr><h3 id="BeanNameAware"><a href="#BeanNameAware" class="headerlink" title="BeanNameAware"></a>BeanNameAware</h3><p>给自定义组件，注入自己在容器的id名。</p><p>1）修改Red类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Red</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span><span class="token punctuation">,</span>BeanNameAware <span class="token punctuation">{</span>    <span class="token keyword">private</span> ApplicationContext applicationContext<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span>ApplicationContext applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext <span class="token operator">=</span> applicationContext<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"容器:"</span> <span class="token operator">+</span> applicationContext<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义组件的id名字："</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2) 运行测试方法：</p><pre class=" language-java"><code class="language-java">自定义组件的id名字：red容器<span class="token operator">:</span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>AnnotationConfigApplicationContext<span class="token annotation punctuation">@2f410acf</span><span class="token operator">:</span> startup date <span class="token punctuation">[</span>Wed Oct <span class="token number">17</span> <span class="token number">14</span><span class="token operator">:</span><span class="token number">21</span><span class="token operator">:</span><span class="token number">56</span> CST <span class="token number">2018</span><span class="token punctuation">]</span><span class="token punctuation">;</span> root of context hierarchyred<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>postProcessBeforeInitializationred<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>postProcessAfterInitialization</code></pre><p><strong>总结：</strong></p><p>想让自定义组件使用Spring底层的组件，就实现xxxAware接口就行。</p><p>ApplicationContextAware<br>ApplicationEventPublisherAware<br>BeanClassLoaderAware<br>BeanFactoryAware<br>BeanNameAware<br>BootstrapContextAware<br>EmbeddedValueResolverAware<br>EnvironmentAware<br>ImportAware<br>LoadTimeWeaverAware<br>MessageSourceAware<br>NotificationPublisherAware<br>PortletConfigAware<br>PortletContextAware<br>ResourceLoaderAware<br>SchedulerContextAware<br>ServletConfigAware<br>ServletContextAware</p><hr><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>1）在Red类下的setApplicationContext方法上面打上断点</p><p>2) 运行测试方法：</p><p>发现ApplicationContextAware是由ApplicationContextAwareProcessor处理的：</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span><span class="token keyword">final</span> Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        AccessControlContext acc <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">EnvironmentAware</span> <span class="token operator">||</span> bean <span class="token keyword">instanceof</span> <span class="token class-name">EmbeddedValueResolverAware</span> <span class="token operator">||</span>                        bean <span class="token keyword">instanceof</span> <span class="token class-name">ResourceLoaderAware</span> <span class="token operator">||</span> bean <span class="token keyword">instanceof</span> <span class="token class-name">ApplicationEventPublisherAware</span> <span class="token operator">||</span>                        bean <span class="token keyword">instanceof</span> <span class="token class-name">MessageSourceAware</span> <span class="token operator">||</span> bean <span class="token keyword">instanceof</span> <span class="token class-name">ApplicationContextAware</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            acc <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAccessControlContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>acc <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> Object <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">invokeAwareInterfaces</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> null<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> acc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">invokeAwareInterfaces</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>内部执行postProcessBeforeInitialization方法来判断自定义的组件是否实现类xxxAware接口。</p><p>最后调用invokeAwareInterfaces(bean)方法</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeAwareInterfaces</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">Aware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">EnvironmentAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>EnvironmentAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setEnvironment</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">EmbeddedValueResolverAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>EmbeddedValueResolverAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setEmbeddedValueResolver</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>embeddedValueResolver<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">ResourceLoaderAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>ResourceLoaderAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setResourceLoader</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">ApplicationEventPublisherAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>ApplicationEventPublisherAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setApplicationEventPublisher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">MessageSourceAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>MessageSourceAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setMessageSource</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">ApplicationContextAware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>ApplicationContextAware<span class="token punctuation">)</span> bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setApplicationContext</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>调用相应的方法来实现注入。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_09</title>
      <link href="/2018/10/16/spring-annotation-day-09/"/>
      <url>/2018/10/16/spring-annotation-day-09/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>Spring的自动装配：  </p><p>Spring利用依赖注入(DI)，完成对IoC容器中各个组件的依赖关系赋值。</p><h3 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="@Autowired注解"></a>@Autowired注解</h3><p>1）在com.liuzhuo.config包下，创建新的类MainConfigOfAutowired：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并扫描三个包.</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"com.liuzhuo.controller"</span><span class="token punctuation">,</span> <span class="token string">"com.liuzhuo.service"</span><span class="token punctuation">,</span> <span class="token string">"com.liuzhuo.dao"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigOfAutowired</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>2) 修改BookService类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> BookDao bookDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">BookService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"BookService{"</span> <span class="token operator">+</span>                <span class="token string">"bookDao="</span> <span class="token operator">+</span> bookDao <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3) 修改BookDao类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Repository</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Integer laber <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">BookDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">BookDao</span><span class="token punctuation">(</span>Integer laber<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>laber <span class="token operator">=</span> laber<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"BookDao{"</span> <span class="token operator">+</span>                <span class="token string">"laber="</span> <span class="token operator">+</span> laber <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>4) 创建新的测试类IocTest_Autowired：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IocTest_Autowired</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfigOfAutowired<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BookService bookService <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>BookService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bookService<span class="token punctuation">)</span><span class="token punctuation">;</span>        applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>5) 运行：</p><pre><code>十月 16, 2018 9:20:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:20:48 CST 2018]; root of context hierarchyBookService{bookDao=BookDao{laber=1}}十月 16, 2018 9:20:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:20:48 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>看到，BookService对象中的BookDao对象也注入进来了。</p><hr><p>当我们有多个相同类型的对象时，会注入哪个对象呢？</p><p>1）我们在配置文件MainConfigOfAutowired中添加先的BookDao对象：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"com.liuzhuo.controller"</span><span class="token punctuation">,</span> <span class="token string">"com.liuzhuo.service"</span><span class="token punctuation">,</span> <span class="token string">"com.liuzhuo.dao"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigOfAutowired</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> BookDao <span class="token function">bookDao2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BookDao</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2）运行测试：</p><pre><code>十月 16, 2018 9:27:35 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:27:35 CST 2018]; root of context hierarchy十月 16, 2018 9:27:36 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doCloseBookService{bookDao=BookDao{laber=1}}信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:27:35 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p><strong>结果不变，说明有多个相同类型时，注入到容器中的对象是与@AutoWired下面属性的名字相同的id的Bean对象。</strong></p><p>3）验证我们的结论，修改BookService类下的属性BookDao的属性名字：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> BookDao bookDao2<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">BookService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"BookService{"</span> <span class="token operator">+</span>                <span class="token string">"bookDao="</span> <span class="token operator">+</span> bookDao2 <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>4) 运行测试：</p><pre><code>十月 16, 2018 9:30:54 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:30:54 CST 2018]; root of context hierarchy十月 16, 2018 9:30:54 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doCloseBookService{bookDao=BookDao{laber=2}}信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:30:54 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>验证正确，说明注入的Bean是与属性的名字相同的对象。</p><hr><p>除了，上述的方法来处理多个相同类型的对象。我们还可以使用 @Qualifier来指定注入容器中的Bean的id名。</p><p>1）修改BookService类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"bookDao"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> BookDao bookDao2<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">BookService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"BookService{"</span> <span class="token operator">+</span>                <span class="token string">"bookDao="</span> <span class="token operator">+</span> bookDao2 <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2) 测试：</p><pre><code>十月 16, 2018 9:34:12 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:34:12 CST 2018]; root of context hierarchy十月 16, 2018 9:34:12 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:34:12 CST 2018]; root of context hierarchyBookService{bookDao=BookDao{laber=1}}Process finished with exit code 0</code></pre><p>此时注入容器中的BookDao对象就是@Qualifier(“bookDao”)注解的对象，而不是bookDao2了。</p><hr><p>默认情况下，@Autowired注解的属性，必须要在容器中已经注入了，否则会报错。</p><p>1）将刚刚的两个BookDao对象都注释掉。</p><p>2）运行测试：</p><pre><code>十月 16, 2018 9:38:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:38:48 CST 2018]; root of context hierarchy十月 16, 2018 9:38:48 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext refresh警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;bookService&#39;: Unsatisfied dependency expressed through field &#39;bookDao2&#39;; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;com.liuzhuo.dao.BookDao&#39; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;bookService&#39;: Unsatisfied dependency expressed through field &#39;bookDao2&#39;; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;com.liuzhuo.dao.BookDao&#39; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}···Process finished with exit code -1</code></pre><h4 id="required属性"><a href="#required属性" class="headerlink" title="required属性"></a>required属性</h4><p>我们也可以使@Autowired注解的属性，不是必须的，即使容器中没有该Bean，也不会报错！<br>因为@Autowired注解里面有一个属性 boolean required() default true;<br>将required设置为：false</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookService</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//@Qualifier("bookDao")</span>    <span class="token annotation punctuation">@Autowired</span><span class="token punctuation">(</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> BookDao bookDao2<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">BookService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"BookService{"</span> <span class="token operator">+</span>                <span class="token string">"bookDao="</span> <span class="token operator">+</span> bookDao2 <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行：</p><pre><code>十月 16, 2018 9:43:23 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:43:23 CST 2018]; root of context hierarchy十月 16, 2018 9:43:24 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:43:23 CST 2018]; root of context hierarchyBookService{bookDao=null}Process finished with exit code 0</code></pre><p>此时不报错了。默认情况下，必须给@Autowired注解的属性，注入到容器中。</p><hr><h4 id="primary注解"><a href="#primary注解" class="headerlink" title="@primary注解"></a>@primary注解</h4><p>@primary注解：使用这个注解，就是当有多个类型的情况下，优先注入的bean对象：</p><p>1) 修改配置文件：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"com.liuzhuo.controller"</span><span class="token punctuation">,</span> <span class="token string">"com.liuzhuo.service"</span><span class="token punctuation">,</span> <span class="token string">"com.liuzhuo.dao"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigOfAutowired</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Primary</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"bookDao2"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> BookDao <span class="token function">bookDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BookDao</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2) 修改BookService：注释掉@Qualifier(“bookDao”)</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookService</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//@Qualifier("bookDao")</span>    <span class="token annotation punctuation">@Autowired</span><span class="token punctuation">(</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> BookDao bookDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">BookService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"BookService{"</span> <span class="token operator">+</span>                <span class="token string">"bookDao="</span> <span class="token operator">+</span> bookDao <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3) 运行测试：</p><pre><code>十月 16, 2018 9:47:44 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:47:44 CST 2018]; root of context hierarchyBookService{bookDao=BookDao{laber=2}}十月 16, 2018 9:47:44 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:47:44 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>此时，输出的是laber=2的BookDao对象了，不再根据@Autowired注解下的属性名来注入到容器中了。</p><p>4）将BookService中的@Qualifier(“bookDao”)的注释去掉：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"bookDao"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Autowired</span><span class="token punctuation">(</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> BookDao bookDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">BookService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"BookService{"</span> <span class="token operator">+</span>                <span class="token string">"bookDao="</span> <span class="token operator">+</span> bookDao <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>5) 运行测试：</p><pre><code>十月 16, 2018 9:51:00 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:51:00 CST 2018]; root of context hierarchyBookService{bookDao=BookDao{laber=1}}十月 16, 2018 9:51:00 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 21:51:00 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p><strong>说明：当@Primary和@Qualifier同时存在时，是以@Qualifier为标准的！</strong></p><hr><h3 id="Resource注解"><a href="#Resource注解" class="headerlink" title="@Resource注解"></a>@Resource注解</h3><p>1）修改BookService类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookService</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//@Qualifier("bookDao")</span>    <span class="token comment" spellcheck="true">//@Autowired(required = false)</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> BookDao bookDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">BookService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"BookService{"</span> <span class="token operator">+</span>                <span class="token string">"bookDao="</span> <span class="token operator">+</span> bookDao <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2) 运行：</p><pre><code>十月 16, 2018 10:09:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:09:41 CST 2018]; root of context hierarchy十月 16, 2018 10:09:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:09:41 CST 2018]; root of context hierarchyBookService{bookDao=BookDao{laber=1}}Process finished with exit code 0</code></pre><p>此时，输出的是laber=1的bookService对象，说明@primary注解没有起作用。<br>@Resource注解，默认是注入属性的名。也可以通过@Resource的name属性来修改需要注入到容器中的Bean对象。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookService</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//@Qualifier("bookDao")</span>    <span class="token comment" spellcheck="true">//@Autowired(required = false)</span>    <span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"bookDao2"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> BookDao bookDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">BookService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"BookService{"</span> <span class="token operator">+</span>                <span class="token string">"bookDao="</span> <span class="token operator">+</span> bookDao <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行：</p><pre><code>十月 16, 2018 10:13:02 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:13:02 CST 2018]; root of context hierarchyBookService{bookDao=BookDao{laber=2}}十月 16, 2018 10:13:02 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:13:02 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><hr><h3 id="Inject注解"><a href="#Inject注解" class="headerlink" title="@Inject注解"></a>@Inject注解</h3><p>@Inject注解：需要导入javax.inject包。</p><p>1）在pom文件中添加依赖：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;javax.inject&lt;/groupId&gt;    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;    &lt;version&gt;1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>2) 修改BookService类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookService</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//@Qualifier("bookDao")</span>    <span class="token comment" spellcheck="true">//@Autowired(required = false)</span>    <span class="token comment" spellcheck="true">//@Resource(name = "bookDao2")</span>    <span class="token annotation punctuation">@Inject</span>    <span class="token keyword">private</span> BookDao bookDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">BookService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"BookService{"</span> <span class="token operator">+</span>                <span class="token string">"bookDao="</span> <span class="token operator">+</span> bookDao <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3) 运行：</p><pre><code>十月 16, 2018 10:16:52 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:16:52 CST 2018]; root of context hierarchy十月 16, 2018 10:16:52 下午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;信息: JSR-330 &#39;javax.inject.Inject&#39; annotation found and supported for autowiringBookService{bookDao=BookDao{laber=2}}十月 16, 2018 10:16:52 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Tue Oct 16 22:16:52 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>输出的是laber=2的BookService对象，说明支持@primary注解。</p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1）@Autowired：自动注入<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1）、默认优先按照类型去容器中找对应的组件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2）、如果找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查找<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3）、@Qualifier：使用@Qualifier指定需要装配的组件的id，而不使用属性名<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.4）、自动装配默认是一定将属性赋值好，没有就报错。可以使用@Autowired(required=false)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.5）、@Primary:当存在多个同类型的Bean时，优先装配的Bean，优先级没有@Qualifier高。  </p><p>2）Spring还支持使用@Resource(JSR250)和@Inject(JSR330)[java规范的注解]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Resource：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以和@Autowired一样实现自动装配功能，默认是按照组件名称进行装配的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不支持@primary功能和@Autowired(required=false)功能，但是有@Resource(name = “bookDao2”)修改注入容器Bean的id的功能。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Inject：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要导入javax.inject包，和@Autowired的功能一样，但是没有required=false的功能。</p><p>3）@Autowired是Spring定义的，只能在有Spring的环境时才有作用，@Resource和@Inject注解是java规范，只要是满足java规范的都可以使用，意思就是跨框架性更好。</p><p>4）上述自动注入都是通过AutowiredAnnotationBeanPostProcessor这个后置处理器完成。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_08</title>
      <link href="/2018/10/16/spring-annotation-day-08/"/>
      <url>/2018/10/16/spring-annotation-day-08/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习Spring的自动注入</p><h3 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h3><p>使用@Value注解来注入值</p><p>1）在com.liuzhuo.config包下，创建新的配置类MainConfigOfProperty：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigOfProperty</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Person <span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2）在com.liuzhuo.test包下，创建新的测试类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PropertyTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfigOfProperty<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printBeanName</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">printBeanName</span><span class="token punctuation">(</span>AnnotationConfigApplicationContext applicationContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String name <span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3) 运行测试方法：test01</p><pre><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymainConfigOfPropertypersonPerson{name=&#39;null&#39;, age=null}十月 16, 2018 5:34:32 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2ff5659e: startup date [Tue Oct 16 17:34:31 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>我们能看到，打印出来的Person对象的属性都是null。</p><p>4）修改Person类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    * value:    *     1.使用直接值，比如字符串，数值等    *     2.使用SpEL表达式，#{}    *     3.使用${},获取资源文件中的数据    * */</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"#{20-2}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    ·····<span class="token punctuation">}</span></code></pre><p>5）再次运行test01：</p><pre><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymainConfigOfPropertypersonPerson{name=&#39;张三&#39;, age=18}十月 16, 2018 5:37:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2ff5659e: startup date [Tue Oct 16 17:37:41 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><hr><h3 id="PropertySource注解"><a href="#PropertySource注解" class="headerlink" title="@PropertySource注解"></a>@PropertySource注解</h3><p>使用@PropertySource注解来获取资源配置文件中的数据。</p><p>1）在resource包下，创建person.properties文件：</p><pre><code>person.nickName=小张三</code></pre><p>2) 修改Person类：<br>添加nickName属性和对应的get、set方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * value:     *     1.使用直接值，比如字符串，数值等     *     2.使用SpEL表达式，#{}     *     3.使用${},获取资源文件中的数据     * */</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"#{20-2}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${person.nickName}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String nickName<span class="token punctuation">;</span>    ·····<span class="token punctuation">}</span></code></pre><p>3）在配置文件中，加入资源文件的扫描：<br>&nbsp;&nbsp;&nbsp;@PropertySource(value = “classpath:person.properties”)</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"classpath:person.properties"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigOfProperty</span></code></pre><p>这里的@PropertySource(value = “classpath:person.properties”)，相当于以前在xml中的配置的<br>&lt;context:property-placeholder location=”person.properties”/&gt;，如下：</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span>beans xmlns<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/beans"</span>       xmlns<span class="token operator">:</span>context<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/context"</span>       xmlns<span class="token operator">:</span>xsi<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/XMLSchema-instance"</span>       xsi<span class="token operator">:</span>schemaLocation<span class="token operator">=</span>"        http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>beans        http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>beans<span class="token operator">/</span>spring<span class="token operator">-</span>beans<span class="token punctuation">.</span>xsd        http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>context        http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>context<span class="token operator">/</span>spring<span class="token operator">-</span>context<span class="token punctuation">.</span>xsd"<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>包扫描、只要标注了<span class="token annotation punctuation">@Controller</span>、<span class="token annotation punctuation">@Service</span>、<span class="token annotation punctuation">@Repository</span>、<span class="token annotation punctuation">@Component</span>都会自动注入到容器中<span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token operator">&lt;</span>context<span class="token operator">:</span>component<span class="token operator">-</span>scan base<span class="token operator">-</span><span class="token keyword">package</span><span class="token operator">=</span><span class="token string">"com.liuzhuo"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>扫描资源文件<span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>context<span class="token operator">:</span>property<span class="token operator">-</span>placeholder location<span class="token operator">=</span><span class="token string">"person.properties"</span><span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>以前的开发模式，使用配置文件<span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"person"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.liuzhuo.bean.Person"</span> init<span class="token operator">-</span>method<span class="token operator">=</span><span class="token string">""</span> destroy<span class="token operator">-</span>method<span class="token operator">=</span><span class="token string">""</span><span class="token operator">></span>        <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"name"</span> value<span class="token operator">=</span><span class="token string">"zhangsan"</span><span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"age"</span> value<span class="token operator">=</span><span class="token string">"18"</span><span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>beans<span class="token operator">></span></code></pre><p>4) 运行test01：</p><pre><code>mainConfigOfPropertypersonPerson{name=&#39;张三&#39;, age=18, nickName=&#39;小张三&#39;}</code></pre><p>这里的昵称，小张三也打印出来了。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_07</title>
      <link href="/2018/10/16/spring-annotation-day-07/"/>
      <url>/2018/10/16/spring-annotation-day-07/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天学习BeanPostProcessor的生命周期流程</p><h3 id="BeanPostProcessor的生命周期流程"><a href="#BeanPostProcessor的生命周期流程" class="headerlink" title="BeanPostProcessor的生命周期流程"></a>BeanPostProcessor的生命周期流程</h3><p>我们知道BeanPostProcessor是后置处理器，是在Bean初始化前后执行一些列操作的，底层到底是怎么执行的呢？现在debug一下。</p><p>1）设置断点，在com.liuzhuo.bean包下的MyBeanPostProcessor类中，给postProcessBeforeInitialization方法设置断点。</p><p><img src="https://gakkil.gitee.io/gakkil-image/spring_annotation/day07/20181016100600.png"></p><p>2) debug一下。发现调用栈如下：</p><p><img src="https://gakkil.gitee.io/gakkil-image/spring_annotation/day07/20181016101036.png" style="width:50%"></p><p>程序是从test01开始：</p><p>1）创建AnnotationConfigApplicationContext对象  </p><p>2）执行AnnotationConfigApplicationContext的构造方法：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token function">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> annotatedClasses<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">register</span><span class="token punctuation">(</span>annotatedClasses<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>3) 调用refresh()方法：完成一系列资源配置操作。最后调用finishBeanFactoryInitialization()方法，初始化容器。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">,</span> IllegalStateException <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>startupShutdownMonitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Prepare this context for refreshing.</span>            <span class="token function">prepareRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Tell the subclass to refresh the internal bean factory.</span>            ConfigurableListableBeanFactory beanFactory <span class="token operator">=</span> <span class="token function">obtainFreshBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Prepare the bean factory for use in this context.</span>            <span class="token function">prepareBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Allows post-processing of the bean factory in context subclasses.</span>                <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Invoke factory processors registered as beans in the context.</span>                <span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Register bean processors that intercept bean creation.</span>                <span class="token function">registerBeanPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Initialize message source for this context.</span>                <span class="token function">initMessageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Initialize event multicaster for this context.</span>                <span class="token function">initApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Initialize other special beans in specific context subclasses.</span>                <span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Check for listener beans and register them.</span>                <span class="token function">registerListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Instantiate all remaining (non-lazy-init) singletons.</span>                <span class="token function">finishBeanFactoryInitialization</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Last step: publish corresponding event.</span>                <span class="token function">finishRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Exception encountered during context initialization - "</span> <span class="token operator">+</span>                            <span class="token string">"cancelling refresh attempt: "</span> <span class="token operator">+</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Destroy already created singletons to avoid dangling resources.</span>                <span class="token function">destroyBeans</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Reset 'active' flag.</span>                <span class="token function">cancelRefresh</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Propagate exception to caller.</span>                <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Reset common introspection caches in Spring's core, since we</span>                <span class="token comment" spellcheck="true">// might not ever need metadata for singleton beans anymore...</span>                <span class="token function">resetCommonCaches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>4）进入finishBeanFactoryInitialization：<br>调用<br><code>beanFactory.preInstantiateSingletons();</code></p><p>5) 最终调用doCreateBean()方法：<br>我们主要看其中的：</p><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">// Initialize the bean instance.</span>        Object exposedObject <span class="token operator">=</span> bean<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>exposedObject <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                exposedObject <span class="token operator">=</span> <span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><p>populateBean: 给Bean的属性赋值等操作<br>initializeBean: Bean初始化操作。</p><p>6）点击initializeBean方法:</p><pre class=" language-java"><code class="language-java">        Object wrappedBean <span class="token operator">=</span> bean<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isSynthetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            wrappedBean <span class="token operator">=</span> <span class="token function">applyBeanPostProcessorsBeforeInitialization</span><span class="token punctuation">(</span>wrappedBean<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">invokeInitMethods</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> wrappedBean<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>                    <span class="token punctuation">(</span>mbd <span class="token operator">!=</span> null <span class="token operator">?</span> mbd<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">,</span>                    beanName<span class="token punctuation">,</span> <span class="token string">"Invocation of init method failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isSynthetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            wrappedBean <span class="token operator">=</span> <span class="token function">applyBeanPostProcessorsAfterInitialization</span><span class="token punctuation">(</span>wrappedBean<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> wrappedBean<span class="token punctuation">;</span></code></pre><p>其中：<br>applyBeanPostProcessorsBeforeInitialization：完成初始化之前的操作。</p><p>invokeInitMethods：初始化是操作(@PostConstruc、init-method等)</p><p>applyBeanPostProcessorsAfterInitialization：完成初始化之后的操作。</p><p>7）点击applyBeanPostProcessorsBeforeInitialization：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">applyBeanPostProcessorsBeforeInitialization</span><span class="token punctuation">(</span>Object existingBean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        Object result <span class="token operator">=</span> existingBean<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>BeanPostProcessor beanProcessor <span class="token operator">:</span> <span class="token function">getBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">=</span> beanProcessor<span class="token punctuation">.</span><span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>发现：就是使用for循环来调用一系列BeanPostProcessor接口的实现类，包括Spring容器自身的和我们自定义的实现类。</p><p><strong>注意:如果其中的某一个BeanPostProcessor实现类返回了null，那么后面的BeanPostProcessor实现类就不执行了！！！</strong></p><p>大概的流程就走完了~~~</p><hr><h3 id="Spring底层对BeanPostProcessor的使用"><a href="#Spring底层对BeanPostProcessor的使用" class="headerlink" title="Spring底层对BeanPostProcessor的使用"></a>Spring底层对BeanPostProcessor的使用</h3><p>ps：在idea中：类名查找类:Ctrl+Shift+Alt+N; </p><p><img src="https://gakkil.gitee.io/gakkil-image/spring_annotation/day07/20181016104349.png"></p><p>1) 找到BeanPostProcessor接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">{</span>    Object <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">;</span>    Object <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2) 在BeanPostProcessor上Ctrl+T：找到所有的实现类：</p><p><img src="https://gakkil.gitee.io/gakkil-image/spring_annotation/day07/20181016105219.png"></p><p>我们能看到各种BeanPostProcessor的实现类</p><p>3）ApplicationContextAwareProcessor</p><p>我们使用一下ApplicationContextAwareProcessor这个处理器。这个处理器是给我们的自定义Bean注入上下文容器的。</p><p>4）在com.liuzhuo.bean包下，随便找个一个Bean，并实现ApplicationContextAware接口：<br>ps:这里使用的Dog类</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span> </code></pre><p>5）需要实现：setApplicationContext方法</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span>ApplicationContext applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext <span class="token operator">=</span> applicationContext<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>这样我们就将上下文组件注入到Dog类中，在Dog类中就能使用ApplicationContext上下容器了。</p><hr><p>还有：<br>InitDestroyAnnotationBeanPostProcessor处理我们的: @PostConstruct、@PreDestory注解。<br>AutowiredAnnotationBeanPostProcessor处理我们的: @Autowired注解等。</p><p><strong>总结：<br>&nbsp;&nbsp;&nbsp;&nbsp;Spring对底层BeanPostProcessor的使用：bean的赋值、注入其他组件、@Autowired、生命周期注解功能、@Async、xxxBeanPostProcessor等等。</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_06</title>
      <link href="/2018/10/15/spring-annotation-day-06/"/>
      <url>/2018/10/15/spring-annotation-day-06/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习Bean的生命周期</p><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p>在Spring中Bean的生命周期：<br>Bean的创建—-初始化—–调用—–销毁。</p><p>构造(对象的创建)：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单实例：在容器启动的时候创建对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多实例：在每次获取的时候创建对象 </p><p>初始化：<br>对象创建完成，并赋值好，调用初始化方法</p><p>销毁：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单实例：容器关闭的时候<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多实例：容器不会管理这个Bean，容器不会调用销毁方法</p><p>以前，我们定义初始化和销毁方法是在xml文件中配置的：</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>以前的开发模式，使用配置文件<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"person"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.liuzhuo.bean.Person"</span> init<span class="token operator">-</span>method<span class="token operator">=</span><span class="token string">""</span> destroy<span class="token operator">-</span>method<span class="token operator">=</span><span class="token string">""</span><span class="token operator">></span>    <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"name"</span> value<span class="token operator">=</span><span class="token string">"zhangsan"</span><span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"age"</span> value<span class="token operator">=</span><span class="token string">"18"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span></code></pre><p>init-method=””    : 定义初始化方法<br>destroy-method=”” : 定义销毁方法  </p><hr><p>现在，我们可以使用其他方式来完成生命周期。</p><h4 id="通过-Bean指定init-method和destroy-method"><a href="#通过-Bean指定init-method和destroy-method" class="headerlink" title="通过@Bean指定init-method和destroy-method"></a>通过@Bean指定init-method和destroy-method</h4><p>1）在com.liuzhuo.config包下，创建MainConfigOfLife配置类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigOfLife</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>2) 在com.liuzhuo.bean包下，创建Car类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Car construct ····"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//定义初始化方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Car init ·····"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//定义销毁方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Car destory ·····"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3) 将Car注册到容器中：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigOfLife</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"init"</span><span class="token punctuation">,</span>destroyMethod <span class="token operator">=</span> <span class="token string">"destory"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Car <span class="token function">car</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>4) 在com.liuzhuo.test包下，创建新的测试类(IocOfLifeTest):</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IocOfLifeTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>                <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfigOfLife<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>5)运行测试test01方法：</p><pre><code>Car construct ····Car init ·····</code></pre><p>说明：单例模式下，容器启动就会将Bean对象注入到容器中，并执行了初始化方法。</p><p>想要调用销毁方法，关闭容器就好。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IocOfLifeTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//启动容器</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>                <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfigOfLife<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭容器</span>        applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><pre><code>D:\Java1.8\bin\java十月 15, 2018 9:08:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:08:11 CST 2018]; root of context hierarchyCar construct ····Car init ·····十月 15, 2018 9:08:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:08:11 CST 2018]; root of context hierarchyCar destory ·····Process finished with exit code 0</code></pre><hr><h4 id="InitializingBean和DisposableBean"><a href="#InitializingBean和DisposableBean" class="headerlink" title="InitializingBean和DisposableBean"></a>InitializingBean和DisposableBean</h4><p>通过让Bean实现InitializingBean和DisposableBean两个接口来定义初始化和销毁。</p><p>1）在com.liuzhuo.bean包下，创建Cat类，并实现上述两个接口：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">,</span> DisposableBean <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Cat constructer ···"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Cat destroy ····"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Cat afterPropertiesSet ····"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2) 将Cat类注入到容器中，这里我使用了包扫描:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"com.liuzhuo"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigOfLife</span> </code></pre><p>3) 运行测试方法test01:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IocOfLifeTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//启动容器</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>                <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfigOfLife<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object cat <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"cat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭容器</span>        applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>4) 结果：</p><pre><code>十月 15, 2018 9:21:42 下午 org.springframework.beans.factory.support.DefaultListableBeanFactory registerBeanDefinition信息: Overriding bean definition for bean &#39;person&#39; with a different definition: replacing [Generic bean: class [com.liuzhuo.bean.Person]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [E:\ideaProject\springannotation\target\classes\com\liuzhuo\bean\Person.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=true; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=mainConfig2; factoryMethodName=person; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/liuzhuo/config/MainConfig2.class]]Cat constructer ···Cat afterPropertiesSet ····Car construct ····Car init ·····十月 15, 2018 9:21:43 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:21:42 CST 2018]; root of context hierarchyCar destory ·····Cat destroy ····</code></pre><hr><h4 id="JSR250-PostConstruct和-PreDestory"><a href="#JSR250-PostConstruct和-PreDestory" class="headerlink" title="JSR250:@PostConstruct和@PreDestory"></a>JSR250:@PostConstruct和@PreDestory</h4><p>@PostConstruct: 在bean创建完成并且属性赋值完成，来执行初始化方法<br>@PreDestory：&nbsp;&nbsp;在容器销毁bean之前通知我们进行清理工作</p><p>1) 在com.liuzhuo.bean包下，创建Dog类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Dog construct ····"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//在构造函数之后</span>    <span class="token annotation punctuation">@PostConstruct</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Dog @PostConstruct ····"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//在销毁之前</span>    <span class="token annotation punctuation">@PreDestroy</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Dog @PreDestroy ····"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2) 运行测试类test01:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IocOfLifeTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//启动容器</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>                <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfigOfLife<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭容器</span>        applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3) 结果：</p><pre><code>十月 15, 2018 9:35:11 下午 org.springframework.beans.factory.support.DefaultListableBeanFactory registerBeanDefinition信息: Overriding bean definition for bean &#39;person&#39; with a different definition: replacing [Generic bean: class [com.liuzhuo.bean.Person]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [E:\ideaProject\springannotation\target\classes\com\liuzhuo\bean\Person.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=true; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=mainConfig2; factoryMethodName=person; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/liuzhuo/config/MainConfig2.class]]Cat constructer ···Cat afterPropertiesSet ····Dog construct ····Dog @PostConstruct ····Car construct ····Car init ·····十月 15, 2018 9:35:12 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:35:11 CST 2018]; root of context hierarchyCar destory ·····Dog @PreDestroy ····Cat destroy ····</code></pre><hr><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>BeanPostProcessor: bean后置处理器（意思是bean初始化前后执行）</p><p>postProcessBeforeInitialization：在初始化之前执行，这里是初始化指：上述的init-method、InitializingBean、@PostConstruct。</p><p>postProcessAfterInitialization：在初始化之后执行。</p><hr><p>1）在com.liuzhuo.bean包下，创建MyBeanPostProcessor并实现BeanPostProcessor接口</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//初始化之前执行</span>    <span class="token comment" spellcheck="true">/**     * @param bean     容器创建的Bean     * @param beanName bean的id     * @return     * @throws BeansException     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>beanName <span class="token operator">+</span> <span class="token string">"------postProcessBeforeInitialization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//返回值是原始的Bean，或者是包装后的Bean</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//初始化之后执行</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>beanName <span class="token operator">+</span> <span class="token string">"------postProcessAfterInitialization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3) 运行测试方法test01：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IocOfLifeTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//启动容器</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>                <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfigOfLife<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关闭容器</span>        applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>4) 结果：</p><pre><code>mainConfigOfLife------postProcessBeforeInitializationmainConfigOfLife------postProcessAfterInitializationCat constructer ···cat------postProcessBeforeInitializationCat afterPropertiesSet ····cat------postProcessAfterInitializationDog construct ····dog------postProcessBeforeInitializationDog @PostConstruct ····dog------postProcessAfterInitializationCar construct ····car------postProcessBeforeInitializationCar init ·····car------postProcessAfterInitializationCar destory ·····Dog @PreDestroy ····Cat destroy ····十月 15, 2018 9:57:03 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2f410acf: startup date [Mon Oct 15 21:57:03 CST 2018]; root of context hierarchyProcess finished with exit code 0</code></pre><p>分析：<br>Cat constructer ···<br>cat——postProcessBeforeInitialization<br>Cat afterPropertiesSet ····<br>cat——postProcessAfterInitialization<br>Cat destroy ····  </p><p><strong>构造–初始化之前–初始化–初始化之后–销毁</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_05</title>
      <link href="/2018/10/15/spring-annotation-day-05/"/>
      <url>/2018/10/15/spring-annotation-day-05/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习给容器中注入组件，昨天，我们学习了条件注解，可以在满足一定的条件下，注入bean，今天的@Import注解也能帮我们完成相同的功能。</p><h3 id="Import注解"><a href="#Import注解" class="headerlink" title="@Import注解"></a>@Import注解</h3><p>给容器中注册组件主要有以下三种方法 :<br>1）、包扫描+组件标记注解（@Controller、@Service、@Repository、@Component)[导入我们自己写的组件]<br>2）、@Bean[导入第三方包里面的组件]<br>3）、@Import[快速给容器中导入一个组件]  </p><hr><p>@Bean导入，只能一个一个的导入，不太方便，所以需要@Import注解。现在我们来看@Import的用法。</p><h4 id="一、-Import"><a href="#一、-Import" class="headerlink" title="一、@Import"></a>一、@Import</h4><p>@Import：容器会自动注册加了该注解的组件，组件的id默认是组件的全类名  </p><p>1）在com.liuzhuo.bean包下，创建Color对象。<br>2）修改配置类MainConfig2类：(看@Import注解)</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//配置类==配置文件</span><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig2</span></code></pre><p>3）在test类中，创建新的测试方法：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testImport</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfig2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printBeanName</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">printBeanName</span><span class="token punctuation">(</span>AnnotationConfigApplicationContext applicationContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String name <span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>4) 运行测试方法：</p><pre><code>mainConfig2com.liuzhuo.bean.Colorpersonbier</code></pre><p>观察结果：发现Color组件已经注册到容器中了，而且id名是全类名。</p><hr><p>点击@Import。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Import</span> <span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>发现，@Import中的value是一个Class类型的数组，说明可以注入多个Class类型  </p><p>1）现在，在com.liuzhuo.bean包下，再创建一个Red类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Red</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>2）修改配置类MainConfig2：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//配置类==配置文件</span><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span>Color<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> Red<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig2</span> </code></pre><p>3) 运行测试方法testImport:</p><pre><code>mainConfig2com.liuzhuo.bean.Colorcom.liuzhuo.bean.Redpersonbier</code></pre><p>结果：Red类也被注册到容器中了。</p><hr><h4 id="二、ImportSelect"><a href="#二、ImportSelect" class="headerlink" title="二、ImportSelect"></a>二、ImportSelect</h4><p>ImportSelect：返回要导入的全类名数组。</p><p>在@Import的value属性中，导入实现了ImportSelect接口的类，该实现类返回我们需要导入的组件的全类名即可。</p><p>1）在com.liuzhuo.condition包下，创建MyImportSelect类并实现ImportSelect接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyImportSelect</span> <span class="token keyword">implements</span> <span class="token class-name">ImportSelector</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    * annotationMetadata:获取注解的信息。    * 返回值：全类名的字符串数组    * */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span>AnnotationMetadata annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//返回值不能是null，否则会出空指针异常</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2) 在com.liuzhuo.bean包下，创建Bule、Yellow类。</p><p>3）修改selectImports方法是返回值：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyImportSelect</span> <span class="token keyword">implements</span> <span class="token class-name">ImportSelector</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    * annotationMetadata:获取注解的信息。    * 返回值：全类名的字符串数组    * */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span>AnnotationMetadata annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//返回值不能是null，否则会出空指针异常</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"com.liuzhuo.bean.Blue"</span><span class="token punctuation">,</span><span class="token string">"com.liuzhuo.bean.Yellow"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>4) 修改配置类MainConfig2:(添加类MyImportSelect类)</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//配置类==配置文件</span><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span>Color<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> Red<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> MyImportSelect<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig2</span></code></pre><p>5)运行测试方法testImport:</p><p>结果：</p><pre><code>mainConfig2com.liuzhuo.bean.Colorcom.liuzhuo.bean.Redcom.liuzhuo.bean.Bluecom.liuzhuo.bean.Yellowpersonbier</code></pre><p>发现：Blue、Yellow也被注册到容器中了。</p><hr><h4 id="三、ImportBeanDefinitionRegistrar"><a href="#三、ImportBeanDefinitionRegistrar" class="headerlink" title="三、ImportBeanDefinitionRegistrar"></a>三、ImportBeanDefinitionRegistrar</h4><p>ImportBeanDefinitionRegistrar ：手动注册Bean。</p><p>使用的形式与ImportSelect类似。</p><p>1）在com.liuzhuo.condition包下，创建MyImportBeanDefinitionRegistrar类实现ImportBeanDefinitionRegistrar接口。  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyImportBeanDefinitionRegistrar</span> <span class="token keyword">implements</span> <span class="token class-name">ImportBeanDefinitionRegistrar</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    *    * importingClassMetadata:注解类的信息    * registry：注册组件，使用register.registerBeanDefinition()方法，手动注册Bean。    * */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span>AnnotationMetadata importingClassMetadata<span class="token punctuation">,</span> BeanDefinitionRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2)在com.liuzhuo.bean包下，创建RainBow类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RainBow</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>3) 修改registerBeanDefinitions方法：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span>AnnotationMetadata importingClassMetadata<span class="token punctuation">,</span> BeanDefinitionRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*         * 这里，我们根据是否有Bule和Yellow组件来注册RainBow组件。         * */</span>        <span class="token comment" spellcheck="true">//注意这里传入的是Bean的id。</span>        <span class="token keyword">boolean</span> b <span class="token operator">=</span> registry<span class="token punctuation">.</span><span class="token function">containsBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"com.liuzhuo.bean.Blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> y <span class="token operator">=</span> registry<span class="token punctuation">.</span><span class="token function">containsBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"com.liuzhuo.bean.Yellow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&amp;&amp;</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//两个参数：String beanName</span>            <span class="token comment" spellcheck="true">//         BeanDefinition beanDefinition</span>            <span class="token comment" spellcheck="true">// beanName：要注册的Bean的id</span>            <span class="token comment" spellcheck="true">//beanDefinition:Bean的定义。是一个接口，我们需要传入一个实现类。</span>            RootBeanDefinition rootBeanDefinition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span>RainBow<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            registry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"rainBow"</span><span class="token punctuation">,</span> rootBeanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>4) 修改配置类MainConfig2：(MyImportBeanDefinitionRegistrar.class)</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//配置类==配置文件</span><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span>Color<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> Red<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> MyImportSelect<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> MyImportBeanDefinitionRegistrar<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig2</span></code></pre><p>5) 运行测试方法testImport:</p><pre><code>mainConfig2com.liuzhuo.bean.Colorcom.liuzhuo.bean.Redcom.liuzhuo.bean.Bluecom.liuzhuo.bean.YellowpersonbierrainBow</code></pre><p>结果：发现rainBow已经被注册到容器中了。</p><hr><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>第四种方法给容器注册Bean.</p><p>使用Spring提供的FactoryBean（工厂Bean）<br> &nbsp;&nbsp;&nbsp;&nbsp;1）默认获取的是工厂bean调用getObject创建的对象<br> &nbsp;&nbsp;&nbsp;&nbsp;2）要想获取工厂Bean本身，需要给id前面加一个&amp;</p><hr><p>1) 在com.liuzhuo.bean包下，创建ColorFactoryBean类，实现FactoryBean接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ColorFactoryBean</span> <span class="token keyword">implements</span> <span class="token class-name">FactoryBean</span><span class="token operator">&lt;</span>Color<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//返回的Bean对象</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Color <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Color</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//Bean的类型</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Color<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//是否是单例：</span>    <span class="token comment" spellcheck="true">//true:单例</span>    <span class="token comment" spellcheck="true">//false:多例</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2) 注册ColorFactoryBean到容器中，在配置文件MainConfig2中：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> ColorFactoryBean <span class="token function">colorFactoryBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ColorFactoryBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>3) 修改testImport方法：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testImport</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfig2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printBeanName</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object colorFactoryBean <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"colorFactoryBean"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>colorFactoryBean<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>4) 结果：</p><pre><code>mainConfig2com.liuzhuo.bean.Colorcom.liuzhuo.bean.Redcom.liuzhuo.bean.Bluecom.liuzhuo.bean.YellowpersonbiercolorFactoryBeanrainBowcom.liuzhuo.bean.Color@6107227e</code></pre><p>发现：com.liuzhuo.bean.Color@6107227e 已经注册到容器中了。</p><font color="red"><strong>注意：我们注册到容器中的是ColorFactoryBean，但是获取Bean的时候，却是Color。</strong></font><p>底层是调用ColorFactoryBean的getObject()来获取的。</p><p>如果就是想要获取ColorFactoryBean本身的话，在id前面加一个&amp;：</p><pre class=" language-java"><code class="language-java">        Object colorFactoryBean <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"colorFactoryBean"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>colorFactoryBean<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object colorFactoryBean2 <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"&amp;colorFactoryBean"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>colorFactoryBean2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>结果：</p><pre><code>com.liuzhuo.bean.Color@6107227ecom.liuzhuo.bean.ColorFactoryBean@7c417213</code></pre><p>ps:点击BeanFactory：<br>会发现有一个字段：<br><code>String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</code><br>这就是为啥加&amp;会获取FactoryBean本身的原因.</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_04</title>
      <link href="/2018/10/14/spring-annotation-day-04/"/>
      <url>/2018/10/14/spring-annotation-day-04/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习条件注解！！！这个注解很重要，对以后大家学习Springboot很有帮助。<br><a id="more"></a></p><h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>作用：按照一定的条件进行判断，满足条件的bean给注入到容器中  </p><p>现在我们的需求的是根据操作系统的类型来，注入给定的bean对象。</p><p>在MainConfig2配置类中，再添加两个新方法：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"bier"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Person <span class="token function">person01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果是windows系统就注入到容器中</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Bier"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"linux"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Person <span class="token function">person02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果是Linux系统就注入到容器中</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Linux"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>在测试类中，创建新的test03方法:</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test03</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfig2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//根据Bean类来获取所有的Bean类的id名字</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> beanNamesForType <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String name <span class="token operator">:</span> beanNamesForType<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//根据Bean类来获取Map结构</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Person<span class="token operator">></span> beansOfType <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeansOfType</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>beansOfType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre><code>D:\Java1.8\bin\java  personbierlinux加载person类到容器中~~~{person=Person{name=&#39;dengjie&#39;, age=18}, bier=Person{name=&#39;Bier&#39;, age=16}, linux=Person{name=&#39;Linux&#39;, age=18}}Process finished with exit code 0</code></pre><p>此时：获取了所有的person类的Bean的id的名字。</p><hr><p>现在，我们创建com.liuzhuo.conditaion包，并创建两个实现了condition接口的类。如下：</p><p><img src="https://gakkil.gitee.io/gakkil-image/spring_annotation/day04/20181014203017.png" style="width:50%"> </p><p>WinCondition类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WinCondition</span> <span class="token keyword">implements</span> <span class="token class-name">Condition</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * conditionContext：     条件上下文（获取我们需要的资源）     * annotatedTypeMetadata：注解类型的信息     * */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span>ConditionContext conditionContext<span class="token punctuation">,</span> AnnotatedTypeMetadata annotatedTypeMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取beanFactory工厂</span>        ConfigurableListableBeanFactory beanFactory <span class="token operator">=</span> conditionContext<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取加载类</span>        ClassLoader classLoader <span class="token operator">=</span> conditionContext<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取注解类</span>        BeanDefinitionRegistry registry <span class="token operator">=</span> conditionContext<span class="token punctuation">.</span><span class="token function">getRegistry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取环境变量</span>        Environment environment <span class="token operator">=</span> conditionContext<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取资源加载类</span>        ResourceLoader resourceLoader <span class="token operator">=</span> conditionContext<span class="token punctuation">.</span><span class="token function">getResourceLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*        * 创建如果是windows系统的话，就注入到容器中        * */</span>        String property <span class="token operator">=</span> environment<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"os.name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>property<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"Windows"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>LinuxCondition类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinuxCondition</span> <span class="token keyword">implements</span> <span class="token class-name">Condition</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span>ConditionContext conditionContext<span class="token punctuation">,</span> AnnotatedTypeMetadata annotatedTypeMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Environment environment <span class="token operator">=</span> conditionContext<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String property <span class="token operator">=</span> environment<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"os.name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>property<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"Linux"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>修改配置类：给刚刚创建的两个方法添加@Conditional注解</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Conditional</span><span class="token punctuation">(</span><span class="token punctuation">{</span>WinCondition<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"bier"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Person <span class="token function">person01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果是windows系统就注入到容器中</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Bier"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Conditional</span><span class="token punctuation">(</span><span class="token punctuation">{</span>LinuxCondition<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"linux"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Person <span class="token function">person02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果是Linux系统就注入到容器中</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Linux"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre><code>personbier加载person类到容器中~~~{person=Person{name=&#39;dengjie&#39;, age=18}, bier=Person{name=&#39;Bier&#39;, age=16}}Windows 10Process finished with exit code 0</code></pre><p>看到结果：现在作者的操作系统是windows系统，所以现在是bier给注入到容器中了。</p><p>现在修改操作系统的类型。</p><p>修改test03的运行环境，在idea的右上角点击 “Edit Configrations···” :</p><p><img src="https://gakkil.gitee.io/gakkil-image/spring_annotation/day04/20181014204146.png" style="width:50%"></p><p>编辑里面的 VM options: <code>-Dos.name=Linux</code></p><p>然后运行test03.</p><pre><code>personlinux加载person类到容器中~~~{person=Person{name=&#39;dengjie&#39;, age=18}, linux=Person{name=&#39;Linux&#39;, age=18}}LinuxProcess finished with exit code 0</code></pre><p>此时，注入到容器中的是linux。</p><hr><p>总结：@Conditional注解是用来按照一定的条件进行判断，满足条件给容器中注入bean。<br>点击@Conditional：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Conditional</span> <span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Condition</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>说明@Conditional里面是Condition&gt;[] value()数组。我们需要在@Conditional的value中写入数组。数组需要使用｛｝来写。传入的是实现了Condition接口的类。比如这里的WinCondition、LinuxCondition类。<br>实例：@Conditional({WinCondition.class})、@Conditional({LinuxCondition.class})。</p><p>@Conditional，不仅可以放在方法上面，还可以是类上面。<br>放在类上面，就是对这个类统一设置。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_03</title>
      <link href="/2018/10/14/spring-annotation-day-03/"/>
      <url>/2018/10/14/spring-annotation-day-03/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习Spring中的@Scope注解<br><a id="more"></a></p><h3 id="Scope注解"><a href="#Scope注解" class="headerlink" title="@Scope注解"></a>@Scope注解</h3><p>@Scope注解：是用来控制创建对象的作用域的，这里的作用域不是我们平时所说的作用域。<br>这里是：单例模式、多例模式等。  </p><p>现在创建新的配置类com.liuzhuo.config.MainConfig2:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//配置类==配置文件</span><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig2</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Person <span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"dengjie"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在测试类IocTest中创建新的测试方法，test02：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfig2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取所有已经注入到容器中的Bean的id.</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> beanDefinitionNames <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String name <span class="token operator">:</span> beanDefinitionNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre><code>mainConfig2person</code></pre><hr><p>现在我们修改配置类MainConfig2：<br>使用@Scope注解（作用域的功能）</p><p>@Scope可以使用四个值：<br>1.singleton：单例模式（<strong>默认值</strong>）<br>2.prototype：多例模式<br>3.request  ：一个request请求，创建一个新的实例<br>4.session  ：一个session请求，创建一个新的实例 </p><p>在配置类下的person方法上加入@Scope注解：   </p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig2</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Scope</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Person <span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"dengjie"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>现在修改test02测试方法，测试person是否是单例：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfig2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取所有已经注入到容器中的Bean的id.</span>        <span class="token comment" spellcheck="true">/*String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();        for (String name : beanDefinitionNames) {            System.out.println(name);        }*/</span>        Object person <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object person2 <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person <span class="token operator">==</span> person2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出结果：true。注意：<strong>此时已经加载的是配置文件2了！！！</strong><br>说明@Scope默认是单例模式。</p><hr><p>现在修改成多例模式：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig2</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"prototype"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Person <span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"dengjie"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行测试方法test02：输出false。<br>说明：现在是多例模式。</p><hr><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>修改配置类，在person方法中加入一句输出语句。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig2</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"singleton"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Person <span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"加载person类到容器中~~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"dengjie"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>修改测试类：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfig2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>运行测试方法：</p><pre class=" language-java"><code class="language-java">D<span class="token operator">:</span>\Java1<span class="token number">.8</span>\bin\java <span class="token operator">-</span>ea <span class="token operator">-</span>Didea<span class="token punctuation">.</span>test<span class="token punctuation">.</span>cyclic<span class="token punctuation">.</span>buffer<span class="token punctuation">.</span>size<span class="token operator">=</span><span class="token number">1048576</span> 加载person类到容器中<span class="token operator">~</span><span class="token operator">~</span><span class="token operator">~</span><span class="token boolean">true</span>Process finished with exit code <span class="token number">0</span></code></pre><p>此时虽然只加载了容器类，但是person还是被加载到了容器中。<br>说明单例模式下，注入到容器中的类是立即注入的。不用到使用person类才注入到容器中来。</p><hr><p>现在将单例变成多例模式，不改测试方法。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig2</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"prototype"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Person <span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"加载person类到容器中~~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"dengjie"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>此时啥也不输出！！!</strong></p><p>现在修改测试方法：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfig2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object person <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object person2 <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person <span class="token operator">==</span> person2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre><code>加载person类到容器中~~~加载person类到容器中~~~false</code></pre><p>说明：多例是懒加载，只有等到获取person对象时，才会将person注入到容器中。</p><hr><h3 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h3><p>使用@Lazy注解来控制是否是懒加载。</p><p>修改配置类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//配置类==配置文件</span><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig2</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Scope</span>    <span class="token annotation punctuation">@Lazy</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Person <span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"加载person类到容器中~~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"dengjie"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>修改测试方法：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfig2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>运行测试方法：啥也不输出，说明此时已经是懒加载了。</p><hr><p>修改测试方法：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfig2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object person <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object person2 <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person <span class="token operator">==</span> person2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>运行测试方法：</p><pre><code>加载person类到容器中~~~true</code></pre><p>此时是到使用person对象时，才会加载。并且只是加载了一次，因为是单例模式。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_02</title>
      <link href="/2018/10/13/spring-annotation-day-02/"/>
      <url>/2018/10/13/spring-annotation-day-02/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天，学习包扫描的功能。<br><a id="more"></a></p><p>接着day01天的内容，我们知道怎么使用java类来配置并初始化容器了，使用@Configuration注解来标记一个java类就等同于了bean.xml文件了。</p><p>接下来，我们看看包扫描怎么配置，因为我们不可能给每个类都使用@Bean来配置，那样太花时间和精力，所以我们需要包扫描的配置，来自动帮我们把需要的bean对象注入到容器中。</p><h3 id="一：xml版的包扫描"><a href="#一：xml版的包扫描" class="headerlink" title="一：xml版的包扫描"></a>一：xml版的包扫描</h3><hr><p>注意：这里在Bean.xml文件中需要配置命名空间,加上context的命名空间.</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>beans xmlns<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/beans"</span>       xmlns<span class="token operator">:</span>context<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/context"</span>       xmlns<span class="token operator">:</span>xsi<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/XMLSchema-instance"</span>       xsi<span class="token operator">:</span>schemaLocation<span class="token operator">=</span>"         http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>beans         http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>beans<span class="token operator">/</span>spring<span class="token operator">-</span>beans<span class="token punctuation">.</span>xsd         http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>context         http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>org<span class="token operator">/</span>schema<span class="token operator">/</span>context<span class="token operator">/</span>spring<span class="token operator">-</span>context<span class="token punctuation">.</span>xsd"<span class="token operator">></span></code></pre><p>主要加入了xmlns:context=···· 和 xsi: 中的两个context (看结尾) .</p><p>bean.xml配置文件加入了：</p><pre class=" language-java"><code class="language-java">    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>包扫描、只要标注了<span class="token annotation punctuation">@Controller</span>、<span class="token annotation punctuation">@Service</span>、<span class="token annotation punctuation">@Repository</span>、<span class="token annotation punctuation">@Component</span>都会自动注入到容器中<span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> base<span class="token operator">-</span><span class="token keyword">package</span>包名，在该包下的子包也会被扫描<span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>context<span class="token operator">:</span>component<span class="token operator">-</span>scan base<span class="token operator">-</span><span class="token keyword">package</span><span class="token operator">=</span><span class="token string">"com.liuzhuo"</span><span class="token operator">/</span><span class="token operator">></span></code></pre><p>现在将bean.xml中的person配置添加注释，让其失效。</p><pre class=" language-java"><code class="language-java">    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>以前的开发模式，使用配置文件<span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"person"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.liuzhuo.bean.Person"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"name"</span> value<span class="token operator">=</span><span class="token string">"zhangsan"</span><span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"age"</span> value<span class="token operator">=</span><span class="token string">"18"</span><span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span class="token operator">--</span><span class="token operator">></span></code></pre><p>在Person类上面加入@Component注解。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> </code></pre><p>运行MainTest测试类：</p><pre class=" language-java"><code class="language-java">  ClassPathXmlApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"bean.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Person person <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出:</p><p><code>Person{name=&#39;null&#39;, age=null}</code>  </p><p>说明包扫描成功!</p><hr><h3 id="二：java类版的包扫描"><a href="#二：java类版的包扫描" class="headerlink" title="二：java类版的包扫描"></a>二：java类版的包扫描</h3><hr><p>首先将xml版本中的包扫描注解掉。</p><p>在java配置类上加入<code>@ComponentScan(value = &quot;com.liuzhuo&quot;)</code><br>value：就是要扫描的具体包的路径。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//配置类==配置文件</span>    <span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span>    <span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"com.liuzhuo"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//包扫描</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig</span> <span class="token punctuation">{</span>       ·····    <span class="token punctuation">}</span></code></pre><p>创建<code>com.liuzhuo.controller</code>、<code>com.liuzhuo.service</code>、<code>com.liuzhuo.dao包</code><br>并创建相应的java类，BookController，BookService，BookDao。如下：</p><p><img src="https://gakkil.gitee.io/gakkil-image/spring_annotation/day02/20181013170247.png" style="width:50%;">  </p><p>并在相应的类上面标注相应的注解。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookController</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookService</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token annotation punctuation">@Repository</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookDao</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>主要是@Controller、@Service、@Repository三个注解。  </p><p>现在在test文件夹下面的jave包下创建测试类。</p><p>com.liuzhuo.test.IocTest类。</p><p>并在pom.xml文件中加入依赖</p><pre class=" language-java"><code class="language-java">        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>junit<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>junit<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">4.12</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre><p>在IocTest类中写入一下代码:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IocTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取所有已经注入到容器中的Bean的id.</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> beanDefinitionNames <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String name <span class="token operator">:</span> beanDefinitionNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行test01，结果：<br>除了spring内置的Bean对象外，主要有以下我们自己定义的Bean对象的id名</p><pre class=" language-java"><code class="language-java">mainConfigbookControllerbookDaobookServiceperson01</code></pre><hr><h3 id="三、-ComponentScan的用法"><a href="#三、-ComponentScan的用法" class="headerlink" title="三、@ComponentScan的用法"></a>三、@ComponentScan的用法</h3><p>上面，我们已经初步了解了@ComponentScan包扫描的基本用法了。<br>点击@ComponentScan注解。我们会看到  </p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>ComponentScans<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">ComponentScan</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"basePackages"</span><span class="token punctuation">)</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    ····<span class="token punctuation">}</span></code></pre><p>value这个字段，说明是一个字符串类型的数组。说明value值，我们可以填写多个值，数组的话，用大花括号来表示: <code>{ }</code> 。每个值用逗号:   <code>，</code> 来隔开。</p><p>ps:提一个小技巧，在idea中，Alt+7可以查看这个类中所有的字段和方法。</p><p>我们可以看到其中有一个includeFilters()的字段。<br><img src="https://gakkil.gitee.io/gakkil-image/spring_annotation/day02/20181013173018.png" style="width:50%"></p><p>ComponentScan.Filter[]  includeFilters()  default {};</p><p>看到includeFilters也是一个数组，类型是ComponentScan的内部类Filter。<br>点击Filter，发现也是一个注解.</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>        FilterType <span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> FilterType<span class="token punctuation">.</span>ANNOTATION<span class="token punctuation">;</span>        <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"classes"</span><span class="token punctuation">)</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">classes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">pattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>发现有一个类型和字节码类的字段。</p><h4 id="1-includeFilters"><a href="#1-includeFilters" class="headerlink" title="1.includeFilters"></a>1.includeFilters</h4><p>现在我们来使用这个includeFilters来在包扫描的时候，只扫描我们相要的类。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"com.liuzhuo"</span><span class="token punctuation">,</span> includeFilters <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">.</span><span class="token function">Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>ANNOTATION<span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token punctuation">{</span>Controller<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//包扫描</span></code></pre><p>type是来说明过滤的类型的，这里的类型是注解<code>(FilterType.ANNOTATION)</code>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> FilterType <span class="token punctuation">{</span>    ANNOTATION<span class="token punctuation">,</span>    ASSIGNABLE_TYPE<span class="token punctuation">,</span>    ASPECTJ<span class="token punctuation">,</span>    REGEX<span class="token punctuation">,</span>    CUSTOM<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">FilterType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>总共有以上五个类型。<br>ANNOTATION：注解类型<br>ASSIGNABLE_TYPE：赋值类型</p><hr><p>运行test01类，发现结果还是扫描了所有的注解。</p><pre class=" language-java"><code class="language-java">mainConfigbookControllerbookDaobookServiceperson01</code></pre><p>是配置出现问题了嘛？<font color="red">不是，是因为我们忘记了，包扫描，默认的配置是扫描所有，所以，我们只需要将默认的配置设置为false就好了</font>。<br>useDefaultFilters = false</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"com.liuzhuo"</span><span class="token punctuation">,</span> includeFilters <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">.</span><span class="token function">Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>ANNOTATION<span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token punctuation">{</span>Controller<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>useDefaultFilters <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//包扫描</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig</span></code></pre><p>结果为：</p><pre class=" language-java"><code class="language-java">mainConfigbookControllerperson01</code></pre><h4 id="2-excludeFilters"><a href="#2-excludeFilters" class="headerlink" title="2.excludeFilters"></a>2.excludeFilters</h4><p>excludeFilters：是和includeFilters对着来的，<strong>是排除哪些类不扫描。</strong></p><p>具体的配置情况如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//配置类==配置文件</span><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"com.liuzhuo"</span><span class="token punctuation">,</span> excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">.</span><span class="token function">Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>ANNOTATION<span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token punctuation">{</span>Controller<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//包扫描</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig</span></code></pre><p>输出结果为：<code>@Controller注解</code>的类就没有被扫描。</p><pre><code>mainConfigbookDaobookServiceperson01</code></pre><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h4><p>@ComponentScan value: 指定要扫描的包<br>jdk1.8中@ComponentScan是可重复的，所以可以写两个@ComponentScan<br>不过，可以使用@ComponentScans来配置多个@ComponentScan<br>excludeFilters = Filter[]: 指定扫描的时候按照什么规则排除哪些组件<br>includeFilters = Filter[]: 指定扫描的时候只需要包含哪些组件</p><font color="red">ps: includeFilters , 需要将默认的包扫描设置为false。(useDefaultFilters = false)</font><hr><h3 id="四、详解Filter的类型"><a href="#四、详解Filter的类型" class="headerlink" title="四、详解Filter的类型"></a>四、详解Filter的类型</h3><pre><code>FilterType.ANNOTATION　　　     按照注解FilterType.ASSIGNABLE_TYPE     按照给定的类型FilterType.ASPECTJ　　　　　    使用ASPECTJ表达式FilterType.REGEX 　　　　　　   使用正则表达式FilterType.CUSTOM　　　　　     使用自定义的规则</code></pre><p>更新MainConfig类:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//配置类==配置文件</span><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token annotation punctuation">@ComponentScans</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"com.liuzhuo"</span><span class="token punctuation">,</span> includeFilters <span class="token operator">=</span> <span class="token punctuation">{</span>                 <span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">.</span><span class="token function">Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>ANNOTATION<span class="token punctuation">,</span>                 classes <span class="token operator">=</span> <span class="token punctuation">{</span>Controller<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>                 <span class="token punctuation">,</span> useDefaultFilters <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig</span></code></pre><p>现在的输出结果为：(只扫描有@Controller注解的类)</p><pre><code>mainConfigbookControllerperson01</code></pre><p>现在我们使用FilterType.ASSIGNABLE_TYPE 类型(给定类的类型)</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//配置类==配置文件</span><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token annotation punctuation">@ComponentScans</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"com.liuzhuo"</span><span class="token punctuation">,</span> includeFilters <span class="token operator">=</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">.</span><span class="token function">Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>ASSIGNABLE_TYPE<span class="token punctuation">,</span>                classes <span class="token operator">=</span> <span class="token punctuation">{</span>BookService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> useDefaultFilters <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig</span> </code></pre><p>输出结果是：只要是BookService类型的就行，他的子类也行。</p><pre><code>mainConfigbookServiceperson01</code></pre><p>现在我们使用自定义规则，FilterType.CUSTOM。</p><p>需要自己创建一个类并实现TypeFilter接口。(我放在com.liuzhuo.config包)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyTypeFilter</span> <span class="token keyword">implements</span> <span class="token class-name">TypeFilter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">match</span><span class="token punctuation">(</span>MetadataReader metadataReader<span class="token punctuation">,</span>                     MetadataReaderFactory metadataReaderFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>解释一下：<br>1.metadataReader  读取到当前正在扫描的类的信息<br>2.metadataReaderFactory  可以获取到其他任何类信息</p><p>我们通过这两个参数可以获取很多当前扫描类的信息。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyTypeFilter</span> <span class="token keyword">implements</span> <span class="token class-name">TypeFilter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">match</span><span class="token punctuation">(</span>MetadataReader metadataReader<span class="token punctuation">,</span> MetadataReaderFactory metadataReaderFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取当前类的注解信息</span>        AnnotationMetadata annotationMetadata <span class="token operator">=</span> metadataReader<span class="token punctuation">.</span><span class="token function">getAnnotationMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取当前正在扫描的类信息</span>        ClassMetadata classMetadata <span class="token operator">=</span> metadataReader<span class="token punctuation">.</span><span class="token function">getClassMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取当前类的资源(类的路径)</span>        Resource resource <span class="token operator">=</span> metadataReader<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String className <span class="token operator">=</span> classMetadata<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--->"</span> <span class="token operator">+</span> className<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述的方法，我们可以打印出被扫描的类的名字；<br>在此之前，我们还需要修改MainConfig配置类：<br>将Filter类型改为自定义类型。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//配置类==配置文件</span><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token annotation punctuation">@ComponentScans</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"com.liuzhuo"</span><span class="token punctuation">,</span> includeFilters <span class="token operator">=</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">.</span><span class="token function">Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span>                                       <span class="token punctuation">{</span>MyTypeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span> useDefaultFilters <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig</span> </code></pre><p>运行test01测试类：<br>结果如下：</p><pre class=" language-java"><code class="language-java"><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span>com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>test<span class="token punctuation">.</span>IocTest<span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span>com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>bean<span class="token punctuation">.</span>Person<span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span>com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>config<span class="token punctuation">.</span>MyTypeFilter<span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span>com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>controller<span class="token punctuation">.</span>BookController<span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span>com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>dao<span class="token punctuation">.</span>BookDao<span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span>com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>MainTest<span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span>com<span class="token punctuation">.</span>liuzhuo<span class="token punctuation">.</span>service<span class="token punctuation">.</span>BookService</code></pre><p>现在我们的MyTypeFilter返回都是false，所以被注入到容器的是<br>mainConfig<br>person01</p><p>现在，我们来更改MyTypeFilter类，我们只注入类名包含‘er’的类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyTypeFilter</span> <span class="token keyword">implements</span> <span class="token class-name">TypeFilter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">match</span><span class="token punctuation">(</span>MetadataReader metadataReader<span class="token punctuation">,</span> MetadataReaderFactory metadataReaderFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取当前类的注解信息</span>        AnnotationMetadata annotationMetadata <span class="token operator">=</span> metadataReader<span class="token punctuation">.</span><span class="token function">getAnnotationMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取当前正在扫描的类信息</span>        ClassMetadata classMetadata <span class="token operator">=</span> metadataReader<span class="token punctuation">.</span><span class="token function">getClassMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取当前类的资源(类的路径)</span>        Resource resource <span class="token operator">=</span> metadataReader<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String className <span class="token operator">=</span> classMetadata<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--->"</span> <span class="token operator">+</span> className<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>className<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"er"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其实就是加了一句代码：<br><code>if (className.contains(&quot;er&quot;)) return true;</code></p><p>运动test01测试类：</p><pre><code>mainConfigpersonmyTypeFilterbookControllerbookServiceperson01</code></pre><p>除了本来的mainConfig、person01是配置文件帮我注入的。<br>其他的注入的类都是类名包含‘er’的。</p><p><strong>ps：都是在包扫描@ComponentScan(value = “com.liuzhuo”)</strong><br><strong>com.liuzhuo包下的’er’.</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring_annotation_day_01</title>
      <link href="/2018/10/12/spring-annotation-01/"/>
      <url>/2018/10/12/spring-annotation-01/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring注解开发</strong>  </p><p>今天学习Spring的第一天，大家一起跟着我动手搭建环境，最后一定会有收获。<br><a id="more"></a></p><p>开发流程：主要是使用idea来完成的，此教程是针对有spring开发经验的人看的。用来对比以前的配置文件来注入依赖和java类配置来注入依赖的区别。  </p><p>打开idea创建Maven工程，输入三个坐标，groupId，artifactId，version。<br>我们这里的三个坐标是:  </p><pre><code>&lt;groupId&gt;com.liuzhuo&lt;/groupId&gt;&lt;artifactId&gt;spring-annotation&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</code></pre><p>创建后的工程如下：<br><img src="https://gakkil.gitee.io/gakkil-image/spring_annotation/day01/20181012212912.png" style="width:300px; heigh:300px"></p><hr><p>现在打开pom.xml文件:添加依赖如下</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>dependencies<span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>context<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">5.0</span><span class="token punctuation">.</span><span class="token number">9</span><span class="token punctuation">.</span>RELEASE<span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependencies<span class="token operator">></span></code></pre><p>更新pom文件，会自动导入jar包。 </p><hr><p>在src下的main下的java中创建Person类。我的包名是com.liuzhuo.bean<br>Person类中主要是两个字段，一个name，一个age，如图:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    ···中间省略了无参、有参的构造函数和getter、setter方法以及toString方法<span class="token punctuation">.</span>    <span class="token punctuation">}</span></code></pre><p>现在在main下的resources下创建bean.xml文件  </p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span>beans xmlns<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/beans"</span>       xmlns<span class="token operator">:</span>xsi<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/XMLSchema-instance"</span>       xsi<span class="token operator">:</span>schemaLocation<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>以前的开发模式，使用配置文件<span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"person"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.liuzhuo.bean.Person"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"name"</span> value<span class="token operator">=</span><span class="token string">"zhangsan"</span><span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"age"</span> value<span class="token operator">=</span><span class="token string">"18"</span><span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>beans<span class="token operator">></span></code></pre><hr><p>现在在com.liuzhuo包下创建MainTest类：  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//以前的开发模式，使用xml来配置bean</span>        ClassPathXmlApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span>                            <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"bean.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><p>输出结果:就是在配置文件中的配置的person类。</p><p><code>Person{name=&#39;zhangsan&#39;, age=18}</code></p><hr><p>现在创建com.liuzhuo.config包，并创建MainConfig类:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//配置类==配置文件</span><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//告诉spring这是一个配置类，用来生成bean</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//给容器中注册一个Bean；类型为返回值的类型，id默认为方法名</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Person <span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"lisi"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><p>修改MainTest类：  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//以前的开发模式，使用xml来配置bean</span>        <span class="token comment" spellcheck="true">/*ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("bean.xml");        Person person = (Person) applicationContext.getBean("person");        System.out.println(person);*/</span>        <span class="token comment" spellcheck="true">//现在使用java类来配置上下文容器</span>        AnnotationConfigApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><p>输出结果：是MainConfig类中配置Person类(@Bean注解的类) </p><p><code>Person{name=&#39;lisi&#39;, age=16}</code></p><p>在配置文件类必须使用@Configuration注解，然后再注入自己想要的Bean对象<br>创建一个方法，使用@Bean注解，返回值就是注入到容器中的Bean类型，默认情况下方法名就是注入到容器中的id。  </p><p>@Bean注解()中，可以输入参数，其中就有value来修改Bean的id名，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//给容器中注册一个Bean；类型为返回值的类型，id默认为方法名</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"person01"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//修改了Bean的id为person01</span>    <span class="token keyword">public</span> Person <span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"lisi"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在MainTest文件中输入获取Person类的名字：</p><pre class=" language-java"><code class="language-java">  <span class="token comment" spellcheck="true">//现在使用java类来配置上下文容器</span>  AnnotationConfigApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Person person <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>  String<span class="token punctuation">[</span><span class="token punctuation">]</span> beanNames <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>String name<span class="token operator">:</span>beanNames<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>输出结果： </p><pre class=" language-java"><code class="language-java">Person<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'lisi'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">}</span>person01</code></pre><p>说明此时，Bean的id名字是被@Bean(value=”person01”)给替换了，不再是方法名person了。</p>]]></content>
      
      
      <categories>
          
          <category> spring_annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring_annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="/2018/10/12/markdown/"/>
      <url>/2018/10/12/markdown/</url>
      
        <content type="html"><![CDATA[<p> <strong>序言</strong>:<br></p><p></p><p>很久没有写日记了，以前只是在QQ空间写，现在觉得在自己的平台写日记还是感觉不错的，还是要多写博客来加强自己学习的知识，学的知识点感觉还是记不住，渐渐地让我明白，看的越多，懂的越少（你这话不是有毛病吗？应该是看的越多，懂的越多才对），此话怎讲，当你在茫茫的知识库里面东看西看的时候，很快就被海量的知识给淹没了，根本就不知道哪些是对的，哪些是错的，感觉好像这个也懂了，那个也懂了，但是真正写起来，脑子又一片空白，又好像什么都不懂，这种状态时有发生，这就叫不懂装懂，最根本的原因就是看的太多，写的太少，所以为了改掉这样毛病，把被动学习变成主动学习，接下来的日子，多写写，即使是写一些学习工作中遇到的坑也是好的，没事翻出来看看，还可以加深印象，好了，废话到处！<br></p><br>正文：<br><br><strong>一、标题的几种写法</strong>：<p></p><p><strong>第一种</strong>：<br></p><p>#一级标题<br></p><p>##二级标题<br></p><p>###三级级标题<br></p><p>####四级标题<br></p><p>#####五级标题<br></p><p>######六级标题<br><br><strong>说明：真正使用的时候，需要在#后加空格!!!!!</strong><br><br>效果:<br>   </p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级级标题"><a href="#三级级标题" class="headerlink" title="三级级标题"></a>三级级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><strong>第二种</strong>：<br><br>  这是一级标题<br><br>  ======<br><br>  这是二级标题<br><br>  ———<br><br>这种只能表示一级和二级标题,==和–的数量个数没有限制，多少都行!!!<br>效果：<br></p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><p><strong>第三种</strong>：<br></p><p>#一级标题#<br></p><p>##二级标题##<br><br>其他几级标题类似，就是一个封闭的意思，也是注意#后面需要有空格!!!</p><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><p>那既然3种都可以使用，可不可以混合使用呢？我试了一下，是可以的，但是为了让页面标签的统一性，不建议混合使用，推荐使用第一种，比较简洁，全面</p><p>为了搞清楚原理，我特意在网上搜一下在线编写markdown的工具，发现实际上是把这些标签最后转化为html标签。<br>在线地址请看这里:<a href="http://tool.oschina.net/markdown/" title="markdown在线编辑器" target="_blank" rel="noopener">markdown在线编辑器</a><br></p><hr><p><strong>二：列表</strong><br><br>1.无序列表：<br><br>*1<br><br>*2<br><br>*3<br><br>+1<br><br>+2<br><br>+3<br><br>-1<br><br>-2<br><br>-3<br><br>效果:<br></p><ul><li>1</li><li>2</li><li>3</li></ul><ul><li>1</li><li>2</li><li>3</li></ul><ul><li>1</li><li>2</li><li>3<br></li></ul><p>可以看到，无序列表可以用 * ， + ， - 来创建，用在线编辑器看，实际上是转换成了ul&gt;li ，所以使用哪个都可以，推荐使用*吧.<br><br><br>2.有序列表:<br><br>1.列表1<br>2.列表2<br>3.列表3</p><ol><li>列表1</li><li>列表2</li><li>列表3</li></ol><p>有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的。</p><hr><p><strong>三：区块引用</strong><br>比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句。使用&gt;  </p><ul><li><p>犯我帝国者，虽远必诛!  </p><blockquote><p>这是嘉文四世说的</p></blockquote></li></ul><p><strong>四：华丽的分割线</strong><br>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</p><hr><p><strong>五:图片</strong><br>图片也有2种方式：行内式和参数式.  </p><pre><code>![我是图片](https://www.fdfdfdf.jpg)[我是图片]: (https://www.fdfdfdf.jpg)参数式图片，这里是[我是图片]</code></pre><p>用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！（这是必须的），没什么好说的。</p><hr><p><strong>六：代码块</strong></p><p>这个就比较重要了，很多时候都需要展示出一些代码</p><p>如果代码量比较少，只有单行的话，可以用单反引号包起来，如下： </p><p>第一种：单行（两个）: ``</p><p><code>var js = new object();</code>  </p><p>要是多行这个就不行了，多行可以用3个 `</p><pre><code>int a = 10;  int b = 20;  int sum = a + b;  printf(&quot;%d&quot;,sum);  </code></pre><hr><p><strong>七：强调</strong>  </p><p>*字体倾斜*<br>_字体倾斜_<br>**字体加粗**<br>__字体加粗__  </p><p>一个星号或者是一个下划线包起来，会转换为<code>&lt;em&gt;</code>倾斜，如果是2个，会转换为<code>&lt;strong&gt;</code>加粗</p><hr><p><strong>八：转义</strong>  </p><p> \：转义符号，和js一样。</p><hr><p><strong>九：删除线</strong>  </p><p>~~请删除我~~:</p><p><del>请删除我</del>  </p><hr><p><strong>十：html原始码</strong> </p><p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理.</p><hr><p>常用的基本上就这些了，如果还有一些常用的，可以跟我留言，我补充上去. </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新文章</title>
      <link href="/2018/10/11/my-new-post/"/>
      <url>/2018/10/11/my-new-post/</url>
      
        <content type="html"><![CDATA[<p>这是作者的第一篇文章，主要是为了纪念自己的博客!!</p><hr><p>欢迎大家在此篇文章下面评论，我会尽量回复大家的问题。</p><p>不管是生活上面的，还是学习上面的疑惑都可以提</p><p>一段故事温柔人心，爱分享爱解忧，么么哒~~</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
